# Closures - Cierres

Los cierres o closures (en inglés) son una especie de funciones rápidas que no necesitan un nombre. En ocasiones se les denomina funciones lambdas. Son fáciles de encontrar en el código debido a que utilizan `||` en lugar de `()`. Son muy habituales en Rust y una vez se aprenden a utilizar uno se pregunta como ha podido vivir sin ellos.

Se puede asociar un closure a una variable y en ese caso funciona y parece exactamente como una función:

```rust
fn main() {
    let my_closure = || println!("Esto es un cierre");
    my_closure();
}
```

Este closure no recibe nada coomo parámetro `||` e imprime el mensaje `Esto es un cierre`.

Entre los símbolos `||` se pueden añadir variables de entrada y tipos, como se hace en las funciones dentro de `()`:

```rust
fn main() {
    let my_closure = |x: i32| println!("{}", x);

    my_closure(5);
    my_closure(5+5);
}
```

Imprime:

```text
5
10
```

Cuando un cierre se hace más complejo, se puede escribir con un bloque de código que puede ser tan largo como se requiera:

```rust
fn main() {
    let my_closure = || {
        let number = 7;
        let other_number = 10;
        println!("Los dos números son {} y {}.", number, other_number);
          // Este cierre puede ser tan largo como se necesite, como sucede con las funciones.
    };

    my_closure();
}
```

Pero los cierres son especiales porque pueden guardarse valores de variables que se encuentren fuera del ellos incluso aunque no reciban parámetros (es decir, incluso habiendo escrito `||`). Por ello, se puede escribir:

```rust
fn main() {
    let number_one = 6;
    let number_two = 10;

    let my_closure = || println!("{}", number_one + number_two);
    my_closure();
}
```

Este código imprime `16`. No ha sido necesario añadir parámetros a `||` porque se pueden usar las variables dentro del código del cierre y sumarlas ahí.

Por cierto, por eso se llaman **closures**. Porque pueden tomar unas variables y *encerrarlas* dentro. Esto significa que si se quiere hablar con precisión:

- Una `||` que no encierra ninguna variable exterior en su interior es una *función anónima*. No es, estrictamente, un *closure*.
- Una `||` que sí encierra una variable exterior en su interior sí es un *cierre*.

Sin embargo, esta precisión no se suele hacer en el habla coloquial. Así que en este texto simplemente se llaman *cierres* a todos los `||`.

¿Por qué es bueno conocer la diferencia? Porque las funciones anónimas generan realmente el mismo código que el de las funciones con nombre. Aunque pueda parecer que el código máquina de una función anónima será más complejo, no lo es. Es igual (y, por lo tanto, igual de rápido) que el código de una función habitual.

Para qué pueden servir los cierres. Por ejemplo:

```rust
fn main() {
    let number_one = 6;
    let number_two = 10;

    let my_closure = |x: i32| println!("{}", number_one + number_two + x);
    my_closure(5);
}
```

Este cierre guarda en su interior a dos variables `number_one` y `number_two`. Pero también recibe como parámetro una nueva variable `x` y cuando se ejecuta, se le pasa 5 al parámetro `x`. Suma los tres valores y, en este caso, devuelve `21`.

Normalmente, se usan los cierres para pasarlos como parámetros a determinados métodos. En la última sección se usaron cierres con `.map()`y `.for_each()`. En esa sección, se escribió `|x|` para obtener el siguiente elemento en un iterador; eso era un cierre.

Otro ejemplo: el método `unwrap_or` que se usa para asignar un valor cuando no funciona `unwrap`. Igual que se puede escribir la siguiente función `let fourth = my_vec.get(3).unwrap_or(&0);`, existe también el método `unwrap_or_else` que recibe un cierre como parámetro. Por ejemplo:

```rust
fn main() {
    let my_vec = vec![8, 9, 10];

    let fourth = my_vec.get(3).unwrap_or_else(|| { // Intenta "desenvolver". Si no funciona:
        if my_vec.get(0).is_some() {               // observa si el vector contiene algo en el índice [0]
            &my_vec[0]                             // Utiliza ese valor si existe algo.
        } else {
            &0 // en otro caso, usa el &0
        }
    });

    println!("{}", fourth);
}
```

Por supuesto, los cierres pueden ser muy simples. Se puede escribir, simplemente `let fourth = my_vec.get(3).unwrap_or_else(|| &0);`. No siempre se necesita usar `{}` y escribir código complejo solo porque es un cierre. Solo con escribir `||` el compilador conoce que hay un cierre.

Quizás el uso más habitual de un cierre sea en la función `.map()`. A continuación se muestra otro ejemplo:

```rust
fn main() {
    let num_vec = vec![2, 4, 6];

    let double_vec = num_vec        // usa el vector
        .iter()                     // para recorrerlo (iterar)
        .map(|number| number * 2)   // para cada elemento, lo multiplica por 2
        .collect::<Vec<i32>>();     // y crea un nuevo vector a partir de ello
    println!("{:?}", double_vec);
}
```

Otro buen ejemplo es su uso con `.for_each()` después de `.enumerate()`. El método `.enumerate()` devuelve un iterador con el número de índice del elemento y el propio elemento. Por ejemplo, de `[10, 9, 8 ]` se obtiene `(0, 10), (1, 9), (2, 8)`. Con los tipos `(usize, i32)`. 

```rust
fn main() {
    let num_vec = vec![10, 9, 8];

    num_vec
        .iter()      // itera sobre num_vec
        .enumerate() // obtiene pares de (índice, valor)
        .for_each(|(index, number)| println!("El índice {} contiene el valor {}", index, number)); // imprime para cada elemento
}
```

Este código imprime:

```text
El índice 0 contiene el valor 10
El índice 1 contiene el valor 9
El índice 2 contiene el valor 8
```

En este caso se usa `for_each` en lugar de `map`. `map` es para ejecutar algo en cada elemento y pasarlo al siguiente paso (es un iterador en sí mismo) y actua de forma *perezosa*, es decir, si no hay nadie a quien pasarle el valor, no hace nada. `for_each` realiza la operación cuando recibe cada elemento. Por eso en caso de `map` hace falta usar un método como `collect` para obtener un resultado.

Esta es una característica muy interesante de los iteradores. Si se intenta ejecutar un `map` sin utilizar un método como `collect`, el compilador observará que ese código no hace nada. No fallará, pero lo indicará:

```rust
fn main() {
    let num_vec = vec![10, 9, 8];

    num_vec
        .iter()
        .enumerate()
        .map(|(index, number)| println!("El índice {} contiene el valor {}", index, number));

}
```

Mostrará:

```text
warning: unused `std::iter::Map` that must be used
 --> src\main.rs:4:5
  |
4 | /     num_vec
5 | |         .iter()
6 | |         .enumerate()
7 | |         .map(|(index, number)| println!("Index number {} has number {}", index, number));
  | |_________________________________________________________________________________________^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: iterators are lazy and do nothing unless consumed
```

Se trata de un aviso **warning**, no es un error. El programa funciona correctamente. Pero no suma nada. Si se observa el tipo del resultado de cada fila, se entenderá:

- `let num_vec = vec![10, 9, 8];` En este momento se tiene un `Vec<i32>`.
- `.iter()` El valor de retorno de esta función es un `Iter<i32>`. Es decir, un iterador sobre elementos de tipo `i32`.
- `.enumerate()` Ahora es de tipo enumerado `Enumerate<Iter<i32>>`. Es decir, un `Enumerate` sobre un `Iter` de `i32`s.
- `.map()` Y ahora el tipo es `Map<Enumerate<Iter<i32>>>`. Es decir, un `Map` sobre un `Enumerate` sobre un `Iter` de `i32`s.

Hasta el momento, todo lo que han hecho las funciones es ir construyendo una estructura compleja que está lista para usarse, solo que hay que decirle de algún modo que lo haga. Rust hace todo esto porque necesita ejecutarse rápido. No quiere hacer:

- itera sobre todos los `i32` en el vector
- luego enumera todos los `i32` del iterador
- luego ejecuta la función sobre todos los `i32`

Rust realiza un único "bucle" solo cuando lo necesita. En el momento que se ejecuta una función como `.collect::<Vec<i32>>()` Rust sabe que se le está pidiendo construir un vector y comienza a pedir los diferentes valores. Esto es lo que significa que *los iteradores son perezosos y no hacen nada a no ser que se consuman*.

Se pueden crear cosas muy complejas como `HashMap` mediante el uso de `.collect()`. A continuación se muestra un ejemplo sobre como construir un `HashMap` a partir de dos vectores. En primer lugar, se construyen ambos vectores. Después se usará `into_iter()` para obtener un interador sobre los valores. Posteriormente se usará `.zip()` para unir ambos iteradores como un una cremallera, emparejando cada elemento de un iterador con el obtenido del otro. Por último, se utilizará `.collect()` para crear el `HashMap`:

```rust
use std::collections::HashMap;

fn main() {
    let some_numbers = vec![0, 1, 2, 3, 4, 5]; // un Vec<i32>
    let some_words = vec!["cero", "uno", "dos", "tres", "cuatro", "cinco"]; // un Vec<&str>

    let number_word_hashmap = some_numbers
        .into_iter()                 // obtiene un iter
        .zip(some_words.into_iter()) // se combinan con .zip() dos iter.
        .collect::<HashMap<_, _>>();

    println!("Para la clave {} se obtiene {}.", 2, number_word_hashmap.get(&2).unwrap());
}
```

Que imprime:

```text
Para la clave 2 se obtiene dos.
```

Se observa que se escribió `<HashMap<_, _>>`, que es información suficiente para que Rust sepa decidir el tipo del objeto como `<HashMap<i32, &str>>`. También habría sido posible haber escrito `.collect::<HashMap<i32, &str>>();`. E incluso así:

```rust
use std::collections::HashMap;

fn main() {
    let some_numbers = vec![0, 1, 2, 3, 4, 5]; // un Vec<i32>
    let some_words = vec!["cero", "uno", "dos", "tres", "cuatro", "cinco"]; // un Vec<&str>
    let number_word_hashmap: HashMap<_, _> = some_numbers  // Puesto que se indica el tipo aquí...
        .into_iter()
        .zip(some_words.into_iter())
        .collect(); // no es necesario indicarlo aquí
}
```

Hay otro método que es como `.enumerate()`, pero para el tipo `char`: `.char_indices()`. Se usa de la misma forma. Si se supone que se tiene una cadena que está formada por números de tres dígitos:

```rust
fn main() {
    let numbers_together = "140399923481800622623218009598281";

    for (index, number) in numbers_together.char_indices() {
        match (index % 3, number) {
            (0..=1, number) => print!("{}", number), // solo imprime el número si hay resto
            _ => print!("{}\t", number), // en otro caso, imprime el número y un tabulador
        }
    }
}
```

Esto imprime: `140     399     923     481     800     622     623     218     009     598    281`.

## |_| en un cierre (closure)

En ocasiones se puede ver `|_|` en un cierre. Esto significa que el cierre (closure) necesita un argumento (como podría ser una variable x), pero no se va a usar. Así que esta expresión en los parámetros de un cierre significa: vale, el cierre recibe un parámetro, pero no le doy un nombre porque no lo uso".

A continuación, se muestra un ejemplo que da error por no expresar el parámetro:

```rust
fn main() {
    let my_vec = vec![8, 9, 10];

    println!("{:?}", my_vec.iter().for_each(|| println!("No usamos la variable que se necesita"))); // ⚠️
}
```

Rust da un error que dice:

```text
error[E0593]: closure is expected to take 1 argument, but it takes 0 arguments
 --> src/main.rs:4:36
  |
4 |     println!("{:?}", my_vec.iter().for_each(|| println!("No usamos la variable que se necesita"))); // ⚠️
  |                                    ^^^^^^^^ -- takes 0 arguments
  |                                    |
  |                                    expected closure that takes 1 argument
```

El propio compilador da alguna pista:

```text
help: consider changing the closure to take and ignore the expected argument
  |
4 |     println!("{:?}", my_vec.iter().for_each(|_| println!("No usamos la variable que se necesita"))); // ⚠️
  |                                             ~~~
```

Es decir, que se debe pasar el argumento que necesita cualquier cierre que se pase como parámetro a la función `for_each`.

Si se cambia de este modo, funcionará:

```rust
fn main() {
    let my_vec = vec![8, 9, 10];

    println!("{:?}", my_vec.iter().for_each(|_| println!("No usamos la variable que se necesita")));
}
```

## Métodos útiles para su uso con cierres e iteradores

Rust es un lenguaje muy divertido cuando se dominan los cierres. Con ellos se pueden *encadenar* métodos para hacer mucho con poco código. A continuación, se muestrans algunos métodos que se utilizan con cierres que aún no se habían visto:

`.filter()`: a partir de un iterador, permite conservar los elementos que se deseen. El siguiente ejemplo filtra los meses del año:

```rust
fn main() {
    let meses = vec!["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"];

    let filtered_meses = meses
        .into_iter()                         // crea un iterador
        .filter(|month| month.len() <= 5)     // Solo los meses con cinco o menos caracters (byte)
                                             // En este caso, todos los caracteres son de un byte, por eso funciona usar .len()
        .filter(|month| month.contains("u")) // Se seleccionan solo los meses que contengan la letra u
        .collect::<Vec<&str>>();

    println!("{:?}", filtered_meses);
}
```

Esto imprime: `["Junio", "Julio"]`.

`.filter_map()`: este método realiza de una vez la función de `.filter()` y `.map()`. El cierre que se pasa como parámetro,debe devolver un `Option<T>`. El método `filter_map()` extraerá `T` para aquellos elementos que tengan valor (que sean de tipo `Some<T>`) y desechará los que sean de tipo `None`. Por ejemplo, el uso de `.filter_map()` con un vector como `vec![Some(2), None, Some(3)]` devuelve `[2, 3]`.

A continuación se muestra un ejemplo con un `struct` de una `Empresa`. Cada empresa tiene un campo `nombre` de tipo `String`, y un campo `ceo` para describir a su responsable. El ceo puede haber dimitido, por lo que es de tipo `Option<String>` En el ejemplo, se filtran las empresas para mostrar el valor de los CEO.

```rust
struct Empresa {
    nombre: String,
    ceo: Option<String>,
}

impl Empresa {
    fn new(nombre: &str, ceo: &str) -> Self {
        let ceo = match ceo {
            "" => None,
            ceo => Some(ceo.to_string()),
        }; // Se crea el valor del campo ceo y debajo se crea el elemento struct
        Self {
            nombre: nombre.to_string(),
            ceo,
        }
    }

    fn get_ceo(&self) -> Option<String> {
        self.ceo.clone() // Devuelve un clone del CEO (struct no es tipo Copy)
    }
}

fn main() {
    let empresa_vec = vec![
        Empresa::new("Umbrella Corporation", "Unknown"),
        Empresa::new("Ovintiv", "Doug Suttles"),
        Empresa::new("The Red-Headed League", ""),
        Empresa::new("Stark Enterprises", ""),
    ];

    let all_the_ceos = empresa_vec
        .into_iter()
        .filter_map(|empresa| empresa.get_ceo()) // filter_map recibe Option<T> que es lo que necesita
        .collect::<Vec<String>>();

    println!("{:?}", all_the_ceos);
}
```

Esto imprime: `["Unknown", "Doug Suttles"]`

Para facilitar el uso de `.filter_map()` con valores `Result<T, E>`, este último tiene el método `.ok()` que lo convierte en `Option<T>` usando `None` para los casos de error.

En el siguiente ejemplo se utiliza `.parse()` para convertir la entrada de usuario en números `f32`. En el resultado se registran los errores que pueda haber en la entrada del usuario, al usar `.filter_map()` junto con `.ok()` se descartan los valores erróneos.

```rust
fn main() {
    let user_input = vec!["8.9", "Nine point nine five", "8.0", "7.6", "eleventy-twelve"];

    let actual_numbers = user_input
        .into_iter()
        .filter_map(|input| input.parse::<f32>().ok())
        .collect::<Vec<f32>>();

    println!("{:?}", actual_numbers);
}
```

Lo anterior imprime: `[8.9, 8.0, 7.6]`

En sentido contrario de `.ok()`, los `Option<T>` disponen de los métodos `.ok_or()` y `.ok_or_else()`. Estas funcones convierten un `Option<T>` en `Resutl<T, E>`. La función `.ok_or()` devuelve un `Ok` o un `Err`, por lo que necesita que se le indique de qué tipo debe ser este error. Esto se debe a que los casos `None` de `Option` no disponen de información adicionales.

En estas funciones, `.ok_or()` y `.ok_or_else()`, el parámetro closure se utiliza para obtener el valor para los casos en los que el `Option` sea `None`.

En el siguiente ejemplo, se toma el `Option` del `struct` de `Empresa` para convertirlo en un `Result`. Para el manejo de errores a largo plazo, es bueno que la aplicación tenga sus propios tipos de error. En este caso solo se incluye un mensaje de error, por lo que el tipo del resultado es `Result<String, &str>`.

```rust
// El código es idéntico, salvo en la función main()
struct Empresa {
    nombre: String,
    ceo: Option<String>,
}

impl Empresa {
    fn new(nombre: &str, ceo: &str) -> Self {
        let ceo = match ceo {
            "" => None,
            ceo => Some(ceo.to_string()),
        };
        Self {
            nombre: nombre.to_string(),
            ceo,
        }
    }

    fn get_ceo(&self) -> Option<String> {
        self.ceo.clone()
    }
}

fn main() {
    let empresa_vec = vec![
        Empresa::new("Umbrella Corporation", "Unknown"),
        Empresa::new("Ovintiv", "Doug Suttles"),
        Empresa::new("The Red-Headed League", ""),
        Empresa::new("Stark Enterprises", ""),
    ];

    let mut results_vec = vec![]; // Para guardar los valores resultantes

    empresa_vec
        .iter()
        .for_each(|empresa| results_vec.push(empresa.get_ceo().ok_or("No CEO found")));

    for item in results_vec {
        println!("{:?}", item);
    }
}
```

El resultado de este código es el siguiente:

```text
Ok("Unknown")
Ok("Doug Suttles")
Err("No CEO found")
Err("No CEO found")
```

En este caso, se dispone de las cuatro entradas del usuario y se indica cuáles son erróneas.

A continuación se usa `.ok_or_else()` para que se pueda pasar como parámetro un cierre y obtener un mensaje de error mejor incluyendo el nombre de la empresa.

```rust
// El código es idéntico, salvo en la función main()
struct Empresa {
    nombre: String,
    ceo: Option<String>,
}

impl Empresa {
    fn new(nombre: &str, ceo: &str) -> Self {
        let ceo = match ceo {
            "" => None,
            ceo => Some(ceo.to_string()),
        };
        Self {
            nombre: nombre.to_string(),
            ceo,
        }
    }

    fn get_ceo(&self) -> Option<String> {
        self.ceo.clone()
    }
}

fn main() {
    let empresa_vec = vec![
        Empresa::new("Umbrella Corporation", "Unknown"),
        Empresa::new("Ovintiv", "Doug Suttles"),
        Empresa::new("The Red-Headed League", ""),
        Empresa::new("Stark Enterprises", ""),
    ];

    let mut results_vec = vec![]; // Para guardar los valores resultantes

    empresa_vec
        .iter()
        .for_each(|empresa| {
            results_vec.push(empresa.get_ceo().ok_or_else(|| {
                let mensaje_error = format!("No CEO found for {}", empresa.nombre);
                mensaje_error
            }))
        });

    for item in results_vec {
        println!("{:?}", item);
    }
}
```

El código anterior, imprime:

```text
Ok("Unknown")
Ok("Doug Suttles")
Err("No CEO found for The Red-Headed League")
Err("No CEO found for Stark Enterprises")
```

`.and_then()`: es un método que toma como parámetro un `Option` y permite realizar una operación con su valor pasando el resultado al siguiente método que exista. El resultado también debe ser de tipo `Option`. Es una forma segura de obtener el contenido del elemento `Some`, realizar la operación deseada y encapsular el resultado de nuevo en un `Option`.

Un ejemplo sencillo se puede ver a partir del resultado de la operación `.get()` sobre un vector, puesto que devuelve un `Option`. En este caso, se obtiene un número, se realiza un cálculo y se vuelve a convertir a `Option`. Los valores `None` se pasan sin procesar, siguen siendo `None`.

```rust
fn main() {
    let new_vec = vec![8, 9, 0]; // solo un vec con números
    let number_to_add = 5;       // Se usa en el cálculo más adelante
    let mut empty_vec = vec![];  // El resultado va aquí


    for index in 0..5 {
        empty_vec.push(
            new_vec
               .get(index)
                .and_then(|number| Some(number + 1))
                .and_then(|number| Some(number + number_to_add))
        );
    }
    println!("{:?}", empty_vec);
}
```

Esto imprime: `[Some(14), Some(15), Some(6), None, None]`. Se observa que no se filtran los `None`.

`.and()`: es parecido a `bool` para `Option`. Se pueden encadenar muchos y si todos son `Some` el resultado será el del último. Si existe algún `None`, el resultado será `None`.

Se muestra en primer lugar un ejemplo con booleanos para ayudar a entender el funcionamiento de `.and()` en base al funcionamiento de `&&`(and). Un solo `false` lo convierte todo en `false`.

```rust
fn main() {
    let one = true;
    let two = false;
    let three = true;
    let four = true;

    println!("{}", one && three); // prints true
    println!("{}", one && two && three && four); // prints false
}
```

A continuación, se muestra el mismo tipo de ejemplo con la función `.and()`. Se puede imagina que se ejecutaron cinco operaciones y para cada una de ellas, si el resultado fue correcto se guardar en un `Vec<Option<&str>>` un valor `Some("éxito")`. Se repiten tres veces estas cinco operaciones. Después se usa `.and()` para comparar si en cada operación se obtubo resultado en todas las ocasiones.

```rust
fn main() {
    let first_try = vec![Some("éxito"), None, Some("éxito"), Some("éxito"), None];
    let second_try = vec![None, Some("éxito"), Some("éxito"), Some("éxito"), Some("éxito")];
    let third_try = vec![Some("éxito"), Some("éxito"), Some("éxito"), Some("éxito"), None];

    for i in 0..first_try.len() {
        println!("{:?}", first_try[i].and(second_try[i]).and(third_try[i]));
    }
}
```

El resultado es el siguiente:

```text
None
None
Some("éxito")
Some("éxito")
None
```

La cadena de `.and()` de la primera operación en los tres intentos devuelve `None` ya que el segundo intento tiene `None` en la primera posición (índice cero). La segunda operación también es `None` debido a que el primer intento dio un resultado `None`. La tercera operación sí tiene éxito debido a que los tres intentos tiene un resultado distinto de `None`.

#TODO

`.any()` y `.all()`:
