# Pruebas (testing)

Ahora que ya se entiende el funcionamiento de los m칩dulos es un buen momento para aprender sobre las pruebas. En Rust es muy f치cil probar el c칩digo porque se pueden escribir los tests junto al propio c칩digo.

La forma m치s sencilla de empezar a probar es a침adir `#[test]` a una funci칩n. Por ejemplo:

```rust
# #![allow(unused)]
# fn main() {
#[test]
fn dos_es_dos() {
    assert_eq!(2, 2);
}
# }
```

Pero si se intenta ejecutar en Playground, da un error: ``error[E0601]: `main` function not found in crate `playground``. Esto se debe a que no se utiliza Run para ejecutar las pruebas. En playground se puede pulsar junto a RUN en los `췅췅췅` y cambiar a TEST. Ahora, si se pulsa, ejecutar치 las pruebas. Si se tiene ya instalado Rust en el ordenador, se debe ejecutar `cargo test` en lugar de `cargo run`.

Este es el resultado de ejecutar el test anterior:

```text
running 1 test
test dos_es_dos ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```

Si se modifica `assert_eq!(2, 2)` a `assert_eq!(2, 3)` el test falla y devuelve una informaci칩n mucho m치s detallada:

```text
running 1 test
test dos_es_dos ... FAILED

failures:

---- dos_es_dos stdout ----
thread 'dos_es_dos' panicked at 'assertion failed: `(left == right)`
  left: `2`,
 right: `3`', src/lib.rs:3:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    dos_es_dos

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
```

En Rust, `assert_eq!(left, right)` es el principal modo de probar una funci칩n. Si no funciona, mostar치 los dos valores que son diferentes: `left has 2, but right has 3`.

쯈u칠 significa `RUST_BACKTRACE=1`? Es una variable del sistema que se puede activar para dar m치s informaci칩n sobre el error. En Playground se puede activar pulsando `췅췅췅` junto a `STABLE`y establecer la traza (backtrace) a `ENABLED`. Si se hace as칤, se mostrar치 mucha informaci칩n:

```text
running 1 test
test dos_es_dos ... FAILED

failures:

---- dos_es_dos stdout ----
thread 'dos_es_dos' panicked at 'assertion failed: 2 == 3', src/lib.rs:3:5
stack backtrace:
   0: backtrace::backtrace::libunwind::trace
             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.46/src/backtrace/libunwind.rs:86
   1: backtrace::backtrace::trace_unsynchronized
             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.46/src/backtrace/mod.rs:66
   2: std::sys_common::backtrace::_print_fmt
             at src/libstd/sys_common/backtrace.rs:78
   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt
             at src/libstd/sys_common/backtrace.rs:59
   4: core::fmt::write
             at src/libcore/fmt/mod.rs:1076
   5: std::io::Write::write_fmt
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/io/mod.rs:1537
   6: std::io::impls::<impl std::io::Write for alloc::boxed::Box<W>>::write_fmt
             at src/libstd/io/impls.rs:176
   7: std::sys_common::backtrace::_print
             at src/libstd/sys_common/backtrace.rs:62
   8: std::sys_common::backtrace::print
             at src/libstd/sys_common/backtrace.rs:49
   9: std::panicking::default_hook::{{closure}}
             at src/libstd/panicking.rs:198
  10: std::panicking::default_hook
             at src/libstd/panicking.rs:215
  11: std::panicking::rust_panic_with_hook
             at src/libstd/panicking.rs:486
  12: std::panicking::begin_panic
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/panicking.rs:410
  13: playground::dos_es_dos
             at src/lib.rs:3
  14: playground::dos_es_dos::{{closure}}
             at src/lib.rs:2
  15: core::ops::function::FnOnce::call_once
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libcore/ops/function.rs:232
  16: <alloc::boxed::Box<F> as core::ops::function::FnOnce<A>>::call_once
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/liballoc/boxed.rs:1076
  17: <std::panic::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/panic.rs:318
  18: std::panicking::try::do_call
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/panicking.rs:297
  19: std::panicking::try
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/panicking.rs:274
  20: std::panic::catch_unwind
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/panic.rs:394
  21: test::run_test_in_process
             at src/libtest/lib.rs:541
  22: test::run_test::run_test_inner::{{closure}}
             at src/libtest/lib.rs:450
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.


failures:
    dos_es_dos

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
```

No es necesario disponer de toda la traza, salvo que no se pueda encontrar cu치l es el problema. Normalmente, tampoco es necesario comprender toda la traza. En ella, se observa que en la l칤nea 13, se habla de `dos_es_dos`. A partir de ah칤 es donde empieza a hablar del c칩digo de la aplicaci칩n. Todo lo dem치s es sobre lo que Rust est치 haciendo en otras librer칤as para ejecutar el programa. Estas dos l칤neas (13 y 14) muestran que son errores en las l칤neas 2 y 3 de playground, es ah칤 donde est치 el error.

```text
  13: playground::dos_es_dos
             at src/lib.rs:3
  14: playground::dos_es_dos::{{closure}}
             at src/lib.rs:2
```

Nota: Rust mejor칩 los mensajes de traza a comienzos de 2021 para mostrar solo la informaci칩n m치s 칰til. Ahora es m치s f치cil de leer:

```text
failures:

---- dos_es_dos stdout ----
thread 'dos_es_dos' panicked at 'assertion failed: `(left == right)`
  left: `2`,
 right: `3`', src/lib.rs:3:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/std/src/panicking.rs:493:5
   1: core::panicking::panic_fmt
             at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/core/src/panicking.rs:92:14
   2: playground::dos_es_dos
             at ./src/lib.rs:3:5
   3: playground::dos_es_dos::{{closure}}
             at ./src/lib.rs:2:1
   4: core::ops::function::FnOnce::call_once
             at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/core/src/ops/function.rs:227:5
   5: core::ops::function::FnOnce::call_once
             at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/core/src/ops/function.rs:227:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.


failures:
    dos_es_dos

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.02s
```

En el siguiente ejemplo se desactiva la traza y se a침aden algunas funciones que se probar치n a trav칠s de unas funciones de prueba:

```rust
# #![allow(unused)]
# fn main() {
fn return_two() -> i8 {
    2
}
#[test]
fn it_returns_two() {
    assert_eq!(return_two(), 2);
}

fn return_six() -> i8 {
    4 + return_two()
}
#[test]
fn it_returns_six() {
    assert_eq!(return_six(), 6)
}
# }
```

Ahora se ejecutan los dos tests:

```text
running 2 tests
test it_returns_two ... ok
test it_returns_six ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```

Normalmente, los tests se llevar치n a un m칩dulo espec칤fico. Para ello, se usa `mod` como ya se conoce y se antecede con `#[cfg(test)]`. Delante de las funciones de prueba se sigue poniendo `#[test]`. Desde la l칤nea de comando de Rust, esto permitir치 realizar diferentes tipos de prueba, ejecutar solo una funci칩n de prueba, todas o unas algunas de ellas. En el m칩dulo de prueba ser치 necesario escribir `use super::*` para que pueda tener acceso sencillo a todas las funciones del m칩dulo principal que se est치 probando. Queda as칤:

```rust

# #![allow(unused)]
# fn main() {
fn return_two() -> i8 {
    2
}
fn return_six() -> i8 {
    4 + return_two()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_returns_six() {
        assert_eq!(return_six(), 6)
    }
    #[test]
    fn it_returns_two() {
        assert_eq!(return_two(), 2);
    }
}
# }
```

## Desarrollo dirigido por pruebas

En ingl칠s se denomina TDD, test driven development. Es una forma de escribir programas en la que primero se escribe el c칩digo de prueba de una funci칩n y luego se escribe su c칩digo. As칤, siempre se dispone de pruebas para todo el c칩digo que se escribe. Normalmente, se escriben las pruebas, se ejecutan y fallan, puesto que no se ha escrito el c칩digo. Despu칠s, se escribe el c칩digo de la funci칩n hasta que pasan todas las pruebas existentes. Esto es muy sencillo en Rust ya que el compilador da mucha informaci칩n sobre lo que hay que arreglar. A continuaci칩n, se escribe un peque침o ejemplo de desarrollo orientado por pruebas para ver c칩mo se hace.

Se va a suponer que se desarrolla una calculadora que suma y resta. Si el usuario escribe "5 + 6" deber칤a dar como resultado 11. Si el usuario escribe "5 + 6 - 7", deber칤a devolver 4, y as칤 para cada entrada. En primer lugar, se escriben las funciones de prueba. Los nombres de las funciones de prueba suelen ser largos, para dejar claro cual es cada prueba y conocer bien qu칠 significa si falla.

El c칩digo real de esta calculadora se encontrar치 en una funci칩n `math()` que realiza los c치lculos. Devolver치 un i32 (no realiza c치lculos con decimales). En primer lugar, esta funci칩n solo devolver치 un n칰mero fijo, el 6. Evidentemente, esto hace que el c칩digo de prueba falle:

```rust
# #![allow(unused)]
# fn main() {
fn math(input: &str) -> i32 {
    6
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_plus_one_is_two() {
        assert_eq!(math("1 + 1"), 2);
    }
    #[test]
    fn one_minus_two_is_minus_one() {
        assert_eq!(math("1 - 2"), -1);
    }
    #[test]
    fn one_minus_minus_one_is_two() {
        assert_eq!(math("1 - -1"), 2);
    }
}
# }
```

La ejecuci칩n de las pruebas, en este momento, da el siguiente resultado:

```text
running 3 tests
test tests::one_minus_minus_one_is_two ... FAILED
test tests::one_minus_two_is_minus_one ... FAILED
test tests::one_plus_one_is_two ... FAILED
```

El texto anterior, est치 resumido. Adem치s, se dispone de toda la informaci칩n del motivo de cada fallo, pero no se reproduce aqu칤.

Ahora se va a dise침ar la calculadora. Esta aceptar치 los d칤gitos, los s칤mbolos `+` y `-` y el espacio en blanco. Y nada m치s. En primer lugar, se crea un `const` con todos los caracteres posibles. La funci칩n `math()` iterar치 a trav칠s de todos los caracteres que tenga el par치metro y comprobar치 si est치n incluidos entre los caracteres v치lidos.

Este es el momento para a침adir una prueba que tenga que fallar debido a que se le pase alg칰n car치cter no v치lido. Para que el resultado de una prueba que falla sea considerado que es el resultado que debe valoes se debe a침adir el atributo `#[should_panic]` a la prueba. Es decir, que la funci칩n de prueba entre en p치nico es lo correcto en este caso.

El c칩digo queda as칤:

```rust
# #![allow(unused)]
# fn main() {
const OKAY_CHARACTERS: &str = "1234567890+- "; // Con el espacio entre los caracteres v치lidos

fn math(input: &str) -> i32 {
    if !input.chars().all(|character| OKAY_CHARACTERS.contains(character)) {
        panic!("Please only input numbers, +-, or spaces");
    }
    6 // por ahora se sigue devolviendo un 6
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_plus_one_is_two() {
        assert_eq!(math("1 + 1"), 2);
    }
    #[test]
    fn one_minus_two_is_minus_one() {
        assert_eq!(math("1 - 2"), -1);
    }
    #[test]
    fn one_minus_minus_one_is_two() {
        assert_eq!(math("1 - -1"), 2);
    }

    #[test]
    #[should_panic]  // Esta es la nueva prueba - que debe lanzar panic como resultado correcto
    fn panics_when_characters_not_right() {
        math("7 + seven");
    }
}
# }
```

Ahora, el resultado de ejecutar los tests es:

```text
running 4 tests
test tests::one_minus_two_is_minus_one ... FAILED
test tests::one_minus_minus_one_is_two ... FAILED
test tests::panics_when_characters_not_right ... ok
test tests::one_plus_one_is_two ... FAILED
```

Una prueba ha funcionado, la funci칩n solo acepta caracteres v치lidos.

El siguiente paso consiste en escribir el c칩digo que calcula los resultados. La l칩gica de la calculadora ser치 as칤:

- Todos los espacios se eliminar치n. Esto se hace con `.filter()`.
- La entrada se convertir치 en un `Vec` con todas las entradas. `+` no necesita ser una entrada, pero cuando el programa vea un `+` deber칤a saber que el n칰mero est치 completo. Por ejemplo, para la entrada `11+1` deber칤a hacer algo as칤:
  1. Encuentra el 1 y lo inserta en una cadena de caracteres vac칤a.
  2. Encuentra el siguiente 1 y lo inserta en la cadena de caracteres que ahora contendr치 "11".
  3. Encuentra el car치cter `+`, entiende que el n칰mero se ha terminado y guarda la cadena de caracteres en el `vec` y limpia la cadena de caracteres.
- El programa debe contar el n칰emro de `-`. Un n칰mero impar (1,3,5,...) significar치 restar, un n칰mero par significar치 sumar. As칤, 1--9 deber칤a dar 10, no -8. Es decir, 1 menos el -9.
- El programa deber칤a eliminar todos lo que aparezca despu칠s del 칰ltimo n칰mero. `5+5+++++-----` est치 compuesto de todos los caracteres en `OKAY_CHARACTERS`, pero deber칤a convertirlo a `5+5`. Es f치cil hacer esto con `.trim_end_matches()`. Esta funci칩n elimina todo lo que coincida con ella al final de una `&str`.

(Por cierto, `.trim_end_matches()` y `.trim_start_matches()` se denominaban antes `.trim_right_matches()` y `.trim_left_matches()`. Pero se observ칩 que algunos lenguajes se leen de derecha a izquierda (persa, hebreo, etc), por lo que la denominaci칩n de izquierda y derecha era err칩nea. En alg칰n c칩digo antiguo, a칰n pueden estar us치ndose las funciones antiguas).

En primer lugar, se debe conseguir que la funci칩n pase todas las pruebas. Despu칠s, se puede refactorizar el c칩digo para hacerlo mejor:

```rust
# #![allow(unused)]
# fn main() {
const OKAY_CHARACTERS: &str = "1234567890+- ";

fn math(input: &str) -> i32 {
    if !input.chars().all(|character| OKAY_CHARACTERS.contains(character)) ||
       !input.chars().take(2).any(|character| character.is_numeric())
    {
        panic!("Please only input numbers, +-, or spaces.");
    }

    let input = input.trim_end_matches(|x| "+- ".contains(x)) // Elimina +, - y espacios al final
        .chars().filter(|x| *x != ' ') // Elimina todos los espacios restantes
        .collect::<String>(); 
    let mut result_vec = vec![]; // Los resultados van aqu칤
    let mut push_string = String::new(); // Esta cadena es para hacer push de lo que se va encontrando. Se reutiliza entre diferentes n칰meros
    for character in input.chars() {
        match character {
            '+' => {
                if !push_string.is_empty() { // Si la cadena es vac칤a, no se quiere a침adir "" al result_vec
                    result_vec.push(push_string.clone()); // Pero si no es vac칤a, es un n칰mero que se a침ade al vector
                    push_string.clear(); // Y se limpia la cadena temporal
                }
            },
            '-' => { // Si llega un s칤mbolo -,
                if push_string.contains('-') || push_string.is_empty() { // Hay que ver si est치 vac칤a o ya tiene -
                    push_string.push(character) // si es as칤, se a침ade.
                } else { // en otro caso, contendr치 un n칰mero
                result_vec.push(push_string.clone()); // a침ade el valor a result_vec
                push_string.clear(); // limpia la cadena temporal
                push_string.push(character); // y a침ade el -
                }
            },
            number => { // cualquier otra cosa que venga, que ser치n d칤gitos, pasa por aqu칤
                if push_string.contains('-') { // Su hay - en la cadena temporal, hay que a침adirlos.
                    result_vec.push(push_string.clone());
                    push_string.clear();
                    push_string.push(number);
                } else { // si no es as칤, se a침ade a la cadena temporal
                    push_string.push(number);
                }
            },
        }
    }
    result_vec.push(push_string); // Cuando se acaba el bucle, se a침ade lo que quedara en a cadena. No es necesario .clone() porque no se usa la variable m치s.

    let mut total = 0; // Ahora es el momento de hacer los c치lculos
    let mut adds = true; // true = sumar, false = restar
    let mut math_iter = result_vec.into_iter();
    while let Some(entry) = math_iter.next() { // Itera a trav칠s de los elementos
        if entry.contains('-') { // Si contiene -, se comprueba si son par o impar
            if entry.chars().count() % 2 == 1 {
                adds = match adds {
                    true => false,
                    false => true
                };
                continue; // va al siguiente elemento
            } else {
                continue;
            }
        }
        if adds == true {
            total += entry.parse::<i32>().unwrap(); // Si llega aqu칤, tiene que ser un n칰mero, por lo que es seguro hacer unwrap
        } else {
            total -= entry.parse::<i32>().unwrap();
            adds = true;  // Despu칠s de restar, se resetea a suma.
        }
    }
    total // Finalmente, devuelve el total
}
   /// Se a침aden m치s tests para a침adir seguridad

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_plus_one_is_two() {
        assert_eq!(math("1 + 1"), 2);
    }
    #[test]
    fn one_minus_two_is_minus_one() {
        assert_eq!(math("1 - 2"), -1);
    }
    #[test]
    fn one_minus_minus_one_is_two() {
        assert_eq!(math("1 - -1"), 2);
    }
    #[test]
    fn nine_plus_nine_minus_nine_minus_nine_is_zero() {
        assert_eq!(math("9+9-9-9"), 0); // Este es nuevo
    }
    #[test]
    fn eight_minus_nine_plus_nine_is_eight_even_with_characters_on_the_end() {
        assert_eq!(math("8  - 9     +9-----+++++"), 8); // Este es nuevo
    }
    #[test]
    #[should_panic]
    fn panics_when_characters_not_right() {
        math("7 + seven");
    }
}
# }
```

Y ahora, las pruebas pasan:

```text
running 6 tests
test tests::one_minus_minus_one_is_two ... ok
test tests::nine_plus_nine_minus_nine_minus_nine_is_zero ... ok
test tests::one_minus_two_is_minus_one ... ok
test tests::eight_minus_nine_plus_nine_is_eight_even_with_characters_on_the_end ... ok
test tests::one_plus_one_is_two ... ok
test tests::panics_when_characters_not_right ... ok

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```

Se observa que, durante el proceso de desarrollo orientado a pruebas, existe un continuo ir y venir que sigue el siguiente patr칩n:

- Primero se escriben todos los casos de prueba que se puedan imaginar.
- Luego se comienza a escribir c칩digo.
- Seg칰n se escribe el c칩digo, aparecen ideas para hacer otras pruebas.
- Se a침aden estas otras pruebas. As칤, las pruebas van creciendo seg칰n se programa. Cuantos m치s pruebas (NT: pruebas que cubran casos nuevos) se codifiquen, m치s veces pruebas el c칩digo.

En todo caso, las pruebas no aseguran que todo est칠 correcto. Pero s칤 son muy 칰tiles cuando se va a modificar el c칩digo m치s tarde. Facilitan encontrar posibles fallos introducidos por el nuevo c칩digo.

Ahora se va a reescribir un poco el c칩digo (refactorizar). Una buena forma de comenzar es usar `clippy`. Si se ha instalado Rust, se puede usar `cargo clippy`. En Playgroudn se puede pulsar en `TOOLS` y seleccionar `Clippy`. Clippy analizar치 el c칩digo y dar치 pistas para hacerlo m치s simple.

En este caso, Clippy dice dos cosas:

```text
warning: this loop could be written as a `for` loop
  --> src/lib.rs:44:5
   |
44 |     while let Some(entry) = math_iter.next() { // Iter through the items
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for entry in math_iter`
   |
   = note: `#[warn(clippy::while_let_on_iterator)]` on by default
   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#while_let_on_iterator

warning: equality checks against true are unnecessary
  --> src/lib.rs:53:12
   |
53 |         if adds == true {
   |            ^^^^^^^^^^^^ help: try simplifying it as shown: `adds`
   |
   = note: `#[warn(clippy::bool_comparison)]` on by default
   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#bool_comparison
```

Esto es cierto: `for entry in math_iter` es mucho m치s simple que `while let Some(entry) = math_iter(next)`. Un bucle `for` ya realiza la iteraci칩n, por lo que no hay que escribir `.iter()`. Y tampoco se necesitaba usar `math_iter`, se puede esribir `for entry in result_vec`.

Adem치s, se va a refactorizar parte del c칩digo. En lugar de variables separadas, se crea una estructura `Calculator` que une las variables necesarias. Se cambiar치n dos nombres por claridad. `result_vec` se convierte en `results` y `push_string` en `current_input` (la entrada actual). En este momento, esta estructura solo tiene un m칠todo: `new()`.

```rust
# #![allow(unused)]
# fn main() {
// 游뚾
#[derive(Clone)]
struct Calculator {
    results: Vec<String>,
    current_input: String,
    total: i32,
    adds: bool,
}

impl Calculator {
    fn new() -> Self {
        Self {
            results: vec![],
            current_input: String::new(),
            total: 0,
            adds: true,
        }
    }
}
# }
```

Ahora el c칩digo es un poco m치s largo, pero m치s f치cil de leer. Por ejemplo, `if adds` ahora es `if calculator.adds`, que es casi como leer ingl칠s. Queda as칤:

```rust
# #![allow(unused)]
# fn main() {
#[derive(Clone)]
struct Calculator {
    results: Vec<String>,
    current_input: String,
    total: i32,
    adds: bool,
}

impl Calculator {
    fn new() -> Self {
        Self {
            results: vec![],
            current_input: String::new(),
            total: 0,
            adds: true,
        }
    }
}

const OKAY_CHARACTERS: &str = "1234567890+- ";

fn math(input: &str) -> i32 {
    if !input.chars().all(|character| OKAY_CHARACTERS.contains(character)) ||
       !input.chars().take(2).any(|character| character.is_numeric()) {
        panic!("Please only input numbers, +-, or spaces");
    }

    let input = input.trim_end_matches(|x| "+- ".contains(x)).chars().filter(|x| *x != ' ').collect::<String>();
    let mut calculator = Calculator::new();

    for character in input.chars() {
        match character {
            '+' => {
                if !calculator.current_input.is_empty() {
                    calculator.results.push(calculator.current_input.clone());
                    calculator.current_input.clear();
                }
            },
            '-' => {
                if calculator.current_input.contains('-') || calculator.current_input.is_empty() {
                    calculator.current_input.push(character)
                } else {
                calculator.results.push(calculator.current_input.clone());
                calculator.current_input.clear();
                calculator.current_input.push(character);
                }
            },
            number => {
                if calculator.current_input.contains('-') {
                    calculator.results.push(calculator.current_input.clone());
                    calculator.current_input.clear();
                    calculator.current_input.push(number);
                } else {
                    calculator.current_input.push(number);
                }
            },
        }
    }
    calculator.results.push(calculator.current_input);

    for entry in calculator.results {
        if entry.contains('-') {
            if entry.chars().count() % 2 == 1 {
                calculator.adds = match calculator.adds {
                    true => false,
                    false => true
                };
                continue;
            } else {
                continue;
            }
        }
        if calculator.adds {
            calculator.total += entry.parse::<i32>().unwrap();
        } else {
            calculator.total -= entry.parse::<i32>().unwrap();
            calculator.adds = true;
        }
    }
    calculator.total
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_plus_one_is_two() {
        assert_eq!(math("1 + 1"), 2);
    }
    #[test]
    fn one_minus_two_is_minus_one() {
        assert_eq!(math("1 - 2"), -1);
    }
    #[test]
    fn one_minus_minus_one_is_two() {
        assert_eq!(math("1 - -1"), 2);
    }
    #[test]
    fn nine_plus_nine_minus_nine_minus_nine_is_zero() {
        assert_eq!(math("9+9-9-9"), 0);
    }
    #[test]
    fn eight_minus_nine_plus_nine_is_eight_even_with_characters_on_the_end() {
        assert_eq!(math("8  - 9     +9-----+++++"), 8);
    }
    #[test]
    #[should_panic]
    fn panics_when_characters_not_right() {
        math("7 + seven");
    }
}
# }
```

Finalmente, se a침aden dos m칠todos nuevos. Uno se denomina `.clear()` que vac칤a la entrada actual. El otro se denomina `push_char()` que a침ade una caracter a la entrada actual. As칤 queda el c칩digo refactorizado.

```rust
# #![allow(unused)]
# fn main() {
#[derive(Clone)]
struct Calculator {
    results: Vec<String>,
    current_input: String,
    total: i32,
    adds: bool,
}

impl Calculator {
    fn new() -> Self {
        Self {
            results: vec![],
            current_input: String::new(),
            total: 0,
            adds: true,
        }
    }

    fn clear(&mut self) {
        self.current_input.clear();
    }

    fn push_char(&mut self, character: char) {
        self.current_input.push(character);
    }
}

const OKAY_CHARACTERS: &str = "1234567890+- ";

fn math(input: &str) -> i32 {
    if !input.chars().all(|character| OKAY_CHARACTERS.contains(character)) ||
       !input.chars().take(2).any(|character| character.is_numeric()) {
        panic!("Please only input numbers, +-, or spaces");
    }

    let input = input.trim_end_matches(|x| "+- ".contains(x)).chars().filter(|x| *x != ' ').collect::<String>();
    let mut calculator = Calculator::new();

    for character in input.chars() {
        match character {
            '+' => {
                if !calculator.current_input.is_empty() {
                    calculator.results.push(calculator.current_input.clone());
                    calculator.clear();
                }
            },
            '-' => {
                if calculator.current_input.contains('-') || calculator.current_input.is_empty() {
                    calculator.push_char(character)
                } else {
                calculator.results.push(calculator.current_input.clone());
                calculator.clear();
                calculator.push_char(character);
                }
            },
            number => {
                if calculator.current_input.contains('-') {
                    calculator.results.push(calculator.current_input.clone());
                    calculator.clear();
                    calculator.push_char(number);
                } else {
                    calculator.push_char(number);
                }
            },
        }
    }
    calculator.results.push(calculator.current_input);

    for entry in calculator.results {
        if entry.contains('-') {
            if entry.chars().count() % 2 == 1 {
                calculator.adds = match calculator.adds {
                    true => false,
                    false => true
                };
                continue;
            } else {
                continue;
            }
        }
        if calculator.adds {
            calculator.total += entry.parse::<i32>().unwrap();
        } else {
            calculator.total -= entry.parse::<i32>().unwrap();
            calculator.adds = true;
        }
    }
    calculator.total
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_plus_one_is_two() {
        assert_eq!(math("1 + 1"), 2);
    }
    #[test]
    fn one_minus_two_is_minus_one() {
        assert_eq!(math("1 - 2"), -1);
    }
    #[test]
    fn one_minus_minus_one_is_two() {
        assert_eq!(math("1 - -1"), 2);
    }
    #[test]
    fn nine_plus_nine_minus_nine_minus_nine_is_zero() {
        assert_eq!(math("9+9-9-9"), 0);
    }
    #[test]
    fn eight_minus_nine_plus_nine_is_eight_even_with_characters_on_the_end() {
        assert_eq!(math("8  - 9     +9-----+++++"), 8);
    }
    #[test]
    #[should_panic]
    fn panics_when_characters_not_right() {
        math("7 + seven");
    }
}
# }
```

Se pueden escribir m치s m칠todos, pero l칤neas como `calculator.results.push(calculator.current_input.clone());` ya quedan suficientemente claras. Cuando se refactoriza, es bueno que el c칩digo quede legible, no se trata de hacerlo m치s corto: `clc.clr()` es peor que `calculator.clear()`, por ejemplo.
