# Cierres en funciones

Los cierres (closures) son muy √∫tiles. ¬øC√≥mo los pasamos como par√°metro a nuestras propias funciones?

Es posible hacerlo, pero dentro de ellas es necesario definir el tipo de cierre (de los tres tipos posibles vistos en el apartardo anterior). Fuera de una funci√≥n, Rust decide por s√≠ mismo qu√© tipo de cierre debe usar: `Fn`, `FnMut` o `FnOnce`. Sin embargo, dentro de la funci√≥n resulta necesario seleccionar qu√© tipo se admite. Loa mejor forma de comprenderlo es revisar varias definiciones de funi√≥n. Por ejemplo, la siguiente de `.all()`. Si se recuerda, esta funci√≥n comprueba si un iterador cumple una condici√≥n en todos sus elementos. Parte de la definici√≥n dice:

```rust
# #![allow(unused)]
# fn main() {
    fn all<F>(&mut self, f: F) -> bool    // üöß
    where
        F: FnMut(Self::Item) -> bool,
# }
```

1. `fn all<F>` indica que existe un tipo gen√©rico `F`. Un cierre siempre es un tipo gen√©rico ya que cada funci√≥n es en s√≠ misma un tipo diferente (con un solo valor).
2. `(&mut self, f: F)`: `&mut self` revela que esta funci√≥n es un m√©todo. `f: F` es lo que por convenio se suele escribir para representar un par√°metro que debe recibir un cierre: este es el nombre de la variable y el tipo gen√©rico. No es obligatorio, l√≥gicamente, usar estas letras `f` y `F`.
3. La siguiente parte es la que define que el gen√©rico tiene que ser uno de los tres tipos de cierre: `where F: FnMut(Self::Item) -> bool`. Se requiere, en este caso, que el cierre sea modificable para que se puedan modificar sus par√°metros. En este caso, necesita cambiar el iterador (`Self::Item`). Se devuelve un booleano: `true` o `false`.

A continuaci√≥n se muestar una definici√≥n m√°s simple con un cierre:

```rust
# #![allow(unused)]
# fn main() {
fn do_something<F>(f: F)    // üöß
where
    F: FnOnce(),
{
    f();
}
# }
```

En este caso, se toma un cierre como par√°metro (se hace propietario de √©l ya que es de tipo `FnOnce`) y no devuelve ning√∫n valor. El cierre, seg√∫n se define en la cl√°usula `where`, no tiene par√°metros y no devuelve ning√∫n valor.

Ampliando el ejemplo anterior, se crea un `Vec` y se itera a trav√©s de √©l para mostrar lo que se puede hacer:

```rust
fn do_something<F>(f: F)
where
    F: FnOnce(),
{
    f();
}

fn main() {
    let some_vec = vec![9, 8, 10];
    do_something(|| {
        some_vec
            .into_iter()
            .for_each(|x| println!("The number is: {}", x));
    })
}
```

Para ver un ejemplo m√°s realista, se crea a continuaci√≥n un `struct City`. Esta vez tendr√° m√°s datos sobre a√±os y poblaci√≥n. Dispone de un `Vec<u32>` para contener todos los a√±os y otro `Vec<u32>`igual para el n√∫mero de habitantes.

`City` tiene dos funciones: `new()` para crear una nueva ciudad y `.city_data()` que recibe un cierre. Cuando se usa `.city_data()` devuelve los a√±os, los habitantes y un cierre, para que se pueda realizar la operaci√≥n que se solicite con los datos. El tipo del cierre es `FnMut` para poder modificar los valores. El ejemplo es as√≠:

```rust
#[derive(Debug)]
struct City {
    name: String,
    years: Vec<u32>,
    populations: Vec<u32>,
}

impl City {
    fn new(name: &str, years: Vec<u32>, populations: Vec<u32>) -> Self {

        Self {
            name: name.to_string(),
            years,
            populations,
        }
    }

    fn city_data<F>(&mut self, mut f: F) // self. Solo f es gen√©rico de tipo F. f es el cierre

    where
        F: FnMut(&mut Vec<u32>, &mut Vec<u32>), // El cierre toma como par√°metrso dos vectors de u32
                                // que representan el a√±o y la poblicaci√≥n.
                                // no devuelve ning√∫n valor
    {
        f(&mut self.years, &mut self.populations) // Finalmente este es el c√≥digo de la funci√≥n
            // simplemente usa el cierre en los dos par√°metros year y habitantes"
            // se puede hacer lo que se quiera dentro del cierre. No devuelve ning√∫n valor
    }
}

fn main() {
    let years = vec![
        1372, 1834, 1851, 1881, 1897, 1925, 1959, 1989, 2000, 2005, 2010, 2020,
    ];
    let populations = vec![
        3_250, 15_300, 24_000, 45_900, 58_800, 119_800, 283_071, 478_974, 400_378, 401_694,
        406_703, 437_619,
    ];
    // Se crea la ciudad
    let mut tallinn = City::new("Tallinn", years, populations);

    // Ahora se tiene el m√©todo .city_data() que utiliza un cierre.
    // Se puede hacer lo que se quiera.

    // En primer lugar se unen los 5  primeros a√±os y los habitantes para imprimirlos.
    tallinn.city_data(|city_years, city_populations| { // Los par√°metros se pueden llamar como se quiera
        let new_vec = city_years
            .into_iter()
            .zip(city_populations.into_iter()) // Zip los dos valores juntos
            .take(5)                           // pero se queda con los 5 primeros
            .collect::<Vec<(_, _)>>(); // Deja a Rust decidir el tipo de la tupla
        println!("{:?}", new_vec);
    });

    // Ahora se va a a√±adir alg√∫n dato para el a√±o 2030
    tallinn.city_data(|x, y| { // Esta vez se les llama a los par√°metros: x, y.
        x.push(2030);
        y.push(500_000);
    });

    // Ahora no se quieren los datos de 1834
    tallinn.city_data(|x, y| {
        let position_option = x.iter().position(|x| *x == 1834);
        if let Some(position) = position_option {
            println!(
                "Going to delete {} at position {:?} now.",
                x[position], position
            ); // Confirma que se est√° borrando el elemento apropiado
            x.remove(position);
            y.remove(position);
        }
    });

    println!(
        "Years left are {:?}\nPopulations left are {:?}",
        tallinn.years, tallinn.populations
    );
}
```

Esto imprimir√° el valor de todas las veces que se ha llamado a `.city_data()`::

```text
[(1372, 3250), (1834, 15300), (1851, 24000), (1881, 45900), (1897, 58800)]
Going to delete 1834 at position 1 now.
Years left are [1372, 1851, 1881, 1897, 1925, 1959, 1989, 2000, 2005, 2010, 2020, 2030]
Populations left are [3250, 24000, 45900, 58800, 119800, 283071, 478974, 400378, 401694, 406703, 437619, 500000]
```
