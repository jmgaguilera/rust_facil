# La escritura de macros

Escribir una macro puede ser mucho complejo. Casi nunca necesitarás escribir una, pero en ocasiones puede ser necesario. Sus reglas de lenguaje pueden ser muy diferentes. Una forma de escribir una macro nueva es usar la macro `macro_rules!`, dándole un nombre y seguida de un bloque `{}`. Dentro del bloque, se comporta como una especie de sentencia `match`.

A continuación, se muestra un ejemplo que solo toma `()` como parámetro y devuelve únicamente el número 6.

```rust
macro_rules! give_six {
    () => {
        6
    };
}

fn main() {
    let six = give_six!();
    println!("{}", six);
}
```

Pero no es lo mismo que una sentencia `match`, debido a que en realidad no compila nada. Solo usa la entrada y devuelve una salida. Con esa salida, el compilador comprueba si tiene sentido. Por eso se dice que las macros son "código que escribe código". En una macro, además, los valores de retorno tienen que ser del mismo tipo, por lo que el siguiente código no funcionaría:

```rust
fn main() {
// ⚠️
    let my_number = 10;
    match my_number {
        10 => println!("You got a ten"),
        _ => 10,
    }
}
```

Dará error indicando que una de las ramas devuelve `()`, mientras que otra devuelve un `10`.

```text
error[E0308]: `match` arms have incompatible types
 --> src\main.rs:5:14
  |
3 | /     match my_number {
4 | |         10 => println!("You got a ten"),
  | |               ------------------------- this is found to be of type `()`
5 | |         _ => 10,
  | |              ^^ expected `()`, found integer
6 | |     }
  | |_____- `match` arms have incompatible types
```

En el caso de una macro, sí se puede "devolver" diferente código, no es algo compilado, es código lo que se devuelve. Por lo que se puede hacer esto:

```rust
macro_rules! six_or_print {
    (6) => {
        6
    };
    () => {
        println!("You didn't give me 6.");
    };
}

fn main() {
    let my_number = six_or_print!(6);
    six_or_print!();
}
```

Lo anterior es correcto e imprime `You didn't give me 6.`. Tampoco existe una rama `_` porque funciona como un `match`. Solo se le puede pasar como parámetro `(6)` o `()`. Cualquier otra cosa dará error. El `6` que se está pasando, no es de tipo `i32`, no es de ningún tipo, solo es el código de Rust `6`. Esto hace que la entrada de una macro pueda ser cualquier cosa. Se puede pasar cualquier cosa, porque internamente solo se mira lo que se pasa, para determinar qué hacer. Por ejemplo:

```rust
macro_rules! might_print {
    (THis is strange input 하하はは哈哈 but it still works) => {
        println!("You guessed the secret message!")
    };
    () => {
        println!("You didn't guess it");
    };
}

fn main() {
    might_print!(THis is strange input 하하はは哈哈 but it still works);
    might_print!();
}
```

La macro anterior solo responde a dos entradas `()` y `(THis is strange input 하하はは哈哈 but it still works)`. A nada más. En este caso imprime:

```text
You guessed the secret message!
You didn't guess it
```

En conclusión, una macro no sigue exactamente la sintaxis habitual de Rust. Pero una macro sí puede comprender diferentes tipos de entrada. Por ejemplo:

```rust
macro_rules! might_print {
    ($input:expr) => {
        println!("You gave me: {}", $input);
    }
}

fn main() {
    might_print!(6);
}
```

Esto imprime `You gave me: 6`. La parte `$input:expr` es importante. Significa: si hay una expresión de entrada, asígnala a la variable `$input`. En las macros, las variables comienzan con el símbolo `$`. En esta macro, si se le pasa una expresión, la imprimirá. El siguiente ejemplo intenta algo más:

```rust
macro_rules! might_print {
    ($input:expr) => {
        println!("You gave me: {:?}", $input); // Now we'll use {:?} because we will give it different kinds of expressions
    }
}

fn main() {
    might_print!(()); // give it a ()
    might_print!(6); // give it a 6
    might_print!(vec![8, 9, 7, 10]); // give it a vec
}
```

Que imprimirá:

```text
You gave me: ()
You gave me: 6
You gave me: [8, 9, 7, 10]
```

Se debe observar que se escribió `{:?}`, pero en el momento de la macro no se comprueba si `&input` implementa `Debug`. Solo generará el código correspondiente `println!("You gave me: {:?}", ())` y lo intenta compilar y si no compila da error.

Aparte de `expr`, una macro puede recibir estos tipos de parámetro: `block`, `expr`, `ident`, `item`, `lifetime`, `literal`, `meta`, `pat`, `path`, `stmt`, `tt`, `ty` y `vis`. Esta parte es compleja, se puede ver lo que significa cada una [aquí](https://doc.rust-lang.org/beta/reference/macros-by-example.html), que dice:

```text
item: an Item
block: a BlockExpression
stmt: a Statement without the trailing semicolon (except for item statements that require semicolons)
pat: a Pattern
expr: an Expression
ty: a Type
ident: an IDENTIFIER_OR_KEYWORD
path: a TypePath style path
tt: a TokenTree (a single token or tokens in matching delimiters (), [], or {})
meta: an Attr, the contents of an attribute
lifetime: a LIFETIME_TOKEN
vis: a possibly empty Visibility qualifier
literal: matches -?LiteralExpression
```

Hay otro lugar denominado [cheats.rs](https://cheats.rs/#macros-attributes) que los explica con ejemplos.

Sin embargo, para la mayoría de macros, será suficiente usar `expr`, `ident` y `tt`. `ident` significa identificador y sirve para pasar variables o nombres de función. `tt` significa árbol de elementos (*token tree*), que permite cualquier tipo de entrada. A continuación se muestra un ejemplo usando ambos:

```rust
macro_rules! check {
    ($input1:ident, $input2:expr) => {
        println!(
            "Is {:?} equal to {:?}? {:?}",
            $input1,
            $input2,
            $input1 == $input2
        );
    };
}

fn main() {
    let x = 6;
    let my_vec = vec![7, 8, 9];
    check!(x, 6);
    check!(my_vec, vec![7, 8, 9]);
    check!(x, 10);
}
```

Esta macro recibe un `ident` (el nombre de una variable, por ejemplo) y una `expr` expresión y comprueban si son iguales. En el ejemplo se imprime:

```text
Is 6 equal to 6? true
Is [7, 8, 9] equal to [7, 8, 9]? true
Is 6 equal to 10? false
```

