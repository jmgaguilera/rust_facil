# Tipos de dato

Rust tiene muchos tipos de dato que permiten trabajar con n√∫meros, caracteres y otros. Algunos son simples, otros son m√°s complicados e, incluso, puedes crear tus propios tipos de dato.

## Tipos de dato primitivos
**[Puedes ver este cap√≠tulo en YouTube en ingl√©s](https://youtu.be/OxTPU5UGMhs)**

Rust tiene tipos simples que llaman **tipos primitivos** (primitivo = muy b√°sico). Comenzaremos con los n√∫meros enteros y los `char` (caracteres). Los enteros son n√∫meros sin coma decimal. Existen dos tipos de enteros:

- Enteros con signo.
- Enteros sin signo.

"Con signo" significa que disponen de `+` (signo m√°s) y `-` (signo menos), por lo que los enteros con signo pueden ser positivos o negativos (por ejemplo, +8, -8). Por el contratio, los enteros sin signo solo pueden ser positivos ya que no tienen signo.

Los enteros con signo son: `i8`, `i16`, `i32`, `i64`, `i128`, e `isize`.

Los enteros sin signo son: `u8`, `u16`, `u32`, `u64`, `u128`, e `usize`.

El n√∫mero tras la **i** o la **u** indica el n√∫mero de bits que se usan para el entero. As√≠, los n√∫meros con m√°s bits pueden ser mayores. 8 bits = un byte por lo que `i8` ocupa un byte, y puede contener valores entre el -128 y el 127. Por lo tanto `i64` ocupa 64 bits o, lo que es lo mismo, 8 bytes y puede representar n√∫meros entre el -9223372036854775808 y el 9223372036854775807.

Los tipos num√©ricos con mayor tama√±o pueden representar valores mayores. Por ejemplo, el tipo `u8`puede representar del 0 al 255, el tipo `u16` puede representar del 0 al 65635, y el tipo `u128` puede representar a un n√∫mero entre el 0 y el 340282366920938463463374607431768211455.

¬øY qu√© representan `isize` y `usize`? El n√∫mero de bits del tipo nativo del procesador de tu ordenador (El n√∫mero de bits nativo de tu procesador se denomina la **arquitectura** de tu procesador). As√≠ que `isize` y `usize` en un ordenador de 32-bits son equivalentes a `i32` y `u32`. En un ordenador de 64-bits son equivalentes a `i64` y `u64`.

Hay muchas razones para disponer de todos estos tipos de n√∫meros enteros. Una raz√≥n es el rendimiento del ordenador: es m√°s r√°pido procesar un n√∫mero menor de bytes. Por ejemplo, el n√∫mero -10 representado como un `i8` es `11110110`, pero como un `i128` es `11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110110`. 

veamos otros usos:

Los caracters en Rust se denominan `char`. Todo `char` se representa por un n√∫mero: la letra `A` es lel n√∫mero 65, mientras que el car√°cter `Âèã` ("amigo" en chino) es el n√∫mero 21451. La lista de estos n√∫meros que representan a carateres se denomina "Unicode". Unicode usa n√∫meros m√°s peque√±os para los caracteres que se usan m√°s, como los de la A a la Z, los d√≠gitos de 0 a 9 o el espacio.


```rust
fn main() {
    let primera_letra = 'A';
    let espacio = ' '; // Un espacio entre ' ' tambi√©n es un char
    let char_en_otro_idioma = '·èÑ'; // Gracias a Unicode, otros lenguajes, como el Cherokee, tambi√©n se visualizan bien
    let cara_gato = 'üò∫'; // Emojis tambi√©n son char
}
```

Los caracters que se utilizan m√°s se representan or n√∫meros menores al 256 y as√≠ pueden caber en un `u8`. Recuerda que un `u8` permite n√∫meros entre el 0 y el 255, lo que facilita la representaci√≥n de 256 caracteres en total. Esto significa que Rust puede convertir de forma segura del tipo de datos `u8` al `char`, utilizando la palabra reservada del lenguaje `as` (Considera el dato de este tipo `u8` como si fuese `char`).

La conversi√≥n de tipos de datos utilizando `as` es muy √∫til ya que Rust es muy estrict. Siempre necesita conocer el tipo de dato y, adem√°s, no deja utilizar de forma conjunta dos tipos de datos diferentes incluso aunque sean de la misma familia (como los enteros). Por ejemplo, este c√≥digo no funcionar√°:

```rust
fn main() { // main() es la funci√≥n a partir de la que se 
            // inician los programas Rust. El c√≥digo entre las llaves {}

    let mi_numero = 100; // No hemos indicado el tipo de datos entero
                         // que Rust debe utilizar,
                         // as√≠ que Rust elige i32. Rust siempre
                         // elige i32 para los enteros si no se le indica
                         // que utilice otro tipo de datos diferente

    println!("{}", mi_numero as char); // ‚ö†Ô∏è
}
```

Esta es la raz√≥n:


```text
error[E0604]: only `u8` can be cast as `char`, not `i32`
 --> src\main.rs:10:20
  |
3 |     println!("{}", mi_numero as char);
  |                    ^^^^^^^^^^^^^^^^^ invalid cast
```

Afortunadamente, podemos corregir esto f√°cilmente con `as`. No podemos convertir un `i32` a `char`, pero podemos convertir un `i32` a `u8`. Y despu√©s, podemos realizar la conversi√≥n de `u8` a `char`. Po tanto, en una l√≠nea usamos `as` para convertir mi_numero a `u8` y despu√©s lo convertimos a `char`. Ahora s√≠ compilar√°:

```rust
fn main() { 
    let mi_numero = 100; 
    println!("{}", mi_numero as u8 as char);
}
```

Se imprime `d` porque es el `char` que est√° representado en Unicode con este n√∫mero.

Existe una forma m√°s f√°cil, sin embargo, de conseguir este resultado: indicarle a Rust que `mi_numero` es de tipo `u8`. As√≠:


```rust
fn main() { 
    let mi_numero: u8 = 100; // se indica de forma expresa que
                             // el tipo de la variable mi_numero es u8
    println!("{}", mi_numero as char);
}
```

Las anteriores, son dos de las razones para la existencia de todos estos tipos de datos num√©ricos en Rust. Hay otra raz√≥n m√°s: `usize` es el tama√±o que Rust utiliza para *indexar* (Indexar significa "conocer cual elemento va primero", "cual va segundo", etc.). `usize` es el mejor tama√±o para el indexado porque:

- Un √≠ndice no puede ser negativo, por lo que tiene que ser uno de los tipos de dato con una **u**.
- Debe ser grande porque en muchas ocasiones necesitas indexar muchas cosas, pero
- No puede ser un u64 porque los ordenadores de 32-bits no lo pueden manejar.

Por eso Rust usa `usize` para indexar y facilitar que tu ordenador pueda utilizar el tipo de datos mayor de que disponga.

Vamos a aprender algo m√°s sobre `char`. Ya vimos que `char`siempre es un car√°cter y utiliza `''` en lugar de `""`.

Todos los `char` usan 4 bytes de memoria, puesto que son necesarios 4 bytes para contener cualquier clase de car√°cter:

- Las letras y s√≠mbolos b√°sicos suelen necesitar solo 1 de los 4 bytes: `a b 1 2 + - = $ @`
- Otras letras como las di√©resis y tildes necesitan 2 de los 4 bytes: `√§ √∂ √º √ü √® √© √† √±`
- Los caracteres coreanos, japoneses o chinos necesitan 3 de los cuatro bytes: `ÂõΩ Ïïà ÎÖï`

Cuando los caracteres se usan como parte de una cadena, esta se codifica para usar la menor cantidad de memoria necesaria para cada car√°cter[^1].

[^1] N.T.: Rust codifica las cadenas en UTF-8.

Para observar esto podemos usar `.len()`:

```rust
fn main() {
    println!("Tama√±o de un char: {}", std::mem::size_of::<char>()); // 4 bytes
    // .len() devuelve el tama√±o de una cadena de texto en bytes
    println!("Tama√±o de una cadena que contiene la 'a': {}", "a".len());
    println!("Tama√±o de una cadena que contiene la '√ü': {}", "√ü".len());
    println!("Tama√±o de una cadena que contiene la 'ÂõΩ': {}", "ÂõΩ".len());
    println!("Tama√±o de una cadena que contiene la 'ìÖ±': {}", "ìÖ±".len());
}
```

Lo que imprime:

```text
Tama√±o de un char: 4
Tama√±o de una cadena que contiene la 'a': 1
Tama√±o de una cadena que contiene la '√ü': 2
Tama√±o de una cadena que contiene la 'ÂõΩ': 3
Tama√±o de una cadena que contiene la 'ìÖ±': 4
```

Puedes ver que la `a` ocupa un byte, la '√ü' alemana ocupa dos, la japonesa `ÂõΩ` ocupa tres, y el car√°cter del antiguo egipto `ìÖ±` ocupa cuatro bytes.

```rust
fn main() {
    let fragmento = "¬°Hola!";
    println!("El fragmento ocupa {} bytes.", fragmento.len());
    let fragmento2 = "ÏïàÎÖï!"; // Coreano de "hola"
    println!("El fragmento2 ocupa {} bytes.", fragmento2.len());
}
```

Que imprime:

```text
El fragmento ocupa 7 bytes.
El fragmento2 ocupa 7 bytes.
```

El primer fragmento consta de seis caracteres y ocupa 7 bytes (la apertura de exclamaci√≥n ocupa dos bytes). El segundo fragmento consta de tres caracteres y ocupa 7 bytes (los dos primeros caracteres ocupan tres bytes cada uno).

Si `.len()` devuelve el tama√±o en bytes, ¬øc√≥mo se puede conocer el tama√±o de una cadena de texto en caracteres? Aprenderemos esto m√°s tarde, en este momento basta con recordar que se hace con `.chars().count()`. La primera funci√≥n `.chars()` devuelve los caracteres separados y luego cuenta cu√°ntos son.


```rust
fn main() {
    let fragmento = "¬°Hola!";
    println!("El fragmento ocupa {} bytes y son {} caracteres.",
        fragmento.len(), fragmento.chars().count());
    let fragmento2 = "ÏïàÎÖï!";
    println!("El fragmento2 ocupa {} bytes y son {} caracteres.",
        fragmento2.len(), fragmento2.chars().count());
}
```

Que imprime:

```text
El fragmento ocupa 7 bytes y son 6 caracteres.
El fragmento2 ocupa 7 bytes y son 3 caracteres.
```

## Inferencia de tipos de dato
**[Puedes ver este cap√≠tulo en YouTube en ingl√©s](https://youtu.be/q1D2vpy3kEI)**

La inferencia de tipos de datos consiste en que si no se le indica el tipo de datos al compilador, pero lo puede determinar por s√≠ mismo, √©l decide que tipo utilizar. El compilador siempre necesita conocer el tipo de las variables, pero no siempre es necesario dec√≠rselo expresamente. En realidad, normalmente no necesitas indic√°rselo. Por ejemplo, en la sentencia `let mi_numero = 8`, `mi_numero` ser√° de tipo `i32`. Esto se debe a que el compilador elige siempre el tipo `i32` para los n√∫meros enteros si no se le indica uno. Sin embargo, en la siguiente sentencia `let mi_numero: u8 = 8`, la variable `mi_numero` es de tipo `u8` ya que as√≠ se le ha indicado.

As√≠ que normalmente el compilador puede deducir el tipo de datos, pero en ocasiones ser√° necesario indic√°rselo por una de las siguientes dos razones:

1. Est√°s programando algo muy complejo y el compilador no puede deducir el tipo de datos que es necesario.
2. Quieres usar un tipo de datos diferente (por ejemplo, quieres un `i128`, no el `i32` que se usa por defecto).

Para especificar un tipo, se a√±aden dos puntos despu√©s del nombre de la variable seguido del tipo.


```rust
fn main() {
    let numerito: u8 = 10;
}
```

Para los n√∫meros, se puede especificar el tipo despu√©s del n√∫mero, no se necesita un espacio - solo teclearlo justo despu√©s del n√∫mero.

```rust
fn main() {
    let numerito = 10u8; // 10u8 = 10 de tipo u8
}
```

Tambi√©n se puede a√±adir `_` para a√±adir claridad a la lectura.

```rust
fn main() {
    let numerito = 10_u8; // Esto es m√°s f√°cil de leer
    let numerazo = 100_000_000_i32; // 100 millones es de f√°cil lectura con _
}
```

El `_` no modifica el n√∫mero. Solo lo hace m√°s f√°cil de leer. Y no importa el cuantos `_` se utilizan.

```rust
fn main() {
    let numero = 0________u8;
    let numero2 = 1___6______2____4______i32;
    println!("{}, {}", numero, numero2);
}
```

Lo anterior imprime `0, 1624`.

## N√∫meros decimales

Los n√∫meros decimales son aquellos que tienen coma decimal[^1]. `5.5` es un n√∫mero decimal y `6` es un n√∫mero entero. `5.0` tambi√©n es un n√∫mero decimal e incluso `5.` lo es.

[^1] N.T.: en espa√±ol se usa una coma como car√°cter para separar la parte entera de un n√∫mero de su parte decimal. En Rust, la coma decimal espa√±ola se sustituye por el punto decimal que es el que se usa habitualmente en los lenguajes de programaci√≥n.

```rust
fn main() {
    let mi_decimal = 5.; // Rust ve un . y sabe que es un decimal (float, en ingl√©s)
}
```

Rust utiliza diversos tipos de dato para almacenar n√∫meros decimales, son el `f32` y el `f64`. Al igual que en los n√∫meros enteros, el n√∫mero tras `f` muestra el n√∫mero de bits utilizados en cada caso para almacenar el dato. Si no se indica el tipo, Rust elige `f64`.

```rust
fn main() {
    let mi_decimal: f64 = 5.0; // Esta variable es de tipo f64
    let mi_otro_decimal: f32 = 8.5; // Esta es de tipo f32
    let tercer_decimal = mi_decimal + mi_otro_decimal; // ‚ö†Ô∏è
}
```

Cuanto se intenta ejecutar el c√≥digo anterior, Rust se queja diciendo:

```text
error[E0308]: mismatched types
 --> src/main.rs:4:39
  |
5 |     let tercer_decimal = mi_decimal + mi_otro_decimal; // ‚ö†Ô∏è
  |                                       ^^^^^^^^^^^^^^^ expected `f64`, found `f32`
```

El compilador indica "expected (tipo), found (type)" cuando se usa el tipo err√≥neo. Rust lee el c√≥digo de esta forma:

```rust
fn main() {
    let mi_decimal: f64 = 5.0; // El compilador ve un f64
    let mi_otro_decimal: f32 = 8.5; // El compilador ve un f64. Es un tipo diferente.
    let tercer_decimal = mi_decimal + // Se quiere sumar mi_decimal, que es f64 a alg√∫n
                                      // otro n√∫mero. Ahora espera otro f64...  
        mi_otro_decimal; // ‚ö†Ô∏è pero se encuentra un f32, no se pueden sumar.
}
```

As√≠ que cuando veas que el compilador indica "expected (tipo), found (type)", debes buscar la causa por la que el compilador esperaba un tipo de datos diferente.

Con los n√∫meros simples es f√°cil arreglarlo. Puedes convertir el `f32` a `f64` con un `as`.

```rust
fn main() {
    let mi_decimal: f64 = 5.0;
    let mi_otro_decimal: f32 = 8.5;
    // En la siguiente l√≠nea, se utiliza mi_otro decimal como un f64
    let tercer_decimal = mi_decimal + mi_otro_decimal as f64;
}
```

O simplemente, se pueden eliminar las declaraciones de tipo, Rust elegir√° tipos que se puedan sumar entre s√≠.

```rust
fn main() {
    let mi_decimal = 5.0; // Rust elige f64
    let mi_otro_decimal = 8.5; // Rust elige de nuevo f64
    let tercer_decimal = mi_decimal + mi_otro_decimal;
}
```

El compilador de Rust es inteligente y no elegir√° f64 si necesitas f32:

```rust
fn main() {
    let mi_decimal: f32 = 5.0; // Rust elige f64
    let mi_otro_decimal = 8.5; // Normalmente Rust elegir√≠a f64
    // pero al conocer que lo vamos a sumar a un f32, elige un f32 para mi_otro_decimal
    let tercer_decimal = mi_decimal + mi_otro_decimal;
}
```

# Imprimiendo '¬°Hola, mundo!'
**Puedes ver este cap√≠tulo en YouTube en ingl√©s: [Video 1](https://youtu.be/yYlPHRl2geQ), [Video 2](https://youtu.be/DTCSfBJJZb8)**
