# Tipos de dato

Rust tiene muchos tipos de dato que permiten trabajar con nÃºmeros, caracteres y otros. Algunos son simples, otros son mÃ¡s complicados e, incluso, puedes crear tus propios tipos de dato.

## Tipos de dato primitivos
**[Puedes ver este capÃ­tulo en YouTube en inglÃ©s](https://youtu.be/OxTPU5UGMhs)**

Rust tiene tipos simples que llaman **tipos primitivos** (primitivo = muy bÃ¡sico). Comenzaremos con los nÃºmeros enteros y los `char` (caracteres). Los enteros son nÃºmeros sin coma decimal. Existen dos tipos de enteros:

- Enteros con signo.
- Enteros sin signo.

"Con signo" significa que disponen de `+` (signo mÃ¡s) y `-` (signo menos), por lo que los enteros con signo pueden ser positivos o negativos (por ejemplo, +8, -8). Por el contratio, los enteros sin signo solo pueden ser positivos ya que no tienen signo.

Los enteros con signo son: `i8`, `i16`, `i32`, `i64`, `i128`, e `isize`.

Los enteros sin signo son: `u8`, `u16`, `u32`, `u64`, `u128`, e `usize`.

El nÃºmero tras la **i** o la **u** indica el nÃºmero de bits que se usan para el entero. AsÃ­, los nÃºmeros con mÃ¡s bits pueden ser mayores. 8 bits = un byte por lo que `i8` ocupa un byte, y puede contener valores entre el -128 y el 127. Por lo tanto `i64` ocupa 64 bits o, lo que es lo mismo, 8 bytes y puede representar nÃºmeros entre el -9223372036854775808 y el 9223372036854775807.

Los tipos numÃ©ricos con mayor tamaÃ±o pueden representar valores mayores. Por ejemplo, el tipo `u8`puede representar del 0 al 255, el tipo `u16` puede representar del 0 al 65635, y el tipo `u128` puede representar a un nÃºmero entre el 0 y el 340282366920938463463374607431768211455.

Â¿Y quÃ© representan `isize` y `usize`? El nÃºmero de bits del tipo nativo del procesador de tu ordenador (El nÃºmero de bits nativo de tu procesador se denomina la **arquitectura** de tu procesador). AsÃ­ que `isize` y `usize` en un ordenador de 32-bits son equivalentes a `i32` y `u32`. En un ordenador de 64-bits son equivalentes a `i64` y `u64`.

Hay muchas razones para disponer de todos estos tipos de nÃºmeros enteros. Una razÃ³n es el rendimiento del ordenador: es mÃ¡s rÃ¡pido procesar un nÃºmero menor de bytes. Por ejemplo, el nÃºmero -10 representado como un `i8` es `11110110`, pero como un `i128` es `11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110110`. 

veamos otros usos:

Los caracters en Rust se denominan `char`. Todo `char` se representa por un nÃºmero: la letra `A` es lel nÃºmero 65, mientras que el carÃ¡cter `å‹` ("amigo" en chino) es el nÃºmero 21451. La lista de estos nÃºmeros que representan a carateres se denomina "Unicode". Unicode usa nÃºmeros mÃ¡s pequeÃ±os para los caracteres que se usan mÃ¡s, como los de la A a la Z, los dÃ­gitos de 0 a 9 o el espacio.


```rust
fn main() {
    let primera_letra = 'A';
    let espacio = ' '; // Un espacio entre ' ' tambiÃ©n es un char
    let char_en_otro_idioma = 'á„'; // Gracias a Unicode, otros lenguajes, como el Cherokee, tambiÃ©n se visualizan bien
    let cara_gato = 'ğŸ˜º'; // Emojis tambiÃ©n son char
}
```

Los caracters que se utilizan mÃ¡s se representan or nÃºmeros menores al 256 y asÃ­ pueden caber en un `u8`. Recuerda que un `u8` permite nÃºmeros entre el 0 y el 255, lo que facilita la representaciÃ³n de 256 caracteres en total. Esto significa que Rust puede convertir de forma segura del tipo de datos `u8` al `char`, utilizando la palabra reservada del lenguaje `as` (Considera el dato de este tipo `u8` como si fuese `char`).

La conversiÃ³n de tipos de datos utilizando `as` es muy Ãºtil ya que Rust es muy estrict. Siempre necesita conocer el tipo de dato y, ademÃ¡s, no deja utilizar de forma conjunta dos tipos de datos diferentes incluso aunque sean de la misma familia (como los enteros). Por ejemplo, este cÃ³digo no funcionarÃ¡:

```rust
fn main() { // main() es la funciÃ³n a partir de la que se 
            // inician los programas Rust. El cÃ³digo entre las llaves {}

    let mi_numero = 100; // No hemos indicado el tipo de datos entero
                         // que Rust debe utilizar,
                         // asÃ­ que Rust elige i32. Rust siempre
                         // elige i32 para los enteros si no se le indica
                         // que utilice otro tipo de datos diferente

    println!("{}", mi_numero as char); // âš ï¸
}
```

Esta es la razÃ³n:


```text
error[E0604]: only `u8` can be cast as `char`, not `i32`
 --> src\main.rs:10:20
  |
3 |     println!("{}", mi_numero as char);
  |                    ^^^^^^^^^^^^^^^^^ invalid cast
```

Afortunadamente, podemos corregir esto fÃ¡cilmente con `as`. No podemos convertir un `i32` a `char`, pero podemos convertir un `i32` a `u8`. Y despuÃ©s, podemos realizar la conversiÃ³n de `u8` a `char`. Po tanto, en una lÃ­nea usamos `as` para convertir mi_numero a `u8` y despuÃ©s lo convertimos a `char`. Ahora sÃ­ compilarÃ¡:

```rust
fn main() { 
    let mi_numero = 100; 
    println!("{}", mi_numero as u8 as char);
}
```

Se imprime `d` porque es el `char` que estÃ¡ representado en Unicode con este nÃºmero.

Existe una forma mÃ¡s fÃ¡cil, sin embargo, de conseguir este resultado: indicarle a Rust que `mi_numero` es de tipo `u8`. AsÃ­:


```rust
fn main() { 
    let mi_numero: u8 = 100; // se indica de forma expresa que
                             // el tipo de la variable mi_numero es u8
    println!("{}", mi_numero as char);
}
```

Las anteriores, son dos de las razones para la existencia de todos estos tipos de datos numÃ©ricos en Rust. Hay otra razÃ³n mÃ¡s: `usize` es el tamaÃ±o que Rust utiliza para *indexar* (Indexar significa "conocer cual elemento va primero", "cual va segundo", etc.). `usize` es el mejor tamaÃ±o para el indexado porque:

- Un Ã­ndice no puede ser negativo, por lo que tiene que ser uno de los tipos de dato con una **u**.
- Debe ser grande porque en muchas ocasiones necesitas indexar muchas cosas, pero
- No puede ser un u64 porque los ordenadores de 32-bits no lo pueden manejar.

Por eso Rust usa `usize` para indexar y facilitar que tu ordenador pueda utilizar el tipo de datos mayor de que disponga.

Vamos a aprender algo mÃ¡s sobre `char`. Ya vimos que `char`siempre es un carÃ¡cter y utiliza `''` en lugar de `""`.

Todos los `char` usan 4 bytes de memoria, puesto que son necesarios 4 bytes para contener cualquier clase de carÃ¡cter:

- Las letras y sÃ­mbolos bÃ¡sicos suelen necesitar solo 1 de los 4 bytes: `a b 1 2 + - = $ @`
- Otras letras como las diÃ©resis y tildes necesitan 2 de los 4 bytes: `Ã¤ Ã¶ Ã¼ ÃŸ Ã¨ Ã© Ã  Ã±`
- Los caracteres coreanos, japoneses o chinos necesitan 3 de los cuatro bytes: `å›½ ì•ˆ ë…•`

Cuando los caracteres se usan como parte de una cadena, esta se codifica para usar la menor cantidad de memoria necesaria para cada carÃ¡cter[^1].

[^1] N.T.: Rust codifica las cadenas en UTF-8.

Para observar esto podemos usar `.len()`:

```rust
fn main() {
    println!("TamaÃ±o de un char: {}", std::mem::size_of::<char>()); // 4 bytes
    // .len() devuelve el tamaÃ±o de una cadena de texto en bytes
    println!("TamaÃ±o de una cadena que contiene la 'a': {}", "a".len());
    println!("TamaÃ±o de una cadena que contiene la 'ÃŸ': {}", "ÃŸ".len());
    println!("TamaÃ±o de una cadena que contiene la 'å›½': {}", "å›½".len());
    println!("TamaÃ±o de una cadena que contiene la 'ğ“…±': {}", "ğ“…±".len());
}
```

Lo que imprime:

```text
TamaÃ±o de un char: 4
TamaÃ±o de una cadena que contiene la 'a': 1
TamaÃ±o de una cadena que contiene la 'ÃŸ': 2
TamaÃ±o de una cadena que contiene la 'å›½': 3
TamaÃ±o de una cadena que contiene la 'ğ“…±': 4
```

Puedes ver que la `a` ocupa un byte, la 'ÃŸ' alemana ocupa dos, la japonesa `å›½` ocupa tres, y el carÃ¡cter del antiguo egipto `ğ“…±` ocupa cuatro bytes.

```rust
fn main() {
    let fragmento = "Â¡Hola!";
    println!("El fragmento ocupa {} bytes.", fragmento.len());
    let fragmento2 = "ì•ˆë…•!"; // Coreano de "hola"
    println!("El fragmento2 ocupa {} bytes.", fragmento2.len());
}
```

Que imprime:

```text
El fragmento ocupa 7 bytes.
El fragmento2 ocupa 7 bytes.
```

El primer fragmento consta de seis caracteres y ocupa 7 bytes (la apertura de exclamaciÃ³n ocupa dos bytes). El segundo fragmento consta de tres caracteres y ocupa 7 bytes (los dos primeros caracteres ocupan tres bytes cada uno).

Si `.len()` devuelve el tamaÃ±o en bytes, Â¿cÃ³mo se puede conocer el tamaÃ±o de una cadena de texto en caracteres? Aprenderemos esto mÃ¡s tarde, en este momento basta con recordar que se hace con `.chars().count()`. La primera funciÃ³n `.chars()` devuelve los caracteres separados y luego cuenta cuÃ¡ntos son.


```rust
fn main() {
    let fragmento = "Â¡Hola!";
    println!("El fragmento ocupa {} bytes y son {} caracteres.",
        fragmento.len(), fragmento.chars().count());
    let fragmento2 = "ì•ˆë…•!";
    println!("El fragmento2 ocupa {} bytes y son {} caracteres.",
        fragmento2.len(), fragmento2.chars().count());
}
```

Que imprime:

```text
El fragmento ocupa 7 bytes y son 6 caracteres.
El fragmento2 ocupa 7 bytes y son 3 caracteres.
```
