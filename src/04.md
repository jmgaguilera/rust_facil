# Tipos de dato

Rust tiene muchos tipos de dato que permiten trabajar con n√∫meros, caracteres y otros. Algunos son simples, otros son m√°s complicados e, incluso, puedes crear tus propios tipos de dato.

## Tipos de dato primitivos
**[Puedes ver este cap√≠tulo en YouTube en ingl√©s](https://youtu.be/OxTPU5UGMhs)**

Rust tiene tipos simples que llaman **tipos primitivos** (primitivo = muy b√°sico). Comenzaremos con los n√∫meros enteros y los `char` (caracteres). Los enteros son n√∫meros sin coma decimal. Existen dos tipos de enteros:

- Enteros con signo.
- Enteros sin signo.

"Con signo" significa que disponen de `+` (signo m√°s) y `-` (signo menos), por lo que los enteros con signo pueden ser positivos o negativos (por ejemplo, +8, -8). Por el contratio, los enteros sin signo solo pueden ser positivos ya que no tienen signo.

Los enteros con signo son: `i8`, `i16`, `i32`, `i64`, `i128`, e `isize`.

Los enteros sin signo son: `u8`, `u16`, `u32`, `u64`, `u128`, e `usize`.

El n√∫mero tras la **i** o la **u** indica el n√∫mero de bits que se usan para el entero. As√≠, los n√∫meros con m√°s bits pueden ser mayores. 8 bits = un byte por lo que `i8` ocupa un byte, y puede contener valores entre el -128 y el 127. Por lo tanto `i64` ocupa 64 bits o, lo que es lo mismo, 8 bytes y puede representar n√∫meros entre el -9223372036854775808 y el 9223372036854775807.

Los tipos num√©ricos con mayor tama√±o pueden representar valores mayores. Por ejemplo, el tipo `u8`puede representar del 0 al 255, el tipo `u16` puede representar del 0 al 65635, y el tipo `u128` puede representar a un n√∫mero entre el 0 y el 340282366920938463463374607431768211455.

¬øY qu√© representan `isize` y `usize`? El n√∫mero de bits del tipo nativo del procesador de tu ordenador (El n√∫mero de bits nativo de tu procesador se denomina la **arquitectura** de tu procesador). As√≠ que `isize` y `usize` en un ordenador de 32-bits son equivalentes a `i32` y `u32`. En un ordenador de 64-bits son equivalentes a `i64` y `u64`.

Hay muchas raziones para disponer de todos estos tipos de n√∫meros enteros. Una raz√≥n es el rendimiento del ordenador: es m√°s r√°pido procesar un n√∫mero menor de bytes. Por ejemplo, el n√∫mero -10 representado como un `i8` es `11110110`, pero como un `i128` es `11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110110`. 

veamos otros usos:

Los caracters en Rust se denominan `char`. Todo `char` se representa por un n√∫mero: la letra `A` es lel n√∫mero 65, mientras que el car√°cter `Âèã` ("amigo" en chino) es el n√∫mero 21451. La lista de estos n√∫meros que representan a carateres se denomina "Unicode". Unicode usa n√∫meros m√°s peque√±os para los caracteres que se usan m√°s, como los de la A a la Z, los d√≠gitos de 0 a 9 o el espacio.


```rust
fn main() {
    let primera_letra = 'A';
    let espacio = ' '; // Un espacio entre ' ' tambi√©n es un char
    let char_en_otro_idioma = '·èÑ'; // Gracias a Unicode, otros lenguajes, como el Cherokee, tambi√©n se visualizan bien
    let cara_gato = 'üò∫'; // Emojis tambi√©n son char
}
```

Los caracters que se utilizan m√°s se representan or n√∫meros menores al 256 y as√≠ pueden caber en un `u8`. Recuerda que un `u8` permite n√∫meros entre el 0 y el 255, lo que facilita la representaci√≥n de 256 caracteres en total. Esto significa que Rust puede convertir de forma segura del tipo de datos `u8` al `char`, utilizando la palabra reservada del lenguaje `as` (Considera el dato de este tipo `u8` como si fuese `char`).

La conversi√≥n de tipos de datos utilizando `as` es muy √∫til ya que Rust es muy estrict. Siempre necesita conocer el tipo de dato y, adem√°s, no deja utilizar de forma conjunta dos tipos de datos diferentes incluso aunque sean de la misma familia (como los enteros). Por ejemplo, este c√≥digo no funcionar√°:

```rust
fn main() { // main() es la funci√≥n a partir de la que se 
            // inician los programas Rust. El c√≥digo entre las llaves {}

    let mi_numero = 100; // No hemos indicado el tipo de datos entero
                         // que Rust debe utilizar,
                         // as√≠ que Rust elige i32. Rust siempre
                         // elige i32 para los enteros si no se le indica
                         // que utilice otro tipo de datos diferente

    println!("{}", mi_numero as char); // ‚ö†Ô∏è
}
```

Esta es la raz√≥n:


```text
error[E0604]: only `u8` can be cast as `char`, not `i32`
 --> src\main.rs:10:20
  |
3 |     println!("{}", mi_numero as char);
  |                    ^^^^^^^^^^^^^^^^^ invalid cast
```

Afortunadamente, podemos corregir esto f√°cilmente con `as`. No podemos convertir un `i32` a `char`, pero podemos convertir un `i32` a `u8`. Y despu√©s, podemos realizar la conversi√≥n de `u8` a `char`. Po tanto, en una l√≠nea usamos `as` para convertir mi_numero a `u8` y despu√©s lo convertimos a `char`. Ahora s√≠ compilar√°:

```rust
fn main() { 
    let mi_numero = 100; 
    println!("{}", mi_numero as u8 as char);
}
```

Se imprime `d` porque es el `char` que est√° representado en Unicode con este n√∫mero.

Existe una forma m√°s f√°cil, sin embargo, de conseguir este resultado: indicarle a Rust que `mi_numero` es de tipo `u8`. As√≠:


```rust
fn main() { 
    let mi_numero: u8 = 100; // se indica de forma expresa que
                             // el tipo de la variable mi_numero es u8
    println!("{}", mi_numero as char);
}
```

Las anteriores, son dos de las razones para la existencia de todos estos tipos de datos num√©ricos en Rust. Hay otra raz√≥n m√°s: `usize` es el tama√±o que Rust utiliza para *indexar* (Indexar significa "conocer cual elemento va primero", "cual va segundo", etc.). `usize` es el mejor tama√±o para el indexado porque:

- Un √≠ndice no puede ser negativo, por lo que tiene que ser uno de los tipos de dato con una **u**.
- Debe ser grande porque en muchas ocasiones necesitas indexar muchas cosas, pero
- No puede ser un u64 porque los ordenadores de 32-bits no lo pueden manejar.

Por eso Rust usa `usize` para indexar y facilitar que tu ordenador pueda utilizar el tipo de datos mayor de que disponga.

