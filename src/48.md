# Entender la documentaci贸n de Rust

Es importante conocer c贸mo leer la documentaci贸n de Rust para poder comprender lo que otras personas han escrito. A continuaci贸n, se observan algunas cosas que es es conveniente conocer de la documentaci贸n de Rust:

## assert_eq!

Como se ha visto, `assert_eq!` se utiliza durante las pruebas. Se pasan dos elementos y la aplicaci贸n entra en p谩nico si no son iguales entre s铆. A continuaci贸n, se muestra un ejemplo simple en el que se necesita un n煤mero par.

```rust
fn main() {
    prints_number(56);
}

fn prints_number(input: i32) {
    assert_eq!(input % 2, 0); // el resto debe ser cero para que sea par.
                              // Si el resultado de number % 2 si no es 0, entra en p谩nico
    println!("El n煤mero no es impar. Es {}", input);
}
```

Puede que no se quiera usar `assert_eq!` en el c贸digo que se escriba, pero est谩 en todas partes de la documentaci贸n de Rust. Esto es debido a que en un documento se requiera mucho espacio para usar `println!` para todo. Adem谩s, se necesitar铆a que los elementos dispusieran del rasgo `Display` o `Debug` para todo lo que se quiera imprimir. Por eso la documentaci贸n utiliza `assert_eq!`. El siguiente es un ejmpleo de [https://doc.rust-lang.org/std/vec/struct.Vec.html](https://doc.rust-lang.org/std/vec/struct.Vec.html) que muestra c贸mo utilizar `Vec`:

```rust
fn main() {
    let mut vec = Vec::new();
    vec.push(1);
    vec.push(2);

    assert_eq!(vec.len(), 2);
    assert_eq!(vec[0], 1);

    assert_eq!(vec.pop(), Some(2));
    assert_eq!(vec.len(), 1);

    vec[0] = 7;
    assert_eq!(vec[0], 7);

    vec.extend([1, 2, 3].iter().copied());

    for x in &vec {
        println!("{}", x);
    }
    assert_eq!(vec, [7, 1, 2, 3]);
}
```

En estos ejemplos basta con leer `assert_eq(a, b)` como que "a es b". A continuaci贸n, se muestra el mismo ejemplo con comentarios que indican lo que significa cada fila.

```rust
fn main() {
    let mut vec = Vec::new();
    vec.push(1);
    vec.push(2);

    assert_eq!(vec.len(), 2); // "La longitud del vec es 2"
    assert_eq!(vec[0], 1); // "vec[0] es 1"

    assert_eq!(vec.pop(), Some(2)); // "Cuando se usa .pop(), se obtiene un Some()"
    assert_eq!(vec.len(), 1); // "La longitud del vec ahora es 1"

    vec[0] = 7;
    assert_eq!(vec[0], 7); // "Vec[0] es 7"

    vec.extend([1, 2, 3].iter().copied());

    for x in &vec {
        println!("{}", x);
    }
    assert_eq!(vec, [7, 1, 2, 3]); // "El vec contiene ahora [7, 1, 2, 3]"
}
```

## B煤squedas

La barra superior en la documentaci贸n de Rust es la barra de b煤squeda. Muestra los resultados seg煤n se teclea. Cuando se avanza en una p谩gina, la barra de b煤squeda desaparece, pero si se pulsa la tecla **s** en el teclado vuelve a aparecer. Esto permite buscar algo de forma r谩pida.

## El enlace [source]

Normalmente, el c贸digo de un m茅todo, struct, etc. No estar谩 completo. Esto se debe a que normalmente no se necesita ver todo el c贸digo para conocer como funciona. De hecho, el c贸digo completo puede hacer m谩s dif铆cil entender el objetivo de una explicaci贸n. Pero si se quiere ver, se puede pulsar en [source] y se mostrar谩 todo el c贸digo. Por ejemplo, en la p谩gina dedicada a `String` se ver la declaraci贸n de `.with_capacity()`:

```rust
# #![allow(unused)]
# fn main() {
// 
pub fn with_capacity(capacity: usize) -> String
# }
```

Este m茅todo recibe un n煤mero y obtiene una `String`. Si se quiere conocer m谩s, se puede pulsar en el enlace [source] que muestra:

```rust
# #![allow(unused)]
# fn main() {
// 
pub fn with_capacity(capacity: usize) -> String {
    String { vec: Vec::with_capacity(capacity) }
}
# }
```

Ahora se puede observar que una `String` es un tipo de `Vec`. Realmente, un `String` es un vector de `u8` bytes, lo que resulta interesante conocer. Para utilizar el m茅todo `with_capacity` no es necesario conocer este detalle, por eso solo se ve si se pulsa [source]. As铆 que es una buena idea pulsarlo cuando se quiere conocer los detalles de algo en la documentaci贸n.

## Informaci贸n sobre rasgos

La parte importante de la documentaci贸n de los rasgos es la de los "M茅todos necesitados" (Required Methods) a la izquierda. Cuando en un rasgo existe un apartado a la izquierda con m茅todos necesitados, es probable que signifique que es necesario escribirlos. Por ejemplo, para `Iterator` se necesita escribir el m茅todo `.next()`. Y para el rasgo `From` se necesita escribir el m茅todo `.from()`. Algunos rasgos se pueden implementar con solo utilizar un  **atributo**, como sucede con el rasgo `Debug` que basta con usar `#[derive(Debug)]`. `Debug` necesita el m茅todo `.fmt()`, pero normalmente no es necesario escribirlo ya que el atributo `#[derive(Debug)]` resulta suficiente para ello. Por eso, la p谩gina de `std::fmt::Debug` dice que "en general,  deber铆a ser suficiente con derivar la implementaci贸n de Debug".
