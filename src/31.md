# Traits (Rasgos)

Anteriormente, se han visto algunos *traits*[^1] (rasgos). `Debug`, `Copy` y `Clone` son traits  (rasgos). Para que un tipo tenga un trait (rasgo) hay que implementarlo. Puesto que algunos traits son tan comunes (como `Debug`), existen atributos en Rust que los implementan autom√°ticamente (con una implementaci√≥n por defecto). Esto es lo que sucede cuando se escribe `#[derive(Debug)]`: se implementa de forma autom√°tica el trait `Debug`.

```rust
#[derive(Debug)]
struct MiStruct {
    numero: usize,
}

fn main() {}
```

Pero hay otros traits que son m√°s dif√≠ciles de implementar y hay que hacerlo a mano con `impl`. Por ejemplo, el trait `Add`, que se encuentra en `std::ops::Add` y se utiliza para sumar dos cosas. Pero Rust no puede adivinar c√≥mo se pueden sumar dos cosas cualquiera, por lo que hay qu√© codificarlo.

```rust
struct CosasASumar {
    primera_cosa: u32,
    segunda_cosa: f32,
}

fn main() {}
```

Se pueden sumar `primera_cosa` y `segunda_cosa`, pero hay que dar m√°s informaci√≥n. Puede que se quiera sumar `f32`, algo as√≠:

```rust
// üöß
let resultado = self.segunda_cosa + self.primera_cosa as f32
```

O puede que se quiera poner `self.primera_cosa` junto a `self.segunda_cosa` y que sea as√≠ como se quiera sumar. As√≠ la suma de 55 a 33.4 ser√≠a 5533.4 y no 88.4.

A continuaci√≥n, se analiza en primer lugar como se crea un trait. Lo importante es recordar que los trait sirven para describir un comportamiento determinado de quien los implementen. Para crear un trait, se escribe `trait` y se crean algunas funciones (o ninguna).

```rust
struct Animal { // Un simple struct - un Animal que solo contiene su nombre
    nombre: String,
}

trait Perro { // El trait Perro asigna alguna funcionalidad
    fn ladrar(&self) { // Puede ladrar
        println!("¬°Guau, guau!");
    }
    fn correr(&self) { // y puede correr
        println!("¬°El perro est√° corriendo!");
    }
}

impl Perro for Animal {} // Ahora el Animal implementa el trait Perro

fn main() {
    let rover = Animal {
        nombre: "Rover".to_string(),
    };

    rover.ladrar(); // El Animal puede usar ladrar()
    rover.correr();  // y puede usar correr()
}
```

As√≠ est√° bien, pero no se quiere imprimir "¬°El perro est√° corriendo!". Se pueden modificar los m√©todos que implementa por defecto un trait, para ello la nueva implementaci√≥n tiene que tener la misma declaraci√≥n. Esto significa que tiene que tomar los mismos par√°metros y devolver el mismo tipo de resultado. Por ejemplo, se puede modificar el m√©todo `.correr()`. La declaraci√≥n indica:

```rust
// üöß
fn correr(&self) {
    println!("¬°El perro est√° corriendo!");
}
```

`fn correr(&self)` significa que la funci√≥n `correr()` tiene de par√°metro `&self` y no devuelve ning√∫n valor. Por lo que no se puede definir una nueva implementaci√≥n as√≠:

```rust
fn correr(&self) -> i32 { // ‚ö†Ô∏è
    5
}
```

Rust se quejar√° as√≠:

```text
   = note: expected fn pointer `fn(&Animal)`
              found fn pointer `fn(&Animal) -> i32`
```

Pero s√≠ se puede hacer esto:

```rust
struct Animal { // Un simple struct - un Animal que solo contiene su nombre
    nombre: String,
}

trait Perro { // El trait Perro asigna alguna funcionalidad
    fn ladrar(&self) { // Puede ladrar
        println!("¬°Guau, guau!");
    }
    fn correr(&self) { // y puede correr
        println!("¬°El perro est√° corriendo!");
    }
}

impl Perro for Animal { // Ahora el Animal implementa el trait Perro
    fn correr(&self) {
        println!("¬°{} est√° corriendo!", self.nombre);
    }
}

fn main() {
    let rover = Animal {
        nombre: "Rover".to_string(),
    };

    rover.ladrar(); // El Animal puede usar ladrar()
    rover.correr();  // y puede usar correr()
}
```

Ahora imprime `¬°Rover est√° corriendo!`. Esta funci√≥n es correcta porque devuelve `()` o nada, que es lo que indica la implementaci√≥n del trait.

Cuando se define un trait, se puede escribir solo la declaraci√≥n de las funciones. Esto obliga a que quien lo quiera implementar tenga que escribir el c√≥digo que desea para las funciones que solo est√°n declaradas en el trait (sin implementar). En el c√≥digo siguiente el trait solo declara las funciones sin aportar una definici√≥n por defecto de `ladrar()` y `correr()`, por eso se obliga a escribir el c√≥digo en la implementaci√≥n del trait por parte del Perro.

```rust
struct Animal {
    nombre: String,
}

trait Perro {
    fn ladrar(&self); // Solo se indica que necesita el par√°metro &self y que no devuelva nada

    fn correr(&self); // necesita &self y que no devuelva nada
    // Ahora se tiene que escribir el c√≥digo en la implementaci√≥n del Perro
}

impl Perro for Animal {

    fn ladrar(&self) {
        println!("¬°{}, para de ladrar!", self.nombre);
    }
    
    fn correr(&self) {
        println!("¬°{} est√° corriendo!", self.nombre);
    }

}

fn main() {
    let rover = Animal {
        nombre: "Rover".to_string(),
    };

    rover.ladrar();
    rover.correr();
}
```

Cuando se crea un trait (rasgo), se debe pensar: ¬øQu√© funciones deber√° tener? ¬øqu√© funciones se pueden implementar en el propio trait? y ¬øqu√© funciones deber√° implementar el propio usuario?

A continuaci√≥n se implementa el trait `Display` para el siguiente struct simple:

```rust
struct Gato {
    nombre: String,
    edad: u8,
}

fn main() {
    let mr_mantle = Gato {
        nombre: "Reggie Mantle".to_string(),
        edad: 4,
    };
}
```

Se quiere imprimir `mr_mantle`. `Debug` es f√°cil de derivar:

```rust
#[derive(Debug)]
struct Gato {
    nombre: String,
    edad: u8,
}

fn main() {
    let mr_mantle = Gato {
        nombre: "Reggie Mantle".to_string(),
        edad: 4,
    };

    println!("Mr. Mantle es un {:?}", mr_mantle);
}
```

Pero la implementaci√≥n de Debug no es muy bonita. Este es el resultado:

```text
Mr. Mantle es un Gato { nombre: "Reggie Mantle", edad: 4 }
```

Por eso, se tiene que implementar `Display` para un `Gato` si se quiere que la impresi√≥n sea bonita. En [https://doc.rust-lang.org/std/fmt/trait.Display.html](https://doc.rust-lang.org/std/fmt/trait.Display.html) se puede ver la informaci√≥n detallada para Display con un ejemplo que dice:

```rust
use std::fmt;

struct Position {
    longitude: f32,
    latitude: f32,
}

impl fmt::Display for Position {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "({}, {})", self.longitude, self.latitude)
    }
}

fn main() {}
```

Hay algunas cosas que a√∫n no se entienden en este c√≥digo, como `<'_>` y lo que hace `f`. Pero se entiende que el struct `Position` tiene √∫nicamente dos valores `f32`. Los campos de este struct son `self.longitude` y `self.latitude`. As√≠ que posiblemente se pueda utilizar este c√≥digo ara implementar la versi√≥n que se necesita para `Gato`, cambiando los campos por `self.nombre` y `self.edad`. Por √∫ltimo, `write!` se parece mucho a `println!`. As√≠, el c√≥digo queda:

```rust
use std::fmt;

struct Gato {
    nombre: String,
    edad: u8,
}

impl fmt::Display for Gato {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{} es un gato de {} a√±os.", self.nombre, self.edad)
    }
}

fn main() {}
```

Si ahora se a√±ade una funci√≥n `fn main()`, el c√≥digo queda as√≠:

```rust
use std::fmt;

struct Gato {
    nombre: String,
    edad: u8,
}

impl fmt::Display for Gato {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{} es un gato de {} a√±os.", self.nombre, self.edad)
    }
}

fn main() {
    let mr_mantle = Gato {
        nombre: "Reggie Mantle".to_string(),
        edad: 4,
    };

    println!("{}", mr_mantle);
}
```

¬°Estupendo! Ahora, cuando se usa `{}` para imprimir a un Gato, se obtiene `Reggie Mantle es un gato de 4 a√±os.`, que queda mucho mejor.

Por cierto, cuando se implementa el trait `Display` se dispone del trait `ToString` sin nada que hacer adicionalmente. Esto pasa al usar la macro `format!` que facilita la creaci√≥n de un `String` con la funci√≥n `.to_string()`. As√≠ que se puede hacer algo como lo siguiente cuando se pasa la variable `reggie_mantle` a una funci√≥n que necesite un `String`:

```rust
use std::fmt;
struct Gato {
    nombre: String,
    edad: u8,
}

impl fmt::Display for Gato {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{} es un gato de {} a√±os.", self.nombre, self.edad)
    }
}

fn print_gatos(mascota: String) {
    println!("{}", mascota);
}

fn main() {
    let mr_mantle = Gato {
        nombre: "Reggie Mantle".to_string(),
        edad: 4,
    };

    print_gatos(mr_mantle.to_string()); // Lo convierte en un String
    println!("La cadena de caracteres de Mr. Mantle tiene {} letras.",
        mr_mantle.to_string().chars().count()); // Los convierte en caracteres y los cuenta
}
```

Lo anterior imprime:

```text
Reggie Mantle es un gato de 4 a√±os.
La cadena de caracteres de Mr. Mantle tiene 35 letras.
```

[^1]: N.T.: Este concepto de Rust se puede traducir como *rasgo*. Est√° relacionado con la programaci√≥n orientada a aspectos. Los rasgos de Rust describen determinados aspectos de los tipos, funciones o variables que los implementen.
