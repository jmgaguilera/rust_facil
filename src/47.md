# Canales

Un canal es una forma f√°cil de utilizar muchos hilos que env√≠an informaci√≥n a un √∫nico punto. Son muy populares porque son simples de usar. En Rust, se puede crear un canal mediante `std::sync::mpsc`. `mpsc` significa "m√∫ltiple productor, solo un consumidor". Es decir, "muchos hilos enviando a un √∫nico lugar". Para iniciar un canal se utiliza `channel()`, que sirve para rear un `Sender` (un proceso que env√≠a) y un `Receiver` (un proceso que recibe) que est√°n unidos. Se puede observar en la declaraci√≥n de la funci√≥n:

```rust

# #![allow(unused)]
# fn main() {
// üöß
pub fn channel<T>() -> (Sender<T>, Receiver<T>)
# }
```

Normalmente, se asignan a unas variables cada elemento de la tupla con nombres como `sender` y `receiver`. O, en espa√±ol, `emisor` y `receptor`. Como se trata de una funci√≥n gen√©rica, si se escribe solo lo siguiente:

```rust
use std::sync::mpsc::channel;

fn main() {
    let (sender, receiver) = channel(); // ‚ö†Ô∏è
}
```

Rust no conocer√° el tipo que se env√≠a y recibe. As√≠ que el compilador indica:

```text
error[E0282]: type annotations needed for `(std::sync::mpsc::Sender<T>, std::sync::mpsc::Receiver<T>)`
  --> src\main.rs:30:30
   |
30 |     let (sender, receiver) = channel();
   |         ------------------   ^^^^^^^ cannot infer type for type parameter `T` declared on the function `channel`
   |         |
   |         consider giving this pattern the explicit type `(std::sync::mpsc::Sender<T>, std::sync::mpsc::Receiver<T>)`, where
the type parameter `T` is specified
```

Que indica que es necesario a√±adir un tipo para el `Sender` y el `Receiver`. Se puede hacer de la siguiente forma:

```rust
use std::sync::mpsc::{channel, Sender, Receiver};

fn main() {
    let (sender, receiver): (Sender<i32>, Receiver<i32>) = channel();
}
```

o

```rust
use std::sync::mpsc::{channel, Sender, Receiver};

fn main() {
    let (sender, receiver) = channel::<i32>();
}
```

o simplemente, se env√≠a algo a trav√©s del `Sender` en el c√≥digo, para que Rust pueda inferir su tipo:

```rust
use std::sync::mpsc::{channel, Sender, Receiver};

fn main() {
    let (sender, receiver) = channel();
    sender.send(5);
    receiver.recv(); //recv es la funci√≥n que sirve para recibir el valor. En este caso, no se usa.
}
```

As√≠, el compilador conoce el tipo. `sender` es de tipo `Result<(), SendError<i32>>` y `receiver` es de tipo `Result<(), RecvError>`. Se puede usar `unwrap()` para ver si el env√≠o ha funcionado. Por ejemplo, se el siguiente c√≥digo comprueba si ha funcionado el env√≠o:

```rust
use std::sync::mpsc::channel;

fn main() {
    let (sender, receiver) = channel();

    sender.send(5).unwrap();
    println!("{}", receiver.recv().unwrap());
}
```

Que imprime `5`.

Un canal es como un `Arc` ya que se puede clonar y enviar los clones a otros hilos. En el siguiente ejemplo se crean dos hilos que env√≠an valores a un `receiver`. Este c√≥digo funcionar√°, aunque no exactamente como se pretende:

```rust
use std::sync::mpsc::channel;

fn main() {
    let (sender, receiver) = channel();
    let sender_clone = sender.clone();

    std::thread::spawn(move|| { // mueve un sender 
        sender.send("Env√≠a un &str esta vez").unwrap();
    });

    std::thread::spawn(move|| { // mueve un sender_clone
        sender_clone.send("Y aqu√≠ otro &str").unwrap();
    });

    println!("{}", receiver.recv().unwrap());   
}
```

Los dos hilos comienzan a enviar (en cualquier orden) y despu√©s se imprime lo primero que se recibe. Por lo tanto, el resultado de la impresi√≥n puede variar cada vez, dependiendo del hilo que env√≠e primero.

Para ver el resultado completo de cada hilo, resulta conveniente guardar los manejadores de ejecutar tantas recepciones como sean necesarias.

```rust
use std::sync::mpsc::channel;

fn main() {
    let (sender, receiver) = channel();
    let sender_clone = sender.clone();
    let mut handle_vec = vec![]; // Se guardan los manejadores

    handle_vec.push(std::thread::spawn(move|| {  // push del primero
        sender.send("Env√≠a un &str esta vez").unwrap();
    }));

    handle_vec.push(std::thread::spawn(move|| {  // y push del segundo
        sender_clone.send("Y aqu√≠ otro &str").unwrap();
    }));

    for _ in handle_vec { // ahora handle_vec tiene 2 elementos. Como cada uno env√≠a un dato, se hacen tantos print como manejadores
        println!("{:?}", receiver.recv().unwrap());
    }
}
```

El orden de los str puede variar en funci√≥n del orden en que se ejecutan los env√≠os.

En el siguiente ejemplo, se crea un vector con los resultados, en lugar de imprimirlos directamente:

```rust
use std::sync::mpsc::channel;

fn main() {
    let (sender, receiver) = channel();
    let sender_clone = sender.clone();
    let mut handle_vec = vec![]; // Se guardan los manejadores
    let mut results_vec = vec![];

    handle_vec.push(std::thread::spawn(move|| {  // push del primero
        sender.send("Env√≠a un &str esta vez").unwrap();
    }));

    handle_vec.push(std::thread::spawn(move|| {  // y push del segundo
        sender_clone.send("Y aqu√≠ otro &str").unwrap();
    }));

    for _ in handle_vec { // ahora handle_vec tiene 2 elementos. Como cada uno env√≠a un dato, alamcenan tantos como manejadores
        results_vec.push(receiver.recv().unwrap());
    }

    println!("{:?}", results_vec);
}
```

El resultado del vector es `["Env√≠a un &str esta vez", "Y aqu√≠ otro &str"]`.

El siguiente ejemplo utiliza diez hilos para modificar un vector de un mill√≥n de elementos. Al comienzo, todos los elementos del vector valen cero. Se modifican todos los valores a 1. Cada hilo har√° la d√©cima parte del trabjo. Se crear√° un nuevo vector y se usar√° `.extend()` para guardar el resultado de cada hilo.

```rust
use std::sync::mpsc::channel;
use std::thread::spawn;

fn main() {
    let (sender, receiver) = channel();
    let hugevec = vec![0; 1_000_000];
    let mut newvec = vec![];
    let mut handle_vec = vec![];

    for i in 0..10 {
        let sender_clone = sender.clone();
        let mut work: Vec<u8> = Vec::with_capacity(hugevec.len() / 10); // el nuevo vec en el que guardar el resultado de la d√©cima parte del trabajo
        work.extend(&hugevec[i*100_000..(i+1)*100_000]); // el primero trabaja de 0..100_000, el siguiente de 100_000..200_000, etc.
        let handle =spawn(move || { // crea un manejador

            for number in work.iter_mut() { // efect√∫a el trabajo
                *number += 1;
            };
            sender_clone.send(work).unwrap(); // utiliza el sender_clone para enviar el trabajo al receptor
        });
        handle_vec.push(handle);
    }
    
    for handle in handle_vec { // espera a que todos los hilos terminen
        handle.join().unwrap();
    }
    
    while let Ok(results) = receiver.try_recv() {
        newvec.push(results); // guarda los resultados en receiver.recv() en el vector final
    }

    // Ahora se tiene un Vec<Vec<u8>>. se debe aplanar con .flatten()
    let newvec = newvec.into_iter().flatten().collect::<Vec<u8>>(); // Ahora es un vector de 1_000_000 u8 n√∫meros. El orden de cada d√©cima parte puede no coincidir aunque en este caso no se nota debido a que todos valen cero inicialmente
    
    println!("{:?}, {:?}, longitud total: {}", // se imprimen algunos para comprobar que contienen un 1
        &newvec[0..10], &newvec[newvec.len()-10..newvec.len()], newvec.len() // y se muestra que la longitud es de  1_000_000 de elementos
    );
    
    for number in newvec { // Si alg√∫nvalor no fuese 1 se entra en p√°nico
        if number != 1 {
            panic!();
        }
    }
}
```

Para que este ejemplo mantuviese el orden de los elementos originales (en caso de no fuesen todos con el mismo valor), ser√≠a necesario que tambi√©n se trabajara con un √≠ndice de cada secci√≥n para reordenar en el resultado antes de aplanar el vector final.
