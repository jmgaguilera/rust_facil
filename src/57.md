# Un paseo por la librería estándar

Ahora que ya se conoce bastante sobre Rust, se puede entender la mayor parte de lo que contiene la librería estándar. El código que contiene no debe asustar ya. Se muestran en este capítulo algunas partes de lo que aún no se ha aprendido. Se revisitarán conceptos que ya se conocen, para aprenderlos en mayor detalle.

## Arrays

En el pasado (antes de Rust 1.53), los arrays no implementaban `Iterator` y se necesitaba usar métodos como `.iter()` en bucles `for` (O se usaba `&` para obtener una sección que usar en un bucle `for`). En resume, este código no funcionaba en el pasado:

```rust
fn main() {
    let my_cities = ["Beirut", "Tel Aviv", "Nicosia"];

    for city in my_cities {
        println!("{}", city);
    }
}
```

El compilador daba el siguiente error:

```text
error[E0277]: `[&str; 3]` is not an iterator
 --> src\main.rs:5:17
  |
  |                 ^^^^^^^^^ borrow the array with `&` or call `.iter()` on it to iterate over it
```

Afortunadamente, esto ya no es un problema. Por lo que las siguientes tres versiones funcionan sin problema:

```rust
fn main() {
    let my_cities = ["Beirut", "Tel Aviv", "Nicosia"];

    for city in my_cities {
        println!("{}", city);
    }
    for city in &my_cities {
        println!("{}", city);
    }
    for city in my_cities.iter() {
        println!("{}", city);
    }
}
```

Que imprime:

```text
Beirut
Tel Aviv
Nicosia
Beirut
Tel Aviv
Nicosia
Beirut
Tel Aviv
Nicosia
```

Si se quiere recuperar elementos de un array para guardarlos en una variable se puede usar `[]` para desestructurarlo (como en las tuplas en sentencias `match`):

```rust
fn main() {
    let my_cities = ["Beirut", "Tel Aviv", "Nicosia"];
    let [city1, city2, city3] = my_cities;
    println!("{}", city1);
}
```

El código anterior imprime `Beirut`.

## char

Se puede usar `.escape_unicode()` para recuperar el código unicode de un carácter `char`:

```rust
fn main() {
    let korean_word = "청춘예찬";
    for character in korean_word.chars() {
        print!("{} ", character.escape_unicode());
    }
}
```

El código anterior imprime `\u{ccad} \u{cd98} \u{c608} \u{cc2c}`.

Se puede obtener un `char` de un `u8` usando el rasgo `From`, pero para obtenerlo de un `u32` resulta necesario usar `TryFrom` ya que no todos los valores `u32` son caracteres unicode y puede fallar la conversión:

```rust
extern crate rand;
use std::convert::TryFrom; // Se necesita importar TryFrom para usarlo
use rand::prelude::*;      // También se usarán números aleatorios

fn main() {
    let some_character = char::from(99); // Este es fácil - no necesita TryFrom
    println!("{}", some_character);

    let mut random_generator = rand::thread_rng();
    // Se intenta esto 40,000 times: crear un char de un u32.
    // El rango entre 0 (std::u32::MIN) to u32's highest number (std::u32::MAX). Si no funciona, devolverá '-'.
    for _ in 0..40_000 {
        let bigger_character = char::try_from(random_generator.gen_range(std::u32::MIN..std::u32::MAX)).unwrap_or('-');
        print!("{}", bigger_character)
    }
}
```

Casi siempre se genera un `-`. La salida del programa anterior se parecerá a lo siguiente:

```text
------------------------------------------------------------------------𤒰---------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-------------------------------------------------------------춗--------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
------------򇍜----------------------------------------------------
```

A partir de agosto de 2020 se puede crear un `String` a partir de `char`. (`String` implementa `From<char>`). Para ello, se usa `String::from()` pasando como parámetro un `char`.

## Enteros

Los tipos de dato enteros tienen a su disposición muchos métodos matemáticos y algunos otros. A continuación se muestran algunos de los más útiles.

`.checked_add()`, `.checked_sub()`, `.checked_mul()`, `.checked_div()`. Son métodos que validan que el resultado "cabe" en el tipo. Devuelven `Option` para que se puda validar de forma fácil el resultado sin que el programa entre en pánico.

```rust
fn main() {
    let some_number = 200_u8;
    let other_number = 200_u8;

    println!("{:?}", some_number.checked_add(other_number));
    println!("{:?}", some_number.checked_add(1));
}
```

Este código imprime:

```text
None
Some(201)
```

Se habrá observado que la página de documentación de los tipos enteros dice mucho `rhs` que significa "right hand side" (lado de la derecha). Por ejemplo, en `5 + 6`, el lado izquierdo es `5` y el derecho es `6`. Es decir, `6` es el `rhs`.

Es posible implementar la suma para cualquier tipo. Para ello, se usa el rasgo correspondiente `Add`. Después de implementarlo, se puede usar el operador `+` en el tipo en que se haya codificado. Este es el ejemplo de la documentación oficial:

```rust

#![allow(unused)]
fn main() {
use std::ops::Add; // añade acceso al rasgo Add

#[derive(Debug, Copy, Clone, PartialEq)] // PartialEq es importante para poder comparar números
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Self; // Recuerda, este es el tipo asociado. El tipo "que va" con este otro
                        // En este caso es otro Point

    fn add(self, other: Self) -> Self {
        Self {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}
}
```

A continuación se implementa para un tipo propio. Se van a sumar dos países para comparar sus economías.

```rust
use std::fmt;
use std::ops::Add;

#[derive(Clone)]
struct Country {
    name: String,
    population: u32,
    gdp: u32, // This is the size of the economy
}

impl Country {
    fn new(name: &str, population: u32, gdp: u32) -> Self {
        Self {
            name: name.to_string(),
            population,
            gdp,
        }
    }
}

impl Add for Country {
    type Output = Self;

    fn add(self, other: Self) -> Self {
        Self {
            name: format!("{} y {}", self.name, other.name), // Se unen los nombres,
            population: self.population + other.population, // se suma la población,
            gdp: self.gdp + other.gdp,   // y el producto interior bruto (gross domestic product)
        }
    }
}

impl fmt::Display for Country {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "En {} hay {} personas y un producto interior bruto de {}€", // Así se puede imprimir con solo {}
            self.name, self.population, self.gdp
        )
    }
}

fn main() {
    let nauru = Country::new("Nauru", 10_670, 160_000_000);
    let vanuatu = Country::new("Vanuatu", 307_815, 820_000_000);
    let micronesia = Country::new("Micronesia", 104_468, 367_000_000);

    // Si se hubiera usado &str en lugar de String para el name, habría que haber usado ciclos de vida
    // y era demasiado para un ejemplo. Mejor usar clone cuando se llama a println!.
    println!("{}", nauru.clone());
    println!("{}", nauru.clone() + vanuatu.clone());
    println!("{}", nauru + vanuatu + micronesia);
}
```

El código anterior imprime:

```text
En Nauru hay 10670 personas y un producto interior bruto de 160000000€
En Nauru y Vanuatu hay 318485 personas y un producto interior bruto de 980000000€
En Nauru y Vanuatu y Micronesia hay 422953 personas y un producto interior bruto de 1347000000€
```

Más adelante en este código se puede cambiar `.fmt()` para mostrar un número de forma que sea más sencillo de leer (formateándolo).

Hay otros rasgos `Sub`, `Mul` y `Div` para implementar la resta, multiplicación y división. Para poder usar `+=`, `-=`, `*=` y `/=` se deben añadir los rassgos: `AddAssign`, `SubAssign`, `MulAssign` y `DivAssign`. La lista completa existente se puede consultar [aquí](https://doc.rust-lang.org/std/ops/index.html#structs). Hay muchos más, como `%`, que se llama `Rem`, o como `-` (operador unario), que se denomina `Neg`.

## Números flotantes

`f32` y `f64` tienen un amplio número de métodos matemáticos. Hay otros más que se pueden usar. Por ejemplo `.floor()`, `.ceil()`, `.round()` y `.trunc()`. Estos métodos devuelven `f32` o `f64` solo que con la parte decimal con valor 0. Esta es su función:

- `.floor()`: devuelve el valor entero inmediatamente anterior.
- `.ceil()`: devuelve el valor entero inmediatamente siguiente.
- `.round()`: devuelve el valor `.ceil()` si la parte decimal es `0.5` o superior. Devuelve el valor `.floor()` si no es así. A esto se le llama redondeo, porque devuelve un número "redondo".
- `.trunc()`: simplemente elimina la parte decimal. (N.T.: en los números positivos funciona igual que `.floor()`, en los negativos no.)

A continuación, se muestra un ejemplo:

```rust
fn four_operations(input: f64) {
    println!(
"Para el número {}:
floor: {}
ceiling: {}
rounded: {}
truncated: {}\n",
        input,
        input.floor(),
        input.ceil(),
        input.round(),
        input.trunc()
    );
}

fn main() {
    four_operations(9.1);
    four_operations(100.7);
    four_operations(-1.1);
    four_operations(-19.9);
}
```

Que imprime:

```text
For the number 9.1:
floor: 9
ceiling: 10
rounded: 9 // because less than 9.5
truncated: 9

For the number 100.7:
floor: 100
ceiling: 101
rounded: 101 // because more than 100.5
truncated: 100

For the number -1.1:
floor: -2
ceiling: -1
rounded: -1
truncated: -1

For the number -19.9:
floor: -20
ceiling: -19
rounded: -20
truncated: -19
```

`f32` y `f64` tienen métodos denominados `.max()` y `.min()` que devuelven el menor y mayor número de dos (para otros tipos se puede usar `std::cmp::max` y `std::cmp::min`). A continuación se muestra una forma de obtener el número mayor y el menor usando `.fold()`:

```rust
fn main() {
    let my_vec = vec![8.0_f64, 7.6, 9.4, 10.0, 22.0, 77.345, 10.22, 3.2, -7.77, -10.0];
    let maximum = my_vec.iter().fold(f64::MIN, |current_number, next_number| current_number.max(*next_number)); // Nota: inicia con el menor f64 existente.
    let minimum = my_vec.iter().fold(f64::MAX, |current_number, next_number| current_number.min(*next_number)); // Y en este se inicia con el mayor posible
    println!("{}, {}", maximum, minimum);
}
```

## bool

En Rust, se pueden convertir los valores `bool` a enteros: es seguro hacerlo. `true` se convierte en `1` y `false' en '0'. Sin embargo, no es posible hacer la conversión en sentido opuesto.

```rust
fn main() {
    let true_false = (true, false);
    println!("{} {}", true_false.0 as u8, true_false.1 as i32);
}
```

Que imprime `1 0`. O se puede usar `.into()`, diciéndole al compilador el tipo:

```rust
fn main() {
    let true_false: (i128, u16) = (true.into(), false.into());
    println!("{} {}", true_false.0, true_false.1);
}
```

Que imprime lo mismo.

Desde Rust 1.50 (liberado en Febrero 2021), existe un método denominado `then()`, que convierte un `bool` en `Option`. En el método `.then()` se pasa como parámetro un cierre (closure) que solo se llama si el elemento es `true`. El valor de retorno del cierre se guarda como valor de retorno en el `Option`. Por ejemplo:

```rust
fn main() {

    let (tru, fals) = (true.then(|| 8), false.then(|| 8));
    println!("{:?}, {:?}", tru, fals);
}
```

Que imprime `Some(8), None`.

A continuación un ejemplo un poco más largo:

```rust
fn main() {
    let bool_vec = vec![true, false, true, false, false];
    
    let option_vec = bool_vec
        .iter()
        .map(|item| {
            item.then(|| { // Lo incluye en un map para poder pasarlo
                println!("¡Tengo un {}!", item);
                "Tiene valor true" // Esto va dentro de Some si es true
                                      // En otro caso, pasa None
            })
        })
        .collect::<Vec<_>>();

    println!("Tenemos este resultado: {:?}", option_vec);

    // Esto imprime Nones también. Se filtran para pasarlo a un nuevo Vec.
    let filtered_vec = option_vec.into_iter().filter_map(|c| c).collect::<Vec<_>>();

    println!("Y sin los None: {:?}", filtered_vec);
}
```

## Vec

`Vec` tiene muchos métodos que aún no se han revisado. En primer lugar, `.sort()` necesita una variable `mut self` para poder ordenar.

```rust
fn main() {
    let mut my_vec = vec![100, 90, 80, 0, 0, 0, 0, 0];
    my_vec.sort();
    println!("{:?}", my_vec);
}
```

Esto imprime `[0, 0, 0, 0, 0, 80, 90, 100]`. Existe otro método que suele ser más rápido denominado `.sort_unstable()`. En este caso, no se preocupa del orden de los números si son el mismo. En el caso de `.sort()` se sabe que el último `0, 0, 0, 0, 0` estará en el mismo orden después. En el caso de `.sort_unstable()` podría pasar que el último cero estuviese en la posición `0`, el tercero inicialmente en la posición `2`, etc.

`.dedup()` significa "quitar duplicados". Elimina los elementos iguales que están en un vector, pero solo si están uno junto a otro. El código siguiente no solo imprime `"sun", "moon"`, sino que mantiene repetidos, siempre que no estuvieran juntos.

```rust
fn main() {
    let mut my_vec = vec!["sun", "sun", "moon", "moon", "sun", "moon", "moon"];
    my_vec.dedup();
    println!("{:?}", my_vec);
}
```

El resultado es `["sun", "moon", "sun", "moon"]`.

Si se quieren eliminar todos los duplicados es necesario usar `.sort()` antes:

```rust
fn main() {
    let mut my_vec = vec!["sun", "sun", "moon", "moon", "sun", "moon", "moon"];
    my_vec.sort();
    my_vec.dedup();
    println!("{:?}", my_vec);
}
```

Así, el resultado es `["moon", "sun"]`.

## String

Se recordará que un `String` es un tipo de `Vec`, por lo tanto se pueden usar muchos de los métodos de los vectores. POr ejemplo, se puede iniciar una cadena de caracteres `String::with_capacity()`. Por ejemplo, puede ser util para ser eficiente cuando se prevé que se van a añadir caracteres con `.push()` o `.push_str()` (cuando se va a insertar un `&str`).

El siguiente ejemplo, es poco eficiente:

```rust
fn main() {
    let mut push_string = String::new();
    let mut capacity_counter = 0; // la capacidad se inicia a 0
    for _ in 0..100_000 { // Hace esto 100,000 veces
        if push_string.capacity() != capacity_counter { // Comprueba si ha variado la capacidad
            println!("{}", push_string.capacity()); // Si ha variado, se muestra la nueva
            capacity_counter = push_string.capacity(); // y se guarda en el contador
        }
        push_string.push_str("I'm getting pushed into the string!"); // y añade esto a la cadena cada vez
    }
}
```

Esto imprime

```text
35
70
140
280
560
1120
2240
4480
8960
17920
35840
71680
143360
286720
573440
1146880
2293760
4587520
```

Durante esta ejecución, ha habido que mover la cadena de sitio en memoria 18 veces. Y se conoce la capacidad final. Se puede crear la cadena de caracteres con la capacidad necesaria desde el inicio.

```rust
fn main() {
    let mut push_string = String::with_capacity(4587520); // Capacidad necesaria
    let mut capacity_counter = 0;
    for _ in 0..100_000 {
        if push_string.capacity() != capacity_counter {
            println!("{}", push_string.capacity());
            capacity_counter = push_string.capacity();
        }
        push_string.push_str("I'm getting pushed into the string!");
    }
}
```

Esto imprime `4587520` una sola vez. No ha habido que mover la cadena de caracteres ni una sola vez.

En este caso, la longitud real es un poco menor. Esto se debe a que Rust duplica la capacidad de una cadena de caracteres cada vez que necesita moverla. Existe el método `.shrink_to_fit()` (igual que en `Vec`). Así se puede reducir el tamaño al espacio realmente ocupado.

```rust
fn main() {
    let mut push_string = String::with_capacity(4587520);
    let mut capacity_counter = 0;
    for _ in 0..100_000 {
        if push_string.capacity() != capacity_counter {
            println!("{}", push_string.capacity());
            capacity_counter = push_string.capacity();
        }
        push_string.push_str("I'm getting pushed into the string!");
    }
    push_string.shrink_to_fit();
    println!("{}", push_string.capacity());
    push_string.push('a');
    println!("{}", push_string.capacity());
    push_string.shrink_to_fit();
    println!("{}", push_string.capacity());
}
```

Que imprime:

```text
4587520
3500000
7000000
3500001
```

La primera vez, una vez completa, la cadena de caracteres ocupa `4587520`, pero no se está usando todo. Se usa `.shrink_to_fit()` y pasa a ocupar `35000000`. Después se añade un `a` al final. En ese momento, Rust determina que necesita más espacio y dobla la capacidad anterior a `7000000`. Una nueva ejecución de `.shrink_to_fit()` lo reduce a `3500001`.

`.pop()` funciona con una `String` igual que en un `Vec`.

```rust
fn main() {
    let mut my_string = String::from(".daer ot drah tib elttil a si gnirts sihT");
    loop {
        let pop_result = my_string.pop();
        match pop_result {
            Some(character) => print!("{}", character),
            None => break,
        }
    }
}
```

Esto imprime `This string is a little bit hard to read`, porque está dada la vuelta.

`.retain()` es un método que usa un cierre com parámetro (lo cual es raro en este tipo `String`). Funciona como `.filter` en un iterador.

```rust
fn main() {
    let mut my_string = String::from("Age: 20 Height: 194 Weight: 80");
    my_string.retain(|character| character.is_alphabetic() || character == ' '); // consérvalo si es una letra o espacio
    dbg!(my_string); // Solo por variar, se usa dbg!() esta vez en lugar de println!
    // Se imprime solo en la consola de error
}
```

Esto imprime:

```text
[src\main.rs:4] my_string = "Age  Height  Weight "
```

## OsString y CString

`std::ffi` es la parte de la librería `std` que ayuda a usar Rust con otros lenguajes o sistemas operativos. Tiene tipos como `OsString` y `CString` que son como `String` del sistema operativo o `String` del lenguaje C. Cada uno tiene sus propias versiones de `&str`: `OsStr` y `CStr`. `ffi` significa "foreign function interface" (interfaz para funciones externas).

Se puede usar `OsString` para trabajar con un Sistema Operativo que no tenga unicode. Todas las cadenas de caracteres de Rust son unicode, pero no todos los sistemas operativos las usan. La explicación de la librería estándar dice lo siguiente:

- Una cadena de caracteres de Unix (Linux, etc) podrían ser un conjunto de bytes juntos sin ceros. En ocasiones es necesario leerla como Unicode UTF-8.
- Una cadena de caracteres de Windows podría estar compuesta de valores de 16 bits que no tengan ceros. También puede ser necesario leerla como Unicode UTF-16.
- En Rust, las cadenas de caracteres siempre están en UTF-8, que sí puede contener ceros.

Con `OsString` se pueden hacer las cosas habituales que se hacen con `String` como `OsString::from("Escribe algo aquí")`. También dispone de un método interesante `.into_string()` que intenta convertirla en una `String` de Rust. Devuelve un `Result` en el que la parte `Err` es la cadena original `OsString`.

```rust
# #![allow(unused)]
#fn main() {
// 🚧
pub fn into_string(self) -> Result<String, OsString>
}
```

Si no funciona, simplemente se dispone de la cadena original del sistema opertivo. En este `Result` no es posible ejecutar `.unwrap()` porque el sistema entra en pánico, pero se puede recuperar usando `match`. Se prueba llamando a métodos que no existen.

```rust
use std::ffi::OsString;

fn main() {
    // ⚠️
    let os_string = OsString::from("This string works for your OS too.");
    match os_string.into_string() {
        Ok(valid) => valid.thth(),           // Compilador: "Qué es .thth()??"
        Err(not_valid) => not_valid.occg(),  // Compilador: "Qué es .occg()??"
    }
}
```

El compilador indica exactamente lo que se necesita conocer. Al haber puesto métodos que no existen, el compilador indica el tipo de dato que no tiene este elemento. 

```text
error[E0599]: no method named `thth` found for struct `std::string::String` in the current scope
 --> src/main.rs:6:28
  |
6 |         Ok(valid) => valid.thth(),
  |                            ^^^^ method not found in `std::string::String`

error[E0599]: no method named `occg` found for struct `std::ffi::OsString` in the current scope
 --> src/main.rs:7:37
  |
7 |         Err(not_valid) => not_valid.occg(),
  |                                     ^^^^ method not found in `std::ffi::OsString`
```

Se ve que en el primer caso, el caso correcto, devolvería `String` y en el caso incorrecto devolvería `OsString`:

## mem
