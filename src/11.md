# Cadenas de caracteres
**[Puedes ver este cap√≠tulo en YouTube en ingl√©s](https://youtu.be/pSyaGzGg26o)**

Rust tiene dos tipos de cadenas de caracteres: `String` y `&str`. ¬øCu√°l es la diferencia?

- `&str` es una cadena de caracteres simple que reside en la pila. Cuando se escribe `let mi_variable = "¬°Hola, mundo!"` se crea una `&str`. Este tipo es muy r√°pido.
- `String` es un tipo de dato m√°s complejo. Es un poco m√°s lento, pero tiene m√°s funciones. Una `String` es un puntero que almacena los datos en la memoria din√°mica.

Hay que destacar que `&str` tiene `&` como primer car√°cter debido a que es necesaria una referencia para utilizar el tipo `str`.  Esto es por la raz√≥n que vimos anteriormente: la pila necesita conocer el tama√±o, as√≠ que se le da una referencia, las referencias siempre tienen el mismo tama√±o. Otro tema a tener en cuenta es que al utilizar `&` una referencia para interactuar con el tipo `str`, nunca se es due√±o del tipo. Por el contrario, `String`es un tipo *con due√±o*. M√°s adelante se mostrar√° la importancia de esta distinci√≥n.

Ambos tipos, `&str` y `String` son UTF-8. Por ejemplo, se puede escribir el siguiente c√≥digo:


```rust
fn main() {
    // Nombre en coreano. No da problemas, ya que &str es UTF-8
    let nombre = "ÏÑúÌÉúÏßÄ";
    // »ö y »ô no son un problema en UTF-8.
    let otro_nombre = String::from("Adrian Fahrenheit »öepe»ô");
}
```

En el c√≥digo anterior se observa que se puede construir de forma f√°cil una `String` de una `&str`. Los dos tipos est√°n muy relacionados, aunque son muy diferentes.

Gracias a UTF-8, incluso se pueden escribir emojis.

```rust
fn main() {
    let nombre = "üòÇ";
    println!("Mi nombre real es {}", nombre);
}
```

Si se ejecuta este c√≥digo en el terminal de comandos de tu propio ordenador tiene que aparecer `Mi nombre real es üòÇ` a menos el terminal de comandos presente limitaciones y no lo pueda imprimir. En cuyo caso imprimir√° algo as√≠ `Mi nombre real es ÔøΩ`. En todo caso, Rust es capaz de manejar todos los caracteres Unicode.

La raz√≥n para utilizar una referencia `&`para el tipo `str` es que `str` es un tipo de datos de tama√±o din√°mico, su tama√±o puede ser diferente. Por ejmplo, los nombres "ÏÑúÌÉúÏßÄ" y "Adrian Fahrenheit »öepe»ô" no son del mismo tama√±o:

```rust
fn main() {

    // std::mem::size_of::<Type>() devuelve el tama√±o en bytes de un tipo
    println!("Una String siempre ocupa {:?} bytes. Es de tama√±o fijo.",
        std::mem::size_of::<String>()); 
    println!("Y un i8 siempre ocupa {:?} bytes. Es de tama√±o fijo.", 
        std::mem::size_of::<i8>());
    println!("Y un f64 siempre ocupa {:?} bytes. Es de tama√±o fijo.", 
        std::mem::size_of::<f64>());
     // std::mem::size_of_val() devuelve el tama√±o en bytes de una variable
    println!("¬øY un &str? Puede ocupar cualquier tama√±o. 'ÏÑúÌÉúÏßÄ' ocupa {:?} bytes. No es de tama√±o fijo.",
        std::mem::size_of_val("ÏÑúÌÉúÏßÄ"));
    println!("Y 'Adrian Fahrenheit »öepe»ô' ocupa {:?} bytes. No es de tama√±o fijo.",
        std::mem::size_of_val("Adrian Fahrenheit »öepe»ô"));
}
```

Lo que da como resultado:

```text
Una String siempre ocupa 24 bytes. Es de tama√±o fijo.
Y un i8 siempre ocupa 1 bytes. Es de tama√±o fijo.
Y un f64 siempre ocupa 8 bytes. Es de tama√±o fijo.
¬øY un &str? Puede ocupar cualquier tama√±o. 'ÏÑúÌÉúÏßÄ' ocupa 9 bytes. No es de tama√±o fijo.
Y 'Adrian Fahrenheit »öepe»ô' ocupa 25 bytes. No es de tama√±o fijo.
```

Por eso es necesario usar &, porque as√≠ se construye un puntero (tipo de tama√±o fijo) que puede almacenarse en la pila.  Si se escribiera `str`, Rust no sabr√≠a qu√© hacer al no conocer su tama√±o.

Hay muchas formas de construir un elemento de tipo `String`. Algunas de ellas son:

- `String::from("Esta es una cadena de texto");` - `String::from()` es un m√©todo de Strgin que crea un `String` a partir de una cadena de texto.
- `"Esta es una cadena de texto".to_string()` - `"".to_string()` es un m√©todo de `&str` que crea un `String`.
- La macro `format!` - Es como `println!` excepto que crea un String en lugar de imprimir el texto.

A continuaci√≥n se muestran algunos ejemplos:

```rust
fn main() {
    let my_name = "Billybrobby";
    let my_country = "USA";
    let my_home = "Korea";

    let together = format!(
        "Soy {} y vengo de {}, pero vivo en {}.",
        my_name, my_country, my_home
    );
}
```

As√≠ se construye un objeto String denominado *together*, pero no se ha impreso.

Otra forma adicional para crear un String es con la funci√≥n `into()`, pero esta forma es algo diferente ya que no solo sirve para crear String. Algunos tipos se pueden convertir de forma f√°cil en otros utilizando `from` y `into()`. Si el tipo tiene `from`, tiene tambi√©n `into()`. `from` resulta m√°s claro ya que con √©l conoces los tipos: al usarlo `String::from("Cadena de texto")` se sabe que se crea una `String` de `&str`. Sin embargo, con `.into()` el compilador, a veces, no lo conoce:

```rust
fn main() {
    let my_string = "Intento construir un String".into(); // ‚ö†Ô∏è
}
```

Rust no conoce el tipo al que se quiere convertir la cadena de texto, porque se pueden crear muchos tipos diferentes a partir de un `&str`. Rust se queja: puedo convertir &str en muchos tipos diferentes. ¬øCu√°l es el que quieres?

```text
error[E0282]: type annotations needed
 --> src/main.rs:2:9
  |
2 |     let my_string = "Intento construir un String".into(); // ‚ö†Ô∏è
  |         ^^^^^^^^^ consider giving `my_string` a type
```

Por lo que se puede corregir as√≠:

```rust
fn main() {
    let my_string: String = "Intento construir un String".into();
}
```

Y ahora s√≠ se ha podido crear un objeto String.

