<!DOCTYPE HTML>
<html lang="es" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust en espa√±ol f√°cil</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="actualizaciones.html">Actualizaciones</a></li><li class="chapter-item expanded affix "><a href="introduccion.html">Introducci√≥n</a></li><li class="chapter-item expanded affix "><a href="quiensoy.html">¬øQui√©n soy?</a></li><li class="chapter-item expanded affix "><a href="escritura.html">La escritura de Rust en ingl√©s f√°cil</a></li><li class="chapter-item expanded affix "><li class="part-title">Parte 1 - Rust en tu navegador</li><li class="chapter-item expanded "><a href="01.html"><strong aria-hidden="true">1.</strong> El entorno de pruebas de Rust</a></li><li class="chapter-item expanded "><a href="02.html"><strong aria-hidden="true">2.</strong> üöß y ‚ö†Ô∏è</a></li><li class="chapter-item expanded "><a href="03.html"><strong aria-hidden="true">3.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="04.html"><strong aria-hidden="true">4.</strong> Tipos de dato</a></li><li class="chapter-item expanded "><a href="05.html"><strong aria-hidden="true">5.</strong> Inferencia de tipos de dato</a></li><li class="chapter-item expanded "><a href="06.html"><strong aria-hidden="true">6.</strong> Imprimiendo '¬°Hola, mundo!'</a></li><li class="chapter-item expanded "><a href="07.html"><strong aria-hidden="true">7.</strong> La visualizaci√≥n y depuraci√≥n</a></li><li class="chapter-item expanded "><a href="08.html"><strong aria-hidden="true">8.</strong> Mutabilidad (cambio)</a></li><li class="chapter-item expanded "><a href="09.html"><strong aria-hidden="true">9.</strong> La pila, la memoria din√°mica y los punteros</a></li><li class="chapter-item expanded "><a href="10.html"><strong aria-hidden="true">10.</strong> M√°s sobre impresi√≥n</a></li><li class="chapter-item expanded "><a href="11.html"><strong aria-hidden="true">11.</strong> Cadenas de caracteres</a></li><li class="chapter-item expanded "><a href="12.html"><strong aria-hidden="true">12.</strong> const y static</a></li><li class="chapter-item expanded "><a href="13.html"><strong aria-hidden="true">13.</strong> Algo m√°s sobre referencias</a></li><li class="chapter-item expanded "><a href="14.html"><strong aria-hidden="true">14.</strong> Referencias modificables (mutables)</a></li><li class="chapter-item expanded "><a href="15.html"><strong aria-hidden="true">15.</strong> Paso de referencias a funciones</a></li><li class="chapter-item expanded "><a href="16.html"><strong aria-hidden="true">16.</strong> Copia</a></li><li class="chapter-item expanded "><a href="17.html"><strong aria-hidden="true">17.</strong> Tipos colecci√≥n</a></li><li class="chapter-item expanded "><a href="18.html"><strong aria-hidden="true">18.</strong> Vectores</a></li><li class="chapter-item expanded "><a href="19.html"><strong aria-hidden="true">19.</strong> Tuplas</a></li><li class="chapter-item expanded "><a href="20.html"><strong aria-hidden="true">20.</strong> Estructuras de control</a></li><li class="chapter-item expanded "><a href="21.html"><strong aria-hidden="true">21.</strong> Estructuras - struct</a></li><li class="chapter-item expanded "><a href="22.html"><strong aria-hidden="true">22.</strong> Enumerados - enum</a></li><li class="chapter-item expanded "><a href="23.html"><strong aria-hidden="true">23.</strong> Bucles</a></li><li class="chapter-item expanded "><a href="24.html"><strong aria-hidden="true">24.</strong> Implementando structs y enums</a></li><li class="chapter-item expanded "><a href="25.html"><strong aria-hidden="true">25.</strong> Desestructurar</a></li><li class="chapter-item expanded "><a href="26.html"><strong aria-hidden="true">26.</strong> Referencias y el operador punto .</a></li><li class="chapter-item expanded "><a href="27.html"><strong aria-hidden="true">27.</strong> Gen√©ricos</a></li><li class="chapter-item expanded "><a href="28.html"><strong aria-hidden="true">28.</strong> Los enumerados Option y Result</a></li><li class="chapter-item expanded "><a href="29.html"><strong aria-hidden="true">29.</strong> Otras colecciones</a></li><li class="chapter-item expanded "><a href="30.html"><strong aria-hidden="true">30.</strong> El operador ?</a></li><li class="chapter-item expanded "><a href="31.html"><strong aria-hidden="true">31.</strong> Traits (Rasgos)</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust en espa√±ol f√°cil</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="actualizaciones"><a class="header" href="#actualizaciones">Actualizaciones</a></h1>
<p><img src="https://github.com/Dhghomon/easy_rust/workflows/github%20pages/badge.svg" alt="example workflow name" /></p>
<p>23 de mayo de 2021: <a href="https://github.com/ariandy/easy-rust-indonesia">Ahora disponible en indonesio</a> gracias <a href="https://github.com/ariandy">Ariandy</a>/<a href="https://1kilobyte.github.io/">1kb</a>.</p>
<p>2 de abril de 2021: <a href="https://www.buymeacoffee.com/mithridates">A√±adido enlace a BuyMeACoffee</a> para aquellos a los que les gustar√≠a invitarme a un caf√©.</p>
<p>1 de febrero de 2021: <a href="https://www.youtube.com/playlist?list=PLfllocyHVgsRwLkTAhG0E-2QxCf-ozBkk">¬°Ahora disponible en youtube! (en ingl√©s)</a> Dos meses despu√©s: completo el 1 de abril de 2021, 186 v√≠deos en total (un poco m√°s de 23 horas).</p>
<p>22 de diciembre 2020: el libro en mdBook se puede encontrar <a href="https://dhghomon.github.io/easy_rust">aqu√≠</a>.</p>
<p>28 de noviembre de 2020: <a href="https://github.com/kumakichi/easy_rust_chs">Ahora tambi√©n disponible en chino simplificado</a> ¬°Gracias a <a href="https://github.com/kumakichi">kumakichi</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introducci√≥n"><a class="header" href="#introducci√≥n">Introducci√≥n</a></h1>
<p>Rust es un nuevo lenguaje de programaci√≥n que ya tiene buenos libros de texto, pero a veces son dif√≠ciles ya que son para personas cuyo ingl√©s es nativo. Muchas empresas y personas est√°n aprendiendo Rust en estos d√≠as y pueden aprenderlo m√°s r√°pido con un libro que use un ingl√©s f√°cil<sup class="footnote-reference"><a href="#1">1</a></sup>. Este libro es para que estas empresas y personas puedan aprender Rust con un espa√±ol simple.</p>
<p>Rust es un lenguaje que bastante nuevo, pero ya es muy popular. Es popular porque te da la velocidad y control de C o C++, pero tambi√©n ofrece protecci√≥n del acceso a la memoria como otros lenguajes como Python. Esto lo hace usando nuevas ideas que son en parte diferentes a otros lenguajes. Lo que significa que hay que aprender cosas nuevas y no puedes simplemente &quot;descubrirlo seg√∫n vas avanzando&quot;. Rust es un lenguaje en el que tienes que pensar las cosas durante un tiempo para comprenderlo, pero que a√∫n suena a familiar si conoces otros lenguajes y est√° dise√±ado para ayudarte a escribir c√≥digo de calidad.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>N.T.: esta traducci√≥n al espa√±ol trata de seguir el mismo principio utilizando un espa√±ol f√°cil.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="qui√©n-soy"><a class="header" href="#qui√©n-soy">¬øQui√©n soy?</a></h1>
<p>Soy un canadiense que vive en Korea y escrib√≠ Rust F√°cil pensando en c√≥mo hacer m√°s f√°cil su uso para las empresas de aqu√≠<sup class="footnote-reference"><a href="#1">1</a></sup>. Espero que otras empresas que no usan el ingl√©s como primer idioma puedan utilizarlo tambi√©n.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>N.T.: Soy un espa√±ol que vive en Madrid, espero que esta traducci√≥n tambi√©n facilite la comprensi√≥n de este lenguaje que tiene aspectos novedosos incluso para los que conocen C, C++, Java, Python, Ruby, Javascript o Typescript...</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="la-escritura-de-rust-en-ingl√©s-f√°cil"><a class="header" href="#la-escritura-de-rust-en-ingl√©s-f√°cil">La escritura de Rust en ingl√©s f√°cil</a></h1>
<p><em>Rust en ingl√©s f√°cil</em> se escribi√≥ de julio a agosto de 2020 y ocupa unas 400 p√°ginas. Puedes contactarme aqu√≠ o <a href="https://www.linkedin.com/in/davemacleod">en LinkedIn</a> o <a href="https://twitter.com/mithridates">en Twitter</a> si tienes cualquier pregunta. Si ves algo err√≥neo o tienes una petici√≥n de inserci√≥n (pull request) que hacer, adelante. M√°s de 20 personas ya han ayudado a corregir erratas y problemas en el c√≥digo, por lo que t√∫ tambi√©n puedes[1^]. no soy el mejor experto de Rust del mundo, as√≠ que me gusta escuchar nuevas ideas o ver en qu√© puedo hacer el libro mejor.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>N.T.: Esta traducci√≥n, <em>Rust en espa√±ol f√°cil</em>, se inici√≥ en julio de 2021. Para cualquier asunto relacionado con ella, puedes contactarme en <a href="https://github.com/jmgaguilera">github</a> o en <a href="https://es.linkedin.com/in/jmgaguilera">LinkedIn</a>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parte-1---rust-en-tu-navegador"><a class="header" href="#parte-1---rust-en-tu-navegador">Parte 1 - Rust en tu navegador</a></h1>
<p>Este libro tiene dos partes. En la primera, aprender√°s todo solo utilizando tu navegador. Puedes aprender casi todo lo que debes saber sin instalar Rust. Por eso esta primera parte es muy larga. En la segunda parte, mucho m√°s corta, se habla de Rust en tu ordenador. Ah√≠ aprender√°s todo lo que necesitas conocer y que solo se puede hacer fuera del navegador. Algunos ejemplos son: trabajar con ficheros, obtener datos del usuario, gr√°ficos y configuraciones personales. Espero que al finalizar la primera parte te guste Rust lo suficiente para que lo instales en tu equipo. Y si no, no hay problema, esta primera parte de ense√±a tanto que no te importar√°.</p>
<h1 id="el-entorno-de-pruebas-playground-de-rust"><a class="header" href="#el-entorno-de-pruebas-playground-de-rust">El entorno de pruebas (Playground) de Rust</a></h1>
<p><strong><a href="https://youtu.be/-lYeJeQ11OI">Puedes ver este cap√≠tulo en ingl√©s en YouTube</a></strong></p>
<p>Puede que no quieras instalarte a√∫n Rust. No pasa nada. Puedes ir a <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> y comenzar a escribir Rust sin salir del navegador. Puedes escribir ah√≠ el c√≥digo y pulsar <strong>Run</strong> para ver los resultados. Puedes ejecutar la mayor√≠a de los ejemplos de este libro en este entorno. Solamente al final del libro ver√°s ejemplos que van m√°s all√° de lo que se puede hacer aqu√≠ (como abrir ficheros.)</p>
<p>Algunas recomendaciones de uso de este entorno de pruebas (Playground):</p>
<ul>
<li>Ejecuta el c√≥digo con <strong>Run</strong></li>
<li>Cambia de <strong>Debug</strong> a <strong>Release</strong> si quieres que el c√≥digo sea m√°s r√°pdio. <strong>Debug</strong> (Depuraci√≥n) hace que compile m√°s r√°pido, se ejecute m√°s lento y contenga informaci√≥n para la depuraci√≥n de errores. <strong>Release</strong> (Producci√≥n) hace que compile m√°s lento, se ejecute m√°s r√°pido y se suprima la informaci√≥n para la depuraci√≥n de errores.</li>
<li>Pulsa en <strong>Share</strong> (Compartir) para obtener un hiperenlace. Puedes usarlo para compartir tu c√≥digo si necesitas ayuda. Despu√©s de pulsar compartir, puedes pulsar en <code>Open a new thread in de Rust user forum</code>(Abre un nuevo hilo en el foro de usuarios de Rust) para pedir ayuda.</li>
<li><strong>Tools</strong> (Herramientas): <strong>Rustfmt</strong> formatea el c√≥digo correctamente.</li>
<li><strong>Tools</strong> (Herramientas): <strong>Clippy</strong> da informaci√≥n extra sobre c√≥mo hacer mejor el c√≥digo.</li>
<li><strong>Config</strong> (Configuraci√≥n): puedes cambiar aqu√≠ el tema a modo oscuro para que puedas trabajar mejor de noche y otras muchas opciones.</li>
</ul>
<p>Si quieres instalar Rust, ve a <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a> y sigue las instrucciones. Normalmente, usar√°s <code>rustup</code> para instalar y actualizar Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-y-"><a class="header" href="#-y-">üöß y ‚ö†Ô∏è</a></h1>
<p>En ocasiones, el c√≥digo de los ejemplos del libro no funciona. Si un ejemplo no funciona, veras un üöß o un ‚ö†Ô∏è junto a √©l. üöß significa &quot;en construcci√≥n&quot;, es decir, que el c√≥digo no est√° completo. Rust necesita una <code>fn main()</code> (funci√≥n principal) para ejecutarse, pero algunas veces solo queremos observar una parte del c√≥digo por lo que no aparecer√° el c√≥digo <code>fn main ()</code>. Estos ejemplos son correctos, pero necesitan de una funci√≥n <code>fn main()</code> para ejecutarse. En algunos ejemplos el c√≥digo mostrar√° un problema que tendr√°s que resolver. Estos ejemplos podr√≠an tener una funci√≥n <code>fn main()</code> pero generar√°n un error y por eso se acompa√±an de un s√≠mbolo ‚ö†Ô∏è.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comentarios"><a class="header" href="#comentarios">Comentarios</a></h1>
<p><strong><a href="https://youtu.be/fJ7jBZG_Rpo">Puedes ver este cap√≠tulo en ingl√©s en YouTube</a></strong></p>
<p>Los comentarios son para que los lean los programadores, no el ordenador. es bueno escribir comentarios para ayudar a otras personas a entender tu c√≥digo. Es bueno, tambi√©n, para ayudarte a entender tu propio c√≥digo pasado un tiempo (Muchas personas escriben buen c√≥digo, pero olvidan porqu√© lo escribieron). Para escribir comentarios en el c√≥digo, en Rust se suele usar <code>//</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Los programas Rust comienzan en fn main()
    // Pones el c√≥digo en un bloque que comienza con { y termina con }
    let algun_numero = 100; // Aqu√≠ podemos esribir todo lo que queramos ya que el compilador no lo va mirar
}
</code></pre></pre>
<p>Cuando lo haces as√≠, el compilador no mirar√° nada que haya a la derecha de <code>//</code>.</p>
<p>Existe otra clase de comentario que se escribe con <code>/*</code> para iniciarlo y se termina con `*/. Este tipo de comentario es √∫til para escribirlo entre el c√≥digo.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let algun_numero/*: i16*/ = 100;
}
</code></pre></pre>
<p>Para el compilador <code>let algun_numero/*: i16*/ = 100;</code> es igual que <code>let algun_numero = 100;</code>.</p>
<p>Esta forma <code>/* */</code> tambi√©n es √∫til para los comentarios de gran longitud que necesiten m√°s de una l√≠nea. En este ejemplo se puede ver que necesitas escribir <code>//</code> en cada l√≠nea, pero si utilizas <code>/*</code>, el comentario dura hasta que lo finalices con <code>*/</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let algun_numero = 100; /* D√©jame contarte
    un poco sobre este n√∫mero.
    Es el 100, que es mi n√∫mero favorito.
    Se llama algun_numero pero realmente creo que...*/

    let algun_numero = 100; // D√©jame contarte
    // un poco sobre este n√∫mero.
    // Es el 100, que es mi n√∫mero favorito.
    // Se llama algun_numero pero realmente creo que...
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tipos-de-dato"><a class="header" href="#tipos-de-dato">Tipos de dato</a></h1>
<p>Rust tiene muchos tipos de dato que permiten trabajar con n√∫meros, caracteres y otros. Algunos son simples, otros son m√°s complicados e, incluso, puedes crear tus propios tipos de dato.</p>
<h2 id="tipos-de-dato-primitivos"><a class="header" href="#tipos-de-dato-primitivos">Tipos de dato primitivos</a></h2>
<p><strong><a href="https://youtu.be/OxTPU5UGMhs">Puedes ver este cap√≠tulo en YouTube en ingl√©s</a></strong></p>
<p>Rust tiene tipos simples que llaman <strong>tipos primitivos</strong> (primitivo = muy b√°sico). Comenzaremos con los n√∫meros enteros y los <code>char</code> (caracteres). Los enteros son n√∫meros sin coma decimal. Existen dos tipos de enteros:</p>
<ul>
<li>Enteros con signo.</li>
<li>Enteros sin signo.</li>
</ul>
<p>&quot;Con signo&quot; significa que disponen de <code>+</code> (signo m√°s) y <code>-</code> (signo menos), por lo que los enteros con signo pueden ser positivos o negativos (por ejemplo, +8, -8). Por el contratio, los enteros sin signo solo pueden ser positivos ya que no tienen signo.</p>
<p>Los enteros con signo son: <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, e <code>isize</code>.</p>
<p>Los enteros sin signo son: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, e <code>usize</code>.</p>
<p>El n√∫mero tras la <strong>i</strong> o la <strong>u</strong> indica el n√∫mero de bits que se usan para el entero. As√≠, los n√∫meros con m√°s bits pueden ser mayores. 8 bits = un byte por lo que <code>i8</code> ocupa un byte, y puede contener valores entre el -128 y el 127. Por lo tanto <code>i64</code> ocupa 64 bits o, lo que es lo mismo, 8 bytes y puede representar n√∫meros entre el -9223372036854775808 y el 9223372036854775807.</p>
<p>Los tipos num√©ricos con mayor tama√±o pueden representar valores mayores. Por ejemplo, el tipo <code>u8</code>puede representar del 0 al 255, el tipo <code>u16</code> puede representar del 0 al 65635, y el tipo <code>u128</code> puede representar a un n√∫mero entre el 0 y el 340282366920938463463374607431768211455.</p>
<p>¬øY qu√© representan <code>isize</code> y <code>usize</code>? El n√∫mero de bits del tipo nativo del procesador de tu ordenador (El n√∫mero de bits nativo de tu procesador se denomina la <strong>arquitectura</strong> de tu procesador). As√≠ que <code>isize</code> y <code>usize</code> en un ordenador de 32-bits son equivalentes a <code>i32</code> y <code>u32</code>. En un ordenador de 64-bits son equivalentes a <code>i64</code> y <code>u64</code>.</p>
<p>Hay muchas razones para disponer de todos estos tipos de n√∫meros enteros. Una raz√≥n es el rendimiento del ordenador: es m√°s r√°pido procesar un n√∫mero menor de bytes. Por ejemplo, el n√∫mero -10 representado como un <code>i8</code> es <code>11110110</code>, pero como un <code>i128</code> es <code>11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110110</code>. </p>
<p>veamos otros usos:</p>
<p>Los caracteres en Rust se denominan <code>char</code>. Todo <code>char</code> se representa por un n√∫mero: la letra <code>A</code> es lel n√∫mero 65, mientras que el car√°cter <code>Âèã</code> (&quot;amigo&quot; en chino) es el n√∫mero 21451. La lista de estos n√∫meros que representan a caracteres se denomina &quot;Unicode&quot;. Unicode usa n√∫meros m√°s peque√±os para los caracteres que se usan m√°s, como los de la A a la Z, los d√≠gitos de 0 a 9 o el espacio.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let primera_letra = 'A';
    let espacio = ' '; // Un espacio entre ' ' tambi√©n es un char
    let char_en_otro_idioma = '·èÑ'; // Gracias a Unicode, otros lenguajes, como el Cherokee, tambi√©n se visualizan bien
    let cara_gato = 'üò∫'; // Emojis tambi√©n son char
}
</code></pre></pre>
<p>Los caracteres que se utilizan m√°s se representan or n√∫meros menores al 256 y as√≠ pueden caber en un <code>u8</code>. Recuerda que un <code>u8</code> permite n√∫meros entre el 0 y el 255, lo que facilita la representaci√≥n de 256 caracteres en total. Esto significa que Rust puede convertir de forma segura del tipo de datos <code>u8</code> al <code>char</code>, utilizando la palabra reservada del lenguaje <code>as</code> (Considera el dato de este tipo <code>u8</code> como si fuese <code>char</code>).</p>
<p>La conversi√≥n de tipos de datos utilizando <code>as</code> es muy √∫til ya que Rust es muy estricto. Siempre necesita conocer el tipo de dato y, adem√°s, no deja utilizar de forma conjunta dos tipos de datos diferentes incluso aunque sean de la misma familia (como los enteros). Por ejemplo, este c√≥digo no funcionar√°:</p>
<pre><pre class="playground"><code class="language-rust">fn main() { // main() es la funci√≥n a partir de la que se 
            // inician los programas Rust. El c√≥digo entre las llaves {}

    let mi_numero = 100; // No hemos indicado el tipo de datos entero
                         // que Rust debe utilizar,
                         // as√≠ que Rust elige i32. Rust siempre
                         // elige i32 para los enteros si no se le indica
                         // que utilice otro tipo de datos diferente

    println!(&quot;{}&quot;, mi_numero as char); // ‚ö†Ô∏è
}
</code></pre></pre>
<p>Esta es la raz√≥n:</p>
<pre><code class="language-text">error[E0604]: only `u8` can be cast as `char`, not `i32`
 --&gt; src\main.rs:10:20
  |
3 |     println!(&quot;{}&quot;, mi_numero as char);
  |                    ^^^^^^^^^^^^^^^^^ invalid cast
</code></pre>
<p>Afortunadamente, podemos corregir esto f√°cilmente con <code>as</code>. No podemos convertir un <code>i32</code> a <code>char</code>, pero podemos convertir un <code>i32</code> a <code>u8</code>. Y despu√©s, podemos realizar la conversi√≥n de <code>u8</code> a <code>char</code>. Po tanto, en una l√≠nea usamos <code>as</code> para convertir mi_numero a <code>u8</code> y despu√©s lo convertimos a <code>char</code>. Ahora s√≠ compilar√°:</p>
<pre><pre class="playground"><code class="language-rust">fn main() { 
    let mi_numero = 100; 
    println!(&quot;{}&quot;, mi_numero as u8 as char);
}
</code></pre></pre>
<p>Se imprime <code>d</code> porque es el <code>char</code> que est√° representado en Unicode con este n√∫mero.</p>
<p>Existe una forma m√°s f√°cil, sin embargo, de conseguir este resultado: indicarle a Rust que <code>mi_numero</code> es de tipo <code>u8</code>. As√≠:</p>
<pre><pre class="playground"><code class="language-rust">fn main() { 
    let mi_numero: u8 = 100; // se indica de forma expresa que
                             // el tipo de la variable mi_numero es u8
    println!(&quot;{}&quot;, mi_numero as char);
}
</code></pre></pre>
<p>Las anteriores, son dos de las razones para la existencia de todos estos tipos de datos num√©ricos en Rust. Hay otra raz√≥n m√°s: <code>usize</code> es el tama√±o que Rust utiliza para <em>indexar</em> (Indexar significa &quot;conocer cual elemento va primero&quot;, &quot;cual va segundo&quot;, etc.). <code>usize</code> es el mejor tama√±o para el indexado porque:</p>
<ul>
<li>Un √≠ndice no puede ser negativo, por lo que tiene que ser uno de los tipos de dato con una <strong>u</strong>.</li>
<li>Debe ser grande porque en muchas ocasiones necesitas indexar muchas cosas, pero</li>
<li>No puede ser un u64 porque los ordenadores de 32-bits no lo pueden manejar.</li>
</ul>
<p>Por eso Rust usa <code>usize</code> para indexar y facilitar que tu ordenador pueda utilizar el tipo de datos mayor de que disponga.</p>
<p>Vamos a aprender algo m√°s sobre <code>char</code>. Ya vimos que <code>char</code>siempre es un car√°cter y utiliza <code>''</code> en lugar de <code>&quot;&quot;</code>.</p>
<p>Todos los <code>char</code> usan 4 bytes de memoria, puesto que son necesarios 4 bytes para contener cualquier clase de car√°cter:</p>
<ul>
<li>Las letras y s√≠mbolos b√°sicos suelen necesitar solo 1 de los 4 bytes: <code>a b 1 2 + - = $ @</code></li>
<li>Otras letras como las di√©resis y tildes necesitan 2 de los 4 bytes: <code>√§ √∂ √º √ü √® √© √† √±</code></li>
<li>Los caracteres coreanos, japoneses o chinos necesitan 3 de los cuatro bytes: <code>ÂõΩ Ïïà ÎÖï</code></li>
</ul>
<p>Cuando los caracteres se usan como parte de una cadena, esta se codifica para usar la menor cantidad de memoria necesaria para cada car√°cter<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<p><sup class="footnote-reference"><a href="#1">1</a></sup> N.T.: Rust codifica las cadenas en UTF-8.</p>
<p>Para observar esto podemos usar <code>.len()</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Tama√±o de un char: {}&quot;, std::mem::size_of::&lt;char&gt;()); // 4 bytes
    // .len() devuelve el tama√±o de una cadena de texto en bytes
    println!(&quot;Tama√±o de una cadena que contiene la 'a': {}&quot;, &quot;a&quot;.len());
    println!(&quot;Tama√±o de una cadena que contiene la '√ü': {}&quot;, &quot;√ü&quot;.len());
    println!(&quot;Tama√±o de una cadena que contiene la 'ÂõΩ': {}&quot;, &quot;ÂõΩ&quot;.len());
    println!(&quot;Tama√±o de una cadena que contiene la 'ìÖ±': {}&quot;, &quot;ìÖ±&quot;.len());
}
</code></pre></pre>
<p>Lo que imprime:</p>
<pre><code class="language-text">Tama√±o de un char: 4
Tama√±o de una cadena que contiene la 'a': 1
Tama√±o de una cadena que contiene la '√ü': 2
Tama√±o de una cadena que contiene la 'ÂõΩ': 3
Tama√±o de una cadena que contiene la 'ìÖ±': 4
</code></pre>
<p>Puedes ver que la <code>a</code> ocupa un byte, la '√ü' alemana ocupa dos, la japonesa <code>ÂõΩ</code> ocupa tres, y el car√°cter del antiguo egipto <code>ìÖ±</code> ocupa cuatro bytes.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let fragmento = &quot;¬°Hola!&quot;;
    println!(&quot;El fragmento ocupa {} bytes.&quot;, fragmento.len());
    let fragmento2 = &quot;ÏïàÎÖï!&quot;; // Coreano de &quot;hola&quot;
    println!(&quot;El fragmento2 ocupa {} bytes.&quot;, fragmento2.len());
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">El fragmento ocupa 7 bytes.
El fragmento2 ocupa 7 bytes.
</code></pre>
<p>El primer fragmento consta de seis caracteres y ocupa 7 bytes (la apertura de exclamaci√≥n ocupa dos bytes). El segundo fragmento consta de tres caracteres y ocupa 7 bytes (los dos primeros caracteres ocupan tres bytes cada uno).</p>
<p>Si <code>.len()</code> devuelve el tama√±o en bytes, ¬øc√≥mo se puede conocer el tama√±o de una cadena de texto en caracteres? Aprenderemos esto m√°s tarde, en este momento basta con recordar que se hace con <code>.chars().count()</code>. La primera funci√≥n <code>.chars()</code> devuelve los caracteres separados y luego cuenta cu√°ntos son.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let fragmento = &quot;¬°Hola!&quot;;
    println!(&quot;El fragmento ocupa {} bytes y son {} caracteres.&quot;,
        fragmento.len(), fragmento.chars().count());
    let fragmento2 = &quot;ÏïàÎÖï!&quot;;
    println!(&quot;El fragmento2 ocupa {} bytes y son {} caracteres.&quot;,
        fragmento2.len(), fragmento2.chars().count());
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">El fragmento ocupa 7 bytes y son 6 caracteres.
El fragmento2 ocupa 7 bytes y son 3 caracteres.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inferencia-de-tipos-de-dato"><a class="header" href="#inferencia-de-tipos-de-dato">Inferencia de tipos de dato</a></h1>
<p><strong><a href="https://youtu.be/q1D2vpy3kEI">Puedes ver este cap√≠tulo en YouTube en ingl√©s</a></strong></p>
<p>La inferencia de tipos de datos consiste en que si no se le indica el tipo de datos al compilador, pero lo puede determinar por s√≠ mismo, √©l decide que tipo utilizar. El compilador siempre necesita conocer el tipo de las variables, pero no siempre es necesario dec√≠rselo expresamente. En realidad, normalmente no necesitas indic√°rselo. Por ejemplo, en la sentencia <code>let mi_numero = 8</code>, <code>mi_numero</code> ser√° de tipo <code>i32</code>. Esto se debe a que el compilador elige siempre el tipo <code>i32</code> para los n√∫meros enteros si no se le indica uno. Sin embargo, en la siguiente sentencia <code>let mi_numero: u8 = 8</code>, la variable <code>mi_numero</code> es de tipo <code>u8</code> ya que as√≠ se le ha indicado.</p>
<p>As√≠ que normalmente el compilador puede deducir el tipo de datos, pero en ocasiones ser√° necesario indic√°rselo por una de las siguientes dos razones:</p>
<ol>
<li>Est√°s programando algo muy complejo y el compilador no puede deducir el tipo de datos que es necesario.</li>
<li>Quieres usar un tipo de datos diferente (por ejemplo, quieres un <code>i128</code>, no el <code>i32</code> que se usa por defecto).</li>
</ol>
<p>Para especificar un tipo, se a√±aden dos puntos despu√©s del nombre de la variable seguido del tipo.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numerito: u8 = 10;
}
</code></pre></pre>
<p>Para los n√∫meros, se puede especificar el tipo despu√©s del n√∫mero, no se necesita un espacio - solo teclearlo justo despu√©s del n√∫mero.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numerito = 10u8; // 10u8 = 10 de tipo u8
}
</code></pre></pre>
<p>Tambi√©n se puede a√±adir <code>_</code> para a√±adir claridad a la lectura.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numerito = 10_u8; // Esto es m√°s f√°cil de leer
    let numerazo = 100_000_000_i32; // 100 millones es de f√°cil lectura con _
}
</code></pre></pre>
<p>El <code>_</code> no modifica el n√∫mero. Solo lo hace m√°s f√°cil de leer. Y no importa el cuantos <code>_</code> se utilizan.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numero = 0________u8;
    let numero2 = 1___6______2____4______i32;
    println!(&quot;{}, {}&quot;, numero, numero2);
}
</code></pre></pre>
<p>Lo anterior imprime <code>0, 1624</code>.</p>
<h2 id="n√∫meros-decimales"><a class="header" href="#n√∫meros-decimales">N√∫meros decimales</a></h2>
<p>Los n√∫meros decimales son aquellos que tienen coma decimal<sup class="footnote-reference"><a href="#1">1</a></sup>. <code>5.5</code> es un n√∫mero decimal y <code>6</code> es un n√∫mero entero. <code>5.0</code> tambi√©n es un n√∫mero decimal e incluso <code>5.</code> lo es.</p>
<p><sup class="footnote-reference"><a href="#1">1</a></sup> N.T.: en espa√±ol se usa una coma como car√°cter para separar la parte entera de un n√∫mero de su parte decimal. En Rust, la coma decimal espa√±ola se sustituye por el punto decimal que es el que se usa habitualmente en los lenguajes de programaci√≥n.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_decimal = 5.; // Rust ve un . y sabe que es un decimal (float, en ingl√©s)
}
</code></pre></pre>
<p>Rust utiliza diversos tipos de dato para almacenar n√∫meros decimales, son el <code>f32</code> y el <code>f64</code>. Al igual que en los n√∫meros enteros, el n√∫mero tras <code>f</code> muestra el n√∫mero de bits utilizados en cada caso para almacenar el dato. Si no se indica el tipo, Rust elige <code>f64</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_decimal: f64 = 5.0; // Esta variable es de tipo f64
    let mi_otro_decimal: f32 = 8.5; // Esta es de tipo f32
    let tercer_decimal = mi_decimal + mi_otro_decimal; // ‚ö†Ô∏è
}
</code></pre></pre>
<p>Cuanto se intenta ejecutar el c√≥digo anterior, Rust se queja diciendo:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:4:39
  |
5 |     let tercer_decimal = mi_decimal + mi_otro_decimal; // ‚ö†Ô∏è
  |                                       ^^^^^^^^^^^^^^^ expected `f64`, found `f32`
</code></pre>
<p>El compilador indica &quot;expected (tipo), found (type)&quot; cuando se usa el tipo err√≥neo. Rust lee el c√≥digo de esta forma:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_decimal: f64 = 5.0; // El compilador ve un f64
    let mi_otro_decimal: f32 = 8.5; // El compilador ve un f64. Es un tipo diferente.
    let tercer_decimal = mi_decimal + // Se quiere sumar mi_decimal, que es f64 a alg√∫n
                                      // otro n√∫mero. Ahora espera otro f64...  
        mi_otro_decimal; // ‚ö†Ô∏è pero se encuentra un f32, no se pueden sumar.
}
</code></pre></pre>
<p>As√≠ que cuando veas que el compilador indica &quot;expected (tipo), found (type)&quot;, debes buscar la causa por la que el compilador esperaba un tipo de datos diferente.</p>
<p>Con los n√∫meros simples es f√°cil arreglarlo. Puedes convertir el <code>f32</code> a <code>f64</code> con un <code>as</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_decimal: f64 = 5.0;
    let mi_otro_decimal: f32 = 8.5;
    // En la siguiente l√≠nea, se utiliza mi_otro decimal como un f64
    let tercer_decimal = mi_decimal + mi_otro_decimal as f64;
}
</code></pre></pre>
<p>O simplemente, se pueden eliminar las declaraciones de tipo, Rust elegir√° tipos que se puedan sumar entre s√≠.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_decimal = 5.0; // Rust elige f64
    let mi_otro_decimal = 8.5; // Rust elige de nuevo f64
    let tercer_decimal = mi_decimal + mi_otro_decimal;
}
</code></pre></pre>
<p>El compilador de Rust es inteligente y no elegir√° f64 si necesitas f32:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_decimal: f32 = 5.0; // Rust elige f64
    let mi_otro_decimal = 8.5; // Normalmente Rust elegir√≠a f64
    // pero al conocer que lo vamos a sumar a un f32, elige un f32 para mi_otro_decimal
    let tercer_decimal = mi_decimal + mi_otro_decimal;
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="imprimiendo-hola-mundo"><a class="header" href="#imprimiendo-hola-mundo">Imprimiendo '¬°Hola, mundo!'</a></h1>
<p><strong>Puedes ver este cap√≠tulo en YouTube en ingl√©s: <a href="https://youtu.be/yYlPHRl2geQ">Video 1</a>, <a href="https://youtu.be/DTCSfBJJZb8">Video 2</a></strong></p>
<p>Cuando creas un nuevo programa Rust, siempre contiene este c√≥digo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<ul>
<li><code>fn</code> significa funci√≥n.</li>
<li><code>main</code> es el nombre de la funci√≥n que inicia el programa.</li>
<li><code>()</code> significa que en este caso no se le pasan variables a esta funci√≥n.</li>
<li><code>{}</code> es un <strong>bloque de c√≥digo</strong>. Es donde se encuentra el c√≥digo.</li>
<li><code>println!</code> es una <strong>macro</strong>, que es como una funci√≥n que sirve para escribir c√≥digo por ti. Las macros siempre tienen un <code>!</code> al final de su nombre. Por ahora, recuerda que <code>!</code> significa que es una macro.</li>
</ul>
<p>Para aprender lo que hace <code>;</code>, crearemos otra funci√≥n. Primero, en <code>main</code> imprimiremos el n√∫mero 8<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<p><sup class="footnote-reference"><a href="#1">1</a></sup> N.T.: aprovechamos para cambiar el saludo a espa√±ol. En Rust, cuando se utiliza la aplicaci√≥n <code>cargo</code> para crear un programa, siempre se incorpora el c√≥digo de <code>main</code> con &quot;Hello, world!&quot; de forma autom√°tica. </p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;¬°Hola, mundo n√∫mero {}!&quot;, 8);
}
</code></pre></pre>
<p>Las <code>{}</code> dentro de <code>println!</code> indican a Rust que &quot;ponga la variable en este lugar&quot;. Este c√≥digo imprime <code>¬°Hola, mundo n√∫mero 8!</code>.</p>
<p>Podemos poner m√°s cosas ampliando lo anterior.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;¬°Hola, mundos n√∫mero {} y {}!&quot;, 8, 9);
}
</code></pre></pre>
<p>El codigo anterior imprime <code>¬°Hola, mundos n√∫mero 8 y 9!</code>.</p>
<p>Ahora vamos a crear una funci√≥n.</p>
<pre><pre class="playground"><code class="language-rust">fn numero() -&gt; i32 {
    8
}

fn main() {
    println!(&quot;¬°Hola, mundo n√∫mero {}!&quot;, numero());
}
</code></pre></pre>
<p>El c√≥digo anterior tambi√©n imprime <code>¬°Hola, mundo n√∫mero 8!</code>. Cuando Rust encuentra <code>numero()</code> entiende que es una funci√≥n. Esta funci√≥n:</p>
<ul>
<li>No toma ning√∫n par√°metro (porque tiene una llamada con <code>()</code>).</li>
<li>Devuelve un <code>i32</code>. El s√≠mbolo de flecha <code>-&gt;</code> muestra el tipo que devuelve la funci√≥n.</li>
<li>La funci√≥n en s√≠ misma solo contiene un <code>8</code>. Al no terminar en <code>;</code> este valor es el que devuelve al terminar de ejecutarse. Si tuviera un <code>;</code> detr√°s, la funci√≥n no devolver√≠a nada (devolver√≠a un <code>()</code>). Rust no compilar√≠a si contuviera un <code>;</code> al final ya que se ha indicado que (tras la flecha) debe devolver un valor de tipo <code>i32</code> y con el <code>;</code> se devuelve <code>()</code> que no es de tipo <code>i32</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn numero() -&gt; i32 {
    8;
}

fn main() {
    println!(&quot;¬°Hola, mundo n√∫mero {}!&quot;, numero());
}
</code></pre></pre>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:1:16
  |
1 | fn numero() -&gt; i32 {
  |    ------      ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
2 |     8;
  |      - help: consider removing this semicolon
</code></pre>
<p>Esto significa que &quot;me dijiste que <code>numero()</code> devuelve un <code>i32</code>, pero a√±adiste un <code>;</code> por lo que esta funci√≥n no devuelve nada&quot;. As√≠ que el compilador sugiere que se elimine el punto y coma.</p>
<p>Tambi√©n se puede escribir lo siguiente <code>return 8;</code>, pero en Rust lo normal es simplemente eliminar el <code>;</code> para ejecutar el <code>return</code>.</p>
<p>Cuando se quiere pasar variables a una funci√≥n, se deben poner dentro de <code>()</code>. Hay que darles un nombre e indicar su tipo.</p>
<pre><pre class="playground"><code class="language-rust">// Entran a la funci√≥n dos i32s. Se llaman num_uno y num_dos
fn multiplicar(num_uno: i32, num_dos: i32) {
    let resultado = num_uno * num_dos;
    println!(&quot;{} por {} es {}&quot;, num_uno, num_dos, resultado);
}

fn main() {
    multiplicar(8, 9); // Pasamos unos n√∫meros directamente
    let algun_numero = 10; // o podemos declarar dos variables
    let algun_otro_numero = 2;
    multiplicar(algun_numero, algun_otro_numero); // y pasarlos a la funci√≥n
}
</code></pre></pre>
<p>Tambi√©n se puede devolver un <code>i32</code>. Basta con poner la variable <code>resultado</code> como la √∫ltima de la funci√≥n sin <code>;</code> al final.</p>
<pre><pre class="playground"><code class="language-rust">fn multiplicar(num_uno: i32, num_dos: i32) -&gt; i32 {
    let resultado = num_uno * num_dos;
    println!(&quot;{} por {} es {}&quot;, num_uno, num_dos, resultado);
    resultado // este es el valor i32 que se retorna
}

fn main() {
    // multiplicar() imprime el resultado y lo devuelve,
    // lo que permite asignarlo a resultado_mult
    let resultado_mult = multiplicar(8, 9);
}
</code></pre></pre>
<h2 id="la-declaraci√≥n-de-variables-y-los-bloques-de-c√≥digo"><a class="header" href="#la-declaraci√≥n-de-variables-y-los-bloques-de-c√≥digo">La declaraci√≥n de variables y los bloques de c√≥digo</a></h2>
<p>Se usa <code>let</code>para declarar una variable (para decirle a Rust que construya una variable).</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_numero = 8;
    println!(&quot;¬°Hola, mundo n√∫mero {}!&quot;, mi_numero);
}
</code></pre></pre>
<p>Las variables existen dentro de un bloque de c√≥digo <code>{}</code>. En el siguiente ejemplo <code>mi_numero</code> desaparece antes de llamar a <code>println!</code> porque se encuentra dentro de su propio c√≥digo.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    {
        let mi_numero = 8; // mi_numero se crea aqu√≠
                           // mi_numero se extingue aqu√≠
    }
    println!(&quot;¬°Hola, mundo n√∫mero {}!&quot;, mi_numero);// ‚ö†Ô∏è  mi_numero no existe y
                                                   // println!() no lo puede encontrar
}
</code></pre></pre>
<p>Se puede usar un bloque de c√≥digo para devolver un valor, como en el siguiente c√≥digo.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_numero = {
        let segundo_num = 8;
        segundo_num + 9 // sin punto y coma, por lo que el
                        // bloque de c√≥digo devuelve 8 + 9 = 17
    }; 
    println!(&quot;¬°Hola, mundo n√∫mero {}!&quot;, mi_numero);
}
</code></pre></pre>
<p>Si se a√±adiera un punto y coma en la sentencia final del bloque, devolver√≠a <code>()</code> (nada).</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_numero = {
        let segundo_num = 8; // declara el segundo n√∫mero
        segundo_num + 9;     // suma 9 con el segundo n√∫mero
                             // pero no se devuelve
                             // segundo_num desaparece aqu√≠
    }; 
    println!(&quot;¬°Hola, mundo n√∫mero {:?}!&quot;, mi_numero); // mi_numero es ()
}
</code></pre></pre>
<p>Si has observado bien, hemos cambiado <code>{}</code> por <code>{:?}</code>. El motivo se ver√° en el siguiente cap√≠tulo.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="la-visualizaci√≥n-y-depuraci√≥n"><a class="header" href="#la-visualizaci√≥n-y-depuraci√≥n">La visualizaci√≥n y depuraci√≥n</a></h1>
<p><strong><a href="https://youtu.be/jd3pC248c0o">Puedes ver este cap√≠tulo en YouTube en ingl√©s</a></strong></p>
<p>En Rust, las variables simples se pueden imprimir usyo <code>{}</code> en <code>println!</code>.  Pero hay variables que no pueden imprimirse y es necesario usar <strong>la impresi√≥n de depuraci√≥n</strong>. La impresi√≥n de depuraci√≥n es para los programadores, porque habitualmente muestra m√°s informaci√≥n. En ocasiones, esta impresi√≥n no es &quot;bonita&quot;, no queda bien, porque muestra informaci√≥n extra para ayudarte.</p>
<p>¬øC√≥mo puedes conocer si necesitas usar <code>{:?}</code> y no <code>{}</code>? El compilador te avesar√°. Por ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let no_imprime = ();
    println!(&quot;Esto no se imprimir√°: {}&quot;, no_imprime); // ‚ö†Ô∏è
}
</code></pre></pre>
<p>Cuyo se compila el c√≥digo anterior, el compilador se queja as√≠:</p>
<pre><code class="language-text">error[E0277]: `()` doesn't implement `std::fmt::Desplay`
 --&gt; src/main.rs:3:42
  |
3 |     println!(&quot;Esto no se imprimir√°: {}&quot;, no_imprime); // ‚ö†Ô∏è
  |                                          ^^^^^^^^^^ `()` cannot be formatted with el default formatter
  |
  = help: el trait `std::fmt::Desplay` es not implemented for `()`
  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
  = note: required by `std::fmt::Desplay::fmt`
  = note: thes error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)
</code></pre>
<p>Esto es mucha informaci√≥n, pero la parte importante es <code>you may be able to use {:?} (or {:#?} for pretty-print) instead</code>. Esto significa que puedes intentar usar <code>{:?}</code> o tambi√©n <code>{:#?}</code>. La segunda opci√≥n, <code>{:#?}</code> se llama &quot;impresi√≥n atractiva&quot;. Es igual que <code>{:?}</code> pero usyo un formateo diferente en m√°s l√≠neas.</p>
<p>En resumen, <code>Desplay</code> (vesualizaci√≥n) supone la impresi√≥n con <code>{}</code>, y <code>Debug</code> (depuraci√≥n) supone la impresi√≥n con <code>{:?}</code>.</p>
<p>Una √∫ltima cosa, puedes usar <code>print!</code> sin <code>ln</code> si no quieres que haya un salto de l√≠nea al final de la impresi√≥n.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    print!(&quot;Esto no imprimir√° un salto de l√≠nea&quot;);
    println!(&quot; as√≠ que esto estar√° en la mesma l√≠nea&quot;);
}
</code></pre></pre>
<p>Que imprimir√° <code>Esto no imprimir√° un salto de l√≠nea as√≠ que esto estar√° en la mesma l√≠nea</code>.</p>
<h2 id="el-n√∫mero-menor-y-el-n√∫mero-mayor"><a class="header" href="#el-n√∫mero-menor-y-el-n√∫mero-mayor">El n√∫mero menor y el n√∫mero mayor</a></h2>
<p>Si se quiere ver el menor y mayor n√∫mero que se puede representar, se puede usar MIN y MAX. <code>std</code> es la &quot;librer√≠a est√°ndar del lenguaje&quot; y contiene las funciones y otros elementos importantes del lenguaje Rust. M√°s adelante se explicar√°n elementos de la librer√≠a estyar. Mientras tanto, puedes recordar que esta es la forma de obtener los numeros menor y mayor de un tipo de datos.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // pista: std::i8::MIN significa
    // &quot;el valor de MIN de la secci√≥n i8 de la librer√≠a estandar&quot;
    println!(&quot;El menor i8 es {} y el mayor i8 es {}.&quot;, std::i8::MIN, std::i8::MAX); 
    println!(&quot;El menor u8 es {} y el mayor u8 es {}.&quot;, std::u8::MIN, std::u8::MAX);
    println!(&quot;El menor i16 es {} y el mayor i16 es {}.&quot;, std::i16::MIN, std::i16::MAX);
    println!(&quot;El menor u16 es {} y el mayor u16 es {}.&quot;, std::u16::MIN, std::u16::MAX);
    println!(&quot;El menor i32 es {} y el mayor i32 es {}.&quot;, std::i32::MIN, std::i32::MAX);
    println!(&quot;El menor u32 es {} y el mayor u32 es {}.&quot;, std::u32::MIN, std::u32::MAX);
    println!(&quot;El menor i64 es {} y el mayor i64 es {}.&quot;, std::i64::MIN, std::i64::MAX);
    println!(&quot;El menor u64 es {} y el mayor u64 es {}.&quot;, std::u64::MIN, std::u64::MAX);
    println!(&quot;El menor i128 es {} y el mayor i128 es {}.&quot;, std::i128::MIN, std::i128::MAX);
    println!(&quot;El menor u128 es {} y el mayor u128 es {}.&quot;, std::u128::MIN, std::u128::MAX);
}
</code></pre></pre>
<p>Que imprimir√°:</p>
<pre><code class="language-text">El menor i8 es -128 y el mayor i8 es 127.
El menor u8 es 0 y el mayor u8 es 255.
El menor i16 es -32768 y el mayor i16 es 32767.
El menor u16 es 0 y el mayor u16 es 65535.
El menor i32 es -2147483648 y el mayor i32 es 2147483647.
El menor u32 es 0 y el mayor u32 es 4294967295.
El menor i64 es -9223372036854775808 y el mayor i64 es 9223372036854775807.
El menor u64 es 0 y el mayor u64 es 18446744073709551615.
El menor i128 es -170141183460469231731687303715884105728 y el mayor i128 es 170141183460469231731687303715884105727.
El menor u128 es 0 y el mayor u128 es 340282366920938463463374607431768211455.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutabilidad-cambio"><a class="header" href="#mutabilidad-cambio">Mutabilidad (cambio)</a></h1>
<p><strong><a href="https://youtu.be/Nyyd6qn7dZY">Puedes ver este cap√≠tulo en YouTube en ingl√©s</a></strong></p>
<p>Cuando se declara una variable con `let, es inmutable (no se puede cambiar su valor).</p>
<p>El c√≥digo siguiente no funciona.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_numero = 8;
    mi_numero = 10; // ‚ö†Ô∏è
}
</code></pre></pre>
<p>El compilador indica <code>error[E0384]: cannot assign twice to immutable variable mi_numero</code>.</p>
<pre><code class="language-text">error[E0384]: cannot assign twice to immutable variable `mi_numero`
 --&gt; src/main.rs:3:5
  |
2 |     let mi_numero = 8;
  |         ---------
  |         |
  |         first assignment to `mi_numero`
  |         help: consider making this binding mutable: `mut mi_numero`
3 |     mi_numero = 10; // ‚ö†Ô∏è
  |     ^^^^^^^^^^^^^^ cannot assign twice to immutable variable
</code></pre>
<p>Esto es porque las variables son inmutables si solo se escribe <code>let</code>.</p>
<p>Muchas veces, ser√° necesario modificar la variable. Para ello, se debe a√±adir <code>mut</code> despu√©s de <code>let</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut mi_numero = 8;
    mi_numero = 10;
}
</code></pre></pre>
<p>El c√≥digo anterior funciona sin problema alguno.</p>
<p>Sin embargo, no se le puede cambiar el tipo. Esto no funciona:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut mi_numero = 8; // La variable es i32. 
                           // El tipo no se puede cambiar.
    mi_numero = &quot;¬°Hola, mundo!&quot;; // ‚ö†Ô∏è
}
</code></pre></pre>
<p>Si se intenta compilar el programa anterior, se obtendr√° el mismo mensaje &quot;expected&quot; por parte del compilador: <code>expected integer, found &amp;str</code>. <code>&amp;str</code>es un tipo de cadena que aprenderemos pronto.</p>
<h3 id="ocultaci√≥n-shadowing"><a class="header" href="#ocultaci√≥n-shadowing">Ocultaci√≥n (Shadowing)</a></h3>
<p>La ocultaci√≥n de una variable sucede cuando se usa <code>let</code> para declarar una nueva variable con el mismo nombre que otra. A primera vista se parece a la mutabilidad, pero es totalmente diferente. En el siguiente ejemplo, se oculta una variable:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_numero = 8; // Esta variable es i32
    println!(&quot;{}&quot;, mi_numero); // imprime 8
    let mi_numero = 9.2; // Esta variable es f64 y tiene el mismo nombre
    // pero es una variable nueva, completamente diferente.
    println!(&quot;{}&quot;, mi_numero) // imprime 9.2
}
</code></pre></pre>
<p>Se dice que hemos &quot;ocultado&quot; <code>mi_numero</code>con un nuevo &quot;enlace&quot;.</p>
<p>¬øSe ha destruido la anterior variable <code>mi_numero</code>? No, pero cuando se llama a <code>mi_numero</code> ahora se accede a la segunda variable de tipo <code>f64</code>. Y como ambas declaraciones se encuentran en el mismo bloque de c√≥digo (mismo √°mbito, mismo <code>{}</code>), se deja de tener acceso al <code>mi_numero</code> de tipo <code>i32</code>.</p>
<p>Si estuvieran en diferentes bloques de c√≥digo, podr√≠amos volver a acceder a la primera variable <code>mi_numero</code>. Por ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_numero = 8; // Esta variable es i32
    println!(&quot;{}&quot;, mi_numero); // imprime 8
    {
        let mi_numero = 9.2; // Esta variable es f64 y tiene el mismo nombre
        // pero es una variable nueva, completamente diferente.
        println!(&quot;{}&quot;, mi_numero) // imprime 9.2
                                  // pero la nueva variable mi_numero
                                  // solo existe hasta aqu√≠
                                  // la anterior ¬°sigue viva!
    }
    println!(&quot;{}&quot;, mi_numero); // imprime 8
}
</code></pre></pre>
<p>En resumen, cuando ocultas una variable, no la destruyes. La <strong>bloqueas</strong>.</p>
<p>Qu√© ventajas tiene el ocultar variables. Es una buena pr√°ctica cuando necesitas modificar una variable en muchas ocasiones. Imagina que quieres hacer un conjunto de c√°lculos matem√°ticos simples con una variable:</p>
<pre><pre class="playground"><code class="language-rust">fn dos_veces(numero: i32) -&gt; i32 {
    numero * 2
}

fn main() {
    let numero_final = {
        let y = 10;
        let x = 9; // x comienza con 9
        let x = dos_veces(x); // se oculta con el nuevo x: 18
        let x = x + y; // se oculta con el nuevo x: 28
        x // devuelve x: a numero_final se asigna este valor de x
    };
    println!(&quot;El n√∫mero ahora es: {}&quot;, numero_final)
}
</code></pre></pre>
<p>Sin ocultar las variables anteriores, habr√≠a sido necesario pensar diferentes nombres, incluso aunque no nos importen estos valores intermedios:</p>
<pre><pre class="playground"><code class="language-rust">fn dos_veces(numero: i32) -&gt; i32 {
    numero * 2
}

fn main() {
    // Ejemplo sin usar las capacidades de ocultar variables
    let numero_final = {
        let y = 10;
        let x = 9; // x comienza con 9
        let x2 = dos_veces(x); // segundo nombre para x
        let x2_y = x2 + y; // ¬°tercer nombre para x!
        x2_y // qu√© pena no tener disponible la ocultaci√≥n
             // habr√≠amos podido usar solo una variable x
    };
    println!(&quot;El n√∫mero ahora es: {}&quot;, numero_final)
}
</code></pre></pre>
<p>En general, se usa la ocultaci√≥n de variables en estos casos. Cuando se quiere usar una variable para un c√°lculo y luego otro m√°s, sin tener mucho inter√©s por los valores intermedios.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="la-pila-la-memoria-din√°mica-y-los-punteros"><a class="header" href="#la-pila-la-memoria-din√°mica-y-los-punteros">La pila, la memoria din√°mica y los punteros</a></h1>
<p>La pila (&quot;stack&quot; en ingl√©s), la memoria din√°mica (&quot;heap&quot; en ingl√©s) y los punteros son elementos muy importantes en Rust.</p>
<p>La pila y la memoria din√°mica son dos tipos de almacenamiento de los datos de un programa durante su ejecuci√≥n. Sus diferencias m√°s importantes son:</p>
<ul>
<li>La pila es muy r√°pida, la memoria din√°mica no lo es tanto. Tampoco es lenta, pero siempre es m√°s r√°pido acceder a la pila. Aunque no es posible utilizar la pila siempre porque:</li>
<li>Rust necesita conocer el tama√±o de una variable en durante su compilaci√≥n para poder guardarla en la pila. As√≠, las variables simples como <code>i32</code> van a la pila ya que se conoce su tama√±o exacto. Se sabe que va a ocupar 4 bytes, 32 bits = 4 bytes. Por lo tanto, los datos de tipo <code>i32</code> pueden ir siempre a la pila.</li>
<li>Algunos tipos no tienen un tama√±o conocido en tiempo de compilaci√≥n. No pueden guardarse en la pila. ¬øQu√© se puede hacer? En primer lugar, se pone la informaci√≥n en la memoria din√°mica ya que esta puede contener datos de cualquier tama√±o. En segundo lugar, se guarda un puntero en la pila. El tama√±o de los punteros es conocid. As√≠, para recuperar un valor de una variable que est√° en la memoria din√°mica, el ordenador va primero a la pila, obtiene el puntero y lo sigue hasta la memoria din√°mica para localizr el dato que se busca.</li>
</ul>
<p>Los punteros parecen complicados, pero no lo son. Son como una tabla de contenidos de un libro. Imagina este libro:</p>
<pre><code class="language-text">MI LIBRO

TABLA DE CONTENIDO

Cap√≠tulo                        P√°gina
Cap√≠tulo 1: mi vida              1
Cap√≠tulo 2: mi gato              15
Cap√≠tulo 3: mi trabajo           23
Cap√≠tulo 4: mi familia           30
Cap√≠tulo 5: mis planes futuros   43
</code></pre>
<p>La tabla de contenido es como una &quot;pila&quot; que, en este caso, contiene cinco punteros. Puedes leerlos y encontrar la informaci√≥n sobre la que tratan. ¬øD√≥nde est√° el cap√≠tulo sobre &quot;mi vida&quot;? Est√° en la p√°gina 1 (<em>Apunta</em> a la p√°gina 1). ¬øD√≥nde est√° el cap√≠tulo sobre &quot;mi trabajo&quot;? Est√° en la p√°gina 23.</p>
<p>El puntero que se ve habitualmente en Rust se denomina <strong>referencia</strong>. Esto es lo importante que se debe saber: una referencia apunta a la memoria de otro valor. Una referencia supone que <em>se tome prestado</em> el valor, pero no se apropia de √©l. Es lo mismo que en el libro anterior: la tabla de contenidos no posee la informaci√≥n. Se encuentra en los cap√≠tulos que son los que la poseen. En Rust, las referencias llevan el s√≠mbolo <code>&amp;</code> al principio de ellas. As√≠.</p>
<ul>
<li><code>let mi_variable = 8</code> crea una variable normal, pero</li>
<li><code>let mi_referencia = &amp;mi_variable</code> crea una referencia. Se lee como &quot;mi_referencia es una referencia a mi_variable&quot; o como &quot;mi_referencia se refiere a mi_variable&quot;.</li>
</ul>
<p>Esto significa que <code>mi_referencia</code> solo mira a los datos de <code>mi_variable</code>. <code>mi_variable</code> sigue siendo propietaria de sus datos.
Tambi√©n es posible tener una referencia que &quot;apunte&quot; a otra referencia. Hasta culquier n√∫mero de referencias.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_numero = 15; // Esto es un i32
    let referencia_simple = &amp;mi_numero; //  Esto es una &amp;i32
    let referencia_doble = &amp;referencia_simple; // Esto es una &amp;&amp;i32
    let referencia_quintuple = &amp;&amp;&amp;&amp;&amp;mi_numero; // Esto es una &amp;&amp;&amp;&amp;&amp;i32
}
</code></pre></pre>
<p>Todos estos son tipos de dato diferentes, de la misma forma que &quot;un amigo de un amigo&quot; es diferente de &quot;un amigo&quot;.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="m√°s-sobre-impresi√≥n"><a class="header" href="#m√°s-sobre-impresi√≥n">M√°s sobre impresi√≥n</a></h1>
<p>En Rust se puede imprimir como se quiera. Por eso, interesa conocer algunas cosas m√°s sobre este tema.</p>
<p>Si se a√±ade <code>\n</code> se imprimir√° una nueva l√≠nea. Si se a√±ade <code>\t</code> se insertar√° un tabulador:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Observa: la funci√≥n usada es print!, no println!
    print!(&quot;\tComienza con un tabulador\ny salta a una nueva l√≠nea&quot;);
}
</code></pre></pre>
<p>El c√≥digo anterior imprime lo siguiente:</p>
<pre><code class="language-text">        Comienza con un tabulador
y salta a una nueva l√≠nea
</code></pre>
<p>Dentro de <code>&quot;&quot;</code> se puede escribir en diferentes l√≠neas, pero es necesario tener cuidado con los espacios:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Nota: despu√©s de la primera l√≠nea tienes que comenzar la siguiente l√≠nea
    // en la primera columna (pegado a la izquierda).
    println!(&quot;Dentro de comillas
se puede escribir
en muchas l√≠neas
y se imprimir√° correctamente.&quot;);
    // Si se escribe directamente bajo la sentencia, se a√±adir√°n los espacios
    // correspondientes de la izquierda
    println!(&quot;Si se olvida que hay que
    escribir pegado al lado izquierdo
    estos espacios se a√±adir√°n
    a la impresi√≥n.&quot;);
}
</code></pre></pre>
<p>El c√≥digo anterior imprime:</p>
<pre><code class="language-text">Dentro de comillas
se puede escribir
en muchas l√≠neas
y se imprimir√° correctamente.
Si se olvida que hay que
    escribir pegado al lado izquierdo
    estos espacios se a√±adir√°n
    a la impresi√≥n.
</code></pre>
<p>Si se necesitase imprimir caracteres como <code>\n</code> (caracteres de escape, como el del salto de l√≠nea y el tabulador que se han visto antes), se puede a√±adir un <code>\</code> extra:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Se imprimen caracteres de escape, no inserta nueva l√≠nea y tabulador: \\n y \\t&quot;);
}
</code></pre></pre>
<p>Lo que imprime:</p>
<pre><code class="language-text">Se imprimen caracteres de escape, no inserta nueva l√≠nea y tabulador: \n y \t
</code></pre>
<p>A veces se necesitan muchos <code>&quot;</code> y caracteres de escape en el texto, por lo que Rust proporciona un m√©todo m√°s simple para ignorarlos: se a√±ade <code>r#</code> al comienzo y <code>#</code> al final de la cadena de caracteres.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // En esta l√≠nea hemos usado \ cinco veces
    println!(&quot;√âl dijo, \&quot;Puedes encontrar el fichero en c:\\files\\my_documents\\file.txt\&quot;. Y as√≠ fue como lo encontr√©.&quot;);
    println!(r#&quot;√âl dijo, &quot;Puedes encontrar el fichero en c:\files\my_documents\file.txt&quot;. Y as√≠ fue como lo encontr√©.&quot;#)
}
</code></pre></pre>
<p>Ambas opciones imprimen lo mismo, pero el uso de <code>r#</code> lo hace m√°s simple de entender.</p>
<pre><code class="language-text">√âl dijo, &quot;Puedes encontrar el fichero en c:\files\my_documents\file.txt&quot;. Y as√≠ fue como lo encontr√©.
√âl dijo, &quot;Puedes encontrar el fichero en c:\files\my_documents\file.txt&quot;. Y as√≠ fue como lo encontr√©.
</code></pre>
<p>Si se necesitara imprimir un car√°cter <code>#</code> en el texto, se puede usar <code>r##</code> al comienzo del texto y <code>##</code> al final. Si se usaran m√°s de dos consecutivos, se pueden seguir a√±adiendo <code>#</code> al comienzo y al final, hasta que no coincida con nada contenido en el texto.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

    let my_string = &quot;'Hola, mundo,' dijo.&quot;; // comilla simples
    let quote_string = r#&quot;&quot;Hola, mundo,&quot; dijo.&quot;#; // comillas dobles
    // Contiene # se necesita al menos ##
    let hashtag_string = r##&quot;El hasgtag #holamundo se ha hecho muy popular.&quot;##; 
    // Contiene ### se necesitan al menos ####
    let many_hashtags = r####&quot;&quot;No se tiene que teclear ### para usar un hashtag. Solo hay que usar #.&quot;&quot;####; 

    println!(&quot;{}\n{}\n{}\n{}\n&quot;, my_string, quote_string, hashtag_string, many_hashtags);
}
</code></pre></pre>
<p>Este c√≥digo imprimir√°:</p>
<pre><code class="language-text">'Hola, mundo,' dijo.
&quot;Hola, mundo,&quot; dijo.
El hasgtag #holamundo se ha hecho muy popular.
&quot;No se tiene que teclear ### para usar un hashtag. Solo hay que usar #.&quot;
</code></pre>
<p>Existe otro uso para <code>r#</code>: usar palabras reservadas (como <code>let</code>, <code>fn</code>, etc.) como nombres de variable.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let r#let = 6; // let como nombre de variable
    let mut r#mut = 10; // Esta variable se llama mut
}
</code></pre></pre>
<p>Esta funci√≥n de <code>r#</code> se introdujo porque las versiones m√°s antiguas de Rust ten√≠an menos palabras reservadas que ahora. As√≠ se pueden evitar errores en c√≥digo previo en el que se usaban nombres de variables que ahora son palabras reservadas.</p>
<p>Puede ser que por alguna raz√≥n <em>realmente</em> se necesite una funci√≥n que se denomine como <code>return</code>. As√≠ se puede escribir:</p>
<pre><pre class="playground"><code class="language-rust">fn r#return() -&gt; u8 {
    println!(&quot;Ah√≠ va tu n√∫mero.&quot;);
    8
}

fn main() {
    let mi_numero = r#return();
    println!(&quot;{}&quot;, mi_numero);
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">Ah√≠ va tu n√∫mero.
8
</code></pre>
<p>Esto no se va a necesitar normalmente, pero si <em>realmente</em> hace falta, se puede usar.</p>
<p>Si se necesita imprimir los bytes de un <code>&amp;str</code> o un <code>char</code>, basta con escribir la letra <code>b</code> delante de la cadena.
Esto funciona para todos los caracteres ASCII. Estos son todos los caracteres ASCII.</p>
<pre><code class="language-text">‚ò∫‚òª‚ô•‚ô¶‚ô£‚ô†‚ô´‚òº‚ñ∫‚óÑ‚Üï‚Äº¬∂¬ß‚ñ¨‚Ü®‚Üë‚Üì‚Üí‚àü‚Üî‚ñ≤‚ñº123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
</code></pre>
<p>As√≠, este c√≥digo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // N.T.: no se pueden poner tildes ya que en las 
    // vocales ya que las letras resultantes no forman
    // parte del conjunto de caracteres ASCII
    println!(&quot;{:?}&quot;, b&quot;Esto aparece como una lista de numeros&quot;);
}
</code></pre></pre>
<p>Da el siguiente resultado:</p>
<pre><code class="language-text">[69, 115, 116, 111, 32, 97, 112, 97, 114, 101, 99, 101, 32, 99, 111, 109, 111, 32, 117, 110, 97, 32, 108, 105, 115, 116, 97, 32, 100, 101, 32, 110, 117, 109, 101, 114, 111, 115]
</code></pre>
<p>Para un <code>char</code> esto se llama <em>byte</em> y para el tipo <code>&amp;str</code> se llama <em>byte de cadena de texto</em>.</p>
<p>Tambi√©n existe un sistema de escape para insertar caracteres Unicode: <code>\u{}</code>. As√≠ es posible imprimir cualquier car√°cter Unicode en una cadena de texto. Adem√°s, es posible formatear un n√∫mero en hexadecimal usando <code>{:X}</code>. El siguiente ejemplo demuestra c√≥mo imprimir el c√≥digo hexadecimal que representa al car√°cter Unicode y c√≥mo imprimirlo de nuevo como car√°cter.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Convierte el char a u32 para obtener su valor num√©rico
    println!(&quot;{:X}&quot;, 'Ìñâ' as u32); 
    println!(&quot;{:X}&quot;, 'H' as u32);
    println!(&quot;{:X}&quot;, 'Â±Ö' as u32);
    println!(&quot;{:X}&quot;, '„ÅÑ' as u32);

    // Imprime los caracteres con el sistema de escape \u
    println!(&quot;\u{D589}, \u{48}, \u{5C45}, \u{3044}&quot;); 
}
</code></pre></pre>
<p>Ya se conoce que <code>println!</code> puede imprimir con <code>{}</code> (modo <em>Display</em>) t <code>{:?}</code> (para Depuraci√≥n). Adem√°s de <code>{:#?}</code> para &quot;impresi√≥n bonita&quot;. Pero existen otras muchas formas de imprimir.</p>
<p>Por ejempli, si se dispone de una referencia se puede usar <code>{:p}</code> para imprimir la <em>direcci√≥n del puntero</em>. Es decir, el lugar de la memoria del ordenador a la que <em>apunta</em> la referencia.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 9;
    let number_ref = &amp;number;
    println!(&quot;{:p}&quot;, number_ref);
}
</code></pre></pre>
<p>El c√≥digo anterior imprime algo parecido a <code>0x7ffec9426f4c</code>, depender√° de d√≥nde se ejecute el programa y se almacene el n√∫mero referenciado en la memoria del ordenador.</p>
<p>Los valores num√©ricos se pueden imprimir en binario, hexadecimal u octal:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 555;
    println!(&quot;Binario: {:b}, hexadecimal: {:x}, octal: {:o}&quot;, number, number, number);
}
</code></pre></pre>
<p>Que imprime <code>Binario: 1000101011, hexadecimal: 22b, octal: 1053</code>.</p>
<p>Tambi√©n se pueden a√±adir n√∫meros entre las llaves para indicar qu√© variable utilizar, teniendo en cuenta que la primera tiene como √≠ndice el 0, la segunda el 1 y as√≠ sucesivamente.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nombre_padre = &quot;Jos√© Miguel&quot;;
    let nombre_hijo = &quot;V√≠ctor&quot;;
    let apellido = &quot;Gonz√°lez&quot;;
    println!(&quot;Este es {1} {2}, hijo de {0} {2}.&quot;, nombre_padre, nombre_hijo, apellido);
}
</code></pre></pre>
<p>La variable <code>nombre_padre</code> est√° en la posici√≥n 0, <code>nombre_hijo</code>en la 1 y <code>apellido</code> est√° en la posici√≥n 2. Por eso, el c√≥digo anterior imprime <code>Este es V√≠ctor Gonz√°lez, hijo de Jos√© Miguel Gonz√°lez.</code>.</p>
<p>Puede suceder que sea necesario imprimir una cadena de caracteres compleja con muchas variables dentro de las llaves. O puede que se necesite imprimir la misma variable dos o m√°s veces. Para ello, se pueden a√±adir nombres a las llaves.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(
        &quot;{city1} est√° en {pais} y {city2} tambi√©n est√° en {pais},
pero {city3} no est√° en {pais}.&quot;,
        city1 = &quot;Seul&quot;,
        city2 = &quot;Busan&quot;,
        city3 = &quot;Tokio&quot;,
        pais = &quot;Korea&quot;
    );
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">Seul est√° en Korea y Busan tambi√©n est√° en Korea,
pero Tokio no est√° en Korea.
</code></pre>
<p>Tambi√©n es posible editar de forma compleja el formato de la impresi√≥n. Tiene esta forma:</p>
<p><code>{variable:relleno alineamiento m√≠nimo.m√°ximo}</code></p>
<p>Para entender esta sintaxis:</p>
<ol>
<li>¬øSe quiere usar un nombre de variable? Se escribe primero su nombre, como antes en {pais}. Lo siguiente ser√° a√±adir (opcionalmente) <code>:</code> despu√©s si se quiere formatear de alg√∫n modo.</li>
<li>¬øSe se necesita un car√°cter de relleno? Por ejemplo, 55 con tres &quot;ceros de relleno&quot; se imprimir√≠a como 00055.</li>
<li>¬øQue alineamiento se necesita para el relleno? izquierda, centro o derecha.</li>
<li>¬øSe desea una longitud m√≠nima? solo hay que indicar el n√∫mero deseado.</li>
<li>¬øSe desea una longitud m√°xima? solo hay que indicarla con un <code>.</code> delante.</li>
</ol>
<p>Por ejemplo, si se quiere escribir la letra &quot;a&quot; con cinco caracteres - de relleno (a izquierda y derecha):</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let letra = &quot;a&quot;;
    println!(&quot;{:-^11}&quot;, letra);
}
</code></pre></pre>
<p>Que imprime <code>-----a-----</code>. El ordenador lo interpreta as√≠:</p>
<ul>
<li>¬øHay un nombre de variable? No, ya que lo primero que aparece en <code>{:-^11}</code> son los dos puntos. No hay nombre de variable delante de estos dos puntos.</li>
<li>¬øSe pide un car√°cter de relleno? S√≠, - est√° justo despu√©s de <code>:</code> y lo sigue un <code>^</code>, lo que significa que el texto se inserta en el centro y el car√°cter de relleno se reparte en los espacios sobrantes a izquierda y derecha. Las otras dos posibilidades son: <code>&lt;</code> que indica que el texto va a la izquierda y el car√°cter de relleno a la izquierda, y <code>&gt;</code> que indica que el texto va a la derecha con el relleno a la izquierda.</li>
</ul>
<p>A continuaci√≥n, se muestran diversos ejemplos de tipos de formateo.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let titulo = &quot;NOTICIAS DE HOY&quot;;
    // sin variable, relleno con -, centrado, longitud de 30 caracteres
    println!(&quot;{:-^30}&quot;, titulo); 
    let barra = &quot;|&quot;;
    // sin variable, relleno con espacios, 15 caracters cada uno, una barra a izquierda y otra a derecha
    println!(&quot;{: &lt;15}{: &gt;15}&quot;, barra, barra); 
    let a = &quot;SEUL&quot;;
    let b = &quot;TOKIO&quot;;
     // variables city1 y city2, relleno con -, a izquierda y a derecha
     println!(&quot;{city1:-&lt;15}{city2:-&gt;15}&quot;, city1 = a, city2 = b);
}
</code></pre></pre>
<p>El c√≥digo anterior imprime:</p>
<pre><code class="language-text">-------NOTICIAS DE HOY--------
|                            |
SEUL---------------------TOKIO
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cadenas-de-caracteres"><a class="header" href="#cadenas-de-caracteres">Cadenas de caracteres</a></h1>
<p><strong><a href="https://youtu.be/pSyaGzGg26o">Puedes ver este cap√≠tulo en YouTube en ingl√©s</a></strong></p>
<p>Rust tiene dos tipos de cadenas de caracteres: <code>String</code> y <code>&amp;str</code>. ¬øCu√°l es la diferencia?</p>
<ul>
<li><code>&amp;str</code> es una cadena de caracteres simple que reside en la pila. Cuando se escribe <code>let mi_variable = &quot;¬°Hola, mundo!&quot;</code> se crea una <code>&amp;str</code>. Este tipo es muy r√°pido.</li>
<li><code>String</code> es un tipo de dato m√°s complejo. Es un poco m√°s lento, pero tiene m√°s funciones. Una <code>String</code> es un puntero que almacena los datos en la memoria din√°mica.</li>
</ul>
<p>Hay que destacar que <code>&amp;str</code> tiene <code>&amp;</code> como primer car√°cter debido a que es necesaria una referencia para utilizar el tipo <code>str</code>.  Esto es por la raz√≥n que vimos anteriormente: la pila necesita conocer el tama√±o, as√≠ que se le da una referencia, las referencias siempre tienen el mismo tama√±o. Otro tema a tener en cuenta es que al utilizar <code>&amp;</code> una referencia para interactuar con el tipo <code>str</code>, nunca se es due√±o del tipo. Por el contrario, <code>String</code>es un tipo <em>con due√±o</em>. M√°s adelante se mostrar√° la importancia de esta distinci√≥n.</p>
<p>Ambos tipos, <code>&amp;str</code> y <code>String</code> son UTF-8. Por ejemplo, se puede escribir el siguiente c√≥digo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Nombre en coreano. No da problemas, ya que &amp;str es UTF-8
    let nombre = &quot;ÏÑúÌÉúÏßÄ&quot;;
    // »ö y »ô no son un problema en UTF-8.
    let otro_nombre = String::from(&quot;Adrian Fahrenheit »öepe»ô&quot;);
}
</code></pre></pre>
<p>En el c√≥digo anterior se observa que se puede construir de forma f√°cil una <code>String</code> de una <code>&amp;str</code>. Los dos tipos est√°n muy relacionados, aunque son muy diferentes.</p>
<p>Gracias a UTF-8, incluso se pueden escribir emojis.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nombre = &quot;üòÇ&quot;;
    println!(&quot;Mi nombre real es {}&quot;, nombre);
}
</code></pre></pre>
<p>Si se ejecuta este c√≥digo en el terminal de comandos de tu propio ordenador tiene que aparecer <code>Mi nombre real es üòÇ</code> a menos el terminal de comandos presente limitaciones y no lo pueda imprimir. En cuyo caso imprimir√° algo as√≠ <code>Mi nombre real es ÔøΩ</code>. En todo caso, Rust es capaz de manejar todos los caracteres Unicode.</p>
<p>La raz√≥n para utilizar una referencia <code>&amp;</code>para el tipo <code>str</code> es que <code>str</code> es un tipo de datos de tama√±o din√°mico, su tama√±o puede ser diferente. Por ejmplo, los nombres &quot;ÏÑúÌÉúÏßÄ&quot; y &quot;Adrian Fahrenheit »öepe»ô&quot; no son del mismo tama√±o:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

    // std::mem::size_of::&lt;Type&gt;() devuelve el tama√±o en bytes de un tipo
    println!(&quot;Una String siempre ocupa {:?} bytes. Es de tama√±o fijo.&quot;,
        std::mem::size_of::&lt;String&gt;()); 
    println!(&quot;Y un i8 siempre ocupa {:?} bytes. Es de tama√±o fijo.&quot;, 
        std::mem::size_of::&lt;i8&gt;());
    println!(&quot;Y un f64 siempre ocupa {:?} bytes. Es de tama√±o fijo.&quot;, 
        std::mem::size_of::&lt;f64&gt;());
     // std::mem::size_of_val() devuelve el tama√±o en bytes de una variable
    println!(&quot;¬øY un &amp;str? Puede ocupar cualquier tama√±o. 'ÏÑúÌÉúÏßÄ' ocupa {:?} bytes. No es de tama√±o fijo.&quot;,
        std::mem::size_of_val(&quot;ÏÑúÌÉúÏßÄ&quot;));
    println!(&quot;Y 'Adrian Fahrenheit »öepe»ô' ocupa {:?} bytes. No es de tama√±o fijo.&quot;,
        std::mem::size_of_val(&quot;Adrian Fahrenheit »öepe»ô&quot;));
}
</code></pre></pre>
<p>Lo que da como resultado:</p>
<pre><code class="language-text">Una String siempre ocupa 24 bytes. Es de tama√±o fijo.
Y un i8 siempre ocupa 1 bytes. Es de tama√±o fijo.
Y un f64 siempre ocupa 8 bytes. Es de tama√±o fijo.
¬øY un &amp;str? Puede ocupar cualquier tama√±o. 'ÏÑúÌÉúÏßÄ' ocupa 9 bytes. No es de tama√±o fijo.
Y 'Adrian Fahrenheit »öepe»ô' ocupa 25 bytes. No es de tama√±o fijo.
</code></pre>
<p>Por eso es necesario usar &amp;, porque as√≠ se construye un puntero (tipo de tama√±o fijo) que puede almacenarse en la pila.  Si se escribiera <code>str</code>, Rust no sabr√≠a qu√© hacer al no conocer su tama√±o.</p>
<p>Hay muchas formas de construir un elemento de tipo <code>String</code>. Algunas de ellas son:</p>
<ul>
<li><code>String::from(&quot;Esta es una cadena de texto&quot;);</code> - <code>String::from()</code> es un m√©todo de Strgin que crea un <code>String</code> a partir de una cadena de texto.</li>
<li><code>&quot;Esta es una cadena de texto&quot;.to_string()</code> - <code>&quot;&quot;.to_string()</code> es un m√©todo de <code>&amp;str</code> que crea un <code>String</code>.</li>
<li>La macro <code>format!</code> - Es como <code>println!</code> excepto que crea un String en lugar de imprimir el texto.</li>
</ul>
<p>A continuaci√≥n se muestran algunos ejemplos:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_name = &quot;Billybrobby&quot;;
    let my_country = &quot;USA&quot;;
    let my_home = &quot;Korea&quot;;

    let together = format!(
        &quot;Soy {} y vengo de {}, pero vivo en {}.&quot;,
        my_name, my_country, my_home
    );
}
</code></pre></pre>
<p>As√≠ se construye un objeto String denominado <em>together</em>, pero no se ha impreso.</p>
<p>Otra forma adicional para crear un String es con la funci√≥n <code>into()</code>, pero esta forma es algo diferente ya que no solo sirve para crear String. Algunos tipos se pueden convertir de forma f√°cil en otros utilizando <code>from</code> y <code>into()</code>. Si el tipo tiene <code>from</code>, tiene tambi√©n <code>into()</code>. <code>from</code> resulta m√°s claro ya que con √©l conoces los tipos: al usarlo <code>String::from(&quot;Cadena de texto&quot;)</code> se sabe que se crea una <code>String</code> de <code>&amp;str</code>. Sin embargo, con <code>.into()</code> el compilador, a veces, no lo conoce:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_string = &quot;Intento construir un String&quot;.into(); // ‚ö†Ô∏è
}
</code></pre></pre>
<p>Rust no conoce el tipo al que se quiere convertir la cadena de texto, porque se pueden crear muchos tipos diferentes a partir de un <code>&amp;str</code>. Rust se queja: puedo convertir &amp;str en muchos tipos diferentes. ¬øCu√°l es el que quieres?</p>
<pre><code class="language-text">error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let my_string = &quot;Intento construir un String&quot;.into(); // ‚ö†Ô∏è
  |         ^^^^^^^^^ consider giving `my_string` a type
</code></pre>
<p>Por lo que se puede corregir as√≠:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_string: String = &quot;Intento construir un String&quot;.into();
}
</code></pre></pre>
<p>Y ahora s√≠ se ha creado un objeto String.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="const-y-static"><a class="header" href="#const-y-static">const y static</a></h1>
<p><strong><a href="https://youtu.be/Ky3HqkWUcI0">Puedes ver este cap√≠tulo en YouTube en ingl√©s</a></strong></p>
<p>Adem√°s de <code>let</code>, existen dos maneras m√°s de declarar valores. <code>const</code> y <code>static</code>. Para estas declaraciones, Rust no realiza la inferencia de los tipos: es necesario declarar el tipo de los valores. Existen vamores que no cambian (<code>const</code> significa constante). La diferencia entre ellos es que:</p>
<ul>
<li><code>const</code> se utiliza para los valores que no cambian y el nombre se reemplaza por su valor, all√≠ donde se usa.</li>
<li><code>static</code> define una posici√≥n fija en memoria que puede actuar como una variable global.</li>
</ul>
<p>Por ello, son casi lo mismo. Los programadores de Rust casi siempre utilizan valores constantes con <code>const</code>.</p>
<p>Por convenci√≥n, las constantes se suelen escribir con todas las letras en may√∫sculas, normalmente est√°n fuera del <code>main</code> para que existan en todo el programas.</p>
<p>Dos ejemplos:</p>
<pre><pre class="playground"><code class="language-rust">const NUMERO_DE_MESES: u32 = 12;
static ESTACIONES: [&amp;str; 4] = [&quot;Primavera&quot;, &quot;Verano&quot;, &quot;Oto√±o&quot;, &quot;Invierno&quot;];

fn main() {
    println!(&quot;{}&quot;, NUMERO_DE_MESES);
    println!(&quot;{:?}&quot;, ESTACIONES);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="algo-m√°s-sobre-referencias"><a class="header" href="#algo-m√°s-sobre-referencias">Algo m√°s sobre referencias</a></h1>
<p><strong><a href="https://youtu.be/R13sQ8SNoEQ">Puedes ver este cap√≠tulo en YouTube en ingl√©s</a></strong></p>
<p>Las referencias son muy importantes en Rust. Las utiliza para asegurarse de que son seguros todos los accesos a la memoria. Ya se ha explicado anteriormente que para crear una referencia se utiliza <code>&amp;</code> delante del valor:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let pais = String::from(&quot;Austria&quot;);
    let ref_uno = &amp;pais;
    let ref_dos = &amp;pais;

    println!(&quot;{}&quot;, ref_uno);
}
</code></pre></pre>
<p>El c√≥digo anterior imprime <code>Austria</code>. <code>pais</code> es un <code>String</code>. Se crean dos referencias a <code>pais</code>. Estas referencias son de tipo <code>&amp;String</code>, es decir son dos variables que son &quot;referencias a String&quot;. Se pueden crear tantas referencias a <code>pais</code>como se quiera. Todas &quot;apuntan&quot; al mismo valor, pero son punteros diferentes.</p>
<p>A continuaci√≥n se muestra un ejemplo sobre c√≥mo Rust proteje el acceso a zonas de memoria err√≥neas:</p>
<pre><pre class="playground"><code class="language-rust">fn return_str() -&gt; &amp;str {
    let pais = String::from(&quot;Austria&quot;);
    let pais_ref = &amp;pais;
    pais_ref // ‚ö†Ô∏è
}

fn main() {
    let pais = return_str();
}
</code></pre></pre>
<p>La funci√≥n <code>return_str()</code> crea un valor de tipo String, luego crea una referencia a dicho valor. Cuando se intenta devolver la referencia se produce un error:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:1:20
  |
1 | fn return_str() -&gt; &amp;str {
  |                    ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
  |
1 | fn return_str() -&gt; &amp;'static str {
  |                    ^^^^^^^^
</code></pre>
<p>El valor de <code>pais</code> solo existe dentro de la funci√≥n, al terminar de ejecutarse desaparece. Una vez la variable desaparece, el ordenador libera la memoria que ocupaba y la utiliza para otra cosa. Por eso, despu√©s de que la funci√≥n termina, <code>pais_ref</code> apunta a una zona de memoria que ya no tiene el valor esperado y eso no es correcto. Rust previene este fallo en el c√≥digo e impide que el programa compile.</p>
<p>Este es el efecto importante de la existencia de tipos de dato &quot;con due√±o&quot; en Rust. En el c√≥digo anterior, el valor <code>String</code> tiene como due√±o a la variable <code>pais</code>, por eso se puede &quot;prestar&quot; a otras variables (referencias), pero cuando desaparece la variable due√±a del valor, <code>pais</code>, la referencia tambi√©n desaparece, la referencia tiene &quot;prestado&quot; el valor, por lo que no se puede pasar a otro &quot;due√±o&quot;.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="referencias-modificables-mutables"><a class="header" href="#referencias-modificables-mutables">Referencias modificables (mutables)</a></h1>
<p><strong><a href="https://youtu.be/G48z6Rv76vc">Puedes ver este cap√≠tulo en YouTube en ingl√©s</a></strong></p>
<p>Si se necesita modificar un valor a trav√©s de una referencia, se debe indicar que la referencia sea modificable (mutable). Para ello, se utiliza <code>&amp;mut</code> en lugar de <code>&amp;</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // no hay que olvidar que hay que escribir mut en la variable original
    let mut mi_numero = 8;
    let num_ref = &amp;mut mi_numero;
}
</code></pre></pre>
<p><code>mi_numero</code> es de tipo <code>i32</code>, y <code>num_ref</code> es de tipo <code>&amp;mut i32</code> (es una &quot;referencia modificable/mutable a un valor <code>√¨32</code>).</p>
<p>Si se desea usar esta referencia para sumar 10, no se puede usar <code>num_ref += 10</code> ya que <code>num_ref</code> no es de tipo <code>i32</code>, es <code>&amp;i32</code>. Para obtener el valor de la referencia, se debe usar <code>*</code> que significa que &quot;no se necesita la referencia, sino el valor que al que representa&quot;. En otras palabras, <code>*</code> es lo opuesto a <code>&amp;</code>, un <code>*</code> borra a un <code>&amp;</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut mi_numero = 8;
    let num_ref = &amp;mut mi_numero;
    *num_ref += 10; // Usa * para cambiar el valor i32
    println!(&quot;{}&quot;, mi_numero);

    let segundo_numero = 800;
    let triple_referencia = &amp;&amp;&amp;segundo_numero;
    println!(&quot;segundo_numero = ¬øtriple_referencia? {}&quot;,
        segundo_numero == ***triple_referencia);
}
</code></pre></pre>
<p>El c√≥digo anterior, da como resultado:</p>
<pre><code class="language-text">18
segundo_numero = ¬øtriple_referencia? true
</code></pre>
<p>El uso del operador sobre una variable <code>&amp;</code> se denomina &quot;referenciar&quot;. El uso del operador sobre una variable de referencia <code>*</code> se denomina &quot;<strong>des</strong>referenciar&quot;.</p>
<p>Rust usa dos reglas para las referencias mutables e inmutables. Son muy importantes y f√°ciles de recordar porque tienen sentido.</p>
<ul>
<li><strong>Regla 1</strong>: Si solo existen referencias inmutables a un valor, se pueden tener tantas como se quiera.</li>
<li><strong>Regla 2</strong>: Si existe una referencia mutable a un valor, solo puede existir una referencia. Esto √∫ltimo significa que no pueden existir a la vez referencias inmutables y mutables en el mismo momento.</li>
</ul>
<p>Estas reglas son necesarias debido a que las referencias mutables pueden cambiar los datos. Ser√≠a problem√°tico que se modificara un dato cuando otras referencias lo est√°n usando.</p>
<p>Un forma de entenderlo es pensar en la creaci√≥n de una presentaci√≥n de Powerpoint <sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>No se trata de un ejemplo excesivamente bueno, ya que actualmente es posible editar simult√°neamente en Office 365.</p>
</div>
<p>El primer caso representa el de <strong>la existencia de una referencia mutable</strong>: un empleado est√° editando una presentaci√≥n de Powerpoint. Piode ayuda a su jefe. El empleado entrega sus credenciales de acceso a su jefe para que pueda editar el Powerpoint. Ahora el jefe tiene una &quot;referencia mutable&quot; a la presentaci√≥n de su empleado. El jefe puede hacer los cambios que quiera y devolver el ordenador m√°s tarde. Nadie m√°s tiene acceso a la presentaci√≥n, por lo que este caso no da problemas.</p>
<p>El segundo caso representa el de **la existencia √∫nicamente de referencias inmutables&quot;: El empleado entrega la presentaci√≥n a 100 personas. Todas ellas pueden verla. Tienen una &quot;referencia inmutable&quot; a la presentaci√≥n ya que nadie puede modificarla, por lo que este caso no da problemas.</p>
<p>El tercer caso representa la <strong>situaci√≥n problem√°tica a evitar</strong>: El empleado entrega sus credenciales de acceso a su jefe, que a partir de aqu√≠ dispone de una &quot;referencia mutable&quot;. Adem√°s, el empleado entrega la presentaci√≥n a 100 personas. El jefe puede entrar a editar y estas modificaciones pueden verse o no por parte de las 100 personas, seg√∫n el momento en que accedan sin que puedan controlar.</p>
<p>Se puede ver que el intento de usar una referencia mutable simult√°neamente con una inmutable no es aceptado por el compilador:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut numero = 10;
    let numero_ref = &amp;numero;
    let numero_modif = &amp;mut numero;
    *numero_modif += 10;
    println!(&quot;{}&quot;, numero_ref); // ‚ö†Ô∏è
}
</code></pre></pre>
<p>El compilador muestra un mensaje explicativo muy claro para mostrar el problema:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `numero` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:4:24
  |
3 |     let numero_ref = &amp;numero;
  |                      ------- immutable borrow occurs here
4 |     let numero_modif = &amp;mut numero;
  |                        ^^^^^^^^^^^ mutable borrow occurs here
5 |     *numero_modif += 10;
6 |     println!(&quot;{}&quot;, numero_ref); // ‚ö†Ô∏è
  |                    ---------- immutable borrow later used here
</code></pre>
<p>Sin embargo, este c√≥digo s√≠ funciona. ¬øPor qu√©?</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut numero = 10;
    let numero_modif = &amp;mut numero; // referencia modificable
    *numero_modif += 10; // suma 10
    let numero_ref = &amp;numero; // referencia inmutable
    println!(&quot;{}&quot;, numero_ref); // imprime el valor referenciado
}
</code></pre></pre>
<p>Imprime <code>20</code> sin problemas. Funciona porque el compilador es suficientemente inteligente para comprender el c√≥digo. Conoce que se ha cmabiado <code>numero</code> a trav√©s de la referencia <code>numero_modif</code>, pero despu√©s, esta referencia mutable no se vuelve a usar. Por eso no hay problema aqu√≠. No se usan &quot;a la vez&quot; referencias inmutables y mutables (como s√≠ pasaba en el caso anterior).</p>
<p>En versiones anteriores de Rust, este c√≥digo s√≠ daba error, pero actualmente no lo hace ya que el compilador es m√°s inteligente. Puede entender no solo lo que se ha tecleado, sino como se usa todo.</p>
<h2 id="ocultaci√≥n-shadowing-de-nuevo"><a class="header" href="#ocultaci√≥n-shadowing-de-nuevo">Ocultaci√≥n (shadowing) de nuevo</a></h2>
<p>Es necesario recordar que el ocultamiento de variables no destruye sus valores, sino que los bloquea. Con el uso de las referencias esto se ve m√°s claro.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let pais = String::from(&quot;Austria&quot;);
    let pais_ref = &amp;pais;
    let pais = 8;
    println!(&quot;{}, {}&quot;, pais_ref, pais);
}
</code></pre></pre>
<p>¬øQu√© imprime este c√≥digo? ¬ø<code>Austria, 8</code> o <code>8, 8</code>? Imprime <code>Austria, 8</code>. En la primera l√≠nea, se declara una variable <code>String</code> con el valor <code>Austria</code> y denominada <code>pais</code>. En la segunda l√≠nea se crea una referencia al valor de esta variable. Es decir, a la <code>String</code> que contiene <code>Austria</code>. Despu√©s, se oculta la variable <code>pais</code> con una nueva cuyo valor es <code>8</code> y que es de tipo <code>i32</code>. El primer elemento <code>pais</code> no se destruy√≥ (lo har√° al finalizar el √°mbito en el que est√°, en la llave de cierre de este bloque), por lo que sigue accesible a trav√©s de la referencia <code>pais_ref</code>. Para mayor claridad, se vuelve a mostrar el c√≥digo, ahora con comentarios sobre su comportamiento.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let pais = String::from(&quot;Austria&quot;); // String denominada pais
    let pais_ref = &amp;pais; // pais_ref es una referencia al valor
    let pais = 8; // nueva variable pais con un valor 8. Sin relaci√≥n con la anterior, ni con pais_ref
    println!(&quot;{}, {}&quot;, pais_ref, pais); // pais_ref sigue &quot;apuntando&quot; al dato Austria
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="paso-de-referencias-a-funciones"><a class="header" href="#paso-de-referencias-a-funciones">Paso de referencias a funciones</a></h1>
<p><strong>Puedes ver este cap√≠tulo en Youtube en ingl√©s: <a href="https://youtu.be/mKWXt9YTavc">referencias inmutables</a> y <a href="https://youtu.be/kJV1wIvAbyk">referencias mutables</a></strong></p>
<p>Las referencias son muy √∫tiles en las funciones. La regla de Rust para todos los valores es que un valor solo puede tener una variable propietario.</p>
<p>Este c√≥digo no funcionar√°:</p>
<pre><pre class="playground"><code class="language-rust">fn print_pais(pais_nombre: String) {
    println!(&quot;{}&quot;, pais_nombre);
}

fn main() {
    let pais = String::from(&quot;Austria&quot;);
    print_pais(pais); // Se imprime &quot;Austria&quot;
    print_pais(pais); // ‚ö†Ô∏è Se intenta de nuevo, pero no funciona
}
</code></pre></pre>
<p>Devuelve el siguiente error:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `pais`
 --&gt; src/main.rs:8:16
  |
6 |     let pais = String::from(&quot;Austria&quot;);
  |         ---- move occurs because `pais` has type `String`, which does not implement the `Copy` trait
7 |     print_pais(pais); // Se imprime &quot;Austria&quot;
  |                ---- value moved here
8 |     print_pais(pais); // ‚ö†Ô∏è Se intenta de nuevo, pero no funciona
  |                ^^^^ value used here after move
</code></pre>
<p>La variable <code>pais</code> ya no existen en la √∫ltima l√≠nea. El funcionamiento es el siguiente:</p>
<ul>
<li>Paso 1: Se crea el valor de tipo <code>String</code> cuyo due√±o es la variable <code>pais</code>.</li>
<li>Paso 2: Se pasa <code>pais</code> a la funci√≥n <code>print_pais</code>. Es una funci√≥n que no tiene <code>-&gt;</code> en su declaraci√≥n, por lo que no retorna ning√∫n valor. Al hacer la llamada, la variable <code>pais_nombre</code> (par√°metro) es la nueva due√±a del valor. Despu√©s de que esta funci√≥n finaliza, <code>pais_nombre</code> desaparece, como es la due√±a del valor, este tambi√©n se destruye.</li>
<li>Paso 3: Se intenta pasar por segunda vez <code>pais</code> a la funci√≥n `print_pais, pero ya no existe ya que dej√≥ de ser due√±a del valor y el valor despareci√≥ dentro de la primera llamada a la funci√≥n.</li>
</ul>
<p>Se podr√≠a hacer que la funci√≥n <code>print_pais</code> devolviera de nuevo el valor <code>String</code>, pero es poco ortodoxo.</p>
<pre><pre class="playground"><code class="language-rust">fn print_pais(pais_nombre: String) -&gt; String {
    println!(&quot;{}&quot;, pais_nombre);
    pais_nombre // se devuelve el valor
}

fn main() {
    let pais = String::from(&quot;Austria&quot;);
    let pais = print_pais(pais); // Es necesario crear una nueva variable para recuperar el valor
    print_pais(pais);
}
</code></pre></pre>
<p>Ahora s√≠ funciona e imprime:</p>
<pre><code class="language-text">Austria
Austria
</code></pre>
<p>Es mucho mejor evitar que la variable <code>print_nombre</code>, par√°metro de la funci√≥n, sea due√±a del valor, solamente se &quot;presta&quot;, sin que la variable <code>pais</code> de la funci√≥n <code>main</code> deje de ser su due√±o.</p>
<pre><pre class="playground"><code class="language-rust">fn print_pais(pais_nombre: &amp;String) {
    println!(&quot;{}&quot;, pais_nombre);
}

fn main() {
    let pais = String::from(&quot;Austria&quot;);
    print_pais(&amp;pais); // Se imprime &quot;Austria&quot;
    print_pais(&amp;pais); // Se intenta de nuevo y funciona correctamente
}
</code></pre></pre>
<p>En este caso <code>print_pais()</code> toma una referencia a una <code>String</code>: <code>&amp;String</code>. Cuando se llama <code>print_pais()</code> se pasa una referencia con <code>&amp;pais</code>. Esto significa que &quot;la funci√≥n puede acceder al valor, pero no se hace due√±a de √©l&quot;.</p>
<p>A continuaci√≥n, se muestra un ejemplo similar para observar el comportamiento de las referencias modificables (mutables).</p>
<pre><pre class="playground"><code class="language-rust">fn a√±ade_hungria(pais_nombre: &amp;mut String) { // se pasa una referencia mutable
    pais_nombre.push_str(&quot;-Hungr√≠a&quot;); // push_str() a√±ade un &amp;str a un String
    println!(&quot;Ahora dice: {}&quot;, pais_nombre);
}

fn main() {
    // es importante que la variable se declare
    // como mutable para poder crear referencias mutables
    let mut pais = String::from(&quot;Austria&quot;);
    a√±ade_hungria(&amp;mut pais); // hay que pasar la referencia mutable.
    println!(&quot;Y el valor se ha modificado aqu√≠: {}&quot;, pais);
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">Ahora dice: Austria-Hungr√≠a
Y el valor se ha modificado aqu√≠: Austria-Hungr√≠a
</code></pre>
<p>En resumen:</p>
<ul>
<li><code>fn nombre_de_funcion(variable: String)</code> toma un <code>String</code> y se hace due√±o de √©l.</li>
<li><code>fn nombre_de_funcion(variable: &amp;String)</code> toma prestado un <code>String</code> y puede acceder a su valor.</li>
<li><code>fn nombre_de_funcion(variable: &amp;mut String)</code> toma prestado un <code>String</code>, puede acceder a su valor y modificarlo.</li>
</ul>
<p>El siguiente ejemplo puede parecer similar, pero es muy diferente. Sirve para mostrar c√≥mo quien se hace due√±o de un objeto puede decidir que sea modificable, aunque anteriormente no lo fuese.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let pais = String::from(&quot;Austria&quot;); // pais no es mutable, ni referencia
    a√±adir_hungria(pais);
}

fn a√±adir_hungria(mut pais: String) { // a√±adir_hungria declara su par√°metro como mutable
    pais.push_str(&quot;-Hungr√≠a&quot;);
    println!(&quot;{}&quot;, pais);
}
</code></pre></pre>
<p>La funci√≥n <code>a√±adir_hungria</code> se hace due√±a del valor en su variable <code>mut pais</code>. A partir de ah√≠, puede hacer con este valor lo que quiera.</p>
<p>Si se recuerda el ejemplo anterior sobre el empleado, su jefe y la presentaci√≥n en powerpoint, esta es la situaci√≥n en la que el empleado le da el control completo al jefe. El empleado no puede volver a tocar la presentaci√≥n y el jefe puede hacer lo que quiera con ella.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="copia"><a class="header" href="#copia">Copia</a></h1>
<p>Algunos tipos de Rust son muy simples. Se almacenan todos en la pila ya que el compilador conoce su tama√±o. Esto significa que son f√°ciles de copiar, por lo que el compilador siempre los copia cuando se env√≠an a una funci√≥n. Son valores de tama√±o fijo, conocido y peque√±o. En estos casos, no hay necesidad de preocuparse por qui√©n es el due√±o de estos tipos de dato. A estos tipos, se los denomina <strong>tipos copia</strong> (Copy Types, en ingl√©s).</p>
<p>Estos tipos simples incluyen a los enteros, flotantes, booleanos (<code>true</code> -verdadero- y <code>false</code> -falso-) y <code>char</code>.</p>
<p>Para que los tipos se puedan copiar tienen que <strong>implementar</strong> la posibilidad de copia (copy). Se puede consultar la documentaci√≥n de cada tipo para conocerlo. Por ejemplo, esta es la documentaci√≥n del tipo <code>char</code>:</p>
<p><a href="https://doc.rust-lang.org/std/primitive.char.html">https://doc.rust-lang.org/std/primitive.char.html</a></p>
<p>A la izquierda de esta documentaci√≥n se puede ver <strong>Trait Implementations</strong>. Se muestran, entre otras: <strong>Copy</strong>, <strong>Debug</strong> y <strong>Display</strong>. Lo que permite conocer que <code>char</code> puede:</p>
<ul>
<li>Copiarse cuando se pasa como par√°metro a una funci√≥n (<strong>Copy</strong>).</li>
<li>Puede usar <code>{}</code> para imprimir (<strong>Display</strong>).</li>
<li>Puede usar <code>{:?}</code> para imprimir (<strong>Debug</strong>).</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn prints_number(numero: i32) { // Esta funci√≥n no tiene -&gt;, no devuelve ning√∫n valor
                             // Si el n√∫mero no se copiara, esta funci√≥n se har√≠a au propietaria 
                             // y no se podr√≠a volver a usar
    println!(&quot;{}&quot;, numero);
}

fn main() {
    let mi_numero = 8;
    prints_number(mi_numero); // Imprime 8. prints_number obtiene una copia del n√∫mero
    prints_number(mi_numero); // Imprime 8 de nuevo.
                              // No hay problema ya que mi_numero es un tipo que se copia
}
</code></pre></pre>
<p>Sin embargo, si se revisa la documentaci√≥n de <code>String</code> se ve que no es un tipo que se copie.</p>
<p><a href="https://doc.rust-lang.org/std/string/struct.String.html">https://doc.rust-lang.org/std/string/struct.String.html</a></p>
<p>A la izquierda de esta documentaci√≥n se puede ver <strong>Trait Implementations</strong>, en orden alfab√©tico. En la C no est√° <strong>Copy</strong>. Lo que s√≠ aparece es <strong>Clone</strong>, que es similar a *<em>Copy</em>, solo que es necesario invocarlo expresamente con el m√©todo <code>clone()</code>. Es decir, que no se clona por s√≠ mismo, se tiene que pedir expresamente.</p>
<p>En el siguiente ejemplo, <code>prints_country()</code> imprime el nombre del pa√≠s, que es de tipo <code>String</code>. Se quiere, como en el caso anterior, imprimir dos veces, pero no es posible:</p>
<pre><pre class="playground"><code class="language-rust">fn prints_country(country_name: String) {
    println!(&quot;{}&quot;, country_name);
}

fn main() {
    let country = String::from(&quot;Kiribati&quot;);
    prints_country(country);
    prints_country(country); // ‚ö†Ô∏è
}
</code></pre></pre>
<p>El mensaje es autoexplicativo:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `country`
 --&gt; src\main.rs:4:20
  |
2 |     let country = String::from(&quot;Kiribati&quot;);
  |         ------- move occurs because `country` has type `std::string::String`, which does not implement the `Copy` trait
3 |     prints_country(country);
  |                    ------- value moved here
4 |     prints_country(country);
  |                    ^^^^^^^ value used here after move
</code></pre>
<p>Dice que <code>String</code> no implementa el rasgo necesario para copiar <code>Copy trait</code>. Sin embargo, se ha visto que s√≠ implementa el rasgo <code>Clone</code>, por lo que se puede a√±adir <code>.clone()</code> al c√≥digo para generar de forma expresa una copia del valor. De este modo, se puede enviar un clon del valor a la funci√≥n. As√≠, despu√©s de llamar a la funci√≥n, la variable <code>country</code> contin√∫a vigente y se puede utilizar.</p>
<pre><pre class="playground"><code class="language-rust">fn prints_country(country_name: String) {
    println!(&quot;{}&quot;, country_name);
}

fn main() {
    let country = String::from(&quot;Kiribati&quot;);
    prints_country(country.clone()); // crea un clon y lo pasa a la funci√≥n. country sigue vigente
    prints_country(country);
}
</code></pre></pre>
<p>Evidentemente, si el <code>String</code> es muy largo, generar un clon requiere el uso de mucha memoria. Una cadena de texto <code>String</code> puede ser de la longitud de un libro entero, y cada vez que se llama a <code>.clone()</code> se genera una copia completa. Por eso, es recomendable el uso de <code>&amp;</code> para utilizar una referencia cuando sea posible. Por ejemplo, el c√≥digo siguiente a√±ade una cadena de texto <code>&amp;str</code> en una <code>String</code> y despu√©s crea un clon cada vez que se utiliza en una funci√≥n:</p>
<pre><pre class="playground"><code class="language-rust">fn get_length(input: String) { // Se apropia de la cadena de texto
    println!(&quot;Tiene una longitud de {} palabras.&quot;, input.split_whitespace().count()); // la divide para contar el n√∫mero de palabras
}

fn main() {
    let mut my_string = String::new();
    for _ in 0..50 {
        my_string.push_str(&quot;Aqu√≠ van palabras en espa√±ol &quot;); // a√±ade las palabras
        get_length(my_string.clone()); // obtiene un nuevo clon cada vez
    }
}
</code></pre></pre>
<p>Lo que imprime es:</p>
<pre><code class="language-text">Tiene una longitud de 5 palabras.
Tiene una longitud de 10 palabras.
...
Tiene una longitud de 250 palabras
</code></pre>
<p>Esto genera 50 clones. El siguiente c√≥digo cumple la misma funci√≥n usando referencias y es mucho m√°s eficiente:</p>
<pre><pre class="playground"><code class="language-rust">fn get_length(input: &amp;String) {
    println!(&quot;Tiene una longitud de {} palabras.&quot;, input.split_whitespace().count());
}

fn main() {
    let mut my_string = String::new();
    for _ in 0..50 {
        my_string.push_str(&quot;Aqu√≠ van palabras en espa√±ol &quot;);
        get_length(&amp;my_string);
    }
}
</code></pre></pre>
<p>Con el c√≥digo anterior no se genera ning√∫n clon.</p>
<h2 id="variables-sin-valores"><a class="header" href="#variables-sin-valores">Variables sin valores</a></h2>
<p>Una variables sin valor est√° <em>sin inicializar</em>. Para crear una variable en este estado se usa <code>let</code> y el nombre de la variable:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_variable; // ‚ö†Ô∏è
}
</code></pre></pre>
<p>Rust no compila si hay alguna variable sin inicializar.</p>
<p>Sin embargo, en ocasiones pueden ser √∫tiles. Un claro ejemplo es cuando:</p>
<ul>
<li>Se tiene un bloque de c√≥digo en el que se genera el valor necesario para la variable y...</li>
<li>...la variable tiene que sobrevivir fuera del bloque de c√≥digo.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn loop_then_return(mut counter: i32) -&gt; i32 {
    loop {
        counter += 1;
        if counter % 50 == 0 {
            break;
        }
    }
    counter
}

fn main() {
    let my_number;

    { // Este bloque es innecesario, pero se crea para documentar caso
        let number = {
            // Aqu√≠ podria haber mucho c√≥digo
            // para generar un valor, por ejemplo:
            57
        };

        my_number = loop_then_return(number);
    }

    println!(&quot;{}&quot;, my_number);
}
</code></pre></pre>
<p>Este ejemplo imprime <code>100</code>.</p>
<p>Se observa que <code>my_number</code> se declar√≥n en la funci√≥n <code>main()</code>, por lo que su tiempo de vida dura hasta su finalizaci√≥n. Y obtiene su valor dentro del bucle <code>loop</code>. El valor pasa a ser propiedad de <code>my_number</code> antes de salir del bloque.</p>
<p>Si se hubiera declarado y asignado el valor en la misma l√≠nea con <code>let my_number = loop_then_return(number)</code> dentro del bloque, la variable hubiera desaparecido con el bloque.</p>
<p>De forma simplificada, ayuda a verlo el sustituir la funci√≥n por su valor de retorno, 100. Se ve en el siguiente c√≥digo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number;
    {
        my_number = 100;
    }

    println!(&quot;{}&quot;, my_number);
}
</code></pre></pre>
<p>Es casi como escribir <code>let my_number = { 100 };</code>.</p>
<p>Se debe observar que <code>my_number</code> no es <code>mut</code>. No se le asigna un valor hasta que se asigna el 100, por lo que no ha cambiado de valor. En el fondo el c√≥digo real para <code>my_number</code> es solo <code>let my_number = 100;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tipos-colecci√≥n"><a class="header" href="#tipos-colecci√≥n">Tipos colecci√≥n</a></h1>
<p>Rust tiene muchos tipos para construir una colecci√≥n. La colecciones sirven para almacenar m√°s de un valor en un mismo lugar. Por ejemplo, permiten almacenar la informaci√≥n sobre todas las ciudades de un pa√≠s en una variable.</p>
<p>Se iniciar√° con los arrays, que son los m√°s r√°pidos, pero tambi√©n los que tienen la funcionalidad m√°s limitada. En este sentido, son como el tipo <code>&amp;str</code>.</p>
<h2 id="arrays"><a class="header" href="#arrays">Arrays</a></h2>
<p>Son los datos guardados dentro de corchetes: <code>[]</code>.</p>
<p>Los Arrays:</p>
<ul>
<li>No pueden cambiar de tama√±o.</li>
<li>Tienen datos del mismo tipo.</li>
</ul>
<p>Sin embargo, son muy r√°pidos.</p>
<p>El tipo de un array es: <code>[tipo; longitud]</code>. Por ejemplo, el tipo de <code>[&quot;Uno&quot;, &quot;Dos&quot;]</code> es <code>[&amp;str; 2]</code>. Esto significa que los siguientes dos arrays tienen tipos diferentes:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let array1 = [&quot;One&quot;, &quot;Two&quot;]; // Este es de tipo [&amp;str; 2]
    let array2 = [&quot;One&quot;, &quot;Two&quot;, &quot;Five&quot;]; // Y este de tipo [&amp;str; 3]. ¬°Son dos tipos diferentes!
}
</code></pre></pre>
<p>Para conocer el tipo de una variable se puede &quot;pedir&quot; al compilador que haga algo con ella que no sea v√°lido, por ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let seasons = [&quot;Spring&quot;, &quot;Summer&quot;, &quot;Autumn&quot;, &quot;Winter&quot;];
    let seasons2 = [&quot;Spring&quot;, &quot;Summer&quot;, &quot;Fall&quot;, &quot;Autumn&quot;, &quot;Winter&quot;];
    seasons.ddd(); // ‚ö†Ô∏è
    seasons2.thd(); // ‚ö†Ô∏è tambi√©n
}
</code></pre></pre>
<p>El compilador dice, &quot;¬øQu√© haces? No existe el m√©todo <code>.ddd()</code> para la variable seasons y tampoco existe el m√©todo <code>.thd()</code> para seasons2&quot; como puedes ver:</p>
<pre><code class="language-text">error[E0599]: no method named `ddd` found for array `[&amp;str; 4]` in the current scope
 --&gt; src\main.rs:4:13
  |
4 |     seasons.ddd(); // 
  |             ^^^ method not found in `[&amp;str; 4]`

error[E0599]: no method named `thd` found for array `[&amp;str; 5]` in the current scope
 --&gt; src\main.rs:5:14
  |
5 |     seasons2.thd(); // 
  |              ^^^ method not found in `[&amp;str; 5]`
</code></pre>
<p>Y dice que <code>method not found in `[&amp;str; 4]`</code>, que es el tipo del array.</p>
<p>Si se necesita un array con el mismo valor en todos los elementos, se puede declarar de la siguiente forma:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_array = [&quot;a&quot;; 10];
    println!(&quot;{:?}&quot;, my_array);
}
</code></pre></pre>
<p>Que imprime <code>[&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;]</code>.</p>
<p>Este m√©todo se utiliza mucho para crear buffers. Por ejemplo, <code>let mut buffer = [0;640]</code> crea un array de 640 ceros. Posteriormente, se puede modificar el valor cero por otro dato.</p>
<p>Se pueden indexrar los valores (recuperarlos) con <code>[]</code>. El primer valor es <code>[0]</code>, el segundo <code>[1]</code> y as√≠ sucesivamente.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_numbers = [0, 10, -20];
    println!(&quot;{}&quot;, my_numbers[1]); // imprime 10
}
</code></pre></pre>
<p>Se puede obtener una secci√≥n (slice) de un array. Lo primero que se necesita es una referencia <code>&amp;</code> porque el compilador no conoce el tama√±o. Despu√©s se puede usar <code>..</code> para mostrar el rango.</p>
<p>Por ejemplo, si se utiliza el siguiente array: <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let array_of_ten = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    let three_to_five = &amp;array_of_ten[2..5];
    let start_at_two = &amp;array_of_ten[1..];
    let end_at_five = &amp;array_of_ten[..5];
    let everything = &amp;array_of_ten[..];

    println!(&quot;Tres a cinco: {:?}, comienza en el segundo: {:?}, finaliza en el quinto: {:?}, todo: {:?}&quot;, three_to_five, start_at_two, end_at_five, everything);
}
</code></pre></pre>
<p>Se debe recordar que:</p>
<ul>
<li>Los n√∫meros de √≠ndice comienzan en 0 (no en 1).</li>
<li>los rangos son <strong>excluyentes</strong> (es decir, no incluyen el √∫ltimo n√∫mero).</li>
</ul>
<p>As√≠, <code>[0..2]</code> obtiene el primer y segundo valor (0 y 1). Dicho de otro modo, el √≠ndice cero y uno. No obtiene el tercer valor, cuyo  √≠ndice es dos.</p>
<p>Es posible establecer un rango <strong>inclusivo</strong>, que s√≠ incluya el √∫ltimo n√∫mero del rango. Para ello se escribe <code>..=</code>, en lugar de <code>..</code>. As√≠ que <code>[0..=2]</code> permite obtener el primer, segundo y tercer elemento del array.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vectores"><a class="header" href="#vectores">Vectores</a></h1>
<p><strong><a href="https://youtu.be/Eh-DsRnDKmw">Puedes ver este cap√≠tulo en Youtube en ingl√©s</a></strong></p>
<p>Del mismo modo que se dispone de <code>&amp;str</code> y <code>String</code>, se dispone de arrays y vectores. Los arrays son m√°s r√°pidos, pero tienen menos funcionalidad, y los vectores son m√°s lentos, pero tienen m√°s funcionalidad (Rust siempre es muy r√°pido, solo que los vectores no son tan r√°pidos como los arrays). El tipo es <code>Vec</code> y, por lo tanto, se le puede llamar como &quot;vec&quot;.</p>
<p>Existen principalemente dos formas de declarar un vector. Una es igual a como se crea un <code>String</code>, mediante el uso de <code>new</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let name1 = String::from(&quot;Windy&quot;);
    let name2 = String::from(&quot;Gomesy&quot;);

    let mut my_vec = Vec::new();
    // Si se compilara este programa hasta aqu√≠, el compilador dar√° un error.
    // ya que no conoce el tipo de datos del vec.

    my_vec.push(name1); // Ahora s√≠ lo conoce, es un Vec&lt;String&gt;
    my_vec.push(name2);
}
</code></pre></pre>
<p>Los <code>Vec</code> siempre contienen valores y para eso sirven <code>&lt;&gt;</code> (los par√©ntesis angulares). Un <code>Vec&lt;String&gt;</code> es un vector que contiene elementos <code>String</code>. Algunos otros ejemplos son:</p>
<ul>
<li><code>Vec&lt;(i32, i32)&gt;</code> es un vector en el que cada elemento de contenido es una tupla <code>(i32, i32)</code>.</li>
<li><code>Vec&lt;Vec&lt;String&gt;&gt;</code> es un vector en el que cada elemento es otro vector de <code>String</code>. Por ejemplo, se puede pensar en almacenar el texto de un libro como un <code>Vec&lt;String&gt;</code>. Para almacenar varios libros har√≠a falta crear una lista de elementos del tipo anterior y esto se puede hacer en otro <code>Vec</code> que contiene <code>Vec&lt;String&gt;</code>. Por lo tanto, el tipo resultante ser√≠a as√≠ <code>Vec&lt;Vec&lt;String&gt;&gt;</code>.</li>
</ul>
<p>En lugar de usar <code>.push()</code> para llegar a deducir el tipo de elementos que contiene un vector, se puede declarar el tipo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec: Vec&lt;String&gt; = Vec::new(); // El compilador conoce el tipo
                                              // Por eso no hay error
}
</code></pre></pre>
<p>Como se observa, todos los elementos de un vector tienen que tener un mismo tipo.</p>
<p>Otra forma sencilla de crear un vector es usando la macro <code>vec!</code>, cuya sintaxis recuerda a la declaraci√≥n de un array.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec = vec![8, 10, 10];
}
</code></pre></pre>
<p>El tipo de los elementos, en este ejemplo, es <code>Vec&lt;i32&gt;</code>. Un vector de enteros. </p>
<p>Se pueden obtener secciones de un vector, igual que como se hace para un array.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let vec_of_ten = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    // Todo el c√≥digo es id√©ntico, salvo que se a√±ade vec!.
    let three_to_five = &amp;vec_of_ten[2..5];
    let start_at_two = &amp;vec_of_ten[1..];
    let end_at_five = &amp;vec_of_ten[..5];
    let everything = &amp;vec_of_ten[..];

    println!(&quot;Three to five: {:?},
start at two: {:?}
end at five: {:?}
everything: {:?}&quot;, three_to_five, start_at_two, end_at_five, everything);
}
</code></pre></pre>
<p>Puesto que un vector es m√°s lento que un array, se pueden usar diversos m√©todos para hacerlo m√°s r√°pido. Un vector tiene una <strong>capacidad</strong> de espacio asignada, que permite que al ir insertando nuevos elementos en el vector, se haga r√°pidamente. Cada vez que se hace esto, el vector se acerca al l√≠mite de su capacidad. Cuando esta se supera, Rust crea un nuevo espacio del doble del tama√±o actual y copia todos los elementos al nuevo espacio. Esto se denomina relocalizaci√≥n. Se puede usar el m√©todo <code>.capacity()</code>para ver la capacidad de un vector seg√∫n se le van a√±adiendo elementos.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut num_vec = Vec::new();
    println!(&quot;{}&quot;, num_vec.capacity()); // 0 elementos: immprime 0
    num_vec.push('a'); // a√±ade un car√°cter
    println!(&quot;{}&quot;, num_vec.capacity()); // 1 elemento: imprime 4. Vecs con 1 elemento siempre se inician con una capacidad de 4
    num_vec.push('a'); // a√±ade uno m√°s
    num_vec.push('a'); // a√±ade uno m√°s
    num_vec.push('a'); // a√±ade uno m√°s
    println!(&quot;{}&quot;, num_vec.capacity()); // 4 elementos: a√∫n 4 de capacidad.
    num_vec.push('a'); // a√±ade uno m√°s
    println!(&quot;{}&quot;, num_vec.capacity()); // imprime 8. Son 5 elementos, pero ha doblado la capacidad de 4 a 8 para hacer espacio.
}
</code></pre></pre>
<p>Esto imprime:</p>
<pre><code class="language-text">0
4
4
8
</code></pre>
<p>As√≠ que este vector ha sufrido dos relocalizaciones: de 0 a 4 y de 4 a 8. Para que fuese m√°s r√°pido se puede iniciar as√≠:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut num_vec = Vec::with_capacity(8); // Se crea con una capacidad inicial de 8
    num_vec.push('a'); // se a√±ade un car√°cter
    println!(&quot;{}&quot;, num_vec.capacity()); // imprime 8
    num_vec.push('a'); // a√±ade uno m√°s
    println!(&quot;{}&quot;, num_vec.capacity()); // imprime 8
    num_vec.push('a'); // a√±ade uno m√°s
    println!(&quot;{}&quot;, num_vec.capacity()); // imprime 8.
    num_vec.push('a'); // a√±ade uno m√°s
    num_vec.push('a'); // a√±ade uno m√°s
    // Ahora hay 5 elementos
    println!(&quot;{}&quot;, num_vec.capacity()); // A√∫n 8
}
</code></pre></pre>
<p>Este vector no ha sufrido ninguna relocalizaci√≥n, lo que es mejor. Por eso, si se conoce a priori el n√∫mero de elementos que se necesitar√°, se puede inicializar el vector con <code>Vec::with_capacity()</code> para que funcione m√°s r√°pido.</p>
<p>En el caso de las <code>&amp;str</code> se pod√≠a utilizar <code>.into()</code> para convertirlo en una <code>String</code>. Igualmente, se puede convertir un array en un vector con la misma funci√≥n.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec: Vec&lt;u8&gt; = [1, 2, 3].into();
    let my_vec2: Vec&lt;_&gt; = [9, 0, 10].into(); // Vec&lt;_&gt; significa &quot;elige el tipo del Vector por m√≠&quot;
                                             // Rust elegir√° Vec&lt;i32&gt;
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuplas"><a class="header" href="#tuplas">Tuplas</a></h1>
<p><strong><a href="https://youtu.be/U67Diy6SlTg">Se puede ver este cap√≠tulo en Youtube en ingl√©s</a></strong></p>
<p>En Rust las tuplas usan <code>()</code>. Ya han aparecido muchas tuplas vac√≠as ya que <em>nada</em>, en una funci√≥n, realmente significa una tupla vac√≠a:</p>
<pre><code class="language-text">fn do_something() {}
</code></pre>
<p>realmente es igual a:</p>
<pre><code class="language-text">fn do_something() -&gt; () {}
</code></pre>
<p>Esta funci√≥n no recibe ning√∫n par√°metro (recibe una tupla vac√≠a) y no retorna ning√∫n valor (una tupla vac√≠a). Por eso, se han estado usando ya muchas tuplas en los ejemplos de cap√≠tulos anteriores. Cuando no se retorna ning√∫n valor en una funci√≥n, se est√° retornando una tupla vac√≠a.</p>
<pre><pre class="playground"><code class="language-rust">fn just_prints() {
    println!(&quot;Estoy imprimiendo&quot;); // Al a√±adir un ;
    // como √∫ltimo dato antes de terminar la funci√≥n
    // se est√° indicando que se debe retornar una tupla vac√≠a
}

fn main() {}
</code></pre></pre>
<p>Las tuplas pueden almacenar muchos tipos de elementos diferentes a la vez. Los elementos incluidos se indexan con n√∫meros de 0 en adelante. Para acceder a ellos se utiliza el operador <code>.</code> en lugar de <code>[]</code>. A continuaci√≥n se incorporan datos de diferentes tipos en una √∫nica tupla:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let random_tuple = (&quot;Esto es un texto&quot;, 8, vec!['a'], 'b', [8, 9, 10], 7.7);
    println!(
        &quot;El interior de la tupla contiene: Primer elemento: {:?}
Segundo elemento: {:?}
Tercer elemento: {:?}
Cuarto elemento: {:?}
Quinto elemento: {:?}
Sexto elemento: {:?}&quot;,
        random_tuple.0,
        random_tuple.1,
        random_tuple.2,
        random_tuple.3,
        random_tuple.4,
        random_tuple.5,
    )
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">El interior de la tupla contiene: Primer elemento: &quot;Esto es un texto&quot;
Segundo elemento: 8
Tercer elemento: ['a']
Cuarto elemento: 'b'
Quinto elemento: [8, 9, 10]
Sexto elemento: 7.7
</code></pre>
<p>Esta tupla es de tipo <code>(&amp;str, i32, Vec&lt;char&gt;, char, [i32; 3], f64)</code>.</p>
<p>Se puede usar una tupla para crear m√∫ltiples variables. En el siguiente c√≥digo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let str_vec = vec![&quot;one&quot;, &quot;two&quot;, &quot;three&quot;];
}
</code></pre></pre>
<p><code>str_vec</code> contiene tres elementos. ¬øC√≥mo se pueden recuperar los tres valores de este vector en diferentes variables? Por ejemplo, con una tupla:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let str_vec = vec![&quot;one&quot;, &quot;two&quot;, &quot;three&quot;];

    let (a, b, c) = (str_vec[0], str_vec[1], str_vec[2]); // las variables ser√°n a, b, y c
    println!(&quot;{:?}&quot;, b);
}
</code></pre></pre>
<p>El resultado del c√≥digo anterior imprime <code>&quot;two&quot;</code>, que es lo que contiene la variable <code>b</code>. A esta forma de extraer valores en variables se denomina <em>desestructuramiento</em>.</p>
<p>Si se necesita desestructurar un conjunto de elementos, pero no se quieren todos, se puede utilizar <code>_</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let str_vec = vec![&quot;one&quot;, &quot;two&quot;, &quot;three&quot;];

    let (_, _, variable) = (str_vec[0], str_vec[1], str_vec[2]);
}
</code></pre></pre>
<p>El c√≥digo anterior solo crea una variable denominada <code>variable</code>, pero no las crea para el resto de elementos.</p>
<p>Existen muchos m√°s tipos colecci√≥n y muchas formas adicionales de utilizar a los arrays, vectores y tuplas. Se ense√±ar√° m√°s sobre ellos m√°s adelante, pero primero, se ense√±ar√° la forma de controlar el flujo de ejecuci√≥n de un programa.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="estructuras-de-control"><a class="header" href="#estructuras-de-control">Estructuras de control</a></h1>
<p><strong>Se puede ver este cap√≠tulo en YouTube en ingl√©s: <a href="https://youtu.be/UAymDOpv_us">Parte 1</a> y <a href="https://youtu.be/eqysTfiiQZs">Parte 2</a></strong></p>
<p>Las estructuras de control del flujo de ejecuci√≥n permiten indicar qu√© c√≥digo debe ejecutarse en cada caso. La estructura de control de flujo m√°s simple es <code>if</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 5;
    if my_number == 7 {
        println!(&quot;Es el siete&quot;);
    }
}
</code></pre></pre>
<p>Se utiliza <code>==</code> y no <code>=</code>. <code>==</code> sirve para comparar y <code>=</code> se utiliza para asignar un valor. Tambi√©n hay que destacar que se escribe <code>if my_number == 7</code> y no <code>if (my_number == 7)</code>. La estructura de control <code>if</code> no necesita par√©ntesis en Rust.</p>
<p>Esta estructura se completa con <code>else if</code> y <code>else</code> si resultan necesarias:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 5;
    if my_number == 7 {
        println!(&quot;Es el siete&quot;);
    } else if my_number == 6 {
        println!(&quot;Es el seis&quot;)
    } else {
        println!(&quot;Es un n√∫mero diferente&quot;)
    }
}
</code></pre></pre>
<p>El c√≥digo anterior imprime <code>Es un n√∫mbero diferente</code> porque no es igual a 7 o 6.</p>
<p>Se pueden a√±adir m√°s condiciones con <code>&amp;&amp;</code> (operador <code>y l√≥gico</code>) y <code>||</code> (operador <code>o l√≥gico</code>).</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 5;
    if my_number % 2 == 1 &amp;&amp; my_number &gt; 0 { // % 2 es el resto de la divisi√≥n entre dos
        println!(&quot;Es un n√∫mero impar positivo&quot;);
    } else if my_number == 6 {
        println!(&quot;Es el seis&quot;)
    } else {
        println!(&quot;Es un n√∫mero diferente&quot;)
    }
}
</code></pre></pre>
<p>El c√≥digo anterior imprime <code>Es un n√∫mero impar positivo</code> porque cuando se divide entre 2 el resto es 1, que es mayor que 0.</p>
<p>Se observa que cuando hay demasiados <code>if</code>, <code>else</code> y <code>else if</code> el c√≥digo puede resultar dif√≠cil de leer. En estos casos (y en otros muchos) se puede utilizar <code>match</code>, que resulta mucho m√°s l√≠mpio. <code>match</code> requiere que se contemplen todos los casos posibles para evitar errores. As√≠ que el siguiente c√≥digo no funciona:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number: u8 = 5;
    match my_number {
        0 =&gt; println!(&quot;Es cero&quot;),
        1 =&gt; println!(&quot;Es uno&quot;),
        2 =&gt; println!(&quot;Es dos&quot;),
        // ‚ö†Ô∏è
    }
}
</code></pre></pre>
<p>El compilar indica lo siguiente:</p>
<pre><code class="language-text">error[E0004]: non-exhaustive patterns: `3u8..=std::u8::MAX` not covered
 --&gt; src\main.rs:3:11
  |
3 |     match my_number {
  |           ^^^^^^^^^ pattern `3u8..=std::u8::MAX` not covered
</code></pre>
<p>El compilador se queja de que solo conoce lo que tiene que ejecutar los casos de 0 a 2, pero <code>u8</code> puede tener valores hasta el 255 (es decir <code>std::u8::MAX</code>). Qu√© debe hacer el programa para el resto de valores posibles que pueden aparecer.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number: u8 = 5;
    match my_number {
        0 =&gt; println!(&quot;Es cero&quot;),
        1 =&gt; println!(&quot;Es uno&quot;),
        2 =&gt; println!(&quot;Es dos&quot;),
        _ =&gt; println!(&quot;Es alg√∫n otro n√∫mero&quot;),
    }
}
</code></pre></pre>
<p>Este c√≥digo imprime <code>Es alg√∫n otro n√∫mero</code>.</p>
<p>Para el caso de <code>match</code> hay que recordar que:</p>
<ul>
<li>A todo <code>match</code> le sigue un bloque de c√≥digo <code>{}</code></li>
<li>Se escriben los <em>patrones</em> a la izquierda y se usa <code>=&gt;</code> (flecha gruesa -fat arrow-) para indicar qu√© hay que hacer cuando hay una coincidencia.</li>
<li>A cada l√≠nea con un patr√≥n se le denomina &quot;brazo&quot; del <code>match</code>.</li>
<li>Entre cada &quot;brazo&quot; se pone una coma de separaci√≥n (no se usa el punto y coma).</li>
</ul>
<p>Se puede declarar un valor usando <code>match</code> ya que retorna una valor.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 5;
    let second_number = match my_number {
        0 =&gt; 0,
        5 =&gt; 10,
        _ =&gt; 2,
    };
}
</code></pre></pre>
<p>En el ejemplo anterior, <code>second_number</code> tendr√° el valor 10. El match, en este caso acaba con un ; ya que una vez se ha finalizado su evaluaci√≥n esta sentencia es como si se hubiese escrito <code>let second_number = 10;</code>. Que define y asigna el 10 a <code>second_number</code>.</p>
<p><code>match</code> se puede utilizar para cosas m√°s complejas. Por ejemplo, con tuplas:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let sky = &quot;nuboso&quot;;
    let temperature = &quot;c√°lido&quot;;

    match (sky, temperature) {
        (&quot;nuboso&quot;, &quot;fr√≠o&quot;) =&gt; println!(&quot;El d√≠a es oscuro y desapacible&quot;),
        (&quot;despejado&quot;, &quot;c√°lido&quot;) =&gt; println!(&quot;El d√≠a es agradable&quot;),
        (&quot;nuboso&quot;, &quot;c√°lido&quot;) =&gt; println!(&quot;El d√≠a es oscuro, pero no se est√° mal&quot;),
        _ =&gt; println!(&quot;No s√© c√≥mo es el d√≠a de hoy&quot;),
    }
}
</code></pre></pre>
<p>Este c√≥digo imprime <code>El d√≠a es oscuro, pero no se est√° mal</code> porque coincide con &quot;nuboso&quot; y &quot;c√°lido&quot; para <code>sky</code> y <code>temperature</code>.</p>
<p>Incluso se puede utilizar <code>if</code> en las ramas de un <code>match</code>. Es lo que se llama una &quot;guarda de coincidencia&quot; (match guard):</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let children = 5;
    let married = true;

    match (children, married) {
        (children, married) if married == false =&gt; println!(&quot;Sin casar con {} ni√±os&quot;, children),
        (children, married) if children == 0 &amp;&amp; married == true =&gt; println!(&quot;Casado, pero sin ni√±os&quot;),
        _ =&gt; println!(&quot;¬øCasado? {}. N√∫mero de ni√±os: {}.&quot;, married, children),
    }
}
</code></pre></pre>
<p>Este progrma imprimir√° <code>¬øCasado? true. N√∫mero de ni√±os: 5.</code></p>
<p>Se puede usar <code>_</code> tantas veces como se necesite en un <code>match</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn match_colours(rbg: (i32, i32, i32)) {
    match rbg {
        (r, _, _) if r &lt; 10 =&gt; println!(&quot;No muy rojo&quot;),
        (_, b, _) if b &lt; 10 =&gt; println!(&quot;No muy azul&quot;),
        (_, _, g) if g &lt; 10 =&gt; println!(&quot;No muy verde&quot;),
        _ =&gt; println!(&quot;Cada color tiene al menos 10&quot;),
    }
}

fn main() {
    let first = (200, 0, 0);
    let second = (50, 50, 50);
    let third = (200, 50, 0);

    match_colours(first);
    match_colours(second);
    match_colours(third);

}
</code></pre></pre>
<p>Este c√≥digo imprime:</p>
<pre><code class="language-text">No muy azul
Cada color tiene al menos 10
No muy verde
</code></pre>
<p>Este c√≥digo tambi√©n muestra c√≥mo funcionan las sentencias <code>match</code>, porque en el primer ejemplo solo imprime <code>No muy rojo</code>, aunque tampoco tiene mucho verde. Las sentencias <code>match</code> siempre se detienen cuando encuentran una coincidencia y no chequea el resto de los &quot;brazos&quot;. Es un buen ejemplo de c√≥digo que compila bien, pero no hace lo que se quiere.</p>
<p>Se puede construir una sentencia <code>match</code>gigante para arreglar este c√≥digo, pero probablemente es mejor utilizar un bucle <code>for</code>. M√°s adelante se hablar√° de los bucles.</p>
<p>La sentencia <code>match</code> siempre tiene que devolver el mismo tipo de datos en todas sus ramas. Por eso, este c√≥digo no funciona:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 10;
    let some_variable = match my_number {
        10 =&gt; 8,
        _ =&gt; &quot;Not ten&quot;, // ‚ö†Ô∏è
    };
}
</code></pre></pre>
<p>El compilador indica lo siguiente:</p>
<pre><code class="language-text">error[E0308]: `match` arms have incompatible types
  --&gt; src\main.rs:17:14
   |
15 |       let some_variable = match my_number {
   |  _________________________-
16 | |         10 =&gt; 8,
   | |               - this is found to be of type `{integer}`
17 | |         _ =&gt; &quot;Not ten&quot;,
   | |              ^^^^^^^^^ expected integer, found `&amp;str`
18 | |     };
   | |_____- `match` arms have incompatible types
</code></pre>
<p>El c√≥digo siguiente, por la misma raz√≥n, tampoco funciona:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let some_variable = if my_number == 10 { 8 } else { &quot;something else &quot;}; // ‚ö†Ô∏è
}
</code></pre></pre>
<p>Pero el siguiente c√≥digo s√≠ funciona, porque no es un <code>match</code>y son dos sentencias diferentes:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 10;

    if my_number == 10 {
        let some_variable = 8;
    } else {
        let some_variable = &quot;Something else&quot;;
    }
}
</code></pre></pre>
<p>Tambi√©n se puede usar <code>@</code> para darle un nombre al valor de un patr√≥n <code>match</code> con el fin de poder usarlo en la expresi√≥n correspondiente a ese &quot;brazo&quot;. En este ejemplo, se guarda el valor en una variable <code>number</code> para pasarlo a una funci√≥n. Si es 4 o 13 se usa ese <code>number</code> en la sentencia <code>println!</code>. En otro caso, no se utiliza.</p>
<pre><pre class="playground"><code class="language-rust">fn match_number(input: i32) {
    match input {
    number @ 4 =&gt; println!(&quot;{} da mala suerte en China (suena parecido a Ê≠ª)&quot;, number),
    number @ 13 =&gt; println!(&quot;{} da mala suerte en Norte Am√©rica, ¬°Suerte en Italia! In bocca al lupo&quot;, number),
    _ =&gt; println!(&quot;Es un n√∫mero normal&quot;),
    }
}

fn main() {
    match_number(50);
    match_number(13);
    match_number(4);
}
</code></pre></pre>
<p>Este c√≥digo imprime:</p>
<pre><code class="language-text">Es un n√∫mero normal
13 da mala suerte en Norte Am√©rica, ¬°Suerte en Italia! In bocca al lupo
4 da mala suerte en China (suena parecido a Ê≠ª)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="estructuras---struct"><a class="header" href="#estructuras---struct">Estructuras - struct</a></h1>
<p><strong>Se puede ver este cap√≠tulo en YouTube en ingl√©s: <a href="https://youtu.be/W23uQghBOFk">Parte 1</a> y <a href="https://youtu.be/GSVhrjLCuNA">Parte 2</a></strong></p>
<p>Con las estructuras se pueden crear nuevos tipos de datos. Se utilizan constantemente en Rust, puesto que son muy √∫tiles. Las estructuras se crean con la palabra reservada <code>struct</code>. El nombre de las estructuras deber√≠a estar en UpperCamelCase (una letra may√∫scula por cada palabra sin espacios, ni guiones bajos). Si se escribe todo en min√∫sculas, el compilador avisar√°.</p>
<p>Existen tres tipos de estructuras.</p>
<p>La primera de ellas es la estructura unitaria &quot;unit struct&quot;, que no tiene nada. Simplemente se escribe su nombre seguido de un punto y coma.</p>
<pre><pre class="playground"><code class="language-rust">struct FileDirectory;
fn main() {}
</code></pre></pre>
<p>La segunda de ellas es la estructura tupla, o estructura sin nombres. Solo es necesario escribir los tipos de dato que contiene, sin nombres de campo. Las estructuras de tupla son indicadas cuando se necesita una estructura simple sin necesidad de utilizar nombres.</p>
<pre><pre class="playground"><code class="language-rust">struct Colour(u8, u8, u8);

fn main() {
    let my_colour = Colour(50, 0, 50); // Crea un color RGB (red, green, blue)
    println!(&quot;La segunda parte del color (la componente verde) es: {}&quot;, my_colour.1);
}
</code></pre></pre>
<p>Este c√≥digo imprime <code>La segunda parte del color (la componente verde) es: 0</code>.</p>
<p>El tercer tipo es la estructura con nombres. Que es, probablemente, la m√°s habitual. En estas estructuras se declaran los nombres de los campos y sus tipos en un bloque <code>{}</code>. Estos bloques no se terminan con punto y coma.</p>
<pre><pre class="playground"><code class="language-rust">struct Colour(u8, u8, u8); // Declara la misma estructura tupla para el color

struct SizeAndColour {
    size: u32,
    colour: Colour, // y la inserta en una estructura con nombres
}

fn main() {
    let my_colour = Colour(50, 0, 50);

    let size_and_colour = SizeAndColour {
        size: 150,
        colour: my_colour
    };
}
</code></pre></pre>
<p>Los campos de una estructura con nombres se separan con comas. El √∫ltimo campo puede llevar o no la coma. En el caso anterior, se puso una coma despu√©s de definir el campo <code>colour: Colour,</code>, pero no es necesario. Normalmente, se considera buena idea poner siempre la coma, porque en ocasiones resulta necesario cambiar el orden de los campos o a√±adir uno al final y de este modo es sistem√°tica la modificaci√≥n:</p>
<pre><pre class="playground"><code class="language-rust">struct Colour(u8, u8, u8); 

struct SizeAndColour {
    size: u32,
    colour: Colour // Sin coma
}

fn main() {}
</code></pre></pre>
<p>Se dedice cambiar su orden, cortando y pegando la fila...</p>
<pre><pre class="playground"><code class="language-rust">struct SizeAndColour {
    colour: Colour // ‚ö†Ô∏è ¬°Error! ya que no tiene coma.
    size: u32,
}

fn main() {}
</code></pre></pre>
<p>En todo caso, no es muy importante si se usa la coma o no.</p>
<p>En el siguiente ejemplo, se crea una estructura <code>Pais</code> que tiene los campos <code>poblacion</code>, <code>capital</code>y <code>presidente</code>.</p>
<pre><pre class="playground"><code class="language-rust">struct Pais {
    poblacion: u32,
    capital: String,
    presidente: String
}

fn main() {
    let poblacion = 500_000;
    let capital = String::from(&quot;Elista&quot;);
    let presidente = String::from(&quot;Batu Khasikov&quot;);

    let kalmykia = Pais {
        poblacion: poblacion,
        capital: capital,
        presidente: presidente,
    };
}
</code></pre></pre>
<p>Se observa que resuta prolijo tener que escribir el nombre del campo y su valor. Se escribe doble. <code>poblacion: poblacion</code>, <code>capital: capital</code> y <code>presidente: presidente</code>. Como se trata de alto habitual, Rust proporciona un atajo si tanto el campo, como la variable que contiene el valor se llaman igual. En ese caso, se puede simplificar as√≠:</p>
<pre><pre class="playground"><code class="language-rust">struct Pais {
    poblacion: u32,
    capital: String,
    presidente: String
}

fn main() {
    let poblacion = 500_000;
    let capital = String::from(&quot;Elista&quot;);
    let presidente = String::from(&quot;Batu Khasikov&quot;);

    let kalmykia = Pais {
        poblacion,
        capital,
        presidente,
    };
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enumerados---enum"><a class="header" href="#enumerados---enum">Enumerados - enum</a></h1>
<p><strong>Este cap√≠tulo se puede ver en YouTube en ingl√©s: <a href="https://youtu.be/SRnqNTJUgjs">Parte 1</a>, <a href="https://youtu.be/F_EcbWM63lk">Parte 2</a>, <a href="https://youtu.be/2uh64U9JesA">Parte 3</a> y <a href="https://youtu.be/LOHVUYTc5Us">Parte 4</a></strong></p>
<p>La palabra reservada de Rust <code>enum</code> se usa para los tipos enumerados. Esta es la diferencia con <code>struct</code>:</p>
<ul>
<li>Se utiliza <code>struct</code> cuando un tipo de datos debe representar una cosa <strong>Y</strong> otra cosa a la vez.</li>
<li>Se utiliza <code>enum</code> cuando un tipo de datos puede representar una cosa <strong>O</strong> alguna cosa diferente.</li>
</ul>
<p>Las estructuras sirven para unir diferentes elementos en uno solo, mientras que los enumerados permiten que un tipo de datos represente a diferentes cosas en diferente momento.</p>
<p>Para declarar un enumerado se debe escribir <code>enum</code> seguido de un bloque <code>{}</code> con las diferentes opciones separadas por coma. Como en el caso de los <code>struct</code> la √∫ltima opci√≥n puede llevar la coma o no. A continuaci√≥n se crea un enumerado denominado <code>CosasEnElCielo</code>:</p>
<pre><pre class="playground"><code class="language-rust">enum CosasEnElCielo {
    Sol,
    Estrellas,
}

fn main() {}
</code></pre></pre>
<p>Es un enumerado, por lo tanto, cuando se cree un valor es necesario que se elija entre el <code>Sol</code> o las <code>Estrellas</code>. A cada elemento que forma parte del enumerado se le denomina <strong>variante</strong>.</p>
<pre><pre class="playground"><code class="language-rust">// Crea el enumerado con dos variantes
enum CosasEnElCielo {
    Sol,
    Estrellas,
}

// Con esa funci√≥n se usa un i32 para crear CosasEnElCielo.
fn crear_estadoEnElCielo(time: i32) -&gt; CosasEnElCielo {
    match time {
        6..=18 =&gt; CosasEnElCielo::Sol, // Entre las 6 y 18 horas se ve el sol
        _ =&gt; CosasEnElCielo::Estrellas, // En otro caso se ven las estrellas
    }
}

// Con esta funci√≥n se localiza el estado y se muestran las CosasEnElCielo.
fn comprobar_el_cielo(state: &amp;CosasEnElCielo) {
    match state {
        CosasEnElCielo::Sol =&gt; println!(&quot;¬°Puedo ver el sol!&quot;),
        CosasEnElCielo::Estrellas =&gt; println!(&quot;¬°Puedo ver las estrellas!&quot;)
    }
}

fn main() {
    let time = 8; // Son las ocho de la ma√±ana
    let skystate = crear_estadoEnElCielo(time); // crear_estadoEnElCielo returns a CosasEnElCielo
    comprobar_el_cielo(&amp;skystate); // Se pasa una referencia para que pueda leer el estado del cielo
}
</code></pre></pre>
<p>Este c√≥digo imprime <code>¬°Puedo ver el sol!</code>.</p>
<p>A cada enumerado, se le pueden a√±adir datos (como en los struts):</p>
<pre><pre class="playground"><code class="language-rust">enum CosasEnElCielo {
    Sol(String), // Ahora cada variante tiene una cadena de texto
    Estrellas(String),
}

fn crear_estadoEnElCielo(time: i32) -&gt; CosasEnElCielo {
    match time {
        6..=18 =&gt; CosasEnElCielo::Sol(String::from(&quot;¬°Puedo ver el sol!&quot;)), // Da el valor aqu√≠
        _ =&gt; CosasEnElCielo::Estrellas(String::from(&quot;¬°Puedo ver las estrellas!&quot;)),
    }
}

fn comprobar_el_cielo(state: &amp;CosasEnElCielo) {
    match state {
        CosasEnElCielo::Sol(description) =&gt; println!(&quot;{}&quot;, description), // recupera la descripci√≥n para que se pueda imprimir
        CosasEnElCielo::Estrellas(n) =&gt; println!(&quot;{}&quot;, n), // se puede usar cualquier variable n para obtener la descripci√≥n
    }
}

fn main() {
    let time = 8; // Son las ocho de la ma√±ana
    let skystate = crear_estadoEnElCielo(time); // crear_estadoEnElCielo devuelve un elemento de CosasEnElCielo
    comprobar_el_cielo(&amp;skystate); // Se pasa una referencia para que pueda leer el estado del cielo
}
</code></pre></pre>
<p>Este c√≥digo imprime lo mismo que antes <code>¬°Puedo ver el sol!</code>.</p>
<p>Tambi√©n se puede &quot;importar&quot; un enumerado para que no haya que escribir mucho. A continuaci√≥n se muestra un ejemplo en se escribe <code>Estado::</code> cada vez que se comprueba el &quot;estado de √°nimo&quot;:</p>
<pre><pre class="playground"><code class="language-rust">enum Estado {
    Feliz,
    Cansado,
    NoEstoyMal,
    Enfadado,
}

fn comprueba_estado(mood: &amp;Estado) -&gt; i32 {
    let nivel_de_felicidad = match mood {
        Estado::Feliz =&gt; 10, // Se escribe Estado:: cada vez
        Estado::Cansado =&gt; 6,
        Estado::NoEstoyMal =&gt; 7,
        Estado::Enfadado =&gt; 2,
    };
    nivel_de_felicidad
}

fn main() {
    let my_mood = Estado::NoEstoyMal;
    let nivel_de_felicidad = comprueba_estado(&amp;my_mood);
    println!(&quot;De 1 a 10, mi estado de felicidad es {}&quot;, nivel_de_felicidad);
}
</code></pre></pre>
<p>El c√≥digo anterior imprime <code>De 1 a 10, mi estado de felicidad es 7</code>. A continuaci√≥n, el mismo c√≥digo, pero importando el enumerado para tener que escribir menos. Para importar todo se utiliza <code>*</code>. Es el mismo car√°cter que para desrreferenciar, pero con un uso diferente.</p>
<pre><pre class="playground"><code class="language-rust">enum Estado {
    Feliz,
    Cansado,
    NoEstoyMal,
    Enfadado,
}

fn comprueba_estado(mood: &amp;Estado) -&gt; i32 {
    use Estado::*; // Se importa el conjunto de variantes de Estado. Ahora se puede escribir menos
    let nivel_de_felicidad = match mood {
        Feliz =&gt; 10, // Ya no es necesario escribir Estado::
        Cansado =&gt; 6,
        NoEstoyMal =&gt; 7,
        Enfadado =&gt; 2,
    };
    nivel_de_felicidad
}

fn main() {
    let my_mood = Estado::NoEstoyMal;
    let nivel_de_felicidad = comprueba_estado(&amp;my_mood);
    println!(&quot;De 1 a 10, mi estado de felicidad es {}&quot;, nivel_de_felicidad);
}
</code></pre></pre>
<p>Las partes de un enumerado se pueden convertir a n√∫mero entero. Esto se debe a que Rust da a cada variante de un <code>enum</code> un n√∫mero que comienza con el 0 (para uso interno de Rust). Se puede utilizar en el c√≥digo, siempre que las variantes con contengan ning√∫n dato adicional:</p>
<pre><pre class="playground"><code class="language-rust">enum Estacion {
    Primavera, // If this was Primavera(String) or something it wouldn't work
    Verano,
    Oto√±o,
    Invierno,
}

fn main() {
    use Estacion::*;
    let cuatro_estaciones = vec![Primavera, Verano, Oto√±o, Invierno];
    for estacion in cuatro_estaciones {
        println!(&quot;{}&quot;, estacion as u32);
    }
}
</code></pre></pre>
<p>El c√≥digo anterior imprime:</p>
<pre><code class="language-text">0
1
2
3
</code></pre>
<p>Es posible asignar un n√∫mero entero expresamente a cada variante. A Rust no le importa el n√∫mero concreto que tenga cada una de ellas. Para ello, se a√±ade un s√≠mbolo <code>=</code> y el n√∫mero deseado a cada variante. No es necesario indicar el n√∫mero a cada variante. Si no se a√±ade, Rust utiliza el siguiente disponible (suma 1) a partir de la variante anterior que tuviera n√∫mero:</p>
<pre><pre class="playground"><code class="language-rust">enum Estrella {
    EnanaMarron = 10,
    EnanaRoja = 50,
    EstrellaAmarilla = 100,
    GiganteRoja = 1000,
    EstrellaMuerta, // ¬øQu√© n√∫mero tendr√°?
}

fn main() {
    use Estrella::*;
    let starvec = vec![EnanaMarron, EnanaRoja, EstrellaAmarilla, GiganteRoja];
    for star in starvec {
        match star as u32 {
            size if size &lt;= 80 =&gt; println!(&quot;No es la estrella m√°s grande&quot;),
            size if size &gt;= 80 =&gt; println!(&quot;Esta estrella tiene un buen tama√±o&quot;),
            _ =&gt; println!(&quot;Esta estrella es muy grande&quot;),
        }
    }
    println!(&quot;¬øQu√© n√∫mero tiene EstrellaMuerta? Es el n√∫mero {}.&quot;, EstrellaMuerta as u32);
}
</code></pre></pre>
<p>This prints:</p>
<pre><code class="language-text">No es la estrella m√°s grande
No es la estrella m√°s grande
Esta estrella tiene un buen tama√±o
Esta estrella tiene un buen tama√±o
¬øQu√© n√∫mero tiene EstrellaMuerta? Es el n√∫mero 1001.
</code></pre>
<p><code>EstrellaMuerta</code> hubiera sido el n√∫mero 4 si no se hubiera expresado ning√∫n n√∫mero, pero ahora es el 1001.</p>
<h2 id="los-enumerados-sirven-para-usar-tipos-diferentes"><a class="header" href="#los-enumerados-sirven-para-usar-tipos-diferentes">Los enumerados sirven para usar tipos diferentes</a></h2>
<p>Como ya se sabe, los elementos de un <code>Vec</code>, array, etc. tienen que ser del mismo tipo siempre (solo las tuplas permiten tipos diferentes). Los enumerados permiten incorporar diferentes tipos en las colecciones anteriores. Si se deseara tener un <code>Vec</code> que almacenara de forma indistinta <code>u32</code> o <code>i32</code> se puede declarar el <code>Vec</code> como que contiene un enumerado como en el siguiente ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">enum Numero {
    U32(u32),
    I32(i32),
}

fn main() {}
</code></pre></pre>
<p>As√≠, este enumerado tiene dos variantes: la variante <code>U32</code>con un <code>u32</code>y la variante <code>I32</code> con un <code>i32</code>. <code>U32</code> y <code>I32</code> son solo los nombres de cada variante. Se podr√≠an haber llamado <code>UTreintaYDos</code> o <code>ITreintaYDos</code> o cualquier otra cosa.</p>
<p>Ahora es posible declarar un <code>Vec</code> de la siguiente forma <code>Vec&lt;Numero&gt;</code> y el compilador no se queja porque el vector es de un solo tipo. Al compilador no le preocupa si en un momento dado hay <code>u32</code> o <code>i32</code> porque esa diferencia est√° oculta por el tipo <code>Numero</code>. Y como es un enumerado, es necesario seleccionar una variante cada vez. En el siguiente c√≥digo se usa el m√©todo <code>.is_positive()</code> para seleccionar la variante. Si es <code>true</code> se selecciona <code>U32</code> y si es <code>false</code> se selecciona <code>I32</code>.</p>
<p>Ahora el c√≥digo queda as√≠:</p>
<pre><pre class="playground"><code class="language-rust">enum Numero {
    U32(u32),
    I32(i32),
}

fn get_numero(input: i32) -&gt; Numero {
    let numero = match input.is_positive() {
        true =&gt; Numero::U32(input as u32), // lo cambia a u32 si es positivo
        false =&gt; Numero::I32(input), 
    };
    numero
}


fn main() {
    let my_vec = vec![get_numero(-800), get_numero(8)];

    for item in my_vec {
        match item {
            Numero::U32(numero) =&gt; println!(&quot;Es un u32 con el valor {}&quot;, numero),
            Numero::I32(numero) =&gt; println!(&quot;Es un i32 con el valor {}&quot;, numero),
        }
    }
}
</code></pre></pre>
<p>Este c√≥digo imprime:</p>
<pre><code class="language-text">Es un i32 con el valor -800
Es un u32 con el valor 8
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bucles"><a class="header" href="#bucles">Bucles</a></h1>
<p>Con los bucles se de puede decir a Rust que repita algo hasta que se quiera que se detenga. Se puede utilizar la palabra reservada <code>loop</code> para iniciar un bucle que no tenga fin. Al menos, hasta que se le indique que se pare mediante la palabra reservada <code>break</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() { // Este programa nunca se detiene
    loop {

    }
}
</code></pre></pre>
<p>El siguiente programa s√≠ acaba. En cada repetici√≥n incrementa en uno un contador, hasta que vale 5. En este momento se acaba:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut contador = 0; // Inicia el contador a 0
    loop {
        contador +=1; // Incrementa el contador en 1
        println!(&quot;El contador vale ahora {}&quot;, contador);
        if contador == 5 { // Sale del bucle cuyo contador == 5
            break;
        }
    }
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">El contador vale ahora 1
El contador vale ahora 2
El contador vale ahora 3
El contador vale ahora 4
El contador vale ahora 5
</code></pre>
<p>Si se inserta un bucle dentro de otro, es posible darles nombre para indicar a Rust a qu√© bucle salir cuyo se ejecuta una sentencia <code>break</code>. Para dar nombre se usa el ap√≥strofo <code>'</code> y los dos puntos <code>:</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut contador = 0;
    let mut contador2 = 0;
    println!(&quot;Entryo en el primer bucle.&quot;);

    'primer_bucle: loop {
        // Da nombre al primer bucle
        contador += 1;
        println!(&quot;El contador es ahora: {}&quot;, contador);
        if contador &gt; 9 {
            // Inicia un segundo bucle dentro del primero
            println!(&quot;Entryo en el segundo bucle.&quot;);

            'segundo_bucle: loop {
                // est√° dentro del 'segundo_bucle
                println!(&quot;El segundo contador es ahora: {}&quot;, contador2);
                contador2 += 1;
                if contador2 == 3 {
                    break 'primer_bucle; // Sale del  'primer_bucle para abyonar el programa
                }
            }
        }
    }
}
</code></pre></pre>
<p>Este c√≥digo imprimir√°:</p>
<pre><code class="language-text">Entryo en el primer bucle.
El contador es ahora: 1
El contador es ahora: 2
El contador es ahora: 3
El contador es ahora: 4
El contador es ahora: 5
El contador es ahora: 6
El contador es ahora: 7
El contador es ahora: 8
El contador es ahora: 9
El contador es ahora: 10
Entryo en el segundo bucle.
El segundo contador es ahora: 0
El segundo contador es ahora: 1
El segundo contador es ahora: 2
</code></pre>
<p>Un bucle <code>while</code> es uno que se repite mientras una condici√≥n se cumple (es <code>true</code>). En cada repetici√≥n, Rust valida si la condici√≥n es a√∫n <code>true</code>. Cuyo es <code>false</code>, Rust finaliza el bucle.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut contador = 0;

    while contador &lt; 5 {
        contador +=1;
        println!(&quot;El contador vale ahora: {}&quot;, contador);
    }
}
</code></pre></pre>
<p>Un bucle <code>for</code> repite la ejecuci√≥n un n√∫mero determinado de veces. Este tipo de bucles suele utilizar <strong>rangos</strong> muy a menudo. Se utiliza <code>..</code> y <code>..=</code> para crear un rango.</p>
<ul>
<li><code>..</code> crea un rango <strong>excluyente</strong>: <code>0..3</code> crea un rango con los siguientes tres n√∫meros <code>0, 1, 2</code>.</li>
<li><code>..=</code> crea un rango <strong>incluyente</strong>: <code>0..=3</code> crea un rango con los siguientes cuatro n√∫meros <code>0, 1, 2, 3</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for numero in 0..3 {
        println!(&quot;El numero es: {}&quot;, numero);
    }

    for numero in 0..=3 {
        println!(&quot;El siguiente numero es: {}&quot;, numero);
    }
}
</code></pre></pre>
<p>Este c√≥digo imprime:</p>
<pre><code class="language-text">El numero es: 0
El numero es: 1
El numero es: 2
El siguiente numero es: 0
El siguiente numero es: 1
El siguiente numero es: 2
El siguiente numero es: 3
</code></pre>
<p>En los bucles <code>for</code> se observa que se crea una variable en cada repetici√≥n que contiene el valor de la repetici√≥n (iteraci√≥n) actual. Esta variable se podr√≠a llamar de cualquier forma. La variable se usa, en este caso, en <code>println!</code>.</p>
<p>Si no se necesitara la variable, se puede utilizar <code>_</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for _ in 0..3 {
        println!(&quot;Imprimiendo lo mismo las tres veces&quot;);
    }
}
</code></pre></pre>
<p>Que imprimir√°:</p>
<pre><code class="language-text">Imprimiendo lo mismo las tres veces
Imprimiendo lo mismo las tres veces
Imprimiendo lo mismo las tres veces
</code></pre>
<p>En este caso no se ha usado la variable.</p>
<p>Realmente, si se le hubiera dado nombre a la variable y no se hubiese usado, Rust lo hubiera indicado:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for numero in 0..3 {
        println!(&quot;Imprimiendo lo mismo las tres veces&quot;);
    }
}
</code></pre></pre>
<p>El c√≥digo anterior imprime lo mismo que antes. El programa compila bien, pero Rust lanzar√° un aviso recordyo que la variable <code>numero</code> no se est√° usyo:</p>
<pre><code class="language-text">warning: unused variable: `numero`
 --&gt; src\main.rs:2:9
  |
2 |     for numero in 0..3 {
  |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_number`
</code></pre>
<p>Rust sugiere que se escriba <code>_numero</code> en lugar de <code>_</code>. Para Rust, una variable que comience por <code>_</code> significa que &quot;puede que se use en el futuro&quot;. El uso de <code>_</code> solo, significa &quot;no importa este valor&quot;. Por eso, se pueden poner <code>_</code> guiones bajos delante del nombre de las variables que se vayan a usar m√°s tarde y no se quiera que el compilador avise sobre que no se est√°n usyo.</p>
<p><code>break</code> tambi√©n se puede usar para devolver un valor. Para ello, se escribe un valor detr√°s de √©l y se usa <code>;</code>. A continuaci√≥n se muestra un ejemplo con <code>loop</code> y un uso de <code>break</code>que devuelve <code>mi_numero</code> como valor.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut contador = 5;
    let mi_numero = loop {
        contador +=1;
        if contador % 53 == 3 {
            break contador;
        }
    };
    println!(&quot;{}&quot;, mi_numero);
}
</code></pre></pre>
<p>Este c√≥digo imprime <code>56</code>. <code>break contador;</code> significa &quot;finaliza el bucle y devuelve el valor del contador&quot;. Puesto que el bucle se asigna a la variable <code>mi_numero</code>, el valor devuelto se almacena en ella.</p>
<p>Con el conocimiento de los bucles se puede escribir una soluci√≥n mejor al problema anterior de la comprobaci√≥n de los colores con <code>match</code>. Es una soluci√≥n mejor porque el objetivo es poder comparar todos los componentes de un color.</p>
<pre><pre class="playground"><code class="language-rust">fn match_colores(rbg: (i32, i32, i32)) {
    println!(&quot;Comparaci√≥n de un color con {} rojo, {} azul, y {} verde:&quot;, rbg.0, rbg.1, rbg.2);
    let new_vec = vec![(rbg.0, &quot;rojo&quot;), (rbg.1, &quot;azul&quot;), (rbg.2, &quot;verde&quot;)]; // Coloca los colores en un vec. Dentro son tuplas con los nombres de los colores
    let mut todos_tienen_al_menos_10 = true; // Comienza a verdadero y se cambia a falso si alg√∫n compomente no tiene 10
    for item in new_vec {
        if item.0 &lt; 10 {
            todos_tienen_al_menos_10 = false; // Ahora es false
            println!(&quot;No mucho {}.&quot;, item.1) // Y se imprime el nombre del color.
        }
    }
    if todos_tienen_al_menos_10 { // Comprueba si es verdadero e imprime si lo es
        println!(&quot;Cada compomente de color tiene al menos 10.&quot;)
    }
    println!(); // A√±ade una l√≠nea vac√≠a para separar
}

fn main() {
    let first = (200, 0, 0);
    let second = (50, 50, 50);
    let third = (200, 50, 0);

    match_colores(first);
    match_colores(second);
    match_colores(third);
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">Comparaci√≥n de un color con 200 rojo, 0 azul, y 0 verde:
No mucho azul.
No mucho verde.

Comparaci√≥n de un color con 50 rojo, 50 azul, y 50 verde:
Cada compomente de color tiene al menos 10.

Comparaci√≥n de un color con 200 rojo, 50 azul, y 0 verde:
No mucho verde.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementando-funciones-para-structs-y-enums"><a class="header" href="#implementando-funciones-para-structs-y-enums">Implementando funciones para structs y enums</a></h1>
<p>Los <code>struct</code> y <code>enum</code> permiten que se puedan definir funciones asociadas a los tipos definidos como tal. Esto da mucha capacidad al lenguaje. Para ello, se utiliza el bloque <code>impl</code> sobre el tipo de datos definido con <code>struct</code> o <code>enum</code>. A estas funciones se las llama <strong>m√©todos</strong>.</p>
<p>En un bloque <code>impl</code> se pueden definir dos tipos diferentes de m√©todos:</p>
<ul>
<li>M√©todos: que toman como primer par√°metro uno denominado <code>self</code> (o <code>&amp;self</code> o <code>&amp;mut self</code>). Estos m√©todos, para utilizarlos, usan <code>.</code> (un punto) sobre una variable del tipo <code>struct</code> o <code>enum</code> correspondiente. Por ejemplo, <code>x.clone()</code> es un m√©todo del tipo de la variable <code>x</code>.</li>
<li>Funciones asociadas (al tipo). Que en otros lenguajes se conocen como m√©todos est√°ticos: No tienen el primer par√°metros <code>self</code>. Son funciones &quot;relacionadas con el tipo de datos&quot;. Se llaman utilizando <code>::</code>. Por ejemplo: <code>String::from()</code> es una llamada a una funci√≥n asociada. Tambi√©n <code>Vec::new()</code>. Normalmente se utilizan para crear valores de variables del tipo correspondiente.</li>
</ul>
<p>El ejemplo que se presenta a continuaci√≥n, crea animales y los imprime.</p>
<p>En el siguiente ejemplo, tambi√©n conviene observar que para poder usar <code>{:?}</code> al imprimir un tipo, este debe tener el rasgo de ser depurable, lo que se consigue mediante <code>#derive(Debug)</code> colocado al inicio del tipo de datos. A este tipo de etiquetado con <code>#</code> seguido de un nombre, se le denomina en Rust <em>atributo</em>. Se utilizan para indicar acciones al compilador. En este caso, para que se implemente de forma autom√°tica la posibilidad de depuraci√≥n al tipo de datos correspondiente. Existen muchos atributos diferentes que se pueden utilizar en un programa Rust, m√°s adelante se ver√°n otros. El m√°s com√∫n es <code>derive</code> y se encuentra muchas veces precediendo la definici√≥n de un <code>struct</code> o <code>enum</code>.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Animal {
    edad: u8,
    tipo_animal: TipoAnimal,
}

#[derive(Debug)]
enum TipoAnimal {
    Gato,
    Perro,
}

impl Animal {
    fn new() -&gt; Self {
        // Self, aqu√≠, significa Animal.
        // Tambi√©n se podr√≠a haber usado Animal
        // en lugar de Self

        Self {
            // Cuando se escriba Animal::new(), se obtendr√° siempre un gato de 10 a√±os
            edad: 10,
            tipo_animal: TipoAnimal::Gato,
        }
    }

    fn cambiar_a_perro(&amp;mut self) { // como est√° dentro de Animal, &amp;mut self significa &amp;mut Animal
                                  // usa .cambiar_a_perro() para convertir el cato en un perro
                                  // con &amp;mut self se puede modificar
        println!(&quot;¬°Cambiando el animal a perro!&quot;);
        self.tipo_animal = TipoAnimal::Perro;
    }

    fn cambiar_a_gato(&amp;mut self) {
        // usa .cambiar_a_gato() para cambiar el perro a gato
        // con &amp;mut self se puede modificar
        println!(&quot;¬°Cambiando el animal a gato!&quot;);
        self.tipo_animal = TipoAnimal::Gato;
    }

    fn comprobar_tipo(&amp;self) {
        // se lee a s√≠ mismo self
        match self.tipo_animal {
            TipoAnimal::Perro =&gt; println!(&quot;El animal es un perro&quot;),
            TipoAnimal::Gato =&gt; println!(&quot;El animal es un gato&quot;),
        }
    }
}



fn main() {
    let mut animal_nuevo = Animal::new(); // Funci√≥n asociada para crear una variable Animal
                                        // Es un gato de 10 a√±os
    animal_nuevo.comprobar_tipo();
    animal_nuevo.cambiar_a_perro();
    animal_nuevo.comprobar_tipo();
    animal_nuevo.cambiar_a_gato();
    animal_nuevo.comprobar_tipo();
}
</code></pre></pre>
<p>Esto imprime:</p>
<pre><code class="language-text">El animal es un gato
¬°Cambiando el animal a perro!
El animal es un perro
¬°Cambiando el animal a gato!
El animal es un gato
</code></pre>
<p>Se debe recordar que <code>Self</code> (el tipo Self) y <code>self</code> (la variable self) funcionan como abreviaturas del tipo que sea en cada momento.</p>
<p>En el c√≥digo anterior, <code>Self</code> es igual a <code>Animal</code>. Y en <code>fn cambiar_a_perro(&amp;mut self)</code> significa que el par√°metro primero es un <code>Animal</code>. Este par√°metro es la variable <code>animal_nuevo</code> cuando se llama de la siguiente forma <code>animal_nuevo.cambiar_a_perro()</code>.</p>
<p>A continuaci√≥n se muestra un ejemplo m√°s de <code>impl</code>. En este caso, con <code>enum</code>.</p>
<pre><pre class="playground"><code class="language-rust">enum Estado {
    Bueno,
    Malo,
    Somnoliento,
}

impl Estado {
    fn consultar(&amp;self) {
        match self {
            Estado::Bueno =&gt; println!(&quot;¬°Me siento bien!&quot;),
            Estado::Malo =&gt; println!(&quot;Eh, no me siento tan bien&quot;),
            Estado::Somnoliento =&gt; println!(&quot;Necesito dormir AHORA&quot;),
        }
    }
}

fn main() {
    let mi_estado = Estado::Somnoliento;
    mi_estado.consultar();
}
</code></pre></pre>
<p>This prints <code>Necesito dormir AHORA</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="desestructurar"><a class="header" href="#desestructurar">Desestructurar</a></h1>
<p>A continuaci√≥n se presentan algunos aspectos adicionales sobre c√≥mo desestructurar los valores de un <code>struct</code> o <code>enum</code>. Ya se vio que se pod√≠a realizar mediante <code>let</code> y el uso de variables que recuperan parte o todo el contenido de la estructura o enumerado. De esta forma, se tienen los valores de forma separada. Se puede observar en el siguiente ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">struct Persona { // crea una estructura simple para Persona
    nombre: String,
    real_nombre: String,
    altura: u8,
    felicidad: bool
}

fn main() {
    let papa_doc = Persona { // se crea la variable papa_doc
        nombre: &quot;Papa Doc&quot;.to_string(),
        real_nombre: &quot;Clarence&quot;.to_string(),
        altura: 170,
        felicidad: false
    };

    let Persona { // Se &quot;desestructura&quot; a  papa_doc
        nombre: a,
        real_nombre: b,
        altura: c,
        felicidad: d
    } = papa_doc;

    println!(&quot;Lo llaman {} pero su nombre real es {}. Es {} cm de alto y ¬øes feliz? {}&quot;, a, b, c, d);
}
</code></pre></pre>
<p>Que imprime: <code>Lo llaman Papa Doc pero su nombre real es Clarence. Es 170 cm de alto y ¬øes feliz? false</code></p>
<p>Primero se crea la estructura <code>let papa_doc = Persona { campos }</code>. Luego, de forma sim√©trica, se escribe <code>let Persona { campos } = papa_doc</code> para desestructurarla.</p>
<p>No es necesario escribir <code>nombre: a</code> - se puede escribir solo <code>nombre</code>. Pero aqu√≠ se escribe <code>nombre: a</code> porque se quiere usar este valor de forma independiente mediante la variable <code>a</code>.</p>
<p>A continuaci√≥n se presenta un ejemplo m√°s amplio.  En este ejemplo, se usa la estructura <code>Ciudad</code>. Se utiliza una funci√≥n asociada <code>new</code> para crear ciudades. Posteriormente, se utiliza la funci√≥n <code>procesar_valores_ciudad</code> para hacer cosas con sus valores. En la funci√≥n, se crea un <code>Vec</code>, pero se pueden imaginar muchas m√°s operaciones sobre estos datos despu√©s de desestructurarlos.</p>
<pre><pre class="playground"><code class="language-rust">struct Ciudad {
    nombre: String,
    nombre_antes: String,
    poblacion: u32,
    fecha_fundacion: u32,
}

impl Ciudad {
    fn new(nombre: String, nombre_antes: String, poblacion: u32, fecha_fundacion: u32) -&gt; Self {
        Self {
            nombre,
            nombre_antes,
            poblacion,
            fecha_fundacion,
        }
    }
}

fn procesar_valores_ciudad(ciudad: &amp;Ciudad) {
    let Ciudad {
        nombre,
        nombre_antes,
        ..
    } = ciudad;
        // se dispone de los valores separados
    let dos_nombres = vec![nombre, nombre_antes];
    println!(&quot;Los dos nombres de la ciudad son {:?}&quot;, dos_nombres);
}

fn main() {
    let tallinn = Ciudad::new(&quot;Tallinn&quot;.to_string(), &quot;Reval&quot;.to_string(), 426_538, 1219);
    procesar_valores_ciudad(&amp;tallinn);
}
</code></pre></pre>
<p>El c√≥digo anterior imprime <code>Los dos nombres de la ciudad son [&quot;Tallinn&quot;, &quot;Reval&quot;]</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="referencias-y-el-operador-punto-"><a class="header" href="#referencias-y-el-operador-punto-">Referencias y el operador punto .</a></h1>
<p>Se ha aprendido que cuyo se dispone de una referencia, se necesita utilizar el operador <code>*</code> para acceder al valor. Una referencia tiene su propio tipo, por lo que este c√≥digo no funcionar√°:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_numero = 9;
    let referencia = &amp;mi_numero;

    println!(&quot;{}&quot;, mi_numero == referencia); // ‚ö†Ô∏è
}
</code></pre></pre>
<p>El compilador imprime lo siguiente:</p>
<pre><code class="language-text">error[E0277]: can't comp¬øSon `{integer}` with `&amp;{integer}`
 --&gt; src\main.rs:5:30
  |
5 |     println!(&quot;{}&quot;, mi_numero == referencia);
  |                              ^^ no implementation for `{integer} == &amp;{integer}`
</code></pre>
<p>Es necesario cambiar la l√≠nea 5 a <code>println!(&quot;{}&quot;, mi_numero == *referencia);</code> para que funcione e imprima <code>true</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_numero = 9;
    let referencia = &amp;mi_numero;

    println!(&quot;{}&quot;, mi_numero == *referencia); // ahora funciona
</code></pre></pre>
<p>Esto se debe a que ahora ya se est√° comparyo <code>i32</code> == <code>i32</code> y no <code>i32</code>== <code>&amp;i32</code> como suced√≠a antes. A esto se le llama desreferenciar.</p>
<p>Sin embargo, cuyo se utiliza un m√©todo sobre una variable, Rust realiza la desreferenciaci√≥n de forma autom√°tica. En concreto, el operador <code>.</code> (punto) es quien est√° definido en Rust de forma que realiza la desreferenciaci√≥n cuyo se utiliza sobre una variable de tipo referencia. Adem√°s, esto se realiza tantas veces como sea necesario hasta llegar al valor concreto.</p>
<p>A continuaci√≥n, se crea un <code>struct</code> con un campo byte sin signo <code>u8</code>. Despu√©s, se crea una referencia y se intenta comparar, lo que no funcionar√°:</p>
<pre><pre class="playground"><code class="language-rust">struct Item {
    numero: u8,
}

fn main() {
    let item = Item {
        numero: 8,
    };

    let referencia_numero = &amp;item.numero; // el tipo de referencia_numero es &amp;u8

    println!(&quot;{}&quot;, referencia_numero == 8); // ‚ö†Ô∏è &amp;u8 y u8 no se pueden comparar entre s√≠
}
</code></pre></pre>
<p>Para que funcione, es necesario desreferenciarlo. Por ejemplo, cambiyo <code>println!(&quot;{}&quot;, *referencia_numero == 8)</code>:</p>
<pre><pre class="playground"><code class="language-rust">struct Item {
    numero: u8,
}

fn main() {
    let item = Item {
        numero: 8,
    };

    let referencia_numero = &amp;item.numero; // el tipo de referencia_numero es &amp;u8

    println!(&quot;{}&quot;, *referencia_numero == 8); // as√≠ s√≠ funciona
}
</code></pre></pre>
<p>Pero no es necesario hacerlo de forma anterior. Con el operador punto, se desreferencia de forma autom√°tica;</p>
<pre><pre class="playground"><code class="language-rust">struct Item {
    numero: u8,
}

fn main() {
    let item = Item {
        numero: 8,
    };

    let referencia_item = &amp;item; // el tipo de referencia_item es &amp;Item

    println!(&quot;{}&quot;, referencia_item.numero == 8); // as√≠ s√≠ funciona
}
</code></pre></pre>
<p>De forma autom√°tica, mediante el operador <code>.</code>, se ha realizado una desreferenciaci√≥n que de otro modo habr√≠a que haber escrito as√≠ <code>(*referencia_item).numero</code>.</p>
<p>A continuaci√≥n, se crea un m√©todo para la estructura <code>Item</code> que compara el <code>numero</code> con otro. Como se ve, no se necesita usar <code>*</code> en ning√∫n lugar:</p>
<pre><pre class="playground"><code class="language-rust">struct Item {
    numero: u8,
}

impl Item {
    fn compara_numero(&amp;self, otro_numero: u8) { // tiene una referencia a self
        println!(&quot;¬øSon {} y {} iguales? {}&quot;, self.numero, otro_numero, self.numero == otro_numero);
            // No se necesita escribir (*self).numero
    }
}

fn main() {
    let item = Item {
        numero: 8,
    };

    let item_referencia = &amp;item; // De tipo &amp;Item
    let item_referencia_dos = &amp;item_referencia; // De tipo &amp;&amp;Item

    item.compara_numero(8); // El m√©todo funciona
    item_referencia.compara_numero(8); // Este m√©todo tambi√©n funciona
    item_referencia_dos.compara_numero(8); // y este
}
</code></pre></pre>
<p>Se concluye as√≠ que cuando se usa el operador <code>.</code>, no se necesita utilizar el operador <code>*</code> para desreferenciar.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gen√©ricos"><a class="header" href="#gen√©ricos">Gen√©ricos</a></h1>
<p>En las funciones es necesario definir el tipo de cada par√°metro de entrada:</p>
<pre><pre class="playground"><code class="language-rust">fn devuelve_numero(numero: i32) -&gt; i32 {
    println!(&quot;Ah√≠ va tu numero.&quot;);
    numero
}

fn main() {
    let numero = devuelve_numero(5);
}
</code></pre></pre>
<p>Pero si lo que se necesita es una funci√≥n que haga lo mismo para cualquier tipo de datos diferente de <code>i32</code>, se pueden usar gen√©ricos. Un tipo gen√©rico sirve para indicar que algo puede ser de diferente tipo.</p>
<p>Tambi√©n se puede decir que la funci√≥n tiene un <em>par√°metro de tipo</em>.</p>
<p>Los par√°metros de tipo gen√©rico se definen con los s√≠mbolos de menor y mayo que encierran el nombre que representa al par√°metro de tipo. Normalmente se utiliza un car√°cter en may√∫scula para representarlos (T, U, V, etc.), aunque no es obligatorio utilizar solo una letra.</p>
<p>La funci√≥n anterior se puede convertir en gen√©rica as√≠:</p>
<pre><pre class="playground"><code class="language-rust">fn devuelve_numero&lt;T&gt;(numero: T) -&gt; T {
    println!(&quot;Ah√≠ va tu numero.&quot;);
    numero
}

fn main() {
    let numero = devuelve_numero(5);
    let numero_decimal = devuelve_numero(5.4);
}
</code></pre></pre>
<p>Se observa que el par√°metro de tipo gen√©rico <code>&lt;T&gt;</code> va despu√©s del nombre de la funci√≥n. Puede resultar m√°s sencillo de comprender si se sustituye la <code>T</code> por un nombre m√°s descriptivo como <code>MiTipo</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn devuelve_numero&lt;MiTipo&gt;(numero: MiTipo) -&gt; MiTipo {
    println!(&quot;Ah√≠ va tu numero.&quot;);
    numero
}

fn main() {
    let numero = devuelve_numero(5);
    let numero_decimal = devuelve_numero(5.4);
}
</code></pre></pre>
<p>As√≠ que la parte de despu√©s del nombre de la funci√≥n es lo que hace que la funci√≥n tenga un par√°metro de tipo gen√©rico que el compilador &quot;sustituye&quot; por el tipo concreto generyo un funci√≥n diferente para cada tipo que se use en el c√≥digo.</p>
<p>Adem√°s, como se ha visto, en Rust existen algunos tipos que implementan determinados rasgos, como son <strong>Copy</strong>, <strong>Clone</strong>, <strong>Display</strong>, <strong>Debug</strong> y otros. Si un tipo es <strong>Debug</strong>, puede usar <code>{:?}</code> para imprimirlo. Esto genera un posible problema si en la funci√≥n gen√©rica se quisiera imprimir:</p>
<pre><pre class="playground"><code class="language-rust">fn imprime_numero&lt;T&gt;(numero: T) {
    println!(&quot;Aqu√≠ est√° tu numero: {:?}&quot;, numero); // ‚ö†Ô∏è
}

fn main() {
    imprime_numero(5);
}
</code></pre></pre>
<p><code>imprime_numero</code> necesita que el par√°metro de tipo gen√©rico implemente <strong>Debug</strong> para poder utilizar <code>{:?}</code>. Con la definici√≥n actual de la funci√≥n, no es posible conocer si realmente <code>T</code> implementa o no <strong>Debug</strong>. Por lo tanto, el compilador emite error:</p>
<pre><code class="language-text">error[E0277]: `T` doesn't implement `Debug`
 --&gt; src/main.rs:2:43
  |
2 |     println!(&quot;Aqu√≠ est√° tu numero: {:?}&quot;, numero); // ‚ö†Ô∏è
  |                                           ^^^^^^ `T` cannot be formatted using `{:?}` because it doesn't implement `Debug`
</code></pre>
<p>La soluci√≥n es que se le indique a Rust que esta funci√≥n gen√©rica solo puede utilizar par√°metros de tipo gen√©rico que implementen <strong>Debug</strong>:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Debug;
// Debug se encuentra en el m√≥dulo std::fmt.
// Ahora es posible usar solo Debug.

fn imprime_numero&lt;T: Debug&gt;(numero: T) { // Esto es lo importante &lt;T: Debug&gt;
    println!(&quot;Aqu√≠ est√° tu numero: {:?}&quot;, numero);
}

fn main() {
    imprime_numero(5);
    imprime_numero(5.4);
}
</code></pre></pre>
<p>Ahora el compilador conoce que los tipos que van a usar esta funci√≥n tienen definido <strong>Debug</strong>. Como tanto <code>i32</code>, como <code>f64</code> tienen <code>Debug</code> definido, el c√≥digo funciona.</p>
<p>Si se amplia el ejemplo, creyo una estructura que implemente <strong>Debug</strong> mediante <code>#[derive(Debug)]</code>, se observa que la funci√≥n tambi√©n es v√°lida:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Debug;

#[derive(Debug)]
struct Animal {
    nombre: String,
    edad: u8,
}

fn imprime_elemento&lt;T: Debug&gt;(item: T) {
    println!(&quot;Aqu√≠ est√° tu elemento: {:?}&quot;, item);
}

fn main() {
    let charlie = Animal {
        nombre: &quot;Charlie&quot;.to_string(),
        edad: 1,
    };

    let numero = 55;

    imprime_elemento(charlie);
    imprime_elemento(numero);
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">Aqu√≠ est√° tu elemento: Animal { nombre: &quot;Charlie&quot;, edad: 1 }
Aqu√≠ est√° tu elemento: 55
</code></pre>
<p>En ocasiones se necesita m√°s de un tipo gen√©rico para definir una funci√≥n gen√©rica. Para ello, se puede escribir cada tipo y pensar c√≥mo se utiliza cada uno de ellos. En el siguiente ejemplo, se muestran dos tipos gen√©ricos. Se desea imprimir un texto con el tipo <code>T</code> con <code>{}</code>, por lo que este tipo deber√° implementar <code>Display</code>.</p>
<p>El segundo tipo es <code>U</code> y las dos variables <code>num_1</code> y <code>num_2</code> son de este tipo (<code>U</code> es alg√∫n tipo de n√∫mero). Se trata de compararlas entre ellas, por lo que estos tipos deben implementar el rasgo <code>PartialOrd</code>, que es el que permite que los elementos de un tipo puedan usar <code>&lt;</code>, <code>&gt;</code> y <code>==</code>, entre otros. Tambi√©n se quiere imprimir los n√∫meros, por lo que el tipo <code>U</code> requiere <code>Display</code>.</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;
use std::cmp::PartialOrd;

fn compara_e_imprime&lt;T: Display, U: Display + PartialOrd&gt;(texto: T, num_1: U, num_2: U) {
    println!(&quot;{} ¬øEs {} mayor que {}? {}&quot;, texto, num_1, num_2, num_1 &gt; num_2);
}

fn main() {
    compara_e_imprime(&quot;¬°¬°Escucha!!&quot;, 9, 8);
}
</code></pre></pre>
<p>El resultado es <code>¬°¬°Escucha!! ¬øEs 9 mayor que 8? true</code>.</p>
<p>La declaraci√≥n de la funci√≥n <code>fn compara_e_imprime&lt;T: Display, U: Display + PartialOrd&gt;(texto: T, num_1: U, num_2: U)</code> significa:</p>
<ul>
<li>El nombre de la funci√≥n es <code>compara_e_imprime</code>.</li>
<li>El primer tipo es T y es gen√©rico. Y debe poder usar <code>{}</code> para imprimir.</li>
<li>El segundo tipo es U y es gen√©rico. Debe ser un tipo que pueda usar <code>{}</code> y tambi√©n se tienen que poder comparar sus elementos con <code>&lt;</code>, <code>&gt;</code> y <code>==</code>.</li>
</ul>
<p>De este modo, se pueden pasar par√°metros de distintos tipos a la funci√≥n <code>compara_e_imprime</code>. Por ejemplo, el par√°metro <code>texto</code> puede ser <code>String</code>, <code>&amp;str</code>, <code>i32</code> o cualquier otro que se pueda imprimir.</p>
<p>Para que las funciones gen√©ricas sean m√°s f√°cil de leer, tambi√©n existe la siguiente sintaxis equivalente al c√≥digo anterior. Se utiliza <code>where</code> para simplificar la declaraci√≥n de la funci√≥n.</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;
use std::cmp::PartialOrd;

fn compara_e_imprime&lt;T, U&gt;(texto: T, num_1: U, num_2: U)
where
    T: Display,
    U: Display + PartialOrd,
{
    println!(&quot;{} ¬øEs {} mayor que {}? {}&quot;, texto, num_1, num_2, num_1 &gt; num_2);
}

fn main() {
    compara_e_imprime(&quot;¬°¬°Escucha!!&quot;, 9, 8);
}
</code></pre></pre>
<p>Cuyo se tienen muchos tipos gen√©ricos con rasgos concretos de implementaci√≥n, resulta m√°s legible esta sintaxis con <code>where</code>.</p>
<p>Hay que destacar tambi√©n que:</p>
<ul>
<li>Si se tiene un par√°metro de tipo T y otro par√°metro de tipo T, ambos tienen que ser del mismo tipo.</li>
<li>Si se tiene un par√°metro de tipo T y otro par√°metro de tipo U, pueden ser de diferente tipo, pero tambi√©n pueden ser del mismo tipo.</li>
</ul>
<p>Por ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

fn diga_dos&lt;T: Display, U: Display&gt;(statement_1: T, statement_2: U) {
// El tipo T necesita Display, el tipo U necesita Display
    println!(&quot;Tengo dos cosas que decir: {} y {}&quot;, statement_1, statement_2);
}

fn main() {

    diga_dos(&quot;¬°Hola!&quot;, String::from(&quot;Odio la arena.&quot;)); // Tipo T es &amp;str, pero el tipo U es String.
    diga_dos(String::from(&quot;¬øD√≥nde est√° Padme?&quot;), String::from(&quot;¬øEst√° bien?&quot;)); // Ambos tipos son String.
}
</code></pre></pre>
<p>Esto imprime:</p>
<pre><code class="language-text">Tengo dos cosas que decir: ¬°Hola! y Odio la arena.
Tengo dos cosas que decir: ¬øD√≥nde est√° Padme? y ¬øEst√° bien?
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="los-enumerados-option-y-result"><a class="header" href="#los-enumerados-option-y-result">Los enumerados Option y Result</a></h1>
<p>Ahora que se conocen los enumerados (enum) y los gen√©ricos, se pueden comprender dos enumerados fundamentales en Rust que permiten hacer que el c√≥digo sea m√°s seguro: <code>Option</code> y <code>Result</code>.</p>
<p>En primer lugar se trata <code>Option</code>.</p>
<h2 id="option"><a class="header" href="#option">Option</a></h2>
<p>Tiene dos posibilidades: <code>Some(valor)</code> y <code>None</code> y se utiliza cuando se da el caso de que un valor pueda existir o no.</p>
<p>Cuando el valor existe, se usa <code>Some(valor)</code>. Cuando no existe es <code>None</code>.</p>
<p>El c√≥digo siguiente, sin <code>Option</code>, da error (panic).</p>
<pre><pre class="playground"><code class="language-rust">    // ‚ö†Ô∏è
fn toma_el_quinto(valor: Vec&lt;i32&gt;) -&gt; i32 {
    valor[4]
}

fn main() {
    let new_vec = vec![1, 2];
    let index = toma_el_quinto(new_vec);
}
</code></pre></pre>
<p>Muestra el siguiente mensaje de error:</p>
<pre><code class="language-text">thread 'main' panicked at 'index out of bounds: the len is 2 but the index is 4', src\main.rs:34:5
</code></pre>
<p>Que el programa &quot;entre en p√°nico&quot; (panicked) significa que se detiene de forma controlada antes de que suceda el error. Rust comprueba que la funci√≥n quiere obtener un valor imposible y se detiene antes del error. Recorre la pila de llamadas de funci√≥n para tratar de encontrar un lugar en que se contemple el error y si no lo encuentra, como es el caso, se detiene y viene a decir &quot;lo siento, no puedo obtener el quinto valor de este vector&quot;.</p>
<p>Para evitar este error, se modificar√° el tipo que devuelve la funci√≥n de <code>i32</code> a <code>Option&lt;i32&gt;</code>. Que significa que a partir de ahora esta funci√≥n puede devolver <code>Some(i32)</code> si existe el √≠ndice, o <code>None</code> cuando no existe. En este caso, el valor de retorno cuando existe, <code>i32</code>, estar√° &quot;envuelto&quot; en un tipo <code>Option</code>, es decir: la funci√≥n lo devuelve dentro de un <code>Option</code>, en concreto <code>Some(i32)</code>. Por lo tanto, al terminar la funci√≥n, hace falta alg√∫n tipo de c√≥digo para que el valor embebido en <code>Some</code> se pueda usar.</p>
<pre><pre class="playground"><code class="language-rust">fn toma_el_quinto(valor: Vec&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    if valor.len() &lt; 5 { // .len() devuelve la longitud del vector (el n√∫mero de elementos).
                         // Deber√≠a ser al menos 5 si se quiere recuperar el dato en esa posici√≥n.
        None            // cuando no lo es, devuelve None
    } else {
        Some(valor[4])
    }
}

fn main() {
    let new_vec = vec![1, 2];
    let bigger_vec = vec![1, 2, 3, 4, 5];
    println!(&quot;{:?}, {:?}&quot;, toma_el_quinto(new_vec), toma_el_quinto(bigger_vec));
}
</code></pre></pre>
<p>El c√≥digo anterior imprime <code>None, Some(5)</code>. Ya no falla &quot;en p√°nico&quot;. Pero, ¬øc√≥mo se recupera ahora el valor 5?.</p>
<p>Para obtenerlo, se puede usar alguna de las funciones que tiene el tipo <code>Option</code>. La funci√≥n <code>unwrap()</code> recupera el valor contenido en el <code>Some</code>, pero tambi√©n entra en p√°nico si contiene un <code>None</code>. Es decir, que solo se debe usar cuando se sabe que el valor retornado es un <code>Some(valor)</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn toma_el_quinto(valor: Vec&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    if valor.len() &lt; 5 { 
        None            
    } else {
        Some(valor[4])
    }
}

fn main() {
    let new_vec = vec![1, 2];
    let bigger_vec = vec![1, 2, 3, 4, 5];
    println!(&quot;{:?}, {:?}&quot;, 
        toma_el_quinto(new_vec).unwrap(), // esta fila falla ya que contiene None.
        toma_el_quinto(bigger_vec).unwrap());
}
</code></pre></pre>
<p>El mensaje que devuelve el c√≥digo anterior es:</p>
<pre><code class="language-text">thread 'main' panicked at 'called `Option::unwrap()` on a `None` valor', src/main.rs:13:33
</code></pre>
<p>La forma correcta de recuperar el valor de un <code>Option</code>, contemplando previamente ambas posibilidades es utilizar <code>match</code>. De este forma, se puede decidir qu√© acci√≥n realizar, imprimir o no el valor, en funci√≥n del resultado. Por ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">fn toma_el_quinto(valor: Vec&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    if valor.len() &lt; 5 {
        None
    } else {
        Some(valor[4])
    }
}

fn manejar_opcion(mi_opcion: Vec&lt;Option&lt;i32&gt;&gt;) {
  for item in mi_opcion {
    match item {
      Some(numero) =&gt; println!(&quot;¬°Encontr√© un {}!&quot;, numero),
      None =&gt; println!(&quot;¬°Encontr√© un None!&quot;),
    }
  }
}

fn main() {
    let new_vec = vec![1, 2];
    let bigger_vec = vec![1, 2, 3, 4, 5];
    let mut option_vec = Vec::new(); // se crea un vector para guardar los valores option
                                     // El vector es de tipo: Vec&lt;Option&lt;i32&gt;&gt;. Es decir, un vector de Option&lt;i32&gt;.

    option_vec.push(toma_el_quinto(new_vec)); // guarda &quot;None&quot; en el vec
    option_vec.push(toma_el_quinto(bigger_vec)); // guarda &quot;Some(5)&quot; en el vec

    manejar_opcion(option_vec); // revisa el vector y realiza la acci√≥n que corresponda
                               // Imprime el valor si es un Some. Y no lo toca, y lo indica, si es un None.
}
</code></pre></pre>
<p>Da como resultado:</p>
<pre><code class="language-text">¬°Encontr√© un None!
¬°Encontr√© un 5!
</code></pre>
<p><code>Option</code> utiliza gen√©ricos en su definici√≥n, para poder definir el contenido de <code>Some</code> en cada caso:</p>
<pre><pre class="playground"><code class="language-rust">enum Option&lt;T&gt; {
    None,
    Some(T),
}

fn main() {}
</code></pre></pre>
<p>El punto importante a recordar es que con <code>Some</code> se incluye un valor de tipo <code>T</code> (cualquier tipo). Se observa que los s√≠mbolos de <code>&lt;</code> y <code>&gt;</code> despu√©s del nombre del enumerado <code>Option</code> contienen el par√°metro de tipo, que es lo que le indica al compilador que este enumerado es gen√©rico. En este caso, el enumerado puede ser uno de los dos structs: <code>None</code> o <code>Some(T)</code>. Adem√°s, se observa que <code>T</code> no tiene ning√∫n trait (rasgo) obligatorio como <code>Display</code> u otro que limite los posibles tipos de datos que se puedan incluir dentro de <code>Some</code>. Adem√°s, en el caso de <code>None</code>, ni siquiera existe un tipo de datos (ni siquiera se usa el par√°metro de tipo <code>T</code>).</p>
<p>Por esto √∫ltimo, no se puede usar lo siguiente en la sentencia <code>match</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
Some(valor) =&gt; println!(&quot;El valor es {}&quot;, valor),
None(valor) =&gt; println!(&quot;El valor es {}&quot;, valor),
<span class="boring">}
</span></code></pre></pre>
<p><code>None</code> solo es <code>None</code>...</p>
<p>Hay formas m√°s f√°ciles de usar <code>Option</code>. En el c√≥digo siguiente, se usa el m√©todo <code>.is_some()</code> para preguntar si el tipo del <code>Option</code> es <code>Some</code> (tambi√©n hay otro m√©todo complementario denominado <code>.is_none()</code>).</p>
<pre><pre class="playground"><code class="language-rust">fn toma_el_quinto(valor: Vec&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    if valor.len() &lt; 5 {
        None
    } else {
        Some(valor[4])
    }
}

fn main() {
    let new_vec = vec![1, 2];
    let bigger_vec = vec![1, 2, 3, 4, 5];
    let vec_of_vecs = vec![new_vec, bigger_vec];
    for vec in vec_of_vecs {
        let numero_interno = toma_el_quinto(vec);
        if numero_interno.is_some() {
            // .is_some() devuelve true si es Some, false si es None
            println!(&quot;Tenemos: {}&quot;, numero_interno.unwrap()); // ahora es seguro usar .unwrap() ya que es seguro que es Some
        } else {
            println!(&quot;No tenemos nada.&quot;);
        }
    }
}
</code></pre></pre>
<p>Esto imprime:</p>
<pre><code class="language-text">No tenemos nada.
Tenemos: 5
</code></pre>
<h2 id="result"><a class="header" href="#result">Result</a></h2>
<p>Es similar a <code>Option</code>, pero su uso es diferente:</p>
<ul>
<li><code>Option</code> trata sobre <code>Some</code> o <code>None</code>. La existencia o no de un valor.</li>
<li><code>Result</code> trata sobre <code>Ok</code> o <code>Error</code>. La existencia de un resultado correcto o no (la existencia de un error).</li>
</ul>
<p>Por eso, se debe usar <code>Option</code> cuando el razonamiento es &quot;puede que haya un valor o puede que no&quot;. Pero se debe usar <code>Result</code> cuando el razonamiento es &quot;puede que esto falle&quot;.</p>
<p>Si se comparan las definiciones de ambos enumerados:</p>
<pre><pre class="playground"><code class="language-rust">enum Option&lt;T&gt; {
    None,
    Some(T),
}

enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}

fn main() {}
</code></pre></pre>
<p>Se observa que <code>Result</code> tiene un valor dentro de <code>Ok</code> y tambi√©n el caso de <code>Err</code>. Se trata de poder gestionar la informaci√≥n espec√≠fica que describe el error que haya sucedido cuando este se produzca.</p>
<p>Al tener dos par√°metros de tipo, <code>Result&lt;T, E&gt;</code>, se debe indicar qu√© se devuelve cuando el resultado es correcto, <code>Ok(T)</code>, y qu√© se devuelve cuando el resultado es err√≥neo, <code>Err(E)</code>. Puede ser cualquier cosa que se decida, incluso:</p>
<pre><pre class="playground"><code class="language-rust">fn check_error() -&gt; Result&lt;(), ()&gt; {
    Ok(())
}

fn main() {
    check_error();
}
</code></pre></pre>
<p><code>check_error</code> indica que se devuelva <code>()</code>, tanto en el caso de <code>Ok</code>, como en el caso de <code>Err</code>. Aunque en el ejemplo, siempre devuelve <code>Ok(())</code>.</p>
<p>En todo caso, con este c√≥digo, el compilador da un aviso interesante:</p>
<pre><code class="language-text">warning: unused `std::result::Result` that must be used
 --&gt; src\main.rs:6:5
  |
6 |     check_error();
  |     ^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: this `Result` may be an `Err` variant, which should be handled
</code></pre>
<p>El compilador avisa de que se prev√© que devuelva <code>Result</code>, por lo que el c√≥digo podr√≠a haber devuelto un <code>Err</code>, pero no se est√° tratando dicha posibilidad de error.</p>
<p>A continuaci√≥n se presenta un c√≥digo que trata el posible caso de error:</p>
<pre><pre class="playground"><code class="language-rust">fn dar_resultado(input: i32) -&gt; Result&lt;(), ()&gt; {
    if input % 2 == 0 {
        return Ok(())
    } else {
        return Err(())
    }
}

fn main() {
    if dar_resultado(5).is_ok() {
        println!(&quot;Es correcto&quot;)
    } else {
        println!(&quot;Es un error&quot;)
    }
}
</code></pre></pre>
<p>Este c√≥digo imprime <code>Es un error</code>. As√≠ se ha gestionado el error.</p>
<p>Se puede recordar que para <code>Option</code> y para <code>Result</code>, dos m√©todos, respectivamente, para chequear de forma sencilla el tipo concreto, son: <code>.is_some()</code>, <code>is_none()</code>, <code>is_ok()</code> y <code>is_err()</code>.</p>
<p>En ocasiones, una funci√≥n con <code>Result</code> usar√° <code>String</code> para el valor contenido en <code>Err</code>. Aunque no es la mejor forma, es mejor que lo visto hasta el momento:</p>
<pre><pre class="playground"><code class="language-rust">fn comprueba_si_es_cinco(numero: i32) -&gt; Result&lt;i32, String&gt; {
    match numero {
        5 =&gt; Ok(numero),
        _ =&gt; Err(&quot;Lo siento, el n√∫mero no era cinco.&quot;.to_string()), // Este es el mensaje de error
    }
}

fn main() {
    let mut result_vec = Vec::new(); // Crea un vector para contener el resultado

    for numero in 2..7 {
        result_vec.push(comprueba_si_es_cinco(numero)); // guarda cada resultado
    }

    println!(&quot;{:?}&quot;, result_vec);
}
</code></pre></pre>
<p>El vector imprime lo siguiente:</p>
<pre><code class="language-text">[Err(&quot;Lo siento, el numero no era cinco.&quot;), Err(&quot;Lo siento, el numero no era cinco.&quot;), Err(&quot;Lo siento, el numero no era cinco.&quot;), Ok(5),
Err(&quot;Lo siento, el numero no era cinco.&quot;)]
</code></pre>
<p>Igual que en el caso de <code>Option</code>, <code>.unwrap()</code> sobre un valor de tipo <code>Err</code> &quot;provoca el p√°nico&quot; del programa.</p>
<pre><pre class="playground"><code class="language-rust">    // ‚ö†Ô∏è
fn main() {
    let valor_error: Result&lt;i32, &amp;str&gt; = Err(&quot;Hubo un error&quot;); // Crea un Result que es un Err
    println!(&quot;{}&quot;, valor_error.unwrap()); // Intenta recuperar el valor del resultado (asumiendo que ser√≠a correcto, cosa que no es)
}
</code></pre></pre>
<p>El programa falla (panic) e imprime:</p>
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: &quot;Hubo un error&quot;', src/main.rs:4:32
</code></pre>
<p>Esta informaci√≥n, <code>src/main.rs:4:32</code> significa que el p√°nico se ha producido en &quot;main.rs en el directorio src, en la l√≠nea 4 y columna 32&quot;. Por lo que se puede mirar ah√≠ para ver cu√°l es el problema y resolverlo.</p>
<p>Tambi√©n se pueden crear nuevos tipos de error, que es lo habitual. Las funciones de la librer√≠a est√°ndar y otras librer√≠as lo suelen hacer. Por ejemplo, esta funci√≥n de la librer√≠a est√°ndar:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
pub fn from_utf8(vec: Vec&lt;u8&gt;) -&gt; Result&lt;String, FromUtf8Error&gt;
<span class="boring">}
</span></code></pre></pre>
<p>Esta funci√≥n toma un vector de bytes (<code>u8</code>) e intenta convertirlo en una <code>String</code>. Como puede ser que los bytes no se correspondan con c√≥digos v√°lidos en UTF8, en lugar de devolver un <code>String</code>, devuelve un <code>Result</code> con un <code>String</code> en el caso de √©xito y un error <code>FromUtf8Error</code> en el caso de que falle la conversi√≥n. Se puede usar cualquier nombre para el caso de fallo.</p>
<p>En ocasiones, el uso de <code>match</code> con <code>Option</code> y <code>Result</code> requiere mucho c√≥digo. Por ejemplo, el m√©todo <code>.get()</code> devuelve un <code>Option</code> sobre un <code>Vec</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![2, 3, 4];
    let get_one = my_vec.get(0); // recupera el primer n√∫mero
    let get_two = my_vec.get(10); // recupera None
    println!(&quot;{:?}&quot;, get_one);
    println!(&quot;{:?}&quot;, get_two);
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">Some(2)
None
</code></pre>
<p>Para obtener los valores, se puede usar <code>match</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![2, 3, 4];

    for index in 0..10 {
      match my_vec.get(index) {
        Some(number) =&gt; println!(&quot;El n√∫mero es: {}&quot;, number),
        None =&gt; {}
      }
    }
}
</code></pre></pre>
<p>Este c√≥digo es correcto, pero queremos hacer nada en el caso de <code>None</code>. En estos casos, se puede optar por escribir un c√≥digo m√°s compacto mediante el uso de <code>if let</code> que permite &quot;hacer algo si coincide un valor&quot; y &quot;no hacer nada en el resto de casos&quot;.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![2, 3, 4];

    for index in 0..10 {
      if let Some(number) = my_vec.get(index) {
        println!(&quot;The n√∫mero es: {}&quot;, number);
      }
    }
}
</code></pre></pre>
<p><strong>Importante, a recordar:</strong> <code>if let Some(number) = my_vec(index)</code> significa que &quot;compruebe si el valor de <code>my_vec(index)</code> es compatible con <code>Some(number)</code>.</p>
<p>Adem√°s, hay que tener en cuenta que se usa <code>=</code>.</p>
<p>Tambi√©n existe <code>while let</code> que es un bucle for en el que se comprueba como en <code>if let</code>. Por ejemplo, si se dispone de los siguientes datos del tiempo procedentes de estaciones meteorol√≥gicas:</p>
<pre><code class="language-text">[&quot;Berlin&quot;, &quot;cloudy&quot;, &quot;5&quot;, &quot;-7&quot;, &quot;78&quot;]
[&quot;Athens&quot;, &quot;sunny&quot;, &quot;not humid&quot;, &quot;20&quot;, &quot;10&quot;, &quot;50&quot;]
</code></pre>
<p>Y se desea obtener solo los n√∫meros. Para ello, se puede usar el m√©todo <code>parse::&lt;i32&gt;()</code>. Este m√©todo intenta convertir un <code>&amp;str</code> en un <code>i32</code> y lo entrega en un valor de tipo <code>Result</code>ya que podr√≠a no funcionar si se le pasa algo que no es un n√∫mero entero.</p>
<p>En el siguiente ejemplo, tambi√©n se usar√° <code>.pop()</code> para extraer el √∫ltimo elemento del vector.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let weather_vec = vec![
        vec![&quot;Berlin&quot;, &quot;cloudy&quot;, &quot;5&quot;, &quot;-7&quot;, &quot;78&quot;],
        vec![&quot;Athens&quot;, &quot;sunny&quot;, &quot;not humid&quot;, &quot;20&quot;, &quot;10&quot;, &quot;50&quot;],
    ];
    for mut city in weather_vec {
        println!(&quot;Para la ciudad de {}:&quot;, city[0]); // En los datos, el primer elemento siempre es el nombre de la ciudad
        while let Some(information) = city.pop() {
            // Esto significa: continua mientras hay valores
            // Cuando no queden valores pop retorna None
            // y se saldr√° del bucle while
            if let Ok(number) = information.parse::&lt;i32&gt;() {
                // Intenta obtener un entero
                // Devuelve un Result. Si es Ok(number), se imprimir√°
                println!(&quot;El n√∫mero es: {}&quot;, number);
            }  // No se hace nada, si no era un n√∫mero, casos en los que se devuelve Err
        }
    }
}
</code></pre></pre>
<p>Que imprimir√°:</p>
<pre><code class="language-text">Para la ciudad de Berlin:
El n√∫mero es: 78
El n√∫mero es: -7
El n√∫mero es: 5
Para la ciudad de Athens:
El n√∫mero es: 50
El n√∫mero es: 10
El n√∫mero es: 20
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="otras-colecciones"><a class="header" href="#otras-colecciones">Otras colecciones</a></h1>
<p>Rust tiene muchos tipos de colecci√≥n m√°s. Se pueden consultar en la librer√≠a est√°ndar: <a href="https://doc.rust-lang.org/beta/std/collections/">https://doc.rust-lang.org/beta/std/collections/</a>. Esta p√°gina dispone de buenas explicaciones en cuanto a cu√°ndo cada tipo, as√≠ que es el lugar en que consultar cuando no se tiene claro qu√© tipo usar. Todas estas colecciones se encuentran dentro de <code>std::collections</code> en la librer√≠a est√°ndar de Rust. La mejor forma de usarlas es mediante <code>use</code>, como se hizo con los enumerados. Se presenta primero <code>HashMap</code> por ser de uso com√∫n.</p>
<h2 id="hashmap-y-btreemap"><a class="header" href="#hashmap-y-btreemap">HashMap (y BTreeMap)</a></h2>
<p>Un HashMap es una colecci√≥n compuesta por <em>claves</em> y <em>valores</em>. Se puede usar la clave para recuperar el valor que se almacen√≥ con ella. Se puede crear un <code>HashMap</code> con <code>HashMap::new()</code> y se pueden insertar nuevos elementos mediante <code>.insert(clave, valor)</code>.</p>
<p>Los <code>HashMap</code> no est√°n ordenados, por lo que si se imprimen todas las claves almacenadas, probablemente saldr√°n en cualquier orden. Se puede ver con un ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap; // As√≠, bastar√° con escribir
// HashMap cada vez, en lugar de std::collections::HashMap

struct Ciudad {
    nombre: String,
    poblacion: HashMap&lt;u32, u32&gt;, // Almacenar√° el a√±o
    //y la poblaci√≥n de cada a√±o
}

fn main() {

    let mut tallinn = Ciudad {
        nombre: &quot;Tallinn&quot;.to_string(),
        poblacion: HashMap::new(), // En este momento el HashMap est√° vac√≠o
    };

    tallinn.poblacion.insert(1372, 3_250); // inserta tres fechas
    tallinn.poblacion.insert(1851, 24_000);
    tallinn.poblacion.insert(2020, 437_619);


    for (a√±o, poblacion) in tallinn.poblacion { // El tipo del Hashmap es HashMap&lt;u32, u32&gt;. Obtiene en cada iteraci√≥n un par clave/valor
        println!(&quot;En el a√±o {} la ciudad de {} ten√≠a una poblaci√≥n de {}.&quot;, a√±o, tallinn.nombre, poblacion);
    }
}
</code></pre></pre>
<p>Que puede imprimir:</p>
<pre><code class="language-text">En el a√±o 1372 la ciudad de Tallinn ten√≠a una poblaci√≥n de 3250.
En el a√±o 2020 la ciudad de Tallinn ten√≠a una poblaci√≥n de 437619.
En el a√±o 1851 la ciudad de Tallinn ten√≠a una poblaci√≥n de 24000.
</code></pre>
<p>Pero tambi√©n podr√≠a imprimir:</p>
<pre><code class="language-text">En el a√±o 1851 la ciudad de Tallinn ten√≠a una poblaci√≥n de 24000.
En el a√±o 2020 la ciudad de Tallinn ten√≠a una poblaci√≥n de 437619.
En el a√±o 1372 la ciudad de Tallinn ten√≠a una poblaci√≥n de 3250.
</code></pre>
<p>Se puede observar que no est√° en orden.</p>
<p>Si se necesita una colecci√≥n para almacenar parejas de clave y valor, se puede utilizar <code>BTreeMap</code>, que funciona igual que <code>HashMap</code>, pero mantiene el orden por clave.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::BTreeMap; // As√≠, bastar√° con cambiar HashMap a BTreeMap

struct Ciudad {
    nombre: String,
    poblacion: BTreeMap&lt;u32, u32&gt;, 
}

fn main() {

    let mut tallinn = Ciudad {
        nombre: &quot;Tallinn&quot;.to_string(),
        poblacion: BTreeMap::new(), 
    };

    tallinn.poblacion.insert(1372, 3_250); 
    tallinn.poblacion.insert(1851, 24_000);
    tallinn.poblacion.insert(2020, 437_619);


    for (a√±o, poblacion) in tallinn.poblacion {
        println!(&quot;En el a√±o {} la ciudad de {} ten√≠a una poblaci√≥n de {}.&quot;, a√±o, tallinn.nombre, poblacion);
    }
}
</code></pre></pre>
<p>Ahora, siempre se imprime:</p>
<pre><code class="language-text">En el a√±o 1372 la ciudad de Tallinn ten√≠a una poblaci√≥n de 3250.
En el a√±o 1851 la ciudad de Tallinn ten√≠a una poblaci√≥n de 24000.
En el a√±o 2020 la ciudad de Tallinn ten√≠a una poblaci√≥n de 437619.
</code></pre>
<p>Volviendo a los <code>HashMap</code>. Se puede recuperar un valor determinado simplemente escribiendo la clave entre <code>[]</code> corchetes. En el siguiente ejemplo se recuperar√° el valor de la clave <code>Bielefeld</code> que est√° en <code>Alemania</code>. La aplicaci√≥n fallar√° si no existe la clave. Si se escribe <code>println!((&quot;{:?}&quot;, ciudad_hashmap[&quot;Bielefeldd&quot;]);</code>, fallar√°, porque <code>Bielefeldd</code>no existe.</p>
<p>Si no se est√° seguro de que exista una clave determinada, se puede usar <code>get()</code> que devuelve un tipo <code>Option</code>. Si existe sera <code>Some(value)</code> y si no, contendr√° <code>None</code>, pero no fallar√° la aplicaci√≥n. Por eso, la forma adecuada de recuperar un valor de un <code>HashMap</code> es usar <code>get()</code>.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let ciudades_canadieneses = vec![&quot;Calgary&quot;, &quot;Vancouver&quot;, &quot;Gimli&quot;];
    let ciudades_alemanas = vec![&quot;Karlsruhe&quot;, &quot;Bad Doberan&quot;, &quot;Bielefeld&quot;];

    let mut ciudad_hashmap = HashMap::new();

    for ciudad in ciudades_canadieneses {
        ciudad_hashmap.insert(ciudad, &quot;Canad√°&quot;);
    }
    for ciudad in ciudades_alemanas {
        ciudad_hashmap.insert(ciudad, &quot;Alemania&quot;);
    }

    println!(&quot;{:?}&quot;, ciudad_hashmap[&quot;Bielefeld&quot;]);
    println!(&quot;{:?}&quot;, ciudad_hashmap.get(&quot;Bielefeld&quot;));
    println!(&quot;{:?}&quot;, ciudad_hashmap.get(&quot;Bielefeldd&quot;));
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">&quot;Alemania&quot;
Some(&quot;Alemania&quot;)
None
</code></pre>
<p>Esto sucede porque <em>Bielefeld</em> existe, pero <em>Bielefeldd</em> no.</p>
<p>Si un <code>HashMap</code>ya contiene una clave y se intenta insertar un nuevo valor, el antiguo se sobreescribe.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut book_hashmap = HashMap::new();

    book_hashmap.insert(1, &quot;L'Allemagne Moderne&quot;);
    book_hashmap.insert(1, &quot;Le Petit Prince&quot;);
    book_hashmap.insert(1, &quot;ÏÑÄÎèÑÏö∞ Ïò§Î∏å Ïú†Ïñ¥ Ïä§ÎßàÏùº&quot;);
    book_hashmap.insert(1, &quot;Eye of the World&quot;);

    println!(&quot;{:?}&quot;, book_hashmap.get(&amp;1));
}
</code></pre></pre>
<p>Que imprime <code>Some(&quot;Eye of the World&quot;)</code>, porque fue el √∫ltimo valor utilizado en al insertar con <code>.insert()</code>.</p>
<p>Es f√°cil comprobar si un valor existe cotejando el enumerado <code>Option</code> que devuelve <code>.get()</code>.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut book_hashmap = HashMap::new();

    book_hashmap.insert(1, &quot;L'Allemagne Moderne&quot;);

    if book_hashmap.get(&amp;1).is_none() { // is_none() devuelve un bool: true si es None, false si es Some
        book_hashmap.insert(1, &quot;Le Petit Prince&quot;);
    }

    println!(&quot;{:?}&quot;, book_hashmap.get(&amp;1));
}
</code></pre></pre>
<p>Que imprime <code>Some(&quot;L\'Allemagne Moderne&quot;)</code> porque exist√≠a ya una clave <code>1</code>, por lo que no se lleg√≥ a insertar <code>Le Petit Prince</code>.</p>
<p><code>HashMap</code> tiene un m√©todo muy interesante denominado <code>.entry()</code> que se puede utilizar. Con el resultado de este m√©todo (que devuelve un valor de tipo enumerado <code>Entry</code>) se puede utilizar el m√©todo <code>.or_entry()</code> para insertar un valor solo si no existe una clave. La parte interesante es que devuelve una referencia modificable por polo que se puede modificar si se quiere. En el siguiente ejemplo e inserta <code>true</code> cada vez que se inserta un libro en el <code>HashMap</code>.</p>
<p>Se quiere llevar el seguimiento de los libros de un biblioteca.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let book_collection = vec![&quot;L'Allemagne Moderne&quot;, &quot;Le Petit Prince&quot;, &quot;Eye of the World&quot;, &quot;Eye of the World&quot;]; // Eye of the World aparece dos veces

    let mut book_hashmap = HashMap::new();

    for book in book_collection {
        book_hashmap.entry(book).or_insert(true);
    }
    for (book, true_or_false) in book_hashmap {
        println!(&quot;¬øTenemos el libro {}? {}&quot;, book, true_or_false);
    }
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">¬øTenemos el libro Eye of the World? true
¬øTenemos el libro Le Petit Prince? true
¬øTenemos el libro L'Allemagne Moderne? true
</code></pre>
<p>Pero esto no es exactamente lo que se quiere. Ser√≠a mejor contar el n√∫mero de copias de cada libro para que se pueda conocer que existen dos copias de <em>Eye of the world</em>.</p>
<p>En primer lugar, se va a estudiar lo que hace el m√©todo <code>.entry()</code> y el m√©todo <code>.or_insert()</code>. <code>.entry()</code> devuelve un <code>enum</code> llamado <code>Entry</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn entry(&amp;mut self, key: K) -&gt; Entry&lt;K, V&gt; // üöß
<span class="boring">}
</span></code></pre></pre>
<p><a href="https://doc.rust-lang.org/std/collections/hash_map/enum.Entry.html">Esta es la p√°gina de Entry</a>. Esa es una versi√≥n simplificada de su c√≥digo. <code>K</code> representa el tipo de la clave y <code>V</code> representa el tipo del valor.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
use std::collections::hash_map::*;

enum Entry&lt;K, V&gt; {
    Occupied(OccupiedEntry&lt;K, V&gt;),
    Vacant(VacantEntry&lt;K, V&gt;),
}
<span class="boring">}
</span></code></pre></pre>
<p>Cuando se llama a <code>.or_insert()</code> se observa el tipo concreto del enumerado y se decide qu√© hacer:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn or_insert(self, default: V) -&gt; &amp;mut V { // üöß
    match self {
        Occupied(entry) =&gt; entry.into_mut(),
        Vacant(entry) =&gt; entry.insert(default),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Lo m√°s interesante es que se devuelve una referencia modificable: <code>&amp;mut V</code>. Esto significa que se puede usar <code>let</code> para asignarla a una variable y cambiar la variable para cambiar el valor del <code>HashMap</code>. As√≠, para cada libro se insertar√° un 0 si no hay una entrada. Si hay una, se utilizar√° <code>+=1</code> en la referencia para incrementar la cuenta. El c√≥digo queda as√≠:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let book_collection = vec![&quot;L'Allemagne Moderne&quot;, &quot;Le Petit Prince&quot;, &quot;Eye of the World&quot;, &quot;Eye of the World&quot;];

    let mut book_hashmap = HashMap::new();

    for book in book_collection {
        let return_value = book_hashmap.entry(book).or_insert(0); // return_value es una referencia mutable.
        // Si no contiene nada, se asigna un cero.
        *return_value +=1; // Ahora return_value vale al menos 1.
        // Y si ya ten√≠a alg√∫n valor, lo incrementa en uno
    }

    for (book, numero) in book_hashmap {
        println!(&quot;{}, {}&quot;, book, numero);
    }
}
</code></pre></pre>
<p>Lo important es <code>let return_value = book_hashmap.entry(book).or_insert(0);</code>. Si no se asignara el valor a una variable, se asignar√≠a el 0 cuando no hubiera valor, pero se perder√≠a la referencia modificable. Al conservarla en la variable <code>return_value</code>, se puede modificar el valor sum√°ndole 1 en este caso. Cuando esto sucede por segunda vez para un mismo valor, no se crea ninguna entrada nueva con un valor 0, sino que simplemente se devuelve el valor para que se pueda incrementar. As√≠ el resultado de este programa es:</p>
<pre><code class="language-text">L'Allemagne Moderne, 1
Le Petit Prince, 1
Eye of the World, 2
</code></pre>
<p>Tambi√©n se pueden hacer otras cosas con <code>.or_insert()</code> como insertar un vector y luego insertar en el vector. Por ejemplo, si se supone que se pregunta a hombres y mujeres qu√© opinan de un pol√≠tico para que les asignen una valoraci√≥n de 0 a 10, se pueden clasificar juntos los puntos para saber si un pol√≠tico es m√°s popular entre los hombres o entre las mujeres, el c√≥digo podr√≠a ser as√≠:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let data = vec![ // Estos son los datos puros
        (&quot;hombre&quot;, 9),
        (&quot;mujer&quot;, 5),
        (&quot;hombre&quot;, 0),
        (&quot;mujer&quot;, 6),
        (&quot;mujer&quot;, 5),
        (&quot;hombre&quot;, 10),
    ];

    let mut survey_hash = HashMap::new();

    for item in data { // Devuelve una tupla de (&amp;str, i32)
        survey_hash.entry(item.0)
            .or_insert(Vec::new())
            .push(item.1); // A√±ade el n√∫mero al vector contenido en el valor correspondiente del HashMap
    }

    for (hombre_or_mujer, numeros) in survey_hash {
        println!(&quot;{:?}: {:?}&quot;, hombre_or_mujer, numeros);
    }
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">&quot;mujer&quot;, [5, 6, 5]
&quot;hombre&quot;, [9, 0, 10]
</code></pre>
<p>La l√≠nea de c√≥digo importante es <code>survey_hash.entry(item.0).or_insert(Vec::new()).push(item.1);</code> que si recibe una &quot;mujer&quot; comprobar√° si ya existe en el <code>HashMap</code>. Si no existe, insertar√° <code>Vec::new()</code> y despu√©s insertar√° el n√∫mero en el vector. Si existe, no insertar√° ning√∫n vector nuevo, lo recuperar√° e insertar√° el n√∫mero en el vector.</p>
<h2 id="hashset-y-btreeset"><a class="header" href="#hashset-y-btreeset">HashSet y BTreeSet</a></h2>
<p>Un <code>HashSet</code> es un <code>HashMap</code> que solo tiene claves. En <a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html">la p√°gina para HashSet</a> explica lo siguiente:</p>
<p>&quot;Es un hash set implementado con HashMap en el que el valor es ().&quot; Es un <code>HashMap</code> con claves y sin valores.</p>
<p>Se utiliza frecuentemente para saber si una clave existe o no.</p>
<p>Por ejemplo, si se tienen 100 n√∫meros aleatorios y cada uno de ellos se encuentra entre el 1 y el 100, habr√° n√∫meros entre el 1 y el 100 que aparezcan varias veces y algunos que no aparecer√°n. Si se insertan en un <code>HashSet</code> se obtendr√° una lista de todos los n√∫meros que s√≠ han aparecido sin tener en cuenta el n√∫mero de veces que lo han hecha.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashSet;

fn main() {
    let many_numeros = vec![
        94, 42, 59, 64, 32, 22, 38, 5, 59, 49, 15, 89, 74, 29, 14, 68, 82, 80, 56, 41, 36, 81, 66,
        51, 58, 34, 59, 44, 19, 93, 28, 33, 18, 46, 61, 76, 14, 87, 84, 73, 71, 29, 94, 10, 35, 20,
        35, 80, 8, 43, 79, 25, 60, 26, 11, 37, 94, 32, 90, 51, 11, 28, 76, 16, 63, 95, 13, 60, 59,
        96, 95, 55, 92, 28, 3, 17, 91, 36, 20, 24, 0, 86, 82, 58, 93, 68, 54, 80, 56, 22, 67, 82,
        58, 64, 80, 16, 61, 57, 14, 11];

    let mut numero_hashset = HashSet::new();

    for numero in many_numeros {
        numero_hashset.insert(numero);
    }

    let hashset_length = numero_hashset.len(); // Cu√°ntos n√∫meros contiene
    println!(&quot;Hay {} n√∫meros √∫nicos, por lo que faltan {}.&quot;, hashset_length, 100 - hashset_length);

    // Veamos cu√°les son los que faltan
    let mut missing_vec = vec![];
    for numero in 0..100 {
        if numero_hashset.get(&amp;numero).is_none() { // Si .get() devuelve None,
            missing_vec.push(numero);
        }
    }

    print!(&quot;No contiene: &quot;);
    for numero in missing_vec {
        print!(&quot;{} &quot;, numero);
    }
}
</code></pre></pre>
<p>Este c√≥digo imprime:</p>
<pre><code class="language-text">Hay 66 n√∫meros √∫nicos, por lo que faltan 34.
No contiene: 1 2 4 6 7 9 12 21 23 27 30 31 39 40 45 47 48 50 52 53 62 65 69 70 72 75 77 78 83 85 88 97 98 99
</code></pre>
<p>Un <code>BTreeSet</code> es similar a un <code>HashSet</code> de la misma manera que un <code>BTreeMap</code> lo es a un <code>HashMap</code>. Si se imprimen los elementos de un <code>HashSet</code> lo har√°n en cualquier orden:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for entry in numero_hashset { // üöß
    print!(&quot;{} &quot;, entry);
}
<span class="boring">}
</span></code></pre></pre>
<p>Puede que imprima: <code>67 28 42 25 95 59 87 11 5 81 64 34 8 15 13 86 10 89 63 93 49 41 46 57 60 29 17 22 74 43 32 38 36 76 71 18 14 84 61 16 35 90 56 54 91 19 94 44 3 0 68 80 51 92 24 20 82 26 58 33 55 96 37 66 79 73</code>. Pero casi nunca lo imprimir√° en el mismo orden en distintas repeticiones.</p>
<p>De nuevo, es muy f√°cil cambiar un <code>HashSet</code> a <code>BTreeSet</code> si se decide que se necesita mantenerlo ordenado. En el c√≥digo anterior, basta con cambiar en dos sitios de <code>HashSet</code> a <code>BTreeSet</code>.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::BTreeSet; // HashSet a BTreeSet

fn main() {
    let many_numeros = vec![
        94, 42, 59, 64, 32, 22, 38, 5, 59, 49, 15, 89, 74, 29, 14, 68, 82, 80, 56, 41, 36, 81, 66,
        51, 58, 34, 59, 44, 19, 93, 28, 33, 18, 46, 61, 76, 14, 87, 84, 73, 71, 29, 94, 10, 35, 20,
        35, 80, 8, 43, 79, 25, 60, 26, 11, 37, 94, 32, 90, 51, 11, 28, 76, 16, 63, 95, 13, 60, 59,
        96, 95, 55, 92, 28, 3, 17, 91, 36, 20, 24, 0, 86, 82, 58, 93, 68, 54, 80, 56, 22, 67, 82,
        58, 64, 80, 16, 61, 57, 14, 11];

    let mut numero_btreeset = BTreeSet::new(); // HashSet a BTreeSet

    for numero in many_numeros {
        numero_btreeset.insert(numero);
    }
    for entry in numero_btreeset {
        print!(&quot;{} &quot;, entry);
    }
}
</code></pre></pre>
<p>Que lo imprimir√° en orden: <code>0 3 5 8 10 11 13 14 15 16 17 18 19 20 22 24 25 26 28 29 32 33 34 35 36 37 38 41 42 43 44 46 49 51 54 55 56 57 58 59 60 61 63 64 66 67 68 71 73 74 76 79 80 81 82 84 86 87 89 90 91 92 93 94 95 96</code>.</p>
<h2 id="binaryheap"><a class="header" href="#binaryheap">BinaryHeap</a></h2>
<p>Un <code>BinaryHeap</code> es un tipo de colecci√≥n mayormente desordenada, pero que tiene un bit de orden. Mantiene el elemento mayor al comienzo, pero los dem√°s elementos est√°n en cualquier orden.</p>
<p>Se usar√° otra lista de elementos para el ejemplo, pero esta vez, ser√° m√°s peque√±a.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::BinaryHeap;

fn muestra_contenido(input: &amp;BinaryHeap&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    // Esta funci√≥n recupera el contenido de un BinaryHeap.
    // Un iterador ser√≠a m√°s r√°pido que esta funci√≥n
    // se aprender√°n m√°s adelante
    let mut remainder_vec = vec![];
    for numero in input {
        remainder_vec.push(*numero)
    }
    remainder_vec
}

fn main() {
    let many_numeros = vec![0, 5, 10, 15, 20, 25, 30]; // Estos n√∫meros est√°n ordenados

    let mut my_heap = BinaryHeap::new();

    for numero in many_numeros {
        my_heap.push(numero);
    }

    while let Some(numero) = my_heap.pop() { // .pop() devuelve Some(numero) si est√°, None si no est√°. Lo recupera del comienzo
        println!(&quot;Se extrae el {}. Los restantes n√∫meros son: {:?}&quot;, numero, muestra_contenido(&amp;my_heap));
    }
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">Se extrae el 30. Los restantes n√∫meros son: [25, 15, 20, 0, 10, 5]
Se extrae el 25. Los restantes n√∫meros son: [20, 15, 5, 0, 10]
Se extrae el 20. Los restantes n√∫meros son: [15, 10, 5, 0]
Se extrae el 15. Los restantes n√∫meros son: [10, 0, 5]
Se extrae el 10. Los restantes n√∫meros son: [5, 0]
Se extrae el 5. Los restantes n√∫meros son: [0]
Se extrae el 0. Los restantes n√∫meros son: []
</code></pre>
<p>Se observa que siempre est√° el n√∫mero mayor en el √≠ndice 0. A partir del √≠ndice 1 no existe orden.</p>
<p>Un buen uso para <code>BinaryHeap</code> es como colecci√≥n de cosas a hacer. Se puede crear un <code>BinaryHeap&lt;(u8, &amp;str)&gt;</code> en el que el <code>u8</code> indica la importancia de la tarea. La cadena de texto <code>&amp;str</code> es la descripci√≥n de lo que hay que hacer:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::BinaryHeap;

fn main() {
    let mut tareas = BinaryHeap::new();

    // A√±ade las tareas a hacer durante el d√≠a
    tareas.push((100, &quot;Contestar correo al CEO&quot;));
    tareas.push((80, &quot;Finalizar el informe hoy&quot;));
    tareas.push((5, &quot;Ver algo en YouTube&quot;));
    tareas.push((70, &quot;Dar las gracias a tu equipo por trabajar siempre duro&quot;));
    tareas.push((30, &quot;Planear a qui√©n contratar parar el equipo&quot;));

    while let Some(job) = tareas.pop() {
        println!(&quot;Tienes que hacer: {}&quot;, job.1);
    }
}
</code></pre></pre>
<p>Lo que siempre imprimir√°:</p>
<pre><code class="language-text">Tienes que hacer: Contestar correo al CEO
Tienes que hacer: Finalizar el informe hoy
Tienes que hacer: Dar las gracias a tu equipo por trabajar siempre duro
Tienes que hacer: Planear a qui√©n contratar parar el equipo
Tienes que hacer: Ver algo en YouTube
</code></pre>
<h2 id="vecdeque"><a class="header" href="#vecdeque">VecDeque</a></h2>
<p>Un <code>VecDeque</code> es un <code>Vec</code> que tiene buen rendimiento extrayendo elementos tanto por el inicio, como por el final. Rust tiene <code>VecDeque</code> porque <code>Vec</code> solo tiene buen rendimiento extrayendo elementos por el final. Cuando se usa <code>.pop()</code> en un <code>Vec</code>, solamente se tiene que recuperar el √∫ltimo elemento de la derecha y nada m√°s se mueve. Pero si se recupera cualquier otro elemento, todos los que quedan a su derecha se tienen que mover hacia la izquierda. Se puede ver esto en la descripci√≥n del m√©todo <code>.remove()</code> de <code>Vec</code>:</p>
<pre><code class="language-text">Quita y devuelve el elemento en la posici√≥n con el √≠ndice indicado, desplazando todos los elementos posteriores hacia la izquierda.
</code></pre>
<p>Por eso, si se hace lo siguiente:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec = vec![9, 8, 7, 6, 5];
    my_vec.remove(0);
}
</code></pre></pre>
<p>Se eliminar√° el <code>9</code>. El <code>8</code> en el √≠ndice 1 se mover√° al √≠ndice 0, el <code>7</code> en el √≠ndice 2 se mover√° al 1 y as√≠ sucesivamente. Se puede imaginar lo complejo que ser√≠a que un aparcamiento de veh√≠culos funcionara as√≠ cada vez que un coche sale de √©l...</p>
<p>Esta forma de eliminar el primer elemento supone mucho trabajo para el ordenador. De hecha, si se ejecuta esto en el Playground de rust, problamente lo abanhecha debido a que es mucho esfuerzo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec = vec![0; 600_000];
    for i in 0..600000 {
        my_vec.remove(0);
    }
}
</code></pre></pre>
<p>El c√≥digo anterior construye un <code>Vec</code> de 600.000 ceros. Cada vez que usa <code>.remove(0)</code> se tiene que mover cada cero una posici√≥n a la izquierda. Y esto se tiene que hacer hasta 600.000 veces.</p>
<p>Esto no es un problema para <code>VecDeque</code>. En general, puede ser un poco m√°s lento que un <code>Vec</code>, pero si es necesario realizar operaciones en ambos lados es much√≠simo m√°s eficiente. Se puede construir a partir de un vector mediante <code>VecDeque::from</code>. El c√≥digo anterior quedar√≠a modificado as√≠:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::VecDeque;

fn main() {
    let mut my_vec = VecDeque::from(vec![0; 600_000]);
    for i in 0..600000 {
        my_vec.pop_front();
    }
}
</code></pre></pre>
<p>Que ahora es mucho m√°s r√°pido y en el Playground de Rust se acaba en menos de un segundo en lugar de fallar.</p>
<p>En el siguiente ejemplo se dispone de un <code>Vec</code> de cosas para hacer. Se convierte a un <code>VecDeque</code> y se usa <code>.push_front()</code> para a√±adir elementos al inicio. As√≠ el primer elemento a√±adido estar√° a la derecha. Cada elemento que se inserta es una tupla <code>(&amp;str, bool)</code>: <code>&amp;str</code> es la descripci√≥n de la tarea y <code>false</code> significa que no se ha ejecutado a√∫n. Se usa la funci√≥n <code>.hecha()</code> para extraer un elemento del final, pero sin eliminarlo. En su lugar, se cambia de <code>false</code> a <code>true</code> y se inserta al inicio para conservarlo.</p>
<p>Queda as√≠:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::VecDeque;

fn comprueba_restantes(input: &amp;VecDeque&lt;(&amp;str, bool)&gt;) { // Cada elemento es un (&amp;str, bool)
    for item in input {
        if item.1 == false {
            println!(&quot;Tienes que: {}&quot;, item.0);
        }
    }
}

fn hecha(input: &amp;mut VecDeque&lt;(&amp;str, bool)&gt;) {
    let mut tarea_hecha = input.pop_back().unwrap(); // extrae del final
    tarea_hecha.1 = true;                            // ahora est√° hecha - se marca como true
    input.push_front(tarea_hecha);                   // y se inserta al inicio
}

fn main() {
    let mut my_vecdeque = VecDeque::new();
    let things_to_do = vec![&quot;enviar correo al cliente&quot;, &quot;a√±adir un producto a la lista&quot;, &quot;devolver la llamada a Loki&quot;];

    for thing in things_to_do {
        my_vecdeque.push_front((thing, false));
    }

    hecha(&amp;mut my_vecdeque);
    hecha(&amp;mut my_vecdeque);

    comprueba_restantes(&amp;my_vecdeque);

    for tarea in my_vecdeque {
        print!(&quot;{:?} &quot;, tarea);
    }
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">Tienes que: devolver la llamada a Loki
(&quot;a√±adir un producto a la lista&quot;, true) (&quot;enviar correo al cliente&quot;, true) (&quot;devolver la llamada a Loki&quot;, false)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="el-operador-"><a class="header" href="#el-operador-">El operador ?</a></h1>
<p>Existe una forma m√°s corta de gestionar un valor de tipo <code>Result</code> (y <code>Option</code>). m√°s corta que <code>match</code> y que <code>if let</code>. Es el &quot;operador interrogaci√≥n&quot; y es <code>?</code>. Despu√©s de una funci√≥n devuelve un resultado, se puede a√±adir <code>?</code> para:</p>
<ul>
<li>devolver el valor contenido en <code>Ok</code>, si es el tipo concreto de <code>Result</code>.</li>
<li>o elevar el error si es <code>Err</code>.</li>
</ul>
<p>En otras palabras, hace casi todo por ti.</p>
<p>Por ejemplo, se puede probar esto con <code>.parse()</code>.  En el siguiente ejemplo se presenta la funci√≥n <code>parse_str</code> que intenta convertir un <code>&amp;str</code> a <code>i32</code>:</p>
<pre><pre class="playground"><code class="language-rust">use std::num::ParseIntError;

fn parse_str(input: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let parsed_number = input.parse::&lt;i32&gt;()?; // Aqu√≠ est√° el ?
    Ok(parsed_number)
}

fn main() {}
</code></pre></pre>
<p>Esta funci√≥n toma un <code>&amp;str</code>. Si es <code>Ok</code>, devuelve un <code>i32</code> envuelto en un <code>Ok</code>. Si es un <code>Err</code>, devuelve <code>ParseIntError</code>. Al intentar obtener el n√∫mero y haberse a√±adido <code>?</code> lo que se hace es comprobar si esta llamada a <code>parse</code> ha devuelto <code>Ok</code> y obtener el contenido de este. Si no es correcto, devolver√° un error y finalizar√° en la linea de <code>parse</code>. Pero si es correcto avanza hasta la l√≠nea siguiente para devolver <code>Ok(i32)</code>. Es necesario envolver el n√∫mero para que sea compatible con el valor de retorno de la funci√≥n <code>Result&lt;i32, ParseIntError&gt;</code>, no <code>i32</code>.</p>
<p>Ahora, se puede probar a ejecutar la funci√≥n. Se observa a continuaci√≥n lo que sucede con un vector de <code>&amp;str</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn parse_str(input: &amp;str) -&gt; Result&lt;i32, std::num::ParseIntError&gt; {
    let parsed_number = input.parse::&lt;i32&gt;()?;
    Ok(parsed_number)
}

fn main() {
    let str_vec = vec![&quot;Siete&quot;, &quot;8&quot;, &quot;9.0&quot;, &quot;bien&quot;, &quot;6060&quot;];
    for item in str_vec {
        let parsed = parse_str(item);
        println!(&quot;{:?}&quot;, parsed);
    }
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">Err(ParseIntError { kind: InvalidDigit })
Ok(8)
Err(ParseIntError { kind: InvalidDigit })
Err(ParseIntError { kind: InvalidDigit })
Ok(6060)
</code></pre>
<p>¬øC√≥mo se puede conocer que el error de esta funci√≥n <code>parse</code> era <code>std::num::ParseIntError</code>? Una forma f√°cil es &quot;ped√≠rselo&quot; al compilador:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let failure = &quot;No es un n√∫mero&quot;.parse::&lt;i32&gt;();
    failure.rbrbrb(); // ‚ö†Ô∏è Compilador: &quot;¬øQu√© es rbrbrb()???&quot;
}
</code></pre></pre>
<p>El compilador se &quot;queja&quot; con:</p>
<pre><code class="language-text">error[E0599]: no method named `rbrbrb` found for enum `std::result::Result&lt;i32, std::num::ParseIntError&gt;` in the current scope
 --&gt; src\main.rs:3:13
  |
3 |     failure.rbrbrb();
  |             ^^^^^^ method not found in `std::result::Result&lt;i32, std::num::ParseIntError&gt;`
</code></pre>
<p>As√≠ se deduce que la definici√≥n de tipo que devuelve <code>parse</code> es <code>std::result::Result&lt;i32, std::num::ParseIntError&gt;</code>.</p>
<p>No se necesita escribir <code>std::result::Result</code> porque <code>Result</code> est√° siempre visible en el alcance (alcance = listo para su uso). Rust hace esto para todos los tipos que se utilizan mucho para que no sea necesario escribir o usar <code>std::result::Result</code>, <code>std::collections::Vec</code>, etc.</p>
<p>A√∫n no se han presentado recursos como los ficheros, por lo que el operador <code>?</code> no parece a√∫n muy √∫til. El siguiente ejemplo muestra c√≥mo se puede ilustrar este uso en una sola l√≠nea. En lugar de construir un <code>i32</code> con <code>.parse()</code>, se hace mucho m√°s. Se construye un <code>u16</code>, luego se convierte a <code>String</code>, despu√©s se convierte a <code>u32</code> y de nuevo se pasa a <code>String</code> para, finalmente, convertirlo en un <code>i32</code>.</p>
<pre><pre class="playground"><code class="language-rust">use std::num::ParseIntError;

fn parse_str(input: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let parsed_number = input.parse::&lt;u16&gt;()?.to_string().parse::&lt;u32&gt;()?.to_string().parse::&lt;i32&gt;()?; // Se a√±ade ? a cada funci√≥n para validar la correcci√≥n y pasar el valor
    Ok(parsed_number)
}

fn main() {
    let str_vec = vec![&quot;Siete&quot;, &quot;8&quot;, &quot;9.0&quot;, &quot;bien&quot;, &quot;6060&quot;];
    for item in str_vec {
        let parsed = parse_str(item);
        println!(&quot;{:?}&quot;, parsed);
    }
}
</code></pre></pre>
<p>Esto imprime lo mismo, pero despu√©s de haber procesado tres <code>Result</code> en una sola l√≠nea. Despu√©s, se mostrar√° un ejemplo parecido con ficheros, puesto que las funciones asociadas siempre devuelven <code>Result</code> ya que pueden ir mal muchas cosas cuando se accede a ellos.</p>
<p>Se puede imaginar lo siguiente: se quiere abrir un fichero, escribir y cerrarlo. Lo primero es encontrar el fichero con √©xito (eso es un <code>Result</code>); despu√©s, escribir en √©l sin fallos (esto es otro <code>Result</code>). Con <code>?</code> se puede hacer todo en una sola l√≠nea.</p>
<h2 id="cuando-panic-y-unwrap-son-buenos"><a class="header" href="#cuando-panic-y-unwrap-son-buenos">Cuando <code>panic</code> y <code>unwrap</code> son buenos</a></h2>
<p>Rust dispone de una macro <code>panic!</code> que se puede utilizar para que &quot;entre en p√°nico&quot;.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    panic!(&quot;¬°hora de entrar en p√°nico!&quot;);
}
</code></pre></pre>
<p>Cuando se ejecuta este programa se muestra el siguiente mensaje: <code>thread 'main' panicked at '¬°hora de entrar en p√°nico!', src/main.rs:2:5</code>.</p>
<p>Se muestra el programa, la l√≠nea de c√≥digo y columna <code>2:5</code> en el que se &quot;entr√≥ en p√°nico&quot;. Con esta informaci√≥n, se puede buscar la l√≠nea de c√≥digo y arreglarla.</p>
<p><code>panic!</code> tiene utilidad para asegurar que algo no cambia. Por ejemplo, la siguiente funci√≥n <code>imprime_tres_cosas</code> siempre imprime los √≠ndices [0], [1] y [2] de un vector. Esto est√° bien siempre que reciba un vector con tres elementos.</p>
<pre><pre class="playground"><code class="language-rust">fn imprime_tres_cosas(vector: Vec&lt;i32&gt;) {
    println!(&quot;{}, {}, {}&quot;, vector[0], vector[1], vector[2]);
}

fn main() {
    let my_vec = vec![8, 9, 10];
    imprime_tres_cosas(my_vec);
}
</code></pre></pre>
<p>Esto imprime <code>8</code>, <code>9</code> y <code>10</code> correctamente.</p>
<p>Si posteriormente se escribe m√°s c√≥digo y se olvida que <code>my_vec</code> tiene que ser siempre de tres elementos, se puede acabar un vector de seis elementos como en el caso siguiente:</p>
<pre><pre class="playground"><code class="language-rust">fn imprime_tres_cosas(vector: Vec&lt;i32&gt;) {
  println!(&quot;{}, {}, {}&quot;, vector[0], vector[1], vector[2]);
}

fn main() {
  let my_vec = vec![8, 9, 10, 10, 55, 99]; // Ahora tiene seis elementos
  imprime_tres_cosas(my_vec);
}
</code></pre></pre>
<p>Con este ejemplo, parece que todo est√° bien, no hay error. Pero si es importante que el vector solo tenga tres cosas, no se detectar√≠a el fallo. Se podr√≠a hacer lo siguiente:</p>
<pre><pre class="playground"><code class="language-rust">fn imprime_tres_cosas(vector: Vec&lt;i32&gt;) {
    if vector.len() != 3 {
        panic!(&quot;my_vec siempre tiene que tener tres elementos&quot;) // entrar√° en p√°nico si tiene longitud 3
    }
    println!(&quot;{}, {}, {}&quot;, vector[0], vector[1], vector[2]);
}

fn main() {
    let my_vec = vec![8, 9, 10];
    imprime_tres_cosas(my_vec);
}
</code></pre></pre>
<p>Ahora, si el vector tuviera seis elementos, el programa fallar√≠a (N.T. a las condiciones que se deben cumplir siempre en una funci√≥n -en sus par√°metros o valores de retorno o durante su ejecuci√≥n- se le denomina &quot;invariante&quot;. Rust proporciona macros espec√≠ficas para ello <code>assert!</code> y <code>assert_debug!</code>):</p>
<pre><pre class="playground"><code class="language-rust">    // ‚ö†Ô∏è
fn imprime_tres_cosas(vector: Vec&lt;i32&gt;) {
    if vector.len() != 3 {
        panic!(&quot;my_vec siempre tiene que tener tres&quot;)
    }
    println!(&quot;{}, {}, {}&quot;, vector[0], vector[1], vector[2]);
}

fn main() {
    let my_vec = vec![8, 9, 10, 10, 55, 99];
    imprime_tres_cosas(my_vec);
}
</code></pre></pre>
<p>Este programa devuelve <code>thread 'main' panicked at 'my_vec siempre tiene que tener tres', src/main.rs:4:9</code>. Gracias a <code>panic!</code>, se alerta de que solo deber√≠a tener tres elementos el vector <code>my_vec</code>. Es una macro √∫til para meter recordatorios en el c√≥digo.</p>
<p>Existen otras tres macros que son similares y que se utilizan mucho durante las pruebas. Son: <code>assert!</code>, <code>assert_eq!</code> y <code>assert_ne!</code>. Esto es lo que hacen:</p>
<ul>
<li><code>assert!()</code>: el programa entra en p√°nico cuando la evaluaci√≥n del contenido entre <code>()</code> no es cierta.</li>
<li><code>assert_eq!()</code>: el programa entra en p√°nico cuando los dos elementos contenidos entre <code>()</code> no son iguales.</li>
<li><code>assert_ne!()</code>: el programa entra en p√°nico cuando los dos elementos contenidos entre <code>()</code> son iguales.</li>
</ul>
<p>Algunos ejemplos son:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_name = &quot;Loki Laufeyson&quot;;

    assert!(my_name == &quot;Loki Laufeyson&quot;);
    assert_eq!(my_name, &quot;Loki Laufeyson&quot;);
    assert_ne!(my_name, &quot;Mithridates&quot;);
}
</code></pre></pre>
<p>El c√≥digo anterior funciona sin problemas ya que en este caso todas las macros comprueban con √©xito los valores que reciben como par√°metro.</p>
<p>Tambi√©n es posible a√±adir un mensaje a cada macro:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_name = &quot;Loki Laufeyson&quot;;

    assert!(
        my_name == &quot;Loki Laufeyson&quot;,
        &quot;{} should be Loki Laufeyson&quot;,
        my_name
    );
    assert_eq!(
        my_name, &quot;Loki Laufeyson&quot;,
        &quot;{} and Loki Laufeyson should be equal&quot;,
        my_name
    );
    assert_ne!(
        my_name, &quot;Mithridates&quot;,
        &quot;You entered {}. Input must not equal Mithridates&quot;,
        my_name
    );
}
</code></pre></pre>
<p>Estos mensajes se mostrar√°n solamente si el programa entra en p√°nico (no se cumple la condici√≥n que establece la macro). Por eso, si se ejecuta lo siguiente:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_name = &quot;Mithridates&quot;;

    assert_ne!(
        my_name, &quot;Mithridates&quot;,
        &quot;You enter {}. Input must not equal Mithridates&quot;,
        my_name
    );
}
</code></pre></pre>
<p>Se mostrar√°:</p>
<pre><code class="language-text">thread 'main' panicked at 'assertion failed: `(left != right)`
  left: `&quot;Mithridates&quot;`,
 right: `&quot;Mithridates&quot;`: You entered Mithridates. Input must not equal Mithridates', src\main.rs:4:5
</code></pre>
<p>Esta respuesta est√° diciendo que se esperaba que los valores fuesen distintos <code>left != right</code>, pero se han recibido valores iguales.</p>
<p>Tambi√©n es √∫til el uso de <code>unwrap</code> cuando se escribe un programa y se quiere que falle (entre en p√°nico) cuando haya un problema. Posteriormente, cuando el c√≥digo est√© completo, conviene eliminar <code>unwrap</code> por una alternativa m√°s robusta que impida que el programa se pare.</p>
<p>Tambi√©n se puede usar <code>expect</code>, que es como <code>unwrap</code>, pero permite que se le pase un mensaje que se mostrar√° en el momento del error. Los libros de texto suelen tener el siguiente aviso: &quot;si se utiliza <code>unwrap()</code> mucho, al menos se deber√≠a usar <code>expect()</code> para tener mensajes de error adecuados.</p>
<p>Esto fallar√°:</p>
<pre><pre class="playground"><code class="language-rust">   // ‚ö†Ô∏è
fn get_cuatro(input: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    let cuatro = input.get(3).unwrap();
    *cuatro
}

fn main() {
    let my_vec = vec![9, 0, 10];
    let cuatro = get_cuatro(&amp;my_vec);
}
</code></pre></pre>
<p>El mensaje de error es: <code>thread 'main' panicked at 'called Option::unwrap() on a None value', src\main.rs:7:18</code>.</p>
<pre><pre class="playground"><code class="language-rust">   // ‚ö†Ô∏è
fn get_cuatro(input: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    let cuatro = input.get(3).expect(&quot;Input vector needs at least 4 items&quot;);
    *cuatro
}

fn main() {
    let my_vec = vec![9, 0, 10];
    let cuatro = get_cuatro(&amp;my_vec);
}
</code></pre></pre>
<p>Vuelve a fallar, pero el mensaje de error es mejor: <code>thread 'main' panicked at 'Input vector needs at least 4 items', src\main.rs:7:18</code>. <code>.expect()</code> es un poco mejor que <code>.unwrap()</code>, pero sigue fallando con <code>None</code>. A continuaci√≥n se muestra un ejemplo de una <strong>mala pr√°ctica</strong> una funci√≥n que intenta <code>unwrap</code> dos veces. Toma como par√°metros un <code>Vec&lt;Option&lt;i32&gt;&gt;</code>, por lo que puede que cada parte contenta un <code>Some&lt;i32&gt;</code> o un <code>None</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn intenta_dos_unwraps(input: Vec&lt;Option&lt;i32&gt;&gt;) {
    println!(&quot;√çndice 0 es: {}&quot;, input[0].unwrap());
    println!(&quot;√çndice 1 es: {}&quot;, input[1].unwrap());
}

fn main() {
    let vector = vec![None, Some(1000)]; // Este vector tiene un None, por lo que entrar√° en p√°nico
    intenta_dos_unwraps(vector);
}
</code></pre></pre>
<p>El mensaje es &quot;<code>thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', src/main.rs:2:42</code>. No se puede saber en qu√© <code>unwrap</code> sucedi√≥ hasta revisar la l√≠nea. Ser√≠a mejor valorar la longitud y no <code>unwrap</code>. Pero con <code>.expect()</code> al menos ser√° <em>un poco</em> mejor:</p>
<pre><pre class="playground"><code class="language-rust">fn intenta_dos_unwrap(input: Vec&lt;Option&lt;i32&gt;&gt;) {
    println!(&quot;Index 0 is: {}&quot;, input[0].expect(&quot;¬°El primer unwrap conten√≠a un None!&quot;));
    println!(&quot;Index 1 is: {}&quot;, input[1].expect(&quot;¬°El segundo unwrap conten√≠a un None!&quot;));
}

fn main() {
    let vector = vec![None, Some(1000)];
    intenta_dos_unwrap(vector);
}
</code></pre></pre>
<p>Ahora el resultado es algo mejor: <code>thread 'main' panicked at '¬°El primer unwrap conten√≠a un None!', src/main.rs:2:41</code>. Y se dispone tambi√©n de la l√≠nea en la que ha sucedido para encontrarlo.</p>
<p>Tambi√©n se puede utilizar <code>unwrap_or</code> si siempre existe un valor a usar por defecto cuando se devuelve <code>None</code>. Esta funci√≥n no entra en p√°nico. Esto es:</p>
<ol>
<li>Bueno, porque el programa no entra en p√°nico, pero...</li>
<li>no tan bueno si se quiere detectar un problema en el c√≥digo.</li>
</ol>
<p>En todo caso, lo habitual es que no se quiera que el programa entre en p√°nico, por lo que <code>unwrap_or</code> es muy √∫til.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![8, 9, 10];

    let cuatro = my_vec.get(3).unwrap_or(&amp;0); // Si .get no funciona, 
    // se toma por defecto el &amp;0.
    // .get devuelve una referencia, por eso se necesita &amp;0

    println!(&quot;{}&quot;, cuatro);
}
</code></pre></pre>
<p>Esto imprime <code>0</code> porque <code>.unwrap_or(&amp;0)</code> devuelve 0 cuando el <code>Option</code> es un <code>None</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits-rasgos"><a class="header" href="#traits-rasgos">Traits (Rasgos)</a></h1>
<p>Anteriormente, se han visto algunos <em>traits</em><sup class="footnote-reference"><a href="#1">1</a></sup> (rasgos). <code>Debug</code>, <code>Copy</code> y <code>Clone</code> son traits  (rasgos). Para que un tipo tenga un trait (rasgo) hay que implementarlo. Puesto que algunos traits son tan comunes (como <code>Debug</code>), existen atributos en Rust que los implementan autom√°ticamente (con una implementaci√≥n por defecto). Esto es lo que sucede cuando se escribe <code>#[derive(Debug)]</code>: se implementa de forma autom√°tica el trait <code>Debug</code>.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct MiStruct {
    numero: usize,
}

fn main() {}
</code></pre></pre>
<p>Pero hay otros traits que son m√°s dif√≠ciles de implementar y hay que hacerlo a mano con <code>impl</code>. Por ejemplo, el trait <code>Add</code>, que se encuentra en <code>std::ops::Add</code> y se utiliza para sumar dos cosas. Pero Rust no puede adivinar c√≥mo se pueden sumar dos cosas cualquiera, por lo que hay qu√© codificarlo.</p>
<pre><pre class="playground"><code class="language-rust">struct CosasASumar {
    primera_cosa: u32,
    segunda_cosa: f32,
}

fn main() {}
</code></pre></pre>
<p>Se pueden sumar <code>primera_cosa</code> y <code>segunda_cosa</code>, pero hay que dar m√°s informaci√≥n. Puede que se quiera sumar <code>f32</code>, algo as√≠:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
let resultado = self.segunda_cosa + self.primera_cosa as f32
<span class="boring">}
</span></code></pre></pre>
<p>O puede que se quiera poner <code>self.primera_cosa</code> junto a <code>self.segunda_cosa</code> y que sea as√≠ como se quiera sumar. As√≠ la suma de 55 a 33.4 ser√≠a 5533.4 y no 88.4.</p>
<p>A continuaci√≥n, se analiza en primer lugar como se crea un trait. Lo importante es recordar que los trait sirven para describir un comportamiento determinado de quien los implementen. Para crear un trait, se escribe <code>trait</code> y se crean algunas funciones (o ninguna).</p>
<pre><pre class="playground"><code class="language-rust">struct Animal { // Un simple struct - un Animal que solo contiene su nombre
    nombre: String,
}

trait Perro { // El trait Perro asigna alguna funcionalidad
    fn ladrar(&amp;self) { // Puede ladrar
        println!(&quot;¬°Guau, guau!&quot;);
    }
    fn correr(&amp;self) { // y puede correr
        println!(&quot;¬°El perro est√° corriendo!&quot;);
    }
}

impl Perro for Animal {} // Ahora el Animal implementa el trait Perro

fn main() {
    let rover = Animal {
        nombre: &quot;Rover&quot;.to_string(),
    };

    rover.ladrar(); // El Animal puede usar ladrar()
    rover.correr();  // y puede usar correr()
}
</code></pre></pre>
<p>As√≠ est√° bien, pero no se quiere imprimir &quot;¬°El perro est√° corriendo!&quot;. Se pueden modificar los m√©todos que implementa por defecto un trait, para ello la nueva implementaci√≥n tiene que tener la misma declaraci√≥n. Esto significa que tiene que tomar los mismos par√°metros y devolver el mismo tipo de resultado. Por ejemplo, se puede modificar el m√©todo <code>.correr()</code>. La declaraci√≥n indica:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
fn correr(&amp;self) {
    println!(&quot;¬°El perro est√° corriendo!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p><code>fn correr(&amp;self)</code> significa que la funci√≥n <code>correr()</code> tiene de par√°metro <code>&amp;self</code> y no devuelve ning√∫n valor. Por lo que no se puede definir una nueva implementaci√≥n as√≠:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn correr(&amp;self) -&gt; i32 { // ‚ö†Ô∏è
    5
}
<span class="boring">}
</span></code></pre></pre>
<p>Rust se quejar√° as√≠:</p>
<pre><code class="language-text">   = note: expected fn pointer `fn(&amp;Animal)`
              found fn pointer `fn(&amp;Animal) -&gt; i32`
</code></pre>
<p>Pero s√≠ se puede hacer esto:</p>
<pre><pre class="playground"><code class="language-rust">struct Animal { // Un simple struct - un Animal que solo contiene su nombre
    nombre: String,
}

trait Perro { // El trait Perro asigna alguna funcionalidad
    fn ladrar(&amp;self) { // Puede ladrar
        println!(&quot;¬°Guau, guau!&quot;);
    }
    fn correr(&amp;self) { // y puede correr
        println!(&quot;¬°El perro est√° corriendo!&quot;);
    }
}

impl Perro for Animal { // Ahora el Animal implementa el trait Perro
    fn correr(&amp;self) {
        println!(&quot;¬°{} est√° corriendo!&quot;, self.nombre);
    }
}

fn main() {
    let rover = Animal {
        nombre: &quot;Rover&quot;.to_string(),
    };

    rover.ladrar(); // El Animal puede usar ladrar()
    rover.correr();  // y puede usar correr()
}
</code></pre></pre>
<p>Ahora imprime <code>¬°Rover est√° corriendo!</code>. Esta funci√≥n es correcta porque devuelve <code>()</code> o nada, que es lo que indica la implementaci√≥n del trait.</p>
<p>Cuando se define un trait, se puede escribir solo la declaraci√≥n de las funciones. Esto obliga a que quien lo quiera implementar tenga que escribir el c√≥digo que desea para las funciones que solo est√°n declaradas en el trait (sin implementar). En el c√≥digo siguiente el trait solo declara las funciones sin aportar una definici√≥n por defecto de <code>ladrar()</code> y <code>correr()</code>, por eso se obliga a escribir el c√≥digo en la implementaci√≥n del trait por parte del Perro.</p>
<pre><pre class="playground"><code class="language-rust">struct Animal {
    nombre: String,
}

trait Perro {
    fn ladrar(&amp;self); // Solo se indica que necesita el par√°metro &amp;self y que no devuelva nada

    fn correr(&amp;self); // necesita &amp;self y que no devuelva nada
    // Ahora se tiene que escribir el c√≥digo en la implementaci√≥n del Perro
}

impl Perro for Animal {

    fn ladrar(&amp;self) {
        println!(&quot;¬°{}, para de ladrar!&quot;, self.nombre);
    }
    
    fn correr(&amp;self) {
        println!(&quot;¬°{} est√° corriendo!&quot;, self.nombre);
    }

}

fn main() {
    let rover = Animal {
        nombre: &quot;Rover&quot;.to_string(),
    };

    rover.ladrar();
    rover.correr();
}
</code></pre></pre>
<p>Cuando se crea un trait (rasgo), se debe pensar: ¬øQu√© funciones deber√° tener? ¬øqu√© funciones se pueden implementar en el propio trait? y ¬øqu√© funciones deber√° implementar el propio usuario?</p>
<p>A continuaci√≥n se implementa el trait <code>Display</code> para el siguiente struct simple:</p>
<pre><pre class="playground"><code class="language-rust">struct Gato {
    nombre: String,
    edad: u8,
}

fn main() {
    let mr_mantle = Gato {
        nombre: &quot;Reggie Mantle&quot;.to_string(),
        edad: 4,
    };
}
</code></pre></pre>
<p>Se quiere imprimir <code>mr_mantle</code>. <code>Debug</code> es f√°cil de derivar:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Gato {
    nombre: String,
    edad: u8,
}

fn main() {
    let mr_mantle = Gato {
        nombre: &quot;Reggie Mantle&quot;.to_string(),
        edad: 4,
    };

    println!(&quot;Mr. Mantle es un {:?}&quot;, mr_mantle);
}
</code></pre></pre>
<p>Pero la implementaci√≥n de Debug no es muy bonita. Este es el resultado:</p>
<pre><code class="language-text">Mr. Mantle es un Gato { nombre: &quot;Reggie Mantle&quot;, edad: 4 }
</code></pre>
<p>Por eso, se tiene que implementar <code>Display</code> para un <code>Gato</code> si se quiere que la impresi√≥n sea bonita. En <a href="https://doc.rust-lang.org/std/fmt/trait.Display.html">https://doc.rust-lang.org/std/fmt/trait.Display.html</a> se puede ver la informaci√≥n detallada para Display con un ejemplo que dice:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Position {
    longitude: f32,
    latitude: f32,
}

impl fmt::Display for Position {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.longitude, self.latitude)
    }
}

fn main() {}
</code></pre></pre>
<p>Hay algunas cosas que a√∫n no se entienden en este c√≥digo, como <code>&lt;'_&gt;</code> y lo que hace <code>f</code>. Pero se entiende que el struct <code>Position</code> tiene √∫nicamente dos valores <code>f32</code>. Los campos de este struct son <code>self.longitude</code> y <code>self.latitude</code>. As√≠ que posiblemente se pueda utilizar este c√≥digo ara implementar la versi√≥n que se necesita para <code>Gato</code>, cambiando los campos por <code>self.nombre</code> y <code>self.edad</code>. Por √∫ltimo, <code>write!</code> se parece mucho a <code>println!</code>. As√≠, el c√≥digo queda:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Gato {
    nombre: String,
    edad: u8,
}

impl fmt::Display for Gato {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;{} es un gato de {} a√±os.&quot;, self.nombre, self.edad)
    }
}

fn main() {}
</code></pre></pre>
<p>Si ahora se a√±ade una funci√≥n <code>fn main()</code>, el c√≥digo queda as√≠:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Gato {
    nombre: String,
    edad: u8,
}

impl fmt::Display for Gato {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;{} es un gato de {} a√±os.&quot;, self.nombre, self.edad)
    }
}

fn main() {
    let mr_mantle = Gato {
        nombre: &quot;Reggie Mantle&quot;.to_string(),
        edad: 4,
    };

    println!(&quot;{}&quot;, mr_mantle);
}
</code></pre></pre>
<p>¬°Estupendo! Ahora, cuando se usa <code>{}</code> para imprimir a un Gato, se obtiene <code>Reggie Mantle es un gato de 4 a√±os.</code>, que queda mucho mejor.</p>
<p>Por cierto, cuando se implementa el trait <code>Display</code> se dispone del trait <code>ToString</code> sin nada que hacer adicionalmente. Esto pasa al usar la macro <code>format!</code> que facilita la creaci√≥n de un <code>String</code> con la funci√≥n <code>.to_string()</code>. As√≠ que se puede hacer algo como lo siguiente cuando se pasa la variable <code>reggie_mantle</code> a una funci√≥n que necesite un <code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;
struct Gato {
    nombre: String,
    edad: u8,
}

impl fmt::Display for Gato {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;{} es un gato de {} a√±os.&quot;, self.nombre, self.edad)
    }
}

fn print_gatos(mascota: String) {
    println!(&quot;{}&quot;, mascota);
}

fn main() {
    let mr_mantle = Gato {
        nombre: &quot;Reggie Mantle&quot;.to_string(),
        edad: 4,
    };

    print_gatos(mr_mantle.to_string()); // Lo convierte en un String
    println!(&quot;La cadena de caracteres de Mr. Mantle tiene {} letras.&quot;,
        mr_mantle.to_string().chars().count()); // Los convierte en caracteres y los cuenta
}
</code></pre></pre>
<p>Lo anterior imprime:</p>
<pre><code class="language-text">Reggie Mantle es un gato de 4 a√±os.
La cadena de caracteres de Mr. Mantle tiene 35 letras.
</code></pre>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>N.T.: Este concepto de Rust se puede traducir como <em>rasgo</em>. Est√° relacionado con la programaci√≥n orientada a aspectos. Los rasgos de Rust describen determinados aspectos de los tipos, funciones o variables que los implementen.</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
