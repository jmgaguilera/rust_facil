<!DOCTYPE HTML>
<html lang="es" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust en español fácil</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="actualizaciones.html">Actualizaciones</a></li><li class="chapter-item expanded affix "><a href="introduccion.html">Introducción</a></li><li class="chapter-item expanded affix "><a href="quiensoy.html">¿Quién soy?</a></li><li class="chapter-item expanded affix "><a href="escritura.html">La escritura de Rust en inglés fácil</a></li><li class="chapter-item expanded affix "><li class="part-title">Parte 1 - Rust en tu navegador</li><li class="chapter-item expanded "><a href="01.html"><strong aria-hidden="true">1.</strong> El entorno de pruebas de Rust</a></li><li class="chapter-item expanded "><a href="02.html"><strong aria-hidden="true">2.</strong> 🚧 y ⚠️</a></li><li class="chapter-item expanded "><a href="03.html"><strong aria-hidden="true">3.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="04.html"><strong aria-hidden="true">4.</strong> Tipos de dato</a></li><li class="chapter-item expanded "><a href="05.html"><strong aria-hidden="true">5.</strong> Inferencia de tipos de dato</a></li><li class="chapter-item expanded "><a href="06.html"><strong aria-hidden="true">6.</strong> Imprimiendo '¡Hola, mundo!'</a></li><li class="chapter-item expanded "><a href="07.html"><strong aria-hidden="true">7.</strong> La visualización y depuración</a></li><li class="chapter-item expanded "><a href="08.html"><strong aria-hidden="true">8.</strong> Mutabilidad (cambio)</a></li><li class="chapter-item expanded "><a href="09.html"><strong aria-hidden="true">9.</strong> La pila, la memoria dinámica y los punteros</a></li><li class="chapter-item expanded "><a href="10.html"><strong aria-hidden="true">10.</strong> Más sobre impresión</a></li><li class="chapter-item expanded "><a href="11.html"><strong aria-hidden="true">11.</strong> Cadenas de caracteres</a></li><li class="chapter-item expanded "><a href="12.html"><strong aria-hidden="true">12.</strong> const y static</a></li><li class="chapter-item expanded "><a href="13.html"><strong aria-hidden="true">13.</strong> Algo más sobre referencias</a></li><li class="chapter-item expanded "><a href="14.html"><strong aria-hidden="true">14.</strong> Referencias modificables (mutables)</a></li><li class="chapter-item expanded "><a href="15.html"><strong aria-hidden="true">15.</strong> Paso de referencias a funciones</a></li><li class="chapter-item expanded "><a href="16.html"><strong aria-hidden="true">16.</strong> Copia</a></li><li class="chapter-item expanded "><a href="17.html"><strong aria-hidden="true">17.</strong> Tipos colección</a></li><li class="chapter-item expanded "><a href="18.html"><strong aria-hidden="true">18.</strong> Vectores</a></li><li class="chapter-item expanded "><a href="19.html"><strong aria-hidden="true">19.</strong> Tuplas</a></li><li class="chapter-item expanded "><a href="20.html"><strong aria-hidden="true">20.</strong> Estructuras de control</a></li><li class="chapter-item expanded "><a href="21.html"><strong aria-hidden="true">21.</strong> Estructuras - struct</a></li><li class="chapter-item expanded "><a href="22.html"><strong aria-hidden="true">22.</strong> Enumerados - enum</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust en español fácil</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="actualizaciones"><a class="header" href="#actualizaciones">Actualizaciones</a></h1>
<p><img src="https://github.com/Dhghomon/easy_rust/workflows/github%20pages/badge.svg" alt="example workflow name" /></p>
<p>23 de mayo de 2021: <a href="https://github.com/ariandy/easy-rust-indonesia">Ahora disponible en indonesio</a> gracias <a href="https://github.com/ariandy">Ariandy</a>/<a href="https://1kilobyte.github.io/">1kb</a>.</p>
<p>2 de abril de 2021: <a href="https://www.buymeacoffee.com/mithridates">Añadido enlace a BuyMeACoffee</a> para aquellos a los que les gustaría invitarme a un café.</p>
<p>1 de febrero de 2021: <a href="https://www.youtube.com/playlist?list=PLfllocyHVgsRwLkTAhG0E-2QxCf-ozBkk">¡Ahora disponible en youtube! (en inglés)</a> Dos meses después: completo el 1 de abril de 2021, 186 vídeos en total (un poco más de 23 horas).</p>
<p>22 de diciembre 2020: el libro en mdBook se puede encontrar <a href="https://dhghomon.github.io/easy_rust">aquí</a>.</p>
<p>28 de noviembre de 2020: <a href="https://github.com/kumakichi/easy_rust_chs">Ahora también disponible en chino simplificado</a> ¡Gracias a <a href="https://github.com/kumakichi">kumakichi</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introducción"><a class="header" href="#introducción">Introducción</a></h1>
<p>Rust es un nuevo lenguaje de programación que ya tiene buenos libros de texto, pero a veces son difíciles ya que son para personas cuyo inglés es nativo. Muchas empresas y personas están aprendiendo Rust en estos días y pueden aprenderlo más rápido con un libro que use un inglés fácil<sup class="footnote-reference"><a href="#1">1</a></sup>. Este libro es para que estas empresas y personas puedan aprender Rust con un español simple.</p>
<p>Rust es un lenguaje que bastante nuevo, pero ya es muy popular. Es popular porque te da la velocidad y control de C o C++, pero también ofrece protección del acceso a la memoria como otros lenguajes como Python. Esto lo hace usando nuevas ideas que son en parte diferentes a otros lenguajes. Lo que significa que hay que aprender cosas nuevas y no puedes simplemente &quot;descubrirlo según vas avanzando&quot;. Rust es un lenguaje en el que tienes que pensar las cosas durante un tiempo para comprenderlo, pero que aún suena a familiar si conoces otros lenguajes y está diseñado para ayudarte a escribir código de calidad.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>N.T.: esta traducción al español trata de seguir el mismo principio utilizando un español fácil.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quién-soy"><a class="header" href="#quién-soy">¿Quién soy?</a></h1>
<p>Soy un canadiense que vive en Korea y escribí Rust Fácil pensando en cómo hacer más fácil su uso para las empresas de aquí<sup class="footnote-reference"><a href="#1">1</a></sup>. Espero que otras empresas que no usan el inglés como primer idioma puedan utilizarlo también.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>N.T.: Soy un español que vive en Madrid, espero que esta traducción también facilite la comprensión de este lenguaje que tiene aspectos novedosos incluso para los que conocen C, C++, Java, Python, Ruby, Javascript o Typescript...</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="la-escritura-de-rust-en-inglés-fácil"><a class="header" href="#la-escritura-de-rust-en-inglés-fácil">La escritura de Rust en inglés fácil</a></h1>
<p><em>Rust en inglés fácil</em> se escribió de julio a agosto de 2020 y ocupa unas 400 páginas. Puedes contactarme aquí o <a href="https://www.linkedin.com/in/davemacleod">en LinkedIn</a> o <a href="https://twitter.com/mithridates">en Twitter</a> si tienes cualquier pregunta. Si ves algo erróneo o tienes una petición de inserción (pull request) que hacer, adelante. Más de 20 personas ya han ayudado a corregir erratas y problemas en el código, por lo que tú también puedes[1^]. no soy el mejor experto de Rust del mundo, así que me gusta escuchar nuevas ideas o ver en qué puedo hacer el libro mejor.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>N.T.: Esta traducción, <em>Rust en español fácil</em>, se inició en julio de 2021. Para cualquier asunto relacionado con ella, puedes contactarme en <a href="https://github.com/jmgaguilera">github</a> o en <a href="https://es.linkedin.com/in/jmgaguilera">LinkedIn</a>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parte-1---rust-en-tu-navegador"><a class="header" href="#parte-1---rust-en-tu-navegador">Parte 1 - Rust en tu navegador</a></h1>
<p>Este libro tiene dos partes. En la primera, aprenderás todo solo utilizando tu navegador. Puedes aprender casi todo lo que debes saber sin instalar Rust. Por eso esta primera parte es muy larga. En la segunda parte, mucho más corta, se habla de Rust en tu ordenador. Ahí aprenderás todo lo que necesitas conocer y que solo se puede hacer fuera del navegador. Algunos ejemplos son: trabajar con ficheros, obtener datos del usuario, gráficos y configuraciones personales. Espero que al finalizar la primera parte te guste Rust lo suficiente para que lo instales en tu equipo. Y si no, no hay problema, esta primera parte de enseña tanto que no te importará.</p>
<h1 id="el-entorno-de-pruebas-playground-de-rust"><a class="header" href="#el-entorno-de-pruebas-playground-de-rust">El entorno de pruebas (Playground) de Rust</a></h1>
<p><strong><a href="https://youtu.be/-lYeJeQ11OI">Puedes ver este capítulo en inglés en YouTube</a></strong></p>
<p>Puede que no quieras instalarte aún Rust. No pasa nada. Puedes ir a <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> y comenzar a escribir Rust sin salir del navegador. Puedes escribir ahí el código y pulsar <strong>Run</strong> para ver los resultados. Puedes ejecutar la mayoría de los ejemplos de este libro en este entorno. Solamente al final del libro verás ejemplos que van más allá de lo que se puede hacer aquí (como abrir ficheros.)</p>
<p>Algunas recomendaciones de uso de este entorno de pruebas (Playground):</p>
<ul>
<li>Ejecuta el código con <strong>Run</strong></li>
<li>Cambia de <strong>Debug</strong> a <strong>Release</strong> si quieres que el código sea más rápdio. <strong>Debug</strong> (Depuración) hace que compile más rápido, se ejecute más lento y contenga información para la depuración de errores. <strong>Release</strong> (Producción) hace que compile más lento, se ejecute más rápido y se suprima la información para la depuración de errores.</li>
<li>Pulsa en <strong>Share</strong> (Compartir) para obtener un hiperenlace. Puedes usarlo para compartir tu código si necesitas ayuda. Después de pulsar compartir, puedes pulsar en <code>Open a new thread in de Rust user forum</code>(Abre un nuevo hilo en el foro de usuarios de Rust) para pedir ayuda.</li>
<li><strong>Tools</strong> (Herramientas): <strong>Rustfmt</strong> formatea el código correctamente.</li>
<li><strong>Tools</strong> (Herramientas): <strong>Clippy</strong> da información extra sobre cómo hacer mejor el código.</li>
<li><strong>Config</strong> (Configuración): puedes cambiar aquí el tema a modo oscuro para que puedas trabajar mejor de noche y otras muchas opciones.</li>
</ul>
<p>Si quieres instalar Rust, ve a <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a> y sigue las instrucciones. Normalmente, usarás <code>rustup</code> para instalar y actualizar Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-y-"><a class="header" href="#-y-">🚧 y ⚠️</a></h1>
<p>En ocasiones, el código de los ejemplos del libro no funciona. Si un ejemplo no funciona, veras un 🚧 o un ⚠️ junto a él. 🚧 significa &quot;en construcción&quot;, es decir, que el código no está completo. Rust necesita una <code>fn main()</code> (función principal) para ejecutarse, pero algunas veces solo queremos observar una parte del código por lo que no aparecerá el código <code>fn main ()</code>. Estos ejemplos son correctos, pero necesitan de una función <code>fn main()</code> para ejecutarse. En algunos ejemplos el código mostrará un problema que tendrás que resolver. Estos ejemplos podrían tener una función <code>fn main()</code> pero generarán un error y por eso se acompañan de un símbolo ⚠️.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comentarios"><a class="header" href="#comentarios">Comentarios</a></h1>
<p><strong><a href="https://youtu.be/fJ7jBZG_Rpo">Puedes ver este capítulo en inglés en YouTube</a></strong></p>
<p>Los comentarios son para que los lean los programadores, no el ordenador. es bueno escribir comentarios para ayudar a otras personas a entender tu código. Es bueno, también, para ayudarte a entender tu propio código pasado un tiempo (Muchas personas escriben buen código, pero olvidan porqué lo escribieron). Para escribir comentarios en el código, en Rust se suele usar <code>//</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Los programas Rust comienzan en fn main()
    // Pones el código en un bloque que comienza con { y termina con }
    let algun_numero = 100; // Aquí podemos esribir todo lo que queramos ya que el compilador no lo va mirar
}
</code></pre></pre>
<p>Cuando lo haces así, el compilador no mirará nada que haya a la derecha de <code>//</code>.</p>
<p>Existe otra clase de comentario que se escribe con <code>/*</code> para iniciarlo y se termina con `*/. Este tipo de comentario es útil para escribirlo entre el código.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let algun_numero/*: i16*/ = 100;
}
</code></pre></pre>
<p>Para el compilador <code>let algun_numero/*: i16*/ = 100;</code> es igual que <code>let algun_numero = 100;</code>.</p>
<p>Esta forma <code>/* */</code> también es útil para los comentarios de gran longitud que necesiten más de una línea. En este ejemplo se puede ver que necesitas escribir <code>//</code> en cada línea, pero si utilizas <code>/*</code>, el comentario dura hasta que lo finalices con <code>*/</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let algun_numero = 100; /* Déjame contarte
    un poco sobre este número.
    Es el 100, que es mi número favorito.
    Se llama algun_numero pero realmente creo que...*/

    let algun_numero = 100; // Déjame contarte
    // un poco sobre este número.
    // Es el 100, que es mi número favorito.
    // Se llama algun_numero pero realmente creo que...
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tipos-de-dato"><a class="header" href="#tipos-de-dato">Tipos de dato</a></h1>
<p>Rust tiene muchos tipos de dato que permiten trabajar con números, caracteres y otros. Algunos son simples, otros son más complicados e, incluso, puedes crear tus propios tipos de dato.</p>
<h2 id="tipos-de-dato-primitivos"><a class="header" href="#tipos-de-dato-primitivos">Tipos de dato primitivos</a></h2>
<p><strong><a href="https://youtu.be/OxTPU5UGMhs">Puedes ver este capítulo en YouTube en inglés</a></strong></p>
<p>Rust tiene tipos simples que llaman <strong>tipos primitivos</strong> (primitivo = muy básico). Comenzaremos con los números enteros y los <code>char</code> (caracteres). Los enteros son números sin coma decimal. Existen dos tipos de enteros:</p>
<ul>
<li>Enteros con signo.</li>
<li>Enteros sin signo.</li>
</ul>
<p>&quot;Con signo&quot; significa que disponen de <code>+</code> (signo más) y <code>-</code> (signo menos), por lo que los enteros con signo pueden ser positivos o negativos (por ejemplo, +8, -8). Por el contratio, los enteros sin signo solo pueden ser positivos ya que no tienen signo.</p>
<p>Los enteros con signo son: <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, e <code>isize</code>.</p>
<p>Los enteros sin signo son: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, e <code>usize</code>.</p>
<p>El número tras la <strong>i</strong> o la <strong>u</strong> indica el número de bits que se usan para el entero. Así, los números con más bits pueden ser mayores. 8 bits = un byte por lo que <code>i8</code> ocupa un byte, y puede contener valores entre el -128 y el 127. Por lo tanto <code>i64</code> ocupa 64 bits o, lo que es lo mismo, 8 bytes y puede representar números entre el -9223372036854775808 y el 9223372036854775807.</p>
<p>Los tipos numéricos con mayor tamaño pueden representar valores mayores. Por ejemplo, el tipo <code>u8</code>puede representar del 0 al 255, el tipo <code>u16</code> puede representar del 0 al 65635, y el tipo <code>u128</code> puede representar a un número entre el 0 y el 340282366920938463463374607431768211455.</p>
<p>¿Y qué representan <code>isize</code> y <code>usize</code>? El número de bits del tipo nativo del procesador de tu ordenador (El número de bits nativo de tu procesador se denomina la <strong>arquitectura</strong> de tu procesador). Así que <code>isize</code> y <code>usize</code> en un ordenador de 32-bits son equivalentes a <code>i32</code> y <code>u32</code>. En un ordenador de 64-bits son equivalentes a <code>i64</code> y <code>u64</code>.</p>
<p>Hay muchas razones para disponer de todos estos tipos de números enteros. Una razón es el rendimiento del ordenador: es más rápido procesar un número menor de bytes. Por ejemplo, el número -10 representado como un <code>i8</code> es <code>11110110</code>, pero como un <code>i128</code> es <code>11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110110</code>. </p>
<p>veamos otros usos:</p>
<p>Los caracters en Rust se denominan <code>char</code>. Todo <code>char</code> se representa por un número: la letra <code>A</code> es lel número 65, mientras que el carácter <code>友</code> (&quot;amigo&quot; en chino) es el número 21451. La lista de estos números que representan a carateres se denomina &quot;Unicode&quot;. Unicode usa números más pequeños para los caracteres que se usan más, como los de la A a la Z, los dígitos de 0 a 9 o el espacio.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let primera_letra = 'A';
    let espacio = ' '; // Un espacio entre ' ' también es un char
    let char_en_otro_idioma = 'Ꮔ'; // Gracias a Unicode, otros lenguajes, como el Cherokee, también se visualizan bien
    let cara_gato = '😺'; // Emojis también son char
}
</code></pre></pre>
<p>Los caracters que se utilizan más se representan or números menores al 256 y así pueden caber en un <code>u8</code>. Recuerda que un <code>u8</code> permite números entre el 0 y el 255, lo que facilita la representación de 256 caracteres en total. Esto significa que Rust puede convertir de forma segura del tipo de datos <code>u8</code> al <code>char</code>, utilizando la palabra reservada del lenguaje <code>as</code> (Considera el dato de este tipo <code>u8</code> como si fuese <code>char</code>).</p>
<p>La conversión de tipos de datos utilizando <code>as</code> es muy útil ya que Rust es muy estrict. Siempre necesita conocer el tipo de dato y, además, no deja utilizar de forma conjunta dos tipos de datos diferentes incluso aunque sean de la misma familia (como los enteros). Por ejemplo, este código no funcionará:</p>
<pre><pre class="playground"><code class="language-rust">fn main() { // main() es la función a partir de la que se 
            // inician los programas Rust. El código entre las llaves {}

    let mi_numero = 100; // No hemos indicado el tipo de datos entero
                         // que Rust debe utilizar,
                         // así que Rust elige i32. Rust siempre
                         // elige i32 para los enteros si no se le indica
                         // que utilice otro tipo de datos diferente

    println!(&quot;{}&quot;, mi_numero as char); // ⚠️
}
</code></pre></pre>
<p>Esta es la razón:</p>
<pre><code class="language-text">error[E0604]: only `u8` can be cast as `char`, not `i32`
 --&gt; src\main.rs:10:20
  |
3 |     println!(&quot;{}&quot;, mi_numero as char);
  |                    ^^^^^^^^^^^^^^^^^ invalid cast
</code></pre>
<p>Afortunadamente, podemos corregir esto fácilmente con <code>as</code>. No podemos convertir un <code>i32</code> a <code>char</code>, pero podemos convertir un <code>i32</code> a <code>u8</code>. Y después, podemos realizar la conversión de <code>u8</code> a <code>char</code>. Po tanto, en una línea usamos <code>as</code> para convertir mi_numero a <code>u8</code> y después lo convertimos a <code>char</code>. Ahora sí compilará:</p>
<pre><pre class="playground"><code class="language-rust">fn main() { 
    let mi_numero = 100; 
    println!(&quot;{}&quot;, mi_numero as u8 as char);
}
</code></pre></pre>
<p>Se imprime <code>d</code> porque es el <code>char</code> que está representado en Unicode con este número.</p>
<p>Existe una forma más fácil, sin embargo, de conseguir este resultado: indicarle a Rust que <code>mi_numero</code> es de tipo <code>u8</code>. Así:</p>
<pre><pre class="playground"><code class="language-rust">fn main() { 
    let mi_numero: u8 = 100; // se indica de forma expresa que
                             // el tipo de la variable mi_numero es u8
    println!(&quot;{}&quot;, mi_numero as char);
}
</code></pre></pre>
<p>Las anteriores, son dos de las razones para la existencia de todos estos tipos de datos numéricos en Rust. Hay otra razón más: <code>usize</code> es el tamaño que Rust utiliza para <em>indexar</em> (Indexar significa &quot;conocer cual elemento va primero&quot;, &quot;cual va segundo&quot;, etc.). <code>usize</code> es el mejor tamaño para el indexado porque:</p>
<ul>
<li>Un índice no puede ser negativo, por lo que tiene que ser uno de los tipos de dato con una <strong>u</strong>.</li>
<li>Debe ser grande porque en muchas ocasiones necesitas indexar muchas cosas, pero</li>
<li>No puede ser un u64 porque los ordenadores de 32-bits no lo pueden manejar.</li>
</ul>
<p>Por eso Rust usa <code>usize</code> para indexar y facilitar que tu ordenador pueda utilizar el tipo de datos mayor de que disponga.</p>
<p>Vamos a aprender algo más sobre <code>char</code>. Ya vimos que <code>char</code>siempre es un carácter y utiliza <code>''</code> en lugar de <code>&quot;&quot;</code>.</p>
<p>Todos los <code>char</code> usan 4 bytes de memoria, puesto que son necesarios 4 bytes para contener cualquier clase de carácter:</p>
<ul>
<li>Las letras y símbolos básicos suelen necesitar solo 1 de los 4 bytes: <code>a b 1 2 + - = $ @</code></li>
<li>Otras letras como las diéresis y tildes necesitan 2 de los 4 bytes: <code>ä ö ü ß è é à ñ</code></li>
<li>Los caracteres coreanos, japoneses o chinos necesitan 3 de los cuatro bytes: <code>国 안 녕</code></li>
</ul>
<p>Cuando los caracteres se usan como parte de una cadena, esta se codifica para usar la menor cantidad de memoria necesaria para cada carácter<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<p><sup class="footnote-reference"><a href="#1">1</a></sup> N.T.: Rust codifica las cadenas en UTF-8.</p>
<p>Para observar esto podemos usar <code>.len()</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Tamaño de un char: {}&quot;, std::mem::size_of::&lt;char&gt;()); // 4 bytes
    // .len() devuelve el tamaño de una cadena de texto en bytes
    println!(&quot;Tamaño de una cadena que contiene la 'a': {}&quot;, &quot;a&quot;.len());
    println!(&quot;Tamaño de una cadena que contiene la 'ß': {}&quot;, &quot;ß&quot;.len());
    println!(&quot;Tamaño de una cadena que contiene la '国': {}&quot;, &quot;国&quot;.len());
    println!(&quot;Tamaño de una cadena que contiene la '𓅱': {}&quot;, &quot;𓅱&quot;.len());
}
</code></pre></pre>
<p>Lo que imprime:</p>
<pre><code class="language-text">Tamaño de un char: 4
Tamaño de una cadena que contiene la 'a': 1
Tamaño de una cadena que contiene la 'ß': 2
Tamaño de una cadena que contiene la '国': 3
Tamaño de una cadena que contiene la '𓅱': 4
</code></pre>
<p>Puedes ver que la <code>a</code> ocupa un byte, la 'ß' alemana ocupa dos, la japonesa <code>国</code> ocupa tres, y el carácter del antiguo egipto <code>𓅱</code> ocupa cuatro bytes.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let fragmento = &quot;¡Hola!&quot;;
    println!(&quot;El fragmento ocupa {} bytes.&quot;, fragmento.len());
    let fragmento2 = &quot;안녕!&quot;; // Coreano de &quot;hola&quot;
    println!(&quot;El fragmento2 ocupa {} bytes.&quot;, fragmento2.len());
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">El fragmento ocupa 7 bytes.
El fragmento2 ocupa 7 bytes.
</code></pre>
<p>El primer fragmento consta de seis caracteres y ocupa 7 bytes (la apertura de exclamación ocupa dos bytes). El segundo fragmento consta de tres caracteres y ocupa 7 bytes (los dos primeros caracteres ocupan tres bytes cada uno).</p>
<p>Si <code>.len()</code> devuelve el tamaño en bytes, ¿cómo se puede conocer el tamaño de una cadena de texto en caracteres? Aprenderemos esto más tarde, en este momento basta con recordar que se hace con <code>.chars().count()</code>. La primera función <code>.chars()</code> devuelve los caracteres separados y luego cuenta cuántos son.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let fragmento = &quot;¡Hola!&quot;;
    println!(&quot;El fragmento ocupa {} bytes y son {} caracteres.&quot;,
        fragmento.len(), fragmento.chars().count());
    let fragmento2 = &quot;안녕!&quot;;
    println!(&quot;El fragmento2 ocupa {} bytes y son {} caracteres.&quot;,
        fragmento2.len(), fragmento2.chars().count());
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">El fragmento ocupa 7 bytes y son 6 caracteres.
El fragmento2 ocupa 7 bytes y son 3 caracteres.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inferencia-de-tipos-de-dato"><a class="header" href="#inferencia-de-tipos-de-dato">Inferencia de tipos de dato</a></h1>
<p><strong><a href="https://youtu.be/q1D2vpy3kEI">Puedes ver este capítulo en YouTube en inglés</a></strong></p>
<p>La inferencia de tipos de datos consiste en que si no se le indica el tipo de datos al compilador, pero lo puede determinar por sí mismo, él decide que tipo utilizar. El compilador siempre necesita conocer el tipo de las variables, pero no siempre es necesario decírselo expresamente. En realidad, normalmente no necesitas indicárselo. Por ejemplo, en la sentencia <code>let mi_numero = 8</code>, <code>mi_numero</code> será de tipo <code>i32</code>. Esto se debe a que el compilador elige siempre el tipo <code>i32</code> para los números enteros si no se le indica uno. Sin embargo, en la siguiente sentencia <code>let mi_numero: u8 = 8</code>, la variable <code>mi_numero</code> es de tipo <code>u8</code> ya que así se le ha indicado.</p>
<p>Así que normalmente el compilador puede deducir el tipo de datos, pero en ocasiones será necesario indicárselo por una de las siguientes dos razones:</p>
<ol>
<li>Estás programando algo muy complejo y el compilador no puede deducir el tipo de datos que es necesario.</li>
<li>Quieres usar un tipo de datos diferente (por ejemplo, quieres un <code>i128</code>, no el <code>i32</code> que se usa por defecto).</li>
</ol>
<p>Para especificar un tipo, se añaden dos puntos después del nombre de la variable seguido del tipo.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numerito: u8 = 10;
}
</code></pre></pre>
<p>Para los números, se puede especificar el tipo después del número, no se necesita un espacio - solo teclearlo justo después del número.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numerito = 10u8; // 10u8 = 10 de tipo u8
}
</code></pre></pre>
<p>También se puede añadir <code>_</code> para añadir claridad a la lectura.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numerito = 10_u8; // Esto es más fácil de leer
    let numerazo = 100_000_000_i32; // 100 millones es de fácil lectura con _
}
</code></pre></pre>
<p>El <code>_</code> no modifica el número. Solo lo hace más fácil de leer. Y no importa el cuantos <code>_</code> se utilizan.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numero = 0________u8;
    let numero2 = 1___6______2____4______i32;
    println!(&quot;{}, {}&quot;, numero, numero2);
}
</code></pre></pre>
<p>Lo anterior imprime <code>0, 1624</code>.</p>
<h2 id="números-decimales"><a class="header" href="#números-decimales">Números decimales</a></h2>
<p>Los números decimales son aquellos que tienen coma decimal<sup class="footnote-reference"><a href="#1">1</a></sup>. <code>5.5</code> es un número decimal y <code>6</code> es un número entero. <code>5.0</code> también es un número decimal e incluso <code>5.</code> lo es.</p>
<p><sup class="footnote-reference"><a href="#1">1</a></sup> N.T.: en español se usa una coma como carácter para separar la parte entera de un número de su parte decimal. En Rust, la coma decimal española se sustituye por el punto decimal que es el que se usa habitualmente en los lenguajes de programación.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_decimal = 5.; // Rust ve un . y sabe que es un decimal (float, en inglés)
}
</code></pre></pre>
<p>Rust utiliza diversos tipos de dato para almacenar números decimales, son el <code>f32</code> y el <code>f64</code>. Al igual que en los números enteros, el número tras <code>f</code> muestra el número de bits utilizados en cada caso para almacenar el dato. Si no se indica el tipo, Rust elige <code>f64</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_decimal: f64 = 5.0; // Esta variable es de tipo f64
    let mi_otro_decimal: f32 = 8.5; // Esta es de tipo f32
    let tercer_decimal = mi_decimal + mi_otro_decimal; // ⚠️
}
</code></pre></pre>
<p>Cuanto se intenta ejecutar el código anterior, Rust se queja diciendo:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:4:39
  |
5 |     let tercer_decimal = mi_decimal + mi_otro_decimal; // ⚠️
  |                                       ^^^^^^^^^^^^^^^ expected `f64`, found `f32`
</code></pre>
<p>El compilador indica &quot;expected (tipo), found (type)&quot; cuando se usa el tipo erróneo. Rust lee el código de esta forma:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_decimal: f64 = 5.0; // El compilador ve un f64
    let mi_otro_decimal: f32 = 8.5; // El compilador ve un f64. Es un tipo diferente.
    let tercer_decimal = mi_decimal + // Se quiere sumar mi_decimal, que es f64 a algún
                                      // otro número. Ahora espera otro f64...  
        mi_otro_decimal; // ⚠️ pero se encuentra un f32, no se pueden sumar.
}
</code></pre></pre>
<p>Así que cuando veas que el compilador indica &quot;expected (tipo), found (type)&quot;, debes buscar la causa por la que el compilador esperaba un tipo de datos diferente.</p>
<p>Con los números simples es fácil arreglarlo. Puedes convertir el <code>f32</code> a <code>f64</code> con un <code>as</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_decimal: f64 = 5.0;
    let mi_otro_decimal: f32 = 8.5;
    // En la siguiente línea, se utiliza mi_otro decimal como un f64
    let tercer_decimal = mi_decimal + mi_otro_decimal as f64;
}
</code></pre></pre>
<p>O simplemente, se pueden eliminar las declaraciones de tipo, Rust elegirá tipos que se puedan sumar entre sí.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_decimal = 5.0; // Rust elige f64
    let mi_otro_decimal = 8.5; // Rust elige de nuevo f64
    let tercer_decimal = mi_decimal + mi_otro_decimal;
}
</code></pre></pre>
<p>El compilador de Rust es inteligente y no elegirá f64 si necesitas f32:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_decimal: f32 = 5.0; // Rust elige f64
    let mi_otro_decimal = 8.5; // Normalmente Rust elegiría f64
    // pero al conocer que lo vamos a sumar a un f32, elige un f32 para mi_otro_decimal
    let tercer_decimal = mi_decimal + mi_otro_decimal;
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="imprimiendo-hola-mundo"><a class="header" href="#imprimiendo-hola-mundo">Imprimiendo '¡Hola, mundo!'</a></h1>
<p><strong>Puedes ver este capítulo en YouTube en inglés: <a href="https://youtu.be/yYlPHRl2geQ">Video 1</a>, <a href="https://youtu.be/DTCSfBJJZb8">Video 2</a></strong></p>
<p>Cuando creas un nuevo programa Rust, siempre contiene este código:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<ul>
<li><code>fn</code> significa función.</li>
<li><code>main</code> es el nombre de la función que inicia el programa.</li>
<li><code>()</code> significa que en este caso no se le pasan variables a esta función.</li>
<li><code>{}</code> es un <strong>bloque de código</strong>. Es donde se encuentra el código.</li>
<li><code>println!</code> es una <strong>macro</strong>, que es como una función que sirve para escribir código por ti. Las macros siempre tienen un <code>!</code> al final de su nombre. Por ahora, recuerda que <code>!</code> significa que es una macro.</li>
</ul>
<p>Para aprender lo que hace <code>;</code>, crearemos otra función. Primero, en <code>main</code> imprimiremos el número 8<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<p><sup class="footnote-reference"><a href="#1">1</a></sup> N.T.: aprovechamos para cambiar el saludo a español. En Rust, cuando se utiliza la aplicación <code>cargo</code> para crear un programa, siempre se incorpora el código de <code>main</code> con &quot;Hello, world!&quot; de forma automática. </p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;¡Hola, mundo número {}!&quot;, 8);
}
</code></pre></pre>
<p>Las <code>{}</code> dentro de <code>println!</code> indican a Rust que &quot;ponga la variable en este lugar&quot;. Este código imprime <code>¡Hola, mundo número 8!</code>.</p>
<p>Podemos poner más cosas ampliando lo anterior.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;¡Hola, mundos número {} y {}!&quot;, 8, 9);
}
</code></pre></pre>
<p>El codigo anterior imprime <code>¡Hola, mundos número 8 y 9!</code>.</p>
<p>Ahora vamos a crear una función.</p>
<pre><pre class="playground"><code class="language-rust">fn numero() -&gt; i32 {
    8
}

fn main() {
    println!(&quot;¡Hola, mundo número {}!&quot;, numero());
}
</code></pre></pre>
<p>El código anterior también imprime <code>¡Hola, mundo número 8!</code>. Cuando Rust encuentra <code>numero()</code> entiende que es una función. Esta función:</p>
<ul>
<li>No toma ningún parámetro (porque tiene una llamada con <code>()</code>).</li>
<li>Devuelve un <code>i32</code>. El símbolo de flecha <code>-&gt;</code> muestra el tipo que devuelve la función.</li>
<li>La función en sí misma solo contiene un <code>8</code>. Al no terminar en <code>;</code> este valor es el que devuelve al terminar de ejecutarse. Si tuviera un <code>;</code> detrás, la función no devolvería nada (devolvería un <code>()</code>). Rust no compilaría si contuviera un <code>;</code> al final ya que se ha indicado que (tras la flecha) debe devolver un valor de tipo <code>i32</code> y con el <code>;</code> se devuelve <code>()</code> que no es de tipo <code>i32</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn numero() -&gt; i32 {
    8;
}

fn main() {
    println!(&quot;¡Hola, mundo número {}!&quot;, numero());
}
</code></pre></pre>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:1:16
  |
1 | fn numero() -&gt; i32 {
  |    ------      ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
2 |     8;
  |      - help: consider removing this semicolon
</code></pre>
<p>Esto significa que &quot;me dijiste que <code>numero()</code> devuelve un <code>i32</code>, pero añadiste un <code>;</code> por lo que esta función no devuelve nada&quot;. Así que el compilador sugiere que se elimine el punto y coma.</p>
<p>También se puede escribir lo siguiente <code>return 8;</code>, pero en Rust lo normal es simplemente eliminar el <code>;</code> para ejecutar el <code>return</code>.</p>
<p>Cuando se quiere pasar variables a una función, se deben poner dentro de <code>()</code>. Hay que darles un nombre e indicar su tipo.</p>
<pre><pre class="playground"><code class="language-rust">// Entran a la función dos i32s. Se llaman num_uno y num_dos
fn multiplicar(num_uno: i32, num_dos: i32) {
    let resultado = num_uno * num_dos;
    println!(&quot;{} por {} es {}&quot;, num_uno, num_dos, resultado);
}

fn main() {
    multiplicar(8, 9); // Pasamos unos números directamente
    let algun_numero = 10; // o podemos declarar dos variables
    let algun_otro_numero = 2;
    multiplicar(algun_numero, algun_otro_numero); // y pasarlos a la función
}
</code></pre></pre>
<p>También se puede devolver un <code>i32</code>. Basta con poner la variable <code>resultado</code> como la última de la función sin <code>;</code> al final.</p>
<pre><pre class="playground"><code class="language-rust">fn multiplicar(num_uno: i32, num_dos: i32) -&gt; i32 {
    let resultado = num_uno * num_dos;
    println!(&quot;{} por {} es {}&quot;, num_uno, num_dos, resultado);
    resultado // este es el valor i32 que se retorna
}

fn main() {
    // multiplicar() imprime el resultado y lo devuelve,
    // lo que permite asignarlo a resultado_mult
    let resultado_mult = multiplicar(8, 9);
}
</code></pre></pre>
<h2 id="la-declaración-de-variables-y-los-bloques-de-código"><a class="header" href="#la-declaración-de-variables-y-los-bloques-de-código">La declaración de variables y los bloques de código</a></h2>
<p>Se usa <code>let</code>para declarar una variable (para decirle a Rust que construya una variable).</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_numero = 8;
    println!(&quot;¡Hola, mundo número {}!&quot;, mi_numero);
}
</code></pre></pre>
<p>Las variables existen dentro de un bloque de código <code>{}</code>. En el siguiente ejemplo <code>mi_numero</code> desaparece antes de llamar a <code>println!</code> porque se encuentra dentro de su propio código.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    {
        let mi_numero = 8; // mi_numero se crea aquí
                           // mi_numero se extingue aquí
    }
    println!(&quot;¡Hola, mundo número {}!&quot;, mi_numero);// ⚠️  mi_numero no existe y
                                                   // println!() no lo puede encontrar
}
</code></pre></pre>
<p>Se puede usar un bloque de código para devolver un valor, como en el siguiente código.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_numero = {
        let segundo_num = 8;
        segundo_num + 9 // sin punto y coma, por lo que el
                        // bloque de código devuelve 8 + 9 = 17
    }; 
    println!(&quot;¡Hola, mundo número {}!&quot;, mi_numero);
}
</code></pre></pre>
<p>Si se añadiera un punto y coma en la sentencia final del bloque, devolvería <code>()</code> (nada).</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_numero = {
        let segundo_num = 8; // declara el segundo número
        segundo_num + 9;     // suma 9 con el segundo número
                             // pero no se devuelve
                             // segundo_num desaparece aquí
    }; 
    println!(&quot;¡Hola, mundo número {:?}!&quot;, mi_numero); // mi_numero es ()
}
</code></pre></pre>
<p>Si has observado bien, hemos cambiado <code>{}</code> por <code>{:?}</code>. El motivo se verá en el siguiente capítulo.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="la-visualización-y-depuración"><a class="header" href="#la-visualización-y-depuración">La visualización y depuración</a></h1>
<p><strong><a href="https://youtu.be/jd3pC248c0o">Puedes ver este capítulo en YouTube en inglés</a></strong></p>
<p>En Rust, las variables simples se pueden imprimir usyo <code>{}</code> en <code>println!</code>.  Pero hay variables que no pueden imprimirse y es necesario usar <strong>la impresión de depuración</strong>. La impresión de depuración es para los programadores, porque habitualmente muestra más información. En ocasiones, esta impresión no es &quot;bonita&quot;, no queda bien, porque muestra información extra para ayudarte.</p>
<p>¿Cómo puedes conocer si necesitas usar <code>{:?}</code> y no <code>{}</code>? El compilador te avesará. Por ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let no_imprime = ();
    println!(&quot;Esto no se imprimirá: {}&quot;, no_imprime); // ⚠️
}
</code></pre></pre>
<p>Cuyo se compila el código anterior, el compilador se queja así:</p>
<pre><code class="language-text">error[E0277]: `()` doesn't implement `std::fmt::Desplay`
 --&gt; src/main.rs:3:42
  |
3 |     println!(&quot;Esto no se imprimirá: {}&quot;, no_imprime); // ⚠️
  |                                          ^^^^^^^^^^ `()` cannot be formatted with el default formatter
  |
  = help: el trait `std::fmt::Desplay` es not implemented for `()`
  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
  = note: required by `std::fmt::Desplay::fmt`
  = note: thes error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)
</code></pre>
<p>Esto es mucha información, pero la parte importante es <code>you may be able to use {:?} (or {:#?} for pretty-print) instead</code>. Esto significa que puedes intentar usar <code>{:?}</code> o también <code>{:#?}</code>. La segunda opción, <code>{:#?}</code> se llama &quot;impresión atractiva&quot;. Es igual que <code>{:?}</code> pero usyo un formateo diferente en más líneas.</p>
<p>En resumen, <code>Desplay</code> (vesualización) supone la impresión con <code>{}</code>, y <code>Debug</code> (depuración) supone la impresión con <code>{:?}</code>.</p>
<p>Una última cosa, puedes usar <code>print!</code> sin <code>ln</code> si no quieres que haya un salto de línea al final de la impresión.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    print!(&quot;Esto no imprimirá un salto de línea&quot;);
    println!(&quot; así que esto estará en la mesma línea&quot;);
}
</code></pre></pre>
<p>Que imprimirá <code>Esto no imprimirá un salto de línea así que esto estará en la mesma línea</code>.</p>
<h2 id="el-número-menor-y-el-número-mayor"><a class="header" href="#el-número-menor-y-el-número-mayor">El número menor y el número mayor</a></h2>
<p>Si se quiere ver el menor y mayor número que se puede representar, se puede usar MIN y MAX. <code>std</code> es la &quot;librería estándar del lenguaje&quot; y contiene las funciones y otros elementos importantes del lenguaje Rust. Más adelante se explicarán elementos de la librería estyar. Mientras tanto, puedes recordar que esta es la forma de obtener los numeros menor y mayor de un tipo de datos.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // pista: std::i8::MIN significa
    // &quot;el valor de MIN de la sección i8 de la librería estandar&quot;
    println!(&quot;El menor i8 es {} y el mayor i8 es {}.&quot;, std::i8::MIN, std::i8::MAX); 
    println!(&quot;El menor u8 es {} y el mayor u8 es {}.&quot;, std::u8::MIN, std::u8::MAX);
    println!(&quot;El menor i16 es {} y el mayor i16 es {}.&quot;, std::i16::MIN, std::i16::MAX);
    println!(&quot;El menor u16 es {} y el mayor u16 es {}.&quot;, std::u16::MIN, std::u16::MAX);
    println!(&quot;El menor i32 es {} y el mayor i32 es {}.&quot;, std::i32::MIN, std::i32::MAX);
    println!(&quot;El menor u32 es {} y el mayor u32 es {}.&quot;, std::u32::MIN, std::u32::MAX);
    println!(&quot;El menor i64 es {} y el mayor i64 es {}.&quot;, std::i64::MIN, std::i64::MAX);
    println!(&quot;El menor u64 es {} y el mayor u64 es {}.&quot;, std::u64::MIN, std::u64::MAX);
    println!(&quot;El menor i128 es {} y el mayor i128 es {}.&quot;, std::i128::MIN, std::i128::MAX);
    println!(&quot;El menor u128 es {} y el mayor u128 es {}.&quot;, std::u128::MIN, std::u128::MAX);
}
</code></pre></pre>
<p>Que imprimirá:</p>
<pre><code class="language-text">El menor i8 es -128 y el mayor i8 es 127.
El menor u8 es 0 y el mayor u8 es 255.
El menor i16 es -32768 y el mayor i16 es 32767.
El menor u16 es 0 y el mayor u16 es 65535.
El menor i32 es -2147483648 y el mayor i32 es 2147483647.
El menor u32 es 0 y el mayor u32 es 4294967295.
El menor i64 es -9223372036854775808 y el mayor i64 es 9223372036854775807.
El menor u64 es 0 y el mayor u64 es 18446744073709551615.
El menor i128 es -170141183460469231731687303715884105728 y el mayor i128 es 170141183460469231731687303715884105727.
El menor u128 es 0 y el mayor u128 es 340282366920938463463374607431768211455.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutabilidad-cambio"><a class="header" href="#mutabilidad-cambio">Mutabilidad (cambio)</a></h1>
<p><strong><a href="https://youtu.be/Nyyd6qn7dZY">Puedes ver este capítulo en YouTube en inglés</a></strong></p>
<p>Cuando se declara una variable con `let, es inmutable (no se puede cambiar su valor).</p>
<p>El código siguiente no funciona.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_numero = 8;
    mi_numero = 10; // ⚠️
}
</code></pre></pre>
<p>El compilador indica <code>error[E0384]: cannot assign twice to immutable variable mi_numero</code>.</p>
<pre><code class="language-text">error[E0384]: cannot assign twice to immutable variable `mi_numero`
 --&gt; src/main.rs:3:5
  |
2 |     let mi_numero = 8;
  |         ---------
  |         |
  |         first assignment to `mi_numero`
  |         help: consider making this binding mutable: `mut mi_numero`
3 |     mi_numero = 10; // ⚠️
  |     ^^^^^^^^^^^^^^ cannot assign twice to immutable variable
</code></pre>
<p>Esto es porque las variables son inmutables si solo se escribe <code>let</code>.</p>
<p>Muchas veces, será necesario modificar la variable. Para ello, se debe añadir <code>mut</code> después de <code>let</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut mi_numero = 8;
    mi_numero = 10;
}
</code></pre></pre>
<p>El código anterior funciona sin problema alguno.</p>
<p>Sin embargo, no se le puede cambiar el tipo. Esto no funciona:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut mi_numero = 8; // La variable es i32. 
                           // El tipo no se puede cambiar.
    mi_numero = &quot;¡Hola, mundo!&quot;; // ⚠️
}
</code></pre></pre>
<p>Si se intenta compilar el programa anterior, se obtendrá el mismo mensaje &quot;expected&quot; por parte del compilador: <code>expected integer, found &amp;str</code>. <code>&amp;str</code>es un tipo de cadena que aprenderemos pronto.</p>
<h3 id="ocultación-shadowing"><a class="header" href="#ocultación-shadowing">Ocultación (Shadowing)</a></h3>
<p>La ocultación de una variable sucede cuando se usa <code>let</code> para declarar una nueva variable con el mismo nombre que otra. A primera vista se parece a la mutabilidad, pero es totalmente diferente. En el siguiente ejemplo, se oculta una variable:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_numero = 8; // Esta variable es i32
    println!(&quot;{}&quot;, mi_numero); // imprime 8
    let mi_numero = 9.2; // Esta variable es f64 y tiene el mismo nombre
    // pero es una variable nueva, completamente diferente.
    println!(&quot;{}&quot;, mi_numero) // imprime 9.2
}
</code></pre></pre>
<p>Se dice que hemos &quot;ocultado&quot; <code>mi_numero</code>con un nuevo &quot;enlace&quot;.</p>
<p>¿Se ha destruido la anterior variable <code>mi_numero</code>? No, pero cuando se llama a <code>mi_numero</code> ahora se accede a la segunda variable de tipo <code>f64</code>. Y como ambas declaraciones se encuentran en el mismo bloque de código (mismo ámbito, mismo <code>{}</code>), se deja de tener acceso al <code>mi_numero</code> de tipo <code>i32</code>.</p>
<p>Si estuvieran en diferentes bloques de código, podríamos volver a acceder a la primera variable <code>mi_numero</code>. Por ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_numero = 8; // Esta variable es i32
    println!(&quot;{}&quot;, mi_numero); // imprime 8
    {
        let mi_numero = 9.2; // Esta variable es f64 y tiene el mismo nombre
        // pero es una variable nueva, completamente diferente.
        println!(&quot;{}&quot;, mi_numero) // imprime 9.2
                                  // pero la nueva variable mi_numero
                                  // solo existe hasta aquí
                                  // la anterior ¡sigue viva!
    }
    println!(&quot;{}&quot;, mi_numero); // imprime 8
}
</code></pre></pre>
<p>En resumen, cuando ocultas una variable, no la destruyes. La <strong>bloqueas</strong>.</p>
<p>Qué ventajas tiene el ocultar variables. Es una buena práctica cuando necesitas modificar una variable en muchas ocasiones. Imagina que quieres hacer un conjunto de cálculos matemáticos simples con una variable:</p>
<pre><pre class="playground"><code class="language-rust">fn dos_veces(numero: i32) -&gt; i32 {
    numero * 2
}

fn main() {
    let numero_final = {
        let y = 10;
        let x = 9; // x comienza con 9
        let x = dos_veces(x); // se oculta con el nuevo x: 18
        let x = x + y; // se oculta con el nuevo x: 28
        x // devuelve x: a numero_final se asigna este valor de x
    };
    println!(&quot;El número ahora es: {}&quot;, numero_final)
}
</code></pre></pre>
<p>Sin ocultar las variables anteriores, habría sido necesario pensar diferentes nombres, incluso aunque no nos importen estos valores intermedios:</p>
<pre><pre class="playground"><code class="language-rust">fn dos_veces(numero: i32) -&gt; i32 {
    numero * 2
}

fn main() {
    // Ejemplo sin usar las capacidades de ocultar variables
    let numero_final = {
        let y = 10;
        let x = 9; // x comienza con 9
        let x2 = dos_veces(x); // segundo nombre para x
        let x2_y = x2 + y; // ¡tercer nombre para x!
        x2_y // qué pena no tener disponible la ocultación
             // habríamos podido usar solo una variable x
    };
    println!(&quot;El número ahora es: {}&quot;, numero_final)
}
</code></pre></pre>
<p>En general, se usa la ocultación de variables en estos casos. Cuando se quiere usar una variable para un cálculo y luego otro más, sin tener mucho interés por los valores intermedios.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="la-pila-la-memoria-dinámica-y-los-punteros"><a class="header" href="#la-pila-la-memoria-dinámica-y-los-punteros">La pila, la memoria dinámica y los punteros</a></h1>
<p>La pila (&quot;stack&quot; en inglés), la memoria dinámica (&quot;heap&quot; en inglés) y los punteros son elementos muy importantes en Rust.</p>
<p>La pila y la memoria dinámica son dos tipos de almacenamiento de los datos de un programa durante su ejecución. Sus diferencias más importantes son:</p>
<ul>
<li>La pila es muy rápida, la memoria dinámica no lo es tanto. Tampoco es lenta, pero siempre es más rápido acceder a la pila. Aunque no es posible utilizar la pila siempre porque:</li>
<li>Rust necesita conocer el tamaño de una variable en durante su compilación para poder guardarla en la pila. Así, las variables simples como <code>i32</code> van a la pila ya que se conoce su tamaño exacto. Se sabe que va a ocupar 4 bytes, 32 bits = 4 bytes. Por lo tanto, los datos de tipo <code>i32</code> pueden ir siempre a la pila.</li>
<li>Algunos tipos no tienen un tamaño conocido en tiempo de compilación. No pueden guardarse en la pila. ¿Qué se puede hacer? En primer lugar, se pone la información en la memoria dinámica ya que esta puede contener datos de cualquier tamaño. En segundo lugar, se guarda un puntero en la pila. El tamaño de los punteros es conocid. Así, para recuperar un valor de una variable que está en la memoria dinámica, el ordenador va primero a la pila, obtiene el puntero y lo sigue hasta la memoria dinámica para localizr el dato que se busca.</li>
</ul>
<p>Los punteros parecen complicados, pero no lo son. Son como una tabla de contenidos de un libro. Imagina este libro:</p>
<pre><code class="language-text">MI LIBRO

TABLA DE CONTENIDO

Capítulo                        Página
Capítulo 1: mi vida              1
Capítulo 2: mi gato              15
Capítulo 3: mi trabajo           23
Capítulo 4: mi familia           30
Capítulo 5: mis planes futuros   43
</code></pre>
<p>La tabla de contenido es como una &quot;pila&quot; que, en este caso, contiene cinco punteros. Puedes leerlos y encontrar la información sobre la que tratan. ¿Dónde está el capítulo sobre &quot;mi vida&quot;? Está en la página 1 (<em>Apunta</em> a la página 1). ¿Dónde está el capítulo sobre &quot;mi trabajo&quot;? Está en la página 23.</p>
<p>El puntero que se ve habitualmente en Rust se denomina <strong>referencia</strong>. Esto es lo importante que se debe saber: una referencia apunta a la memoria de otro valor. Una referencia supone que <em>se tome prestado</em> el valor, pero no se apropia de él. Es lo mismo que en el libro anterior: la tabla de contenidos no posee la información. Se encuentra en los capítulos que son los que la poseen. En Rust, las referencias llevan el símbolo <code>&amp;</code> al principio de ellas. Así.</p>
<ul>
<li><code>let mi_variable = 8</code> crea una variable normal, pero</li>
<li><code>let mi_referencia = &amp;mi_variable</code> crea una referencia. Se lee como &quot;mi_referencia es una referencia a mi_variable&quot; o como &quot;mi_referencia se refiere a mi_variable&quot;.</li>
</ul>
<p>Esto significa que <code>mi_referencia</code> solo mira a los datos de <code>mi_variable</code>. <code>mi_variable</code> sigue siendo propietaria de sus datos.
También es posible tener una referencia que &quot;apunte&quot; a otra referencia. Hasta culquier número de referencias.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_numero = 15; // Esto es un i32
    let referencia_simple = &amp;mi_numero; //  Esto es una &amp;i32
    let referencia_doble = &amp;referencia_simple; // Esto es una &amp;&amp;i32
    let referencia_quintuple = &amp;&amp;&amp;&amp;&amp;mi_numero; // Esto es una &amp;&amp;&amp;&amp;&amp;i32
}
</code></pre></pre>
<p>Todos estos son tipos de dato diferentes, de la misma forma que &quot;un amigo de un amigo&quot; es diferente de &quot;un amigo&quot;.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="más-sobre-impresión"><a class="header" href="#más-sobre-impresión">Más sobre impresión</a></h1>
<p>En Rust se puede imprimir como se quiera. Por eso, interesa conocer algunas cosas más sobre este tema.</p>
<p>Si se añade <code>\n</code> se imprimirá una nueva línea. Si se añade <code>\t</code> se insertará un tabulador:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Observa: la función usada es print!, no println!
    print!(&quot;\tComienza con un tabulador\ny salta a una nueva línea&quot;);
}
</code></pre></pre>
<p>El código anterior imprime lo siguiente:</p>
<pre><code class="language-text">        Comienza con un tabulador
y salta a una nueva línea
</code></pre>
<p>Dentro de <code>&quot;&quot;</code> se puede escribir en diferentes líneas, pero es necesario tener cuidado con los espacios:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Nota: después de la primera línea tienes que comenzar la siguiente línea
    // en la primera columna (pegado a la izquierda).
    println!(&quot;Dentro de comillas
se puede escribir
en muchas líneas
y se imprimirá correctamente.&quot;);
    // Si se escribe directamente bajo la sentencia, se añadirán los espacios
    // correspondientes de la izquierda
    println!(&quot;Si se olvida que hay que
    escribir pegado al lado izquierdo
    estos espacios se añadirán
    a la impresión.&quot;);
}
</code></pre></pre>
<p>El código anterior imprime:</p>
<pre><code class="language-text">Dentro de comillas
se puede escribir
en muchas líneas
y se imprimirá correctamente.
Si se olvida que hay que
    escribir pegado al lado izquierdo
    estos espacios se añadirán
    a la impresión.
</code></pre>
<p>Si se necesitase imprimir caracteres como <code>\n</code> (caracteres de escape, como el del salto de línea y el tabulador que se han visto antes), se puede añadir un <code>\</code> extra:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Se imprimen caracteres de escape, no inserta nueva línea y tabulador: \\n y \\t&quot;);
}
</code></pre></pre>
<p>Lo que imprime:</p>
<pre><code class="language-text">Se imprimen caracteres de escape, no inserta nueva línea y tabulador: \n y \t
</code></pre>
<p>A veces se necesitan muchos <code>&quot;</code> y caracteres de escape en el texto, por lo que Rust proporciona un método más simple para ignorarlos: se añade <code>r#</code> al comienzo y <code>#</code> al final de la cadena de caracteres.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // En esta línea hemos usado \ cinco veces
    println!(&quot;Él dijo, \&quot;Puedes encontrar el fichero en c:\\files\\my_documents\\file.txt\&quot;. Y así fue como lo encontré.&quot;);
    println!(r#&quot;Él dijo, &quot;Puedes encontrar el fichero en c:\files\my_documents\file.txt&quot;. Y así fue como lo encontré.&quot;#)
}
</code></pre></pre>
<p>Ambas opciones imprimen lo mismo, pero el uso de <code>r#</code> lo hace más simple de entender.</p>
<pre><code class="language-text">Él dijo, &quot;Puedes encontrar el fichero en c:\files\my_documents\file.txt&quot;. Y así fue como lo encontré.
Él dijo, &quot;Puedes encontrar el fichero en c:\files\my_documents\file.txt&quot;. Y así fue como lo encontré.
</code></pre>
<p>Si se necesitara imprimir un carácter <code>#</code> en el texto, se puede usar <code>r##</code> al comienzo del texto y <code>##</code> al final. Si se usaran más de dos consecutivos, se pueden seguir añadiendo <code>#</code> al comienzo y al final, hasta que no coincida con nada contenido en el texto.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

    let my_string = &quot;'Hola, mundo,' dijo.&quot;; // comilla simples
    let quote_string = r#&quot;&quot;Hola, mundo,&quot; dijo.&quot;#; // comillas dobles
    // Contiene # se necesita al menos ##
    let hashtag_string = r##&quot;El hasgtag #holamundo se ha hecho muy popular.&quot;##; 
    // Contiene ### se necesitan al menos ####
    let many_hashtags = r####&quot;&quot;No se tiene que teclear ### para usar un hashtag. Solo hay que usar #.&quot;&quot;####; 

    println!(&quot;{}\n{}\n{}\n{}\n&quot;, my_string, quote_string, hashtag_string, many_hashtags);
}
</code></pre></pre>
<p>Este código imprimirá:</p>
<pre><code class="language-text">'Hola, mundo,' dijo.
&quot;Hola, mundo,&quot; dijo.
El hasgtag #holamundo se ha hecho muy popular.
&quot;No se tiene que teclear ### para usar un hashtag. Solo hay que usar #.&quot;
</code></pre>
<p>Existe otro uso para <code>r#</code>: usar palabras reservadas (como <code>let</code>, <code>fn</code>, etc.) como nombres de variable.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let r#let = 6; // let como nombre de variable
    let mut r#mut = 10; // Esta variable se llama mut
}
</code></pre></pre>
<p>Esta función de <code>r#</code> se introdujo porque las versiones más antiguas de Rust tenían menos palabras reservadas que ahora. Así se pueden evitar errores en código previo en el que se usaban nombres de variables que ahora son palabras reservadas.</p>
<p>Puede ser que por alguna razón <em>realmente</em> se necesite una función que se denomine como <code>return</code>. Así se puede escribir:</p>
<pre><pre class="playground"><code class="language-rust">fn r#return() -&gt; u8 {
    println!(&quot;Ahí va tu número.&quot;);
    8
}

fn main() {
    let mi_numero = r#return();
    println!(&quot;{}&quot;, mi_numero);
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">Ahí va tu número.
8
</code></pre>
<p>Esto no se va a necesitar normalmente, pero si <em>realmente</em> hace falta, se puede usar.</p>
<p>Si se necesita imprimir los bytes de un <code>&amp;str</code> o un <code>char</code>, basta con escribir la letra <code>b</code> delante de la cadena.
Esto funciona para todos los caracteres ASCII. Estos son todos los caracteres ASCII.</p>
<pre><code class="language-text">☺☻♥♦♣♠♫☼►◄↕‼¶§▬↨↑↓→∟↔▲▼123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
</code></pre>
<p>Así, este código:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // N.T.: no se pueden poner tildes ya que en las 
    // vocales ya que las letras resultantes no forman
    // parte del conjunto de caracteres ASCII
    println!(&quot;{:?}&quot;, b&quot;Esto aparece como una lista de numeros&quot;);
}
</code></pre></pre>
<p>Da el siguiente resultado:</p>
<pre><code class="language-text">[69, 115, 116, 111, 32, 97, 112, 97, 114, 101, 99, 101, 32, 99, 111, 109, 111, 32, 117, 110, 97, 32, 108, 105, 115, 116, 97, 32, 100, 101, 32, 110, 117, 109, 101, 114, 111, 115]
</code></pre>
<p>Para un <code>char</code> esto se llama <em>byte</em> y para el tipo <code>&amp;str</code> se llama <em>byte de cadena de texto</em>.</p>
<p>También existe un sistema de escape para insertar caracteres Unicode: <code>\u{}</code>. Así es posible imprimir cualquier carácter Unicode en una cadena de texto. Además, es posible formatear un número en hexadecimal usando <code>{:X}</code>. El siguiente ejemplo demuestra cómo imprimir el código hexadecimal que representa al carácter Unicode y cómo imprimirlo de nuevo como carácter.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Convierte el char a u32 para obtener su valor numérico
    println!(&quot;{:X}&quot;, '행' as u32); 
    println!(&quot;{:X}&quot;, 'H' as u32);
    println!(&quot;{:X}&quot;, '居' as u32);
    println!(&quot;{:X}&quot;, 'い' as u32);

    // Imprime los caracteres con el sistema de escape \u
    println!(&quot;\u{D589}, \u{48}, \u{5C45}, \u{3044}&quot;); 
}
</code></pre></pre>
<p>Ya se conoce que <code>println!</code> puede imprimir con <code>{}</code> (modo <em>Display</em>) t <code>{:?}</code> (para Depuración). Además de <code>{:#?}</code> para &quot;impresión bonita&quot;. Pero existen otras muchas formas de imprimir.</p>
<p>Por ejempli, si se dispone de una referencia se puede usar <code>{:p}</code> para imprimir la <em>dirección del puntero</em>. Es decir, el lugar de la memoria del ordenador a la que <em>apunta</em> la referencia.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 9;
    let number_ref = &amp;number;
    println!(&quot;{:p}&quot;, number_ref);
}
</code></pre></pre>
<p>El código anterior imprime algo parecido a <code>0x7ffec9426f4c</code>, dependerá de dónde se ejecute el programa y se almacene el número referenciado en la memoria del ordenador.</p>
<p>Los valores numéricos se pueden imprimir en binario, hexadecimal u octal:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 555;
    println!(&quot;Binario: {:b}, hexadecimal: {:x}, octal: {:o}&quot;, number, number, number);
}
</code></pre></pre>
<p>Que imprime <code>Binario: 1000101011, hexadecimal: 22b, octal: 1053</code>.</p>
<p>También se pueden añadir números entre las llaves para indicar qué variable utilizar, teniendo en cuenta que la primera tiene como índice el 0, la segunda el 1 y así sucesivamente.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nombre_padre = &quot;José Miguel&quot;;
    let nombre_hijo = &quot;Víctor&quot;;
    let apellido = &quot;González&quot;;
    println!(&quot;Este es {1} {2}, hijo de {0} {2}.&quot;, nombre_padre, nombre_hijo, apellido);
}
</code></pre></pre>
<p>La variable <code>nombre_padre</code> está en la posición 0, <code>nombre_hijo</code>en la 1 y <code>apellido</code> está en la posición 2. Por eso, el código anterior imprime <code>Este es Víctor González, hijo de José Miguel González.</code>.</p>
<p>Puede suceder que sea necesario imprimir una cadena de caracteres compleja con muchas variables dentro de las llaves. O puede que se necesite imprimir la misma variable dos o más veces. Para ello, se pueden añadir nombres a las llaves.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(
        &quot;{city1} está en {pais} y {city2} también está en {pais},
pero {city3} no está en {pais}.&quot;,
        city1 = &quot;Seul&quot;,
        city2 = &quot;Busan&quot;,
        city3 = &quot;Tokio&quot;,
        pais = &quot;Korea&quot;
    );
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">Seul está en Korea y Busan también está en Korea,
pero Tokio no está en Korea.
</code></pre>
<p>También es posible editar de forma compleja el formato de la impresión. Tiene esta forma:</p>
<p><code>{variable:relleno alineamiento mínimo.máximo}</code></p>
<p>Para entender esta sintaxis:</p>
<ol>
<li>¿Se quiere usar un nombre de variable? Se escribe primero su nombre, como antes en {pais}. Lo siguiente será añadir (opcionalmente) <code>:</code> después si se quiere formatear de algún modo.</li>
<li>¿Se se necesita un carácter de relleno? Por ejemplo, 55 con tres &quot;ceros de relleno&quot; se imprimiría como 00055.</li>
<li>¿Que alineamiento se necesita para el relleno? izquierda, centro o derecha.</li>
<li>¿Se desea una longitud mínima? solo hay que indicar el número deseado.</li>
<li>¿Se desea una longitud máxima? solo hay que indicarla con un <code>.</code> delante.</li>
</ol>
<p>Por ejemplo, si se quiere escribir la letra &quot;a&quot; con cinco caracteres - de relleno (a izquierda y derecha):</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let letra = &quot;a&quot;;
    println!(&quot;{:-^11}&quot;, letra);
}
</code></pre></pre>
<p>Que imprime <code>-----a-----</code>. El ordenador lo interpreta así:</p>
<ul>
<li>¿Hay un nombre de variable? No, ya que lo primero que aparece en <code>{:-^11}</code> son los dos puntos. No hay nombre de variable delante de estos dos puntos.</li>
<li>¿Se pide un carácter de relleno? Sí, - está justo después de <code>:</code> y lo sigue un <code>^</code>, lo que significa que el texto se inserta en el centro y el carácter de relleno se reparte en los espacios sobrantes a izquierda y derecha. Las otras dos posibilidades son: <code>&lt;</code> que indica que el texto va a la izquierda y el carácter de relleno a la izquierda, y <code>&gt;</code> que indica que el texto va a la derecha con el relleno a la izquierda.</li>
</ul>
<p>A continuación, se muestran diversos ejemplos de tipos de formateo.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let titulo = &quot;NOTICIAS DE HOY&quot;;
    // sin variable, relleno con -, centrado, longitud de 30 caracteres
    println!(&quot;{:-^30}&quot;, titulo); 
    let barra = &quot;|&quot;;
    // sin variable, relleno con espacios, 15 caracters cada uno, una barra a izquierda y otra a derecha
    println!(&quot;{: &lt;15}{: &gt;15}&quot;, barra, barra); 
    let a = &quot;SEUL&quot;;
    let b = &quot;TOKIO&quot;;
     // variables city1 y city2, relleno con -, a izquierda y a derecha
     println!(&quot;{city1:-&lt;15}{city2:-&gt;15}&quot;, city1 = a, city2 = b);
}
</code></pre></pre>
<p>El código anterior imprime:</p>
<pre><code class="language-text">-------NOTICIAS DE HOY--------
|                            |
SEUL---------------------TOKIO
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cadenas-de-caracteres"><a class="header" href="#cadenas-de-caracteres">Cadenas de caracteres</a></h1>
<p><strong><a href="https://youtu.be/pSyaGzGg26o">Puedes ver este capítulo en YouTube en inglés</a></strong></p>
<p>Rust tiene dos tipos de cadenas de caracteres: <code>String</code> y <code>&amp;str</code>. ¿Cuál es la diferencia?</p>
<ul>
<li><code>&amp;str</code> es una cadena de caracteres simple que reside en la pila. Cuando se escribe <code>let mi_variable = &quot;¡Hola, mundo!&quot;</code> se crea una <code>&amp;str</code>. Este tipo es muy rápido.</li>
<li><code>String</code> es un tipo de dato más complejo. Es un poco más lento, pero tiene más funciones. Una <code>String</code> es un puntero que almacena los datos en la memoria dinámica.</li>
</ul>
<p>Hay que destacar que <code>&amp;str</code> tiene <code>&amp;</code> como primer carácter debido a que es necesaria una referencia para utilizar el tipo <code>str</code>.  Esto es por la razón que vimos anteriormente: la pila necesita conocer el tamaño, así que se le da una referencia, las referencias siempre tienen el mismo tamaño. Otro tema a tener en cuenta es que al utilizar <code>&amp;</code> una referencia para interactuar con el tipo <code>str</code>, nunca se es dueño del tipo. Por el contrario, <code>String</code>es un tipo <em>con dueño</em>. Más adelante se mostrará la importancia de esta distinción.</p>
<p>Ambos tipos, <code>&amp;str</code> y <code>String</code> son UTF-8. Por ejemplo, se puede escribir el siguiente código:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Nombre en coreano. No da problemas, ya que &amp;str es UTF-8
    let nombre = &quot;서태지&quot;;
    // Ț y ș no son un problema en UTF-8.
    let otro_nombre = String::from(&quot;Adrian Fahrenheit Țepeș&quot;);
}
</code></pre></pre>
<p>En el código anterior se observa que se puede construir de forma fácil una <code>String</code> de una <code>&amp;str</code>. Los dos tipos están muy relacionados, aunque son muy diferentes.</p>
<p>Gracias a UTF-8, incluso se pueden escribir emojis.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nombre = &quot;😂&quot;;
    println!(&quot;Mi nombre real es {}&quot;, nombre);
}
</code></pre></pre>
<p>Si se ejecuta este código en el terminal de comandos de tu propio ordenador tiene que aparecer <code>Mi nombre real es 😂</code> a menos el terminal de comandos presente limitaciones y no lo pueda imprimir. En cuyo caso imprimirá algo así <code>Mi nombre real es �</code>. En todo caso, Rust es capaz de manejar todos los caracteres Unicode.</p>
<p>La razón para utilizar una referencia <code>&amp;</code>para el tipo <code>str</code> es que <code>str</code> es un tipo de datos de tamaño dinámico, su tamaño puede ser diferente. Por ejmplo, los nombres &quot;서태지&quot; y &quot;Adrian Fahrenheit Țepeș&quot; no son del mismo tamaño:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

    // std::mem::size_of::&lt;Type&gt;() devuelve el tamaño en bytes de un tipo
    println!(&quot;Una String siempre ocupa {:?} bytes. Es de tamaño fijo.&quot;,
        std::mem::size_of::&lt;String&gt;()); 
    println!(&quot;Y un i8 siempre ocupa {:?} bytes. Es de tamaño fijo.&quot;, 
        std::mem::size_of::&lt;i8&gt;());
    println!(&quot;Y un f64 siempre ocupa {:?} bytes. Es de tamaño fijo.&quot;, 
        std::mem::size_of::&lt;f64&gt;());
     // std::mem::size_of_val() devuelve el tamaño en bytes de una variable
    println!(&quot;¿Y un &amp;str? Puede ocupar cualquier tamaño. '서태지' ocupa {:?} bytes. No es de tamaño fijo.&quot;,
        std::mem::size_of_val(&quot;서태지&quot;));
    println!(&quot;Y 'Adrian Fahrenheit Țepeș' ocupa {:?} bytes. No es de tamaño fijo.&quot;,
        std::mem::size_of_val(&quot;Adrian Fahrenheit Țepeș&quot;));
}
</code></pre></pre>
<p>Lo que da como resultado:</p>
<pre><code class="language-text">Una String siempre ocupa 24 bytes. Es de tamaño fijo.
Y un i8 siempre ocupa 1 bytes. Es de tamaño fijo.
Y un f64 siempre ocupa 8 bytes. Es de tamaño fijo.
¿Y un &amp;str? Puede ocupar cualquier tamaño. '서태지' ocupa 9 bytes. No es de tamaño fijo.
Y 'Adrian Fahrenheit Țepeș' ocupa 25 bytes. No es de tamaño fijo.
</code></pre>
<p>Por eso es necesario usar &amp;, porque así se construye un puntero (tipo de tamaño fijo) que puede almacenarse en la pila.  Si se escribiera <code>str</code>, Rust no sabría qué hacer al no conocer su tamaño.</p>
<p>Hay muchas formas de construir un elemento de tipo <code>String</code>. Algunas de ellas son:</p>
<ul>
<li><code>String::from(&quot;Esta es una cadena de texto&quot;);</code> - <code>String::from()</code> es un método de Strgin que crea un <code>String</code> a partir de una cadena de texto.</li>
<li><code>&quot;Esta es una cadena de texto&quot;.to_string()</code> - <code>&quot;&quot;.to_string()</code> es un método de <code>&amp;str</code> que crea un <code>String</code>.</li>
<li>La macro <code>format!</code> - Es como <code>println!</code> excepto que crea un String en lugar de imprimir el texto.</li>
</ul>
<p>A continuación se muestran algunos ejemplos:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_name = &quot;Billybrobby&quot;;
    let my_country = &quot;USA&quot;;
    let my_home = &quot;Korea&quot;;

    let together = format!(
        &quot;Soy {} y vengo de {}, pero vivo en {}.&quot;,
        my_name, my_country, my_home
    );
}
</code></pre></pre>
<p>Así se construye un objeto String denominado <em>together</em>, pero no se ha impreso.</p>
<p>Otra forma adicional para crear un String es con la función <code>into()</code>, pero esta forma es algo diferente ya que no solo sirve para crear String. Algunos tipos se pueden convertir de forma fácil en otros utilizando <code>from</code> y <code>into()</code>. Si el tipo tiene <code>from</code>, tiene también <code>into()</code>. <code>from</code> resulta más claro ya que con él conoces los tipos: al usarlo <code>String::from(&quot;Cadena de texto&quot;)</code> se sabe que se crea una <code>String</code> de <code>&amp;str</code>. Sin embargo, con <code>.into()</code> el compilador, a veces, no lo conoce:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_string = &quot;Intento construir un String&quot;.into(); // ⚠️
}
</code></pre></pre>
<p>Rust no conoce el tipo al que se quiere convertir la cadena de texto, porque se pueden crear muchos tipos diferentes a partir de un <code>&amp;str</code>. Rust se queja: puedo convertir &amp;str en muchos tipos diferentes. ¿Cuál es el que quieres?</p>
<pre><code class="language-text">error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let my_string = &quot;Intento construir un String&quot;.into(); // ⚠️
  |         ^^^^^^^^^ consider giving `my_string` a type
</code></pre>
<p>Por lo que se puede corregir así:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_string: String = &quot;Intento construir un String&quot;.into();
}
</code></pre></pre>
<p>Y ahora sí se ha creado un objeto String.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="const-y-static"><a class="header" href="#const-y-static">const y static</a></h1>
<p><strong><a href="https://youtu.be/Ky3HqkWUcI0">Puedes ver este capítulo en YouTube en inglés</a></strong></p>
<p>Además de <code>let</code>, existen dos maneras más de declarar valores. <code>const</code> y <code>static</code>. Para estas declaraciones, Rust no realiza la inferencia de los tipos: es necesario declarar el tipo de los valores. Existen vamores que no cambian (<code>const</code> significa constante). La diferencia entre ellos es que:</p>
<ul>
<li><code>const</code> se utiliza para los valores que no cambian y el nombre se reemplaza por su valor, allí donde se usa.</li>
<li><code>static</code> define una posición fija en memoria que puede actuar como una variable global.</li>
</ul>
<p>Por ello, son casi lo mismo. Los programadores de Rust casi siempre utilizan valores constantes con <code>const</code>.</p>
<p>Por convención, las constantes se suelen escribir con todas las letras en mayúsculas, normalmente están fuera del <code>main</code> para que existan en todo el programas.</p>
<p>Dos ejemplos:</p>
<pre><pre class="playground"><code class="language-rust">const NUMERO_DE_MESES: u32 = 12;
static ESTACIONES: [&amp;str; 4] = [&quot;Primavera&quot;, &quot;Verano&quot;, &quot;Otoño&quot;, &quot;Invierno&quot;];

fn main() {
    println!(&quot;{}&quot;, NUMERO_DE_MESES);
    println!(&quot;{:?}&quot;, ESTACIONES);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="algo-más-sobre-referencias"><a class="header" href="#algo-más-sobre-referencias">Algo más sobre referencias</a></h1>
<p><strong><a href="https://youtu.be/R13sQ8SNoEQ">Puedes ver este capítulo en YouTube en inglés</a></strong></p>
<p>Las referencias son muy importantes en Rust. Las utiliza para asegurarse de que son seguros todos los accesos a la memoria. Ya se ha explicado anteriormente que para crear una referencia se utiliza <code>&amp;</code> delante del valor:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let pais = String::from(&quot;Austria&quot;);
    let ref_uno = &amp;pais;
    let ref_dos = &amp;pais;

    println!(&quot;{}&quot;, ref_uno);
}
</code></pre></pre>
<p>El código anterior imprime <code>Austria</code>. <code>pais</code> es un <code>String</code>. Se crean dos referencias a <code>pais</code>. Estas referencias son de tipo <code>&amp;String</code>, es decir son dos variables que son &quot;referencias a String&quot;. Se pueden crear tantas referencias a <code>pais</code>como se quiera. Todas &quot;apuntan&quot; al mismo valor, pero son punteros diferentes.</p>
<p>A continuación se muestra un ejemplo sobre cómo Rust proteje el acceso a zonas de memoria erróneas:</p>
<pre><pre class="playground"><code class="language-rust">fn return_str() -&gt; &amp;str {
    let pais = String::from(&quot;Austria&quot;);
    let pais_ref = &amp;pais;
    pais_ref // ⚠️
}

fn main() {
    let pais = return_str();
}
</code></pre></pre>
<p>La función <code>return_str()</code> crea un valor de tipo String, luego crea una referencia a dicho valor. Cuando se intenta devolver la referencia se produce un error:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:1:20
  |
1 | fn return_str() -&gt; &amp;str {
  |                    ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
  |
1 | fn return_str() -&gt; &amp;'static str {
  |                    ^^^^^^^^
</code></pre>
<p>El valor de <code>pais</code> solo existe dentro de la función, al terminar de ejecutarse desaparece. Una vez la variable desaparece, el ordenador libera la memoria que ocupaba y la utiliza para otra cosa. Por eso, después de que la función termina, <code>pais_ref</code> apunta a una zona de memoria que ya no tiene el valor esperado y eso no es correcto. Rust previene este fallo en el código e impide que el programa compile.</p>
<p>Este es el efecto importante de la existencia de tipos de dato &quot;con dueño&quot; en Rust. En el código anterior, el valor <code>String</code> tiene como dueño a la variable <code>pais</code>, por eso se puede &quot;prestar&quot; a otras variables (referencias), pero cuando desaparece la variable dueña del valor, <code>pais</code>, la referencia también desaparece, la referencia tiene &quot;prestado&quot; el valor, por lo que no se puede pasar a otro &quot;dueño&quot;.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="referencias-modificables-mutables"><a class="header" href="#referencias-modificables-mutables">Referencias modificables (mutables)</a></h1>
<p><strong><a href="https://youtu.be/G48z6Rv76vc">Puedes ver este capítulo en YouTube en inglés</a></strong></p>
<p>Si se necesita modificar un valor a través de una referencia, se debe indicar que la referencia sea modificable (mutable). Para ello, se utiliza <code>&amp;mut</code> en lugar de <code>&amp;</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // no hay que olvidar que hay que escribir mut en la variable original
    let mut mi_numero = 8;
    let num_ref = &amp;mut mi_numero;
}
</code></pre></pre>
<p><code>mi_numero</code> es de tipo <code>i32</code>, y <code>num_ref</code> es de tipo <code>&amp;mut i32</code> (es una &quot;referencia modificable/mutable a un valor <code>ì32</code>).</p>
<p>Si se desea usar esta referencia para sumar 10, no se puede usar <code>num_ref += 10</code> ya que <code>num_ref</code> no es de tipo <code>i32</code>, es <code>&amp;i32</code>. Para obtener el valor de la referencia, se debe usar <code>*</code> que significa que &quot;no se necesita la referencia, sino el valor que al que representa&quot;. En otras palabras, <code>*</code> es lo opuesto a <code>&amp;</code>, un <code>*</code> borra a un <code>&amp;</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut mi_numero = 8;
    let num_ref = &amp;mut mi_numero;
    *num_ref += 10; // Usa * para cambiar el valor i32
    println!(&quot;{}&quot;, mi_numero);

    let segundo_numero = 800;
    let triple_referencia = &amp;&amp;&amp;segundo_numero;
    println!(&quot;segundo_numero = ¿triple_referencia? {}&quot;,
        segundo_numero == ***triple_referencia);
}
</code></pre></pre>
<p>El código anterior, da como resultado:</p>
<pre><code class="language-text">18
segundo_numero = ¿triple_referencia? true
</code></pre>
<p>El uso del operador sobre una variable <code>&amp;</code> se denomina &quot;referenciar&quot;. El uso del operador sobre una variable de referencia <code>*</code> se denomina &quot;<strong>des</strong>referenciar&quot;.</p>
<p>Rust usa dos reglas para las referencias mutables e inmutables. Son muy importantes y fáciles de recordar porque tienen sentido.</p>
<ul>
<li><strong>Regla 1</strong>: Si solo existen referencias inmutables a un valor, se pueden tener tantas como se quiera.</li>
<li><strong>Regla 2</strong>: Si existe una referencia mutable a un valor, solo puede existir una referencia. Esto último significa que no pueden existir a la vez referencias inmutables y mutables en el mismo momento.</li>
</ul>
<p>Estas reglas son necesarias debido a que las referencias mutables pueden cambiar los datos. Sería problemático que se modificara un dato cuando otras referencias lo están usando.</p>
<p>Un forma de entenderlo es pensar en la creación de una presentación de Powerpoint <sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>No se trata de un ejemplo excesivamente bueno, ya que actualmente es posible editar simultáneamente en Office 365.</p>
</div>
<p>El primer caso representa el de <strong>la existencia de una referencia mutable</strong>: un empleado está editando una presentación de Powerpoint. Piode ayuda a su jefe. El empleado entrega sus credenciales de acceso a su jefe para que pueda editar el Powerpoint. Ahora el jefe tiene una &quot;referencia mutable&quot; a la presentación de su empleado. El jefe puede hacer los cambios que quiera y devolver el ordenador más tarde. Nadie más tiene acceso a la presentación, por lo que este caso no da problemas.</p>
<p>El segundo caso representa el de **la existencia únicamente de referencias inmutables&quot;: El empleado entrega la presentación a 100 personas. Todas ellas pueden verla. Tienen una &quot;referencia inmutable&quot; a la presentación ya que nadie puede modificarla, por lo que este caso no da problemas.</p>
<p>El tercer caso representa la <strong>situación problemática a evitar</strong>: El empleado entrega sus credenciales de acceso a su jefe, que a partir de aquí dispone de una &quot;referencia mutable&quot;. Además, el empleado entrega la presentación a 100 personas. El jefe puede entrar a editar y estas modificaciones pueden verse o no por parte de las 100 personas, según el momento en que accedan sin que puedan controlar.</p>
<p>Se puede ver que el intento de usar una referencia mutable simultáneamente con una inmutable no es aceptado por el compilador:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut numero = 10;
    let numero_ref = &amp;numero;
    let numero_modif = &amp;mut numero;
    *numero_modif += 10;
    println!(&quot;{}&quot;, numero_ref); // ⚠️
}
</code></pre></pre>
<p>El compilador muestra un mensaje explicativo muy claro para mostrar el problema:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `numero` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:4:24
  |
3 |     let numero_ref = &amp;numero;
  |                      ------- immutable borrow occurs here
4 |     let numero_modif = &amp;mut numero;
  |                        ^^^^^^^^^^^ mutable borrow occurs here
5 |     *numero_modif += 10;
6 |     println!(&quot;{}&quot;, numero_ref); // ⚠️
  |                    ---------- immutable borrow later used here
</code></pre>
<p>Sin embargo, este código sí funciona. ¿Por qué?</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut numero = 10;
    let numero_modif = &amp;mut numero; // referencia modificable
    *numero_modif += 10; // suma 10
    let numero_ref = &amp;numero; // referencia inmutable
    println!(&quot;{}&quot;, numero_ref); // imprime el valor referenciado
}
</code></pre></pre>
<p>Imprime <code>20</code> sin problemas. Funciona porque el compilador es suficientemente inteligente para comprender el código. Conoce que se ha cmabiado <code>numero</code> a través de la referencia <code>numero_modif</code>, pero después, esta referencia mutable no se vuelve a usar. Por eso no hay problema aquí. No se usan &quot;a la vez&quot; referencias inmutables y mutables (como sí pasaba en el caso anterior).</p>
<p>En versiones anteriores de Rust, este código sí daba error, pero actualmente no lo hace ya que el compilador es más inteligente. Puede entender no solo lo que se ha tecleado, sino como se usa todo.</p>
<h2 id="ocultación-shadowing-de-nuevo"><a class="header" href="#ocultación-shadowing-de-nuevo">Ocultación (shadowing) de nuevo</a></h2>
<p>Es necesario recordar que el ocultamiento de variables no destruye sus valores, sino que los bloquea. Con el uso de las referencias esto se ve más claro.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let pais = String::from(&quot;Austria&quot;);
    let pais_ref = &amp;pais;
    let pais = 8;
    println!(&quot;{}, {}&quot;, pais_ref, pais);
}
</code></pre></pre>
<p>¿Qué imprime este código? ¿<code>Austria, 8</code> o <code>8, 8</code>? Imprime <code>Austria, 8</code>. En la primera línea, se declara una variable <code>String</code> con el valor <code>Austria</code> y denominada <code>pais</code>. En la segunda línea se crea una referencia al valor de esta variable. Es decir, a la <code>String</code> que contiene <code>Austria</code>. Después, se oculta la variable <code>pais</code> con una nueva cuyo valor es <code>8</code> y que es de tipo <code>i32</code>. El primer elemento <code>pais</code> no se destruyó (lo hará al finalizar el ámbito en el que está, en la llave de cierre de este bloque), por lo que sigue accesible a través de la referencia <code>pais_ref</code>. Para mayor claridad, se vuelve a mostrar el código, ahora con comentarios sobre su comportamiento.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let pais = String::from(&quot;Austria&quot;); // String denominada pais
    let pais_ref = &amp;pais; // pais_ref es una referencia al valor
    let pais = 8; // nueva variable pais con un valor 8. Sin relación con la anterior, ni con pais_ref
    println!(&quot;{}, {}&quot;, pais_ref, pais); // pais_ref sigue &quot;apuntando&quot; al dato Austria
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="paso-de-referencias-a-funciones"><a class="header" href="#paso-de-referencias-a-funciones">Paso de referencias a funciones</a></h1>
<p><strong>Puedes ver este capítulo en Youtube en inglés: <a href="https://youtu.be/mKWXt9YTavc">referencias inmutables</a> y <a href="https://youtu.be/kJV1wIvAbyk">referencias mutables</a></strong></p>
<p>Las referencias son muy útiles en las funciones. La regla de Rust para todos los valores es que un valor solo puede tener una variable propietario.</p>
<p>Este código no funcionará:</p>
<pre><pre class="playground"><code class="language-rust">fn print_pais(pais_nombre: String) {
    println!(&quot;{}&quot;, pais_nombre);
}

fn main() {
    let pais = String::from(&quot;Austria&quot;);
    print_pais(pais); // Se imprime &quot;Austria&quot;
    print_pais(pais); // ⚠️ Se intenta de nuevo, pero no funciona
}
</code></pre></pre>
<p>Devuelve el siguiente error:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `pais`
 --&gt; src/main.rs:8:16
  |
6 |     let pais = String::from(&quot;Austria&quot;);
  |         ---- move occurs because `pais` has type `String`, which does not implement the `Copy` trait
7 |     print_pais(pais); // Se imprime &quot;Austria&quot;
  |                ---- value moved here
8 |     print_pais(pais); // ⚠️ Se intenta de nuevo, pero no funciona
  |                ^^^^ value used here after move
</code></pre>
<p>La variable <code>pais</code> ya no existen en la última línea. El funcionamiento es el siguiente:</p>
<ul>
<li>Paso 1: Se crea el valor de tipo <code>String</code> cuyo dueño es la variable <code>pais</code>.</li>
<li>Paso 2: Se pasa <code>pais</code> a la función <code>print_pais</code>. Es una función que no tiene <code>-&gt;</code> en su declaración, por lo que no retorna ningún valor. Al hacer la llamada, la variable <code>pais_nombre</code> (parámetro) es la nueva dueña del valor. Después de que esta función finaliza, <code>pais_nombre</code> desaparece, como es la dueña del valor, este también se destruye.</li>
<li>Paso 3: Se intenta pasar por segunda vez <code>pais</code> a la función `print_pais, pero ya no existe ya que dejó de ser dueña del valor y el valor despareció dentro de la primera llamada a la función.</li>
</ul>
<p>Se podría hacer que la función <code>print_pais</code> devolviera de nuevo el valor <code>String</code>, pero es poco ortodoxo.</p>
<pre><pre class="playground"><code class="language-rust">fn print_pais(pais_nombre: String) -&gt; String {
    println!(&quot;{}&quot;, pais_nombre);
    pais_nombre // se devuelve el valor
}

fn main() {
    let pais = String::from(&quot;Austria&quot;);
    let pais = print_pais(pais); // Es necesario crear una nueva variable para recuperar el valor
    print_pais(pais);
}
</code></pre></pre>
<p>Ahora sí funciona e imprime:</p>
<pre><code class="language-text">Austria
Austria
</code></pre>
<p>Es mucho mejor evitar que la variable <code>print_nombre</code>, parámetro de la función, sea dueña del valor, solamente se &quot;presta&quot;, sin que la variable <code>pais</code> de la función <code>main</code> deje de ser su dueño.</p>
<pre><pre class="playground"><code class="language-rust">fn print_pais(pais_nombre: &amp;String) {
    println!(&quot;{}&quot;, pais_nombre);
}

fn main() {
    let pais = String::from(&quot;Austria&quot;);
    print_pais(&amp;pais); // Se imprime &quot;Austria&quot;
    print_pais(&amp;pais); // Se intenta de nuevo y funciona correctamente
}
</code></pre></pre>
<p>En este caso <code>print_pais()</code> toma una referencia a una <code>String</code>: <code>&amp;String</code>. Cuando se llama <code>print_pais()</code> se pasa una referencia con <code>&amp;pais</code>. Esto significa que &quot;la función puede acceder al valor, pero no se hace dueña de él&quot;.</p>
<p>A continuación, se muestra un ejemplo similar para observar el comportamiento de las referencias modificables (mutables).</p>
<pre><pre class="playground"><code class="language-rust">fn añade_hungria(pais_nombre: &amp;mut String) { // se pasa una referencia mutable
    pais_nombre.push_str(&quot;-Hungría&quot;); // push_str() añade un &amp;str a un String
    println!(&quot;Ahora dice: {}&quot;, pais_nombre);
}

fn main() {
    // es importante que la variable se declare
    // como mutable para poder crear referencias mutables
    let mut pais = String::from(&quot;Austria&quot;);
    añade_hungria(&amp;mut pais); // hay que pasar la referencia mutable.
    println!(&quot;Y el valor se ha modificado aquí: {}&quot;, pais);
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">Ahora dice: Austria-Hungría
Y el valor se ha modificado aquí: Austria-Hungría
</code></pre>
<p>En resumen:</p>
<ul>
<li><code>fn nombre_de_funcion(variable: String)</code> toma un <code>String</code> y se hace dueño de él.</li>
<li><code>fn nombre_de_funcion(variable: &amp;String)</code> toma prestado un <code>String</code> y puede acceder a su valor.</li>
<li><code>fn nombre_de_funcion(variable: &amp;mut String)</code> toma prestado un <code>String</code>, puede acceder a su valor y modificarlo.</li>
</ul>
<p>El siguiente ejemplo puede parecer similar, pero es muy diferente. Sirve para mostrar cómo quien se hace dueño de un objeto puede decidir que sea modificable, aunque anteriormente no lo fuese.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let pais = String::from(&quot;Austria&quot;); // pais no es mutable, ni referencia
    añadir_hungria(pais);
}

fn añadir_hungria(mut pais: String) { // añadir_hungria declara su parámetro como mutable
    pais.push_str(&quot;-Hungría&quot;);
    println!(&quot;{}&quot;, pais);
}
</code></pre></pre>
<p>La función <code>añadir_hungria</code> se hace dueña del valor en su variable <code>mut pais</code>. A partir de ahí, puede hacer con este valor lo que quiera.</p>
<p>Si se recuerda el ejemplo anterior sobre el empleado, su jefe y la presentación en powerpoint, esta es la situación en la que el empleado le da el control completo al jefe. El empleado no puede volver a tocar la presentación y el jefe puede hacer lo que quiera con ella.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="copia"><a class="header" href="#copia">Copia</a></h1>
<p>Algunos tipos de Rust son muy simples. Se almacenan todos en la pila ya que el compilador conoce su tamaño. Esto significa que son fáciles de copiar, por lo que el compilador siempre los copia cuando se envían a una función. Son valores de tamaño fijo, conocido y pequeño. En estos casos, no hay necesidad de preocuparse por quién es el dueño de estos tipos de dato. A estos tipos, se los denomina <strong>tipos copia</strong> (Copy Types, en inglés).</p>
<p>Estos tipos simples incluyen a los enteros, flotantes, booleanos (<code>true</code> -verdadero- y <code>false</code> -falso-) y <code>char</code>.</p>
<p>Para que los tipos se puedan copiar tienen que <strong>implementar</strong> la posibilidad de copia (copy). Se puede consultar la documentación de cada tipo para conocerlo. Por ejemplo, esta es la documentación del tipo <code>char</code>:</p>
<p><a href="https://doc.rust-lang.org/std/primitive.char.html">https://doc.rust-lang.org/std/primitive.char.html</a></p>
<p>A la izquierda de esta documentación se puede ver <strong>Trait Implementations</strong>. Se muestran, entre otras: <strong>Copy</strong>, <strong>Debug</strong> y <strong>Display</strong>. Lo que permite conocer que <code>char</code> puede:</p>
<ul>
<li>Copiarse cuando se pasa como parámetro a una función (<strong>Copy</strong>).</li>
<li>Puede usar <code>{}</code> para imprimir (<strong>Display</strong>).</li>
<li>Puede usar <code>{:?}</code> para imprimir (<strong>Debug</strong>).</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn prints_number(numero: i32) { // Esta función no tiene -&gt;, no devuelve ningún valor
                             // Si el número no se copiara, esta función se haría au propietaria 
                             // y no se podría volver a usar
    println!(&quot;{}&quot;, numero);
}

fn main() {
    let mi_numero = 8;
    prints_number(mi_numero); // Imprime 8. prints_number obtiene una copia del número
    prints_number(mi_numero); // Imprime 8 de nuevo.
                              // No hay problema ya que mi_numero es un tipo que se copia
}
</code></pre></pre>
<p>Sin embargo, si se revisa la documentación de <code>String</code> se ve que no es un tipo que se copie.</p>
<p><a href="https://doc.rust-lang.org/std/string/struct.String.html">https://doc.rust-lang.org/std/string/struct.String.html</a></p>
<p>A la izquierda de esta documentación se puede ver <strong>Trait Implementations</strong>, en orden alfabético. En la C no está <strong>Copy</strong>. Lo que sí aparece es <strong>Clone</strong>, que es similar a *<em>Copy</em>, solo que es necesario invocarlo expresamente con el método <code>clone()</code>. Es decir, que no se clona por sí mismo, se tiene que pedir expresamente.</p>
<p>En el siguiente ejemplo, <code>prints_country()</code> imprime el nombre del país, que es de tipo <code>String</code>. Se quiere, como en el caso anterior, imprimir dos veces, pero no es posible:</p>
<pre><pre class="playground"><code class="language-rust">fn prints_country(country_name: String) {
    println!(&quot;{}&quot;, country_name);
}

fn main() {
    let country = String::from(&quot;Kiribati&quot;);
    prints_country(country);
    prints_country(country); // ⚠️
}
</code></pre></pre>
<p>El mensaje es autoexplicativo:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `country`
 --&gt; src\main.rs:4:20
  |
2 |     let country = String::from(&quot;Kiribati&quot;);
  |         ------- move occurs because `country` has type `std::string::String`, which does not implement the `Copy` trait
3 |     prints_country(country);
  |                    ------- value moved here
4 |     prints_country(country);
  |                    ^^^^^^^ value used here after move
</code></pre>
<p>Dice que <code>String</code> no implementa el rasgo necesario para copiar <code>Copy trait</code>. Sin embargo, se ha visto que sí implementa el rasgo <code>Clone</code>, por lo que se puede añadir <code>.clone()</code> al código para generar de forma expresa una copia del valor. De este modo, se puede enviar un clon del valor a la función. Así, después de llamar a la función, la variable <code>country</code> continúa vigente y se puede utilizar.</p>
<pre><pre class="playground"><code class="language-rust">fn prints_country(country_name: String) {
    println!(&quot;{}&quot;, country_name);
}

fn main() {
    let country = String::from(&quot;Kiribati&quot;);
    prints_country(country.clone()); // crea un clon y lo pasa a la función. country sigue vigente
    prints_country(country);
}
</code></pre></pre>
<p>Evidentemente, si el <code>String</code> es muy largo, generar un clon requiere el uso de mucha memoria. Una cadena de texto <code>String</code> puede ser de la longitud de un libro entero, y cada vez que se llama a <code>.clone()</code> se genera una copia completa. Por eso, es recomendable el uso de <code>&amp;</code> para utilizar una referencia cuando sea posible. Por ejemplo, el código siguiente añade una cadena de texto <code>&amp;str</code> en una <code>String</code> y después crea un clon cada vez que se utiliza en una función:</p>
<pre><pre class="playground"><code class="language-rust">fn get_length(input: String) { // Se apropia de la cadena de texto
    println!(&quot;Tiene una longitud de {} palabras.&quot;, input.split_whitespace().count()); // la divide para contar el número de palabras
}

fn main() {
    let mut my_string = String::new();
    for _ in 0..50 {
        my_string.push_str(&quot;Aquí van palabras en español &quot;); // añade las palabras
        get_length(my_string.clone()); // obtiene un nuevo clon cada vez
    }
}
</code></pre></pre>
<p>Lo que imprime es:</p>
<pre><code class="language-text">Tiene una longitud de 5 palabras.
Tiene una longitud de 10 palabras.
...
Tiene una longitud de 250 palabras
</code></pre>
<p>Esto genera 50 clones. El siguiente código cumple la misma función usando referencias y es mucho más eficiente:</p>
<pre><pre class="playground"><code class="language-rust">fn get_length(input: &amp;String) {
    println!(&quot;Tiene una longitud de {} palabras.&quot;, input.split_whitespace().count());
}

fn main() {
    let mut my_string = String::new();
    for _ in 0..50 {
        my_string.push_str(&quot;Aquí van palabras en español &quot;);
        get_length(&amp;my_string);
    }
}
</code></pre></pre>
<p>Con el código anterior no se genera ningún clon.</p>
<h2 id="variables-sin-valores"><a class="header" href="#variables-sin-valores">Variables sin valores</a></h2>
<p>Una variables sin valor está <em>sin inicializar</em>. Para crear una variable en este estado se usa <code>let</code> y el nombre de la variable:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_variable; // ⚠️
}
</code></pre></pre>
<p>Rust no compila si hay alguna variable sin inicializar.</p>
<p>Sin embargo, en ocasiones pueden ser útiles. Un claro ejemplo es cuando:</p>
<ul>
<li>Se tiene un bloque de código en el que se genera el valor necesario para la variable y...</li>
<li>...la variable tiene que sobrevivir fuera del bloque de código.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn loop_then_return(mut counter: i32) -&gt; i32 {
    loop {
        counter += 1;
        if counter % 50 == 0 {
            break;
        }
    }
    counter
}

fn main() {
    let my_number;

    { // Este bloque es innecesario, pero se crea para documentar caso
        let number = {
            // Aquí podria haber mucho código
            // para generar un valor, por ejemplo:
            57
        };

        my_number = loop_then_return(number);
    }

    println!(&quot;{}&quot;, my_number);
}
</code></pre></pre>
<p>Este ejemplo imprime <code>100</code>.</p>
<p>Se observa que <code>my_number</code> se declarón en la función <code>main()</code>, por lo que su tiempo de vida dura hasta su finalización. Y obtiene su valor dentro del bucle <code>loop</code>. El valor pasa a ser propiedad de <code>my_number</code> antes de salir del bloque.</p>
<p>Si se hubiera declarado y asignado el valor en la misma línea con <code>let my_number = loop_then_return(number)</code> dentro del bloque, la variable hubiera desaparecido con el bloque.</p>
<p>De forma simplificada, ayuda a verlo el sustituir la función por su valor de retorno, 100. Se ve en el siguiente código:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number;
    {
        my_number = 100;
    }

    println!(&quot;{}&quot;, my_number);
}
</code></pre></pre>
<p>Es casi como escribir <code>let my_number = { 100 };</code>.</p>
<p>Se debe observar que <code>my_number</code> no es <code>mut</code>. No se le asigna un valor hasta que se asigna el 100, por lo que no ha cambiado de valor. En el fondo el código real para <code>my_number</code> es solo <code>let my_number = 100;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tipos-colección"><a class="header" href="#tipos-colección">Tipos colección</a></h1>
<p>Rust tiene muchos tipos para construir una colección. La colecciones sirven para almacenar más de un valor en un mismo lugar. Por ejemplo, permiten almacenar la información sobre todas las ciudades de un país en una variable.</p>
<p>Se iniciará con los arrays, que son los más rápidos, pero también los que tienen la funcionalidad más limitada. En este sentido, son como el tipo <code>&amp;str</code>.</p>
<h2 id="arrays"><a class="header" href="#arrays">Arrays</a></h2>
<p>Son los datos guardados dentro de corchetes: <code>[]</code>.</p>
<p>Los Arrays:</p>
<ul>
<li>No pueden cambiar de tamaño.</li>
<li>Tienen datos del mismo tipo.</li>
</ul>
<p>Sin embargo, son muy rápidos.</p>
<p>El tipo de un array es: <code>[tipo; longitud]</code>. Por ejemplo, el tipo de <code>[&quot;Uno&quot;, &quot;Dos&quot;]</code> es <code>[&amp;str; 2]</code>. Esto significa que los siguientes dos arrays tienen tipos diferentes:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let array1 = [&quot;One&quot;, &quot;Two&quot;]; // Este es de tipo [&amp;str; 2]
    let array2 = [&quot;One&quot;, &quot;Two&quot;, &quot;Five&quot;]; // Y este de tipo [&amp;str; 3]. ¡Son dos tipos diferentes!
}
</code></pre></pre>
<p>Para conocer el tipo de una variable se puede &quot;pedir&quot; al compilador que haga algo con ella que no sea válido, por ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let seasons = [&quot;Spring&quot;, &quot;Summer&quot;, &quot;Autumn&quot;, &quot;Winter&quot;];
    let seasons2 = [&quot;Spring&quot;, &quot;Summer&quot;, &quot;Fall&quot;, &quot;Autumn&quot;, &quot;Winter&quot;];
    seasons.ddd(); // ⚠️
    seasons2.thd(); // ⚠️ también
}
</code></pre></pre>
<p>El compilador dice, &quot;¿Qué haces? No existe el método <code>.ddd()</code> para la variable seasons y tampoco existe el método <code>.thd()</code> para seasons2&quot; como puedes ver:</p>
<pre><code class="language-text">error[E0599]: no method named `ddd` found for array `[&amp;str; 4]` in the current scope
 --&gt; src\main.rs:4:13
  |
4 |     seasons.ddd(); // 
  |             ^^^ method not found in `[&amp;str; 4]`

error[E0599]: no method named `thd` found for array `[&amp;str; 5]` in the current scope
 --&gt; src\main.rs:5:14
  |
5 |     seasons2.thd(); // 
  |              ^^^ method not found in `[&amp;str; 5]`
</code></pre>
<p>Y dice que <code>method not found in `[&amp;str; 4]`</code>, que es el tipo del array.</p>
<p>Si se necesita un array con el mismo valor en todos los elementos, se puede declarar de la siguiente forma:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_array = [&quot;a&quot;; 10];
    println!(&quot;{:?}&quot;, my_array);
}
</code></pre></pre>
<p>Que imprime <code>[&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;]</code>.</p>
<p>Este método se utiliza mucho para crear buffers. Por ejemplo, <code>let mut buffer = [0;640]</code> crea un array de 640 ceros. Posteriormente, se puede modificar el valor cero por otro dato.</p>
<p>Se pueden indexrar los valores (recuperarlos) con <code>[]</code>. El primer valor es <code>[0]</code>, el segundo <code>[1]</code> y así sucesivamente.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_numbers = [0, 10, -20];
    println!(&quot;{}&quot;, my_numbers[1]); // imprime 10
}
</code></pre></pre>
<p>Se puede obtener una sección (slice) de un array. Lo primero que se necesita es una referencia <code>&amp;</code> porque el compilador no conoce el tamaño. Después se puede usar <code>..</code> para mostrar el rango.</p>
<p>Por ejemplo, si se utiliza el siguiente array: <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let array_of_ten = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    let three_to_five = &amp;array_of_ten[2..5];
    let start_at_two = &amp;array_of_ten[1..];
    let end_at_five = &amp;array_of_ten[..5];
    let everything = &amp;array_of_ten[..];

    println!(&quot;Tres a cinco: {:?}, comienza en el segundo: {:?}, finaliza en el quinto: {:?}, todo: {:?}&quot;, three_to_five, start_at_two, end_at_five, everything);
}
</code></pre></pre>
<p>Se debe recordar que:</p>
<ul>
<li>Los números de índice comienzan en 0 (no en 1).</li>
<li>los rangos son <strong>excluyentes</strong> (es decir, no incluyen el último número).</li>
</ul>
<p>Así, <code>[0..2]</code> obtiene el primer y segundo valor (0 y 1). Dicho de otro modo, el índice cero y uno. No obtiene el tercer valor, cuyo  índice es dos.</p>
<p>Es posible establecer un rango <strong>inclusivo</strong>, que sí incluya el último número del rango. Para ello se escribe <code>..=</code>, en lugar de <code>..</code>. Así que <code>[0..=2]</code> permite obtener el primer, segundo y tercer elemento del array.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vectores"><a class="header" href="#vectores">Vectores</a></h1>
<p><strong><a href="https://youtu.be/Eh-DsRnDKmw">Puedes ver este capítulo en Youtube en inglés</a></strong></p>
<p>Del mismo modo que se dispone de <code>&amp;str</code> y <code>String</code>, se dispone de arrays y vectores. Los arrays son más rápidos, pero tienen menos funcionalidad, y los vectores son más lentos, pero tienen más funcionalidad (Rust siempre es muy rápido, solo que los vectores no son tan rápidos como los arrays). El tipo es <code>Vec</code> y, por lo tanto, se le puede llamar como &quot;vec&quot;.</p>
<p>Existen principalemente dos formas de declarar un vector. Una es igual a como se crea un <code>String</code>, mediante el uso de <code>new</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let name1 = String::from(&quot;Windy&quot;);
    let name2 = String::from(&quot;Gomesy&quot;);

    let mut my_vec = Vec::new();
    // Si se compilara este programa hasta aquí, el compilador dará un error.
    // ya que no conoce el tipo de datos del vec.

    my_vec.push(name1); // Ahora sí lo conoce, es un Vec&lt;String&gt;
    my_vec.push(name2);
}
</code></pre></pre>
<p>Los <code>Vec</code> siempre contienen valores y para eso sirven <code>&lt;&gt;</code> (los paréntesis angulares). Un <code>Vec&lt;String&gt;</code> es un vector que contiene elementos <code>String</code>. Algunos otros ejemplos son:</p>
<ul>
<li><code>Vec&lt;(i32, i32)&gt;</code> es un vector en el que cada elemento de contenido es una tupla <code>(i32, i32)</code>.</li>
<li><code>Vec&lt;Vec&lt;String&gt;&gt;</code> es un vector en el que cada elemento es otro vector de <code>String</code>. Por ejemplo, se puede pensar en almacenar el texto de un libro como un <code>Vec&lt;String&gt;</code>. Para almacenar varios libros haría falta crear una lista de elementos del tipo anterior y esto se puede hacer en otro <code>Vec</code> que contiene <code>Vec&lt;String&gt;</code>. Por lo tanto, el tipo resultante sería así <code>Vec&lt;Vec&lt;String&gt;&gt;</code>.</li>
</ul>
<p>En lugar de usar <code>.push()</code> para llegar a deducir el tipo de elementos que contiene un vector, se puede declarar el tipo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec: Vec&lt;String&gt; = Vec::new(); // El compilador conoce el tipo
                                              // Por eso no hay error
}
</code></pre></pre>
<p>Como se observa, todos los elementos de un vector tienen que tener un mismo tipo.</p>
<p>Otra forma sencilla de crear un vector es usando la macro <code>vec!</code>, cuya sintaxis recuerda a la declaración de un array.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec = vec![8, 10, 10];
}
</code></pre></pre>
<p>El tipo de los elementos, en este ejemplo, es <code>Vec&lt;i32&gt;</code>. Un vector de enteros. </p>
<p>Se pueden obtener secciones de un vector, igual que como se hace para un array.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let vec_of_ten = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    // Todo el código es idéntico, salvo que se añade vec!.
    let three_to_five = &amp;vec_of_ten[2..5];
    let start_at_two = &amp;vec_of_ten[1..];
    let end_at_five = &amp;vec_of_ten[..5];
    let everything = &amp;vec_of_ten[..];

    println!(&quot;Three to five: {:?},
start at two: {:?}
end at five: {:?}
everything: {:?}&quot;, three_to_five, start_at_two, end_at_five, everything);
}
</code></pre></pre>
<p>Puesto que un vector es más lento que un array, se pueden usar diversos métodos para hacerlo más rápido. Un vector tiene una <strong>capacidad</strong> de espacio asignada, que permite que al ir insertando nuevos elementos en el vector, se haga rápidamente. Cada vez que se hace esto, el vector se acerca al límite de su capacidad. Cuando esta se supera, Rust crea un nuevo espacio del doble del tamaño actual y copia todos los elementos al nuevo espacio. Esto se denomina relocalización. Se puede usar el método <code>.capacity()</code>para ver la capacidad de un vector según se le van añadiendo elementos.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut num_vec = Vec::new();
    println!(&quot;{}&quot;, num_vec.capacity()); // 0 elementos: immprime 0
    num_vec.push('a'); // añade un carácter
    println!(&quot;{}&quot;, num_vec.capacity()); // 1 elemento: imprime 4. Vecs con 1 elemento siempre se inician con una capacidad de 4
    num_vec.push('a'); // añade uno más
    num_vec.push('a'); // añade uno más
    num_vec.push('a'); // añade uno más
    println!(&quot;{}&quot;, num_vec.capacity()); // 4 elementos: aún 4 de capacidad.
    num_vec.push('a'); // añade uno más
    println!(&quot;{}&quot;, num_vec.capacity()); // imprime 8. Son 5 elementos, pero ha doblado la capacidad de 4 a 8 para hacer espacio.
}
</code></pre></pre>
<p>Esto imprime:</p>
<pre><code class="language-text">0
4
4
8
</code></pre>
<p>Así que este vector ha sufrido dos relocalizaciones: de 0 a 4 y de 4 a 8. Para que fuese más rápido se puede iniciar así:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut num_vec = Vec::with_capacity(8); // Se crea con una capacidad inicial de 8
    num_vec.push('a'); // se añade un carácter
    println!(&quot;{}&quot;, num_vec.capacity()); // imprime 8
    num_vec.push('a'); // añade uno más
    println!(&quot;{}&quot;, num_vec.capacity()); // imprime 8
    num_vec.push('a'); // añade uno más
    println!(&quot;{}&quot;, num_vec.capacity()); // imprime 8.
    num_vec.push('a'); // añade uno más
    num_vec.push('a'); // añade uno más
    // Ahora hay 5 elementos
    println!(&quot;{}&quot;, num_vec.capacity()); // Aún 8
}
</code></pre></pre>
<p>Este vector no ha sufrido ninguna relocalización, lo que es mejor. Por eso, si se conoce a priori el número de elementos que se necesitará, se puede inicializar el vector con <code>Vec::with_capacity()</code> para que funcione más rápido.</p>
<p>En el caso de las <code>&amp;str</code> se podía utilizar <code>.into()</code> para convertirlo en una <code>String</code>. Igualmente, se puede convertir un array en un vector con la misma función.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec: Vec&lt;u8&gt; = [1, 2, 3].into();
    let my_vec2: Vec&lt;_&gt; = [9, 0, 10].into(); // Vec&lt;_&gt; significa &quot;elige el tipo del Vector por mí&quot;
                                             // Rust elegirá Vec&lt;i32&gt;
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuplas"><a class="header" href="#tuplas">Tuplas</a></h1>
<p><strong><a href="https://youtu.be/U67Diy6SlTg">Se puede ver este capítulo en Youtube en inglés</a></strong></p>
<p>En Rust las tuplas usan <code>()</code>. Ya han aparecido muchas tuplas vacías ya que <em>nada</em>, en una función, realmente significa una tupla vacía:</p>
<pre><code class="language-text">fn do_something() {}
</code></pre>
<p>realmente es igual a:</p>
<pre><code class="language-text">fn do_something() -&gt; () {}
</code></pre>
<p>Esta función no recibe ningún parámetro (recibe una tupla vacía) y no retorna ningún valor (una tupla vacía). Por eso, se han estado usando ya muchas tuplas en los ejemplos de capítulos anteriores. Cuando no se retorna ningún valor en una función, se está retornando una tupla vacía.</p>
<pre><pre class="playground"><code class="language-rust">fn just_prints() {
    println!(&quot;Estoy imprimiendo&quot;); // Al añadir un ;
    // como último dato antes de terminar la función
    // se está indicando que se debe retornar una tupla vacía
}

fn main() {}
</code></pre></pre>
<p>Las tuplas pueden almacenar muchos tipos de elementos diferentes a la vez. Los elementos incluidos se indexan con números de 0 en adelante. Para acceder a ellos se utiliza el operador <code>.</code> en lugar de <code>[]</code>. A continuación se incorporan datos de diferentes tipos en una única tupla:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let random_tuple = (&quot;Esto es un texto&quot;, 8, vec!['a'], 'b', [8, 9, 10], 7.7);
    println!(
        &quot;El interior de la tupla contiene: Primer elemento: {:?}
Segundo elemento: {:?}
Tercer elemento: {:?}
Cuarto elemento: {:?}
Quinto elemento: {:?}
Sexto elemento: {:?}&quot;,
        random_tuple.0,
        random_tuple.1,
        random_tuple.2,
        random_tuple.3,
        random_tuple.4,
        random_tuple.5,
    )
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">El interior de la tupla contiene: Primer elemento: &quot;Esto es un texto&quot;
Segundo elemento: 8
Tercer elemento: ['a']
Cuarto elemento: 'b'
Quinto elemento: [8, 9, 10]
Sexto elemento: 7.7
</code></pre>
<p>Esta tupla es de tipo <code>(&amp;str, i32, Vec&lt;char&gt;, char, [i32; 3], f64)</code>.</p>
<p>Se puede usar una tupla para crear múltiples variables. En el siguiente código:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let str_vec = vec![&quot;one&quot;, &quot;two&quot;, &quot;three&quot;];
}
</code></pre></pre>
<p><code>str_vec</code> contiene tres elementos. ¿Cómo se pueden recuperar los tres valores de este vector en diferentes variables? Por ejemplo, con una tupla:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let str_vec = vec![&quot;one&quot;, &quot;two&quot;, &quot;three&quot;];

    let (a, b, c) = (str_vec[0], str_vec[1], str_vec[2]); // las variables serán a, b, y c
    println!(&quot;{:?}&quot;, b);
}
</code></pre></pre>
<p>El resultado del código anterior imprime <code>&quot;two&quot;</code>, que es lo que contiene la variable <code>b</code>. A esta forma de extraer valores en variables se denomina <em>desestructuramiento</em>.</p>
<p>Si se necesita desestructurar un conjunto de elementos, pero no se quieren todos, se puede utilizar <code>_</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let str_vec = vec![&quot;one&quot;, &quot;two&quot;, &quot;three&quot;];

    let (_, _, variable) = (str_vec[0], str_vec[1], str_vec[2]);
}
</code></pre></pre>
<p>El código anterior solo crea una variable denominada <code>variable</code>, pero no las crea para el resto de elementos.</p>
<p>Existen muchos más tipos colección y muchas formas adicionales de utilizar a los arrays, vectores y tuplas. Se enseñará más sobre ellos más adelante, pero primero, se enseñará la forma de controlar el flujo de ejecución de un programa.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="estructuras-de-control"><a class="header" href="#estructuras-de-control">Estructuras de control</a></h1>
<p><strong>Se puede ver este capítulo en YouTube en inglés: <a href="https://youtu.be/UAymDOpv_us">Parte 1</a> y <a href="https://youtu.be/eqysTfiiQZs">Parte 2</a></strong></p>
<p>Las estructuras de control del flujo de ejecución permiten indicar qué código debe ejecutarse en cada caso. La estructura de control de flujo más simple es <code>if</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 5;
    if my_number == 7 {
        println!(&quot;Es el siete&quot;);
    }
}
</code></pre></pre>
<p>Se utiliza <code>==</code> y no <code>=</code>. <code>==</code> sirve para comparar y <code>=</code> se utiliza para asignar un valor. También hay que destacar que se escribe <code>if my_number == 7</code> y no <code>if (my_number == 7)</code>. La estructura de control <code>if</code> no necesita paréntesis en Rust.</p>
<p>Esta estructura se completa con <code>else if</code> y <code>else</code> si resultan necesarias:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 5;
    if my_number == 7 {
        println!(&quot;Es el siete&quot;);
    } else if my_number == 6 {
        println!(&quot;Es el seis&quot;)
    } else {
        println!(&quot;Es un número diferente&quot;)
    }
}
</code></pre></pre>
<p>El código anterior imprime <code>Es un númbero diferente</code> porque no es igual a 7 o 6.</p>
<p>Se pueden añadir más condiciones con <code>&amp;&amp;</code> (operador <code>y lógico</code>) y <code>||</code> (operador <code>o lógico</code>).</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 5;
    if my_number % 2 == 1 &amp;&amp; my_number &gt; 0 { // % 2 es el resto de la división entre dos
        println!(&quot;Es un número impar positivo&quot;);
    } else if my_number == 6 {
        println!(&quot;Es el seis&quot;)
    } else {
        println!(&quot;Es un número diferente&quot;)
    }
}
</code></pre></pre>
<p>El código anterior imprime <code>Es un número impar positivo</code> porque cuando se divide entre 2 el resto es 1, que es mayor que 0.</p>
<p>Se observa que cuando hay demasiados <code>if</code>, <code>else</code> y <code>else if</code> el código puede resultar difícil de leer. En estos casos (y en otros muchos) se puede utilizar <code>match</code>, que resulta mucho más límpio. <code>match</code> requiere que se contemplen todos los casos posibles para evitar errores. Así que el siguiente código no funciona:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number: u8 = 5;
    match my_number {
        0 =&gt; println!(&quot;Es cero&quot;),
        1 =&gt; println!(&quot;Es uno&quot;),
        2 =&gt; println!(&quot;Es dos&quot;),
        // ⚠️
    }
}
</code></pre></pre>
<p>El compilar indica lo siguiente:</p>
<pre><code class="language-text">error[E0004]: non-exhaustive patterns: `3u8..=std::u8::MAX` not covered
 --&gt; src\main.rs:3:11
  |
3 |     match my_number {
  |           ^^^^^^^^^ pattern `3u8..=std::u8::MAX` not covered
</code></pre>
<p>El compilador se queja de que solo conoce lo que tiene que ejecutar los casos de 0 a 2, pero <code>u8</code> puede tener valores hasta el 255 (es decir <code>std::u8::MAX</code>). Qué debe hacer el programa para el resto de valores posibles que pueden aparecer.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number: u8 = 5;
    match my_number {
        0 =&gt; println!(&quot;Es cero&quot;),
        1 =&gt; println!(&quot;Es uno&quot;),
        2 =&gt; println!(&quot;Es dos&quot;),
        _ =&gt; println!(&quot;Es algún otro número&quot;),
    }
}
</code></pre></pre>
<p>Este código imprime <code>Es algún otro número</code>.</p>
<p>Para el caso de <code>match</code> hay que recordar que:</p>
<ul>
<li>A todo <code>match</code> le sigue un bloque de código <code>{}</code></li>
<li>Se escriben los <em>patrones</em> a la izquierda y se usa <code>=&gt;</code> (flecha gruesa -fat arrow-) para indicar qué hay que hacer cuando hay una coincidencia.</li>
<li>A cada línea con un patrón se le denomina &quot;brazo&quot; del <code>match</code>.</li>
<li>Entre cada &quot;brazo&quot; se pone una coma de separación (no se usa el punto y coma).</li>
</ul>
<p>Se puede declarar un valor usando <code>match</code> ya que retorna una valor.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 5;
    let second_number = match my_number {
        0 =&gt; 0,
        5 =&gt; 10,
        _ =&gt; 2,
    };
}
</code></pre></pre>
<p>En el ejemplo anterior, <code>second_number</code> tendrá el valor 10. El match, en este caso acaba con un ; ya que una vez se ha finalizado su evaluación esta sentencia es como si se hubiese escrito <code>let second_number = 10;</code>. Que define y asigna el 10 a <code>second_number</code>.</p>
<p><code>match</code> se puede utilizar para cosas más complejas. Por ejemplo, con tuplas:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let sky = &quot;nuboso&quot;;
    let temperature = &quot;cálido&quot;;

    match (sky, temperature) {
        (&quot;nuboso&quot;, &quot;frío&quot;) =&gt; println!(&quot;El día es oscuro y desapacible&quot;),
        (&quot;despejado&quot;, &quot;cálido&quot;) =&gt; println!(&quot;El día es agradable&quot;),
        (&quot;nuboso&quot;, &quot;cálido&quot;) =&gt; println!(&quot;El día es oscuro, pero no se está mal&quot;),
        _ =&gt; println!(&quot;No sé cómo es el día de hoy&quot;),
    }
}
</code></pre></pre>
<p>Este código imprime <code>El día es oscuro, pero no se está mal</code> porque coincide con &quot;nuboso&quot; y &quot;cálido&quot; para <code>sky</code> y <code>temperature</code>.</p>
<p>Incluso se puede utilizar <code>if</code> en las ramas de un <code>match</code>. Es lo que se llama una &quot;guarda de coincidencia&quot; (match guard):</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let children = 5;
    let married = true;

    match (children, married) {
        (children, married) if married == false =&gt; println!(&quot;Sin casar con {} niños&quot;, children),
        (children, married) if children == 0 &amp;&amp; married == true =&gt; println!(&quot;Casado, pero sin niños&quot;),
        _ =&gt; println!(&quot;¿Casado? {}. Número de niños: {}.&quot;, married, children),
    }
}
</code></pre></pre>
<p>Este progrma imprimirá <code>¿Casado? true. Número de niños: 5.</code></p>
<p>Se puede usar <code>_</code> tantas veces como se necesite en un <code>match</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn match_colours(rbg: (i32, i32, i32)) {
    match rbg {
        (r, _, _) if r &lt; 10 =&gt; println!(&quot;No muy rojo&quot;),
        (_, b, _) if b &lt; 10 =&gt; println!(&quot;No muy azul&quot;),
        (_, _, g) if g &lt; 10 =&gt; println!(&quot;No muy verde&quot;),
        _ =&gt; println!(&quot;Cada color tiene al menos 10&quot;),
    }
}

fn main() {
    let first = (200, 0, 0);
    let second = (50, 50, 50);
    let third = (200, 50, 0);

    match_colours(first);
    match_colours(second);
    match_colours(third);

}
</code></pre></pre>
<p>Este código imprime:</p>
<pre><code class="language-text">No muy azul
Cada color tiene al menos 10
No muy verde
</code></pre>
<p>Este código también muestra cómo funcionan las sentencias <code>match</code>, porque en el primer ejemplo solo imprime <code>No muy rojo</code>, aunque tampoco tiene mucho verde. Las sentencias <code>match</code> siempre se detienen cuando encuentran una coincidencia y no chequea el resto de los &quot;brazos&quot;. Es un buen ejemplo de código que compila bien, pero no hace lo que se quiere.</p>
<p>Se puede construir una sentencia <code>match</code>gigante para arreglar este código, pero probablemente es mejor utilizar un bucle <code>for</code>. Más adelante se hablará de los bucles.</p>
<p>La sentencia <code>match</code> siempre tiene que devolver el mismo tipo de datos en todas sus ramas. Por eso, este código no funciona:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 10;
    let some_variable = match my_number {
        10 =&gt; 8,
        _ =&gt; &quot;Not ten&quot;, // ⚠️
    };
}
</code></pre></pre>
<p>El compilador indica lo siguiente:</p>
<pre><code class="language-text">error[E0308]: `match` arms have incompatible types
  --&gt; src\main.rs:17:14
   |
15 |       let some_variable = match my_number {
   |  _________________________-
16 | |         10 =&gt; 8,
   | |               - this is found to be of type `{integer}`
17 | |         _ =&gt; &quot;Not ten&quot;,
   | |              ^^^^^^^^^ expected integer, found `&amp;str`
18 | |     };
   | |_____- `match` arms have incompatible types
</code></pre>
<p>El código siguiente, por la misma razón, tampoco funciona:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let some_variable = if my_number == 10 { 8 } else { &quot;something else &quot;}; // ⚠️
}
</code></pre></pre>
<p>Pero el siguiente código sí funciona, porque no es un <code>match</code>y son dos sentencias diferentes:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 10;

    if my_number == 10 {
        let some_variable = 8;
    } else {
        let some_variable = &quot;Something else&quot;;
    }
}
</code></pre></pre>
<p>También se puede usar <code>@</code> para darle un nombre al valor de un patrón <code>match</code> con el fin de poder usarlo en la expresión correspondiente a ese &quot;brazo&quot;. En este ejemplo, se guarda el valor en una variable <code>number</code> para pasarlo a una función. Si es 4 o 13 se usa ese <code>number</code> en la sentencia <code>println!</code>. En otro caso, no se utiliza.</p>
<pre><pre class="playground"><code class="language-rust">fn match_number(input: i32) {
    match input {
    number @ 4 =&gt; println!(&quot;{} da mala suerte en China (suena parecido a 死)&quot;, number),
    number @ 13 =&gt; println!(&quot;{} da mala suerte en Norte América, ¡Suerte en Italia! In bocca al lupo&quot;, number),
    _ =&gt; println!(&quot;Es un número normal&quot;),
    }
}

fn main() {
    match_number(50);
    match_number(13);
    match_number(4);
}
</code></pre></pre>
<p>Este código imprime:</p>
<pre><code class="language-text">Es un número normal
13 da mala suerte en Norte América, ¡Suerte en Italia! In bocca al lupo
4 da mala suerte en China (suena parecido a 死)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="estructuras---struct"><a class="header" href="#estructuras---struct">Estructuras - struct</a></h1>
<p><strong>Se puede ver este capítulo en YouTube en inglés: <a href="https://youtu.be/W23uQghBOFk">Parte 1</a> y <a href="https://youtu.be/GSVhrjLCuNA">Parte 2</a></strong></p>
<p>Con las estructuras se pueden crear nuevos tipos de datos. Se utilizan constantemente en Rust, puesto que son muy útiles. Las estructuras se crean con la palabra reservada <code>struct</code>. El nombre de las estructuras debería estar en UpperCamelCase (una letra mayúscula por cada palabra sin espacios, ni guiones bajos). Si se escribe todo en minúsculas, el compilador avisará.</p>
<p>Existen tres tipos de estructuras.</p>
<p>La primera de ellas es la estructura unitaria &quot;unit struct&quot;, que no tiene nada. Simplemente se escribe su nombre seguido de un punto y coma.</p>
<pre><pre class="playground"><code class="language-rust">struct FileDirectory;
fn main() {}
</code></pre></pre>
<p>La segunda de ellas es la estructura tupla, o estructura sin nombres. Solo es necesario escribir los tipos de dato que contiene, sin nombres de campo. Las estructuras de tupla son indicadas cuando se necesita una estructura simple sin necesidad de utilizar nombres.</p>
<pre><pre class="playground"><code class="language-rust">struct Colour(u8, u8, u8);

fn main() {
    let my_colour = Colour(50, 0, 50); // Crea un color RGB (red, green, blue)
    println!(&quot;La segunda parte del color (la componente verde) es: {}&quot;, my_colour.1);
}
</code></pre></pre>
<p>Este código imprime <code>La segunda parte del color (la componente verde) es: 0</code>.</p>
<p>El tercer tipo es la estructura con nombres. Que es, probablemente, la más habitual. En estas estructuras se declaran los nombres de los campos y sus tipos en un bloque <code>{}</code>. Estos bloques no se terminan con punto y coma.</p>
<pre><pre class="playground"><code class="language-rust">struct Colour(u8, u8, u8); // Declara la misma estructura tupla para el color

struct SizeAndColour {
    size: u32,
    colour: Colour, // y la inserta en una estructura con nombres
}

fn main() {
    let my_colour = Colour(50, 0, 50);

    let size_and_colour = SizeAndColour {
        size: 150,
        colour: my_colour
    };
}
</code></pre></pre>
<p>Los campos de una estructura con nombres se separan con comas. El último campo puede llevar o no la coma. En el caso anterior, se puso una coma después de definir el campo <code>colour: Colour,</code>, pero no es necesario. Normalmente, se considera buena idea poner siempre la coma, porque en ocasiones resulta necesario cambiar el orden de los campos o añadir uno al final y de este modo es sistemática la modificación:</p>
<pre><pre class="playground"><code class="language-rust">struct Colour(u8, u8, u8); 

struct SizeAndColour {
    size: u32,
    colour: Colour // Sin coma
}

fn main() {}
</code></pre></pre>
<p>Se dedice cambiar su orden, cortando y pegando la fila...</p>
<pre><pre class="playground"><code class="language-rust">struct SizeAndColour {
    colour: Colour // ⚠️ ¡Error! ya que no tiene coma.
    size: u32,
}

fn main() {}
</code></pre></pre>
<p>En todo caso, no es muy importante si se usa la coma o no.</p>
<p>En el siguiente ejemplo, se crea una estructura <code>Pais</code> que tiene los campos <code>poblacion</code>, <code>capital</code>y <code>presidente</code>.</p>
<pre><pre class="playground"><code class="language-rust">struct Pais {
    poblacion: u32,
    capital: String,
    presidente: String
}

fn main() {
    let poblacion = 500_000;
    let capital = String::from(&quot;Elista&quot;);
    let presidente = String::from(&quot;Batu Khasikov&quot;);

    let kalmykia = Pais {
        poblacion: poblacion,
        capital: capital,
        presidente: presidente,
    };
}
</code></pre></pre>
<p>Se observa que resuta prolijo tener que escribir el nombre del campo y su valor. Se escribe doble. <code>poblacion: poblacion</code>, <code>capital: capital</code> y <code>presidente: presidente</code>. Como se trata de alto habitual, Rust proporciona un atajo si tanto el campo, como la variable que contiene el valor se llaman igual. En ese caso, se puede simplificar así:</p>
<pre><pre class="playground"><code class="language-rust">struct Pais {
    poblacion: u32,
    capital: String,
    presidente: String
}

fn main() {
    let poblacion = 500_000;
    let capital = String::from(&quot;Elista&quot;);
    let presidente = String::from(&quot;Batu Khasikov&quot;);

    let kalmykia = Pais {
        poblacion,
        capital,
        presidente,
    };
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enumerados---enum"><a class="header" href="#enumerados---enum">Enumerados - enum</a></h1>
<p><strong>Este capítulo se puede ver en YouTube en inglés: <a href="https://youtu.be/SRnqNTJUgjs">Parte 1</a>, <a href="https://youtu.be/F_EcbWM63lk">Parte 2</a>, <a href="https://youtu.be/2uh64U9JesA">Parte 3</a> y <a href="https://youtu.be/LOHVUYTc5Us">Parte 4</a></strong></p>
<p>La palabra reservada de Rust <code>enum</code> se usa para los tipos enumerados. Esta es la diferencia con <code>struct</code>:</p>
<ul>
<li>Se utiliza <code>struct</code> cuando un tipo de datos debe representar una cosa <strong>Y</strong> otra cosa a la vez.</li>
<li>Se utiliza <code>enum</code> cuando un tipo de datos puede representar una cosa <strong>O</strong> alguna cosa diferente.</li>
</ul>
<p>Las estructuras sirven para unir diferentes elementos en uno solo, mientras que los enumerados permiten que un tipo de datos represente a diferentes cosas en diferente momento.</p>
<p>Para declarar un enumerado se debe escribir <code>enum</code> seguido de un bloque <code>{}</code> con las diferentes opciones separadas por coma. Como en el caso de los <code>struct</code> la última opción puede llevar la coma o no. A continuación se crea un enumerado denominado <code>CosasEnElCielo</code>:</p>
<pre><pre class="playground"><code class="language-rust">enum CosasEnElCielo {
    Sol,
    Estrellas,
}

fn main() {}
</code></pre></pre>
<p>Es un enumerado, por lo tanto, cuando se cree un valor es necesario que se elija entre el <code>Sol</code> o las <code>Estrellas</code>. A cada elemento que forma parte del enumerado se le denomina <strong>variante</strong>.</p>
<pre><pre class="playground"><code class="language-rust">// Crea el enumerado con dos variantes
enum CosasEnElCielo {
    Sol,
    Estrellas,
}

// Con esa función se usa un i32 para crear CosasEnElCielo.
fn crear_estadoEnElCielo(time: i32) -&gt; CosasEnElCielo {
    match time {
        6..=18 =&gt; CosasEnElCielo::Sol, // Entre las 6 y 18 horas se ve el sol
        _ =&gt; CosasEnElCielo::Estrellas, // En otro caso se ven las estrellas
    }
}

// Con esta función se localiza el estado y se muestran las CosasEnElCielo.
fn comprobar_el_cielo(state: &amp;CosasEnElCielo) {
    match state {
        CosasEnElCielo::Sol =&gt; println!(&quot;¡Puedo ver el sol!&quot;),
        CosasEnElCielo::Estrellas =&gt; println!(&quot;¡Puedo ver las estrellas!&quot;)
    }
}

fn main() {
    let time = 8; // Son las ocho de la mañana
    let skystate = crear_estadoEnElCielo(time); // crear_estadoEnElCielo returns a CosasEnElCielo
    comprobar_el_cielo(&amp;skystate); // Se pasa una referencia para que pueda leer el estado del cielo
}
</code></pre></pre>
<p>Este código imprime <code>¡Puedo ver el sol!</code>.</p>
<p>A cada enumerado, se le pueden añadir datos (como en los struts):</p>
<pre><pre class="playground"><code class="language-rust">enum CosasEnElCielo {
    Sol(String), // Ahora cada variante tiene una cadena de texto
    Estrellas(String),
}

fn crear_estadoEnElCielo(time: i32) -&gt; CosasEnElCielo {
    match time {
        6..=18 =&gt; CosasEnElCielo::Sol(String::from(&quot;¡Puedo ver el sol!&quot;)), // Da el valor aquí
        _ =&gt; CosasEnElCielo::Estrellas(String::from(&quot;¡Puedo ver las estrellas!&quot;)),
    }
}

fn comprobar_el_cielo(state: &amp;CosasEnElCielo) {
    match state {
        CosasEnElCielo::Sol(description) =&gt; println!(&quot;{}&quot;, description), // recupera la descripción para que se pueda imprimir
        CosasEnElCielo::Estrellas(n) =&gt; println!(&quot;{}&quot;, n), // se puede usar cualquier variable n para obtener la descripción
    }
}

fn main() {
    let time = 8; // Son las ocho de la mañana
    let skystate = crear_estadoEnElCielo(time); // crear_estadoEnElCielo devuelve un elemento de CosasEnElCielo
    comprobar_el_cielo(&amp;skystate); // Se pasa una referencia para que pueda leer el estado del cielo
}
</code></pre></pre>
<p>Este código imprime lo mismo que antes <code>¡Puedo ver el sol!</code>.</p>
<p>También se puede &quot;importar&quot; un enumerado para que no haya que escribir mucho. A continuación se muestra un ejemplo en se escribe <code>Estado::</code> cada vez que se comprueba el &quot;estado de ánimo&quot;:</p>
<pre><pre class="playground"><code class="language-rust">enum Estado {
    Feliz,
    Cansado,
    NoEstoyMal,
    Enfadado,
}

fn comprueba_estado(mood: &amp;Estado) -&gt; i32 {
    let nivel_de_felicidad = match mood {
        Estado::Feliz =&gt; 10, // Se escribe Estado:: cada vez
        Estado::Cansado =&gt; 6,
        Estado::NoEstoyMal =&gt; 7,
        Estado::Enfadado =&gt; 2,
    };
    nivel_de_felicidad
}

fn main() {
    let my_mood = Estado::NoEstoyMal;
    let nivel_de_felicidad = comprueba_estado(&amp;my_mood);
    println!(&quot;De 1 a 10, mi estado de felicidad es {}&quot;, nivel_de_felicidad);
}
</code></pre></pre>
<p>El código anterior imprime <code>De 1 a 10, mi estado de felicidad es 7</code>. A continuación, el mismo código, pero importando el enumerado para tener que escribir menos. Para importar todo se utiliza <code>*</code>. Es el mismo carácter que para desrreferenciar, pero con un uso diferente.</p>
<pre><pre class="playground"><code class="language-rust">enum Estado {
    Feliz,
    Cansado,
    NoEstoyMal,
    Enfadado,
}

fn comprueba_estado(mood: &amp;Estado) -&gt; i32 {
    use Estado::*; // Se importa el conjunto de variantes de Estado. Ahora se puede escribir menos
    let nivel_de_felicidad = match mood {
        Feliz =&gt; 10, // Ya no es necesario escribir Estado::
        Cansado =&gt; 6,
        NoEstoyMal =&gt; 7,
        Enfadado =&gt; 2,
    };
    nivel_de_felicidad
}

fn main() {
    let my_mood = Estado::NoEstoyMal;
    let nivel_de_felicidad = comprueba_estado(&amp;my_mood);
    println!(&quot;De 1 a 10, mi estado de felicidad es {}&quot;, nivel_de_felicidad);
}
</code></pre></pre>
<p>Las partes de un enumerado se pueden convertir a número entero. Esto se debe a que Rust da a cada variante de un <code>enum</code> un número que comienza con el 0 (para uso interno de Rust). Se puede utilizar en el código, siempre que las variantes con contengan ningún dato adicional:</p>
<pre><pre class="playground"><code class="language-rust">enum Estacion {
    Primavera, // If this was Primavera(String) or something it wouldn't work
    Verano,
    Otoño,
    Invierno,
}

fn main() {
    use Estacion::*;
    let cuatro_estaciones = vec![Primavera, Verano, Otoño, Invierno];
    for estacion in cuatro_estaciones {
        println!(&quot;{}&quot;, estacion as u32);
    }
}
</code></pre></pre>
<p>El código anterior imprime:</p>
<pre><code class="language-text">0
1
2
3
</code></pre>
<p>Es posible asignar un número entero expresamente a cada variante. A Rust no le importa el número concreto que tenga cada una de ellas. Para ello, se añade un símbolo <code>=</code> y el número deseado a cada variante. No es necesario indicar el número a cada variante. Si no se añade, Rust utiliza el siguiente disponible (suma 1) a partir de la variante anterior que tuviera número:</p>
<pre><pre class="playground"><code class="language-rust">enum Estrella {
    EnanaMarron = 10,
    EnanaRoja = 50,
    EstrellaAmarilla = 100,
    GiganteRoja = 1000,
    EstrellaMuerta, // ¿Qué número tendrá?
}

fn main() {
    use Estrella::*;
    let starvec = vec![EnanaMarron, EnanaRoja, EstrellaAmarilla, GiganteRoja];
    for star in starvec {
        match star as u32 {
            size if size &lt;= 80 =&gt; println!(&quot;No es la estrella más grande&quot;),
            size if size &gt;= 80 =&gt; println!(&quot;Esta estrella tiene un buen tamaño&quot;),
            _ =&gt; println!(&quot;Esta estrella es muy grande&quot;),
        }
    }
    println!(&quot;¿Qué número tiene EstrellaMuerta? Es el número {}.&quot;, EstrellaMuerta as u32);
}
</code></pre></pre>
<p>This prints:</p>
<pre><code class="language-text">No es la estrella más grande
No es la estrella más grande
Esta estrella tiene un buen tamaño
Esta estrella tiene un buen tamaño
¿Qué número tiene EstrellaMuerta? Es el número 1001.
</code></pre>
<p><code>EstrellaMuerta</code> hubiera sido el número 4 si no se hubiera expresado ningún número, pero ahora es el 1001.</p>
<h2 id="los-enumerados-sirven-para-usar-tipos-diferentes"><a class="header" href="#los-enumerados-sirven-para-usar-tipos-diferentes">Los enumerados sirven para usar tipos diferentes</a></h2>
<p>Como ya se sabe, los elementos de un <code>Vec</code>, array, etc. tienen que ser del mismo tipo siempre (solo las tuplas permiten tipos diferentes). Los enumerados permiten incorporar diferentes tipos en las colecciones anteriores. Si se deseara tener un <code>Vec</code> que almacenara de forma indistinta <code>u32</code> o <code>i32</code> se puede declarar el <code>Vec</code> como que contiene un enumerado como en el siguiente ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">enum Numero {
    U32(u32),
    I32(i32),
}

fn main() {}
</code></pre></pre>
<p>Así, este enumerado tiene dos variantes: la variante <code>U32</code>con un <code>u32</code>y la variante <code>I32</code> con un <code>i32</code>. <code>U32</code> y <code>I32</code> son solo los nombres de cada variante. Se podrían haber llamado <code>UTreintaYDos</code> o <code>ITreintaYDos</code> o cualquier otra cosa.</p>
<p>Ahora es posible declarar un <code>Vec</code> de la siguiente forma <code>Vec&lt;Numero&gt;</code> y el compilador no se queja porque el vector es de un solo tipo. Al compilador no le preocupa si en un momento dado hay <code>u32</code> o <code>i32</code> porque esa diferencia está oculta por el tipo <code>Numero</code>. Y como es un enumerado, es necesario seleccionar una variante cada vez. En el siguiente código se usa el método <code>.is_positive()</code> para seleccionar la variante. Si es <code>true</code> se selecciona <code>U32</code> y si es <code>false</code> se selecciona <code>I32</code>.</p>
<p>Ahora el código queda así:</p>
<pre><pre class="playground"><code class="language-rust">enum Numero {
    U32(u32),
    I32(i32),
}

fn get_numero(input: i32) -&gt; Numero {
    let numero = match input.is_positive() {
        true =&gt; Numero::U32(input as u32), // lo cambia a u32 si es positivo
        false =&gt; Numero::I32(input), 
    };
    numero
}


fn main() {
    let my_vec = vec![get_numero(-800), get_numero(8)];

    for item in my_vec {
        match item {
            Numero::U32(numero) =&gt; println!(&quot;Es un u32 con el valor {}&quot;, numero),
            Numero::I32(numero) =&gt; println!(&quot;Es un i32 con el valor {}&quot;, numero),
        }
    }
}
</code></pre></pre>
<p>Este código imprime:</p>
<pre><code class="language-text">Es un i32 con el valor -800
Es un u32 con el valor 8
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
