<!DOCTYPE HTML>
<html lang="es" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust en espa√±ol f√°cil</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="actualizaciones.html">Actualizaciones</a></li><li class="chapter-item expanded affix "><a href="introduccion.html">Introducci√≥n</a></li><li class="chapter-item expanded affix "><a href="quiensoy.html">¬øQui√©n soy?</a></li><li class="chapter-item expanded affix "><a href="escritura.html">La escritura de Rust en ingl√©s f√°cil</a></li><li class="chapter-item expanded affix "><li class="part-title">Parte 1 - Rust en tu navegador</li><li class="chapter-item expanded "><a href="01.html"><strong aria-hidden="true">1.</strong> El entorno de pruebas de Rust</a></li><li class="chapter-item expanded "><a href="02.html"><strong aria-hidden="true">2.</strong> üöß y ‚ö†Ô∏è</a></li><li class="chapter-item expanded "><a href="03.html"><strong aria-hidden="true">3.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="04.html"><strong aria-hidden="true">4.</strong> Tipos de dato</a></li><li class="chapter-item expanded "><a href="05.html"><strong aria-hidden="true">5.</strong> Inferencia de tipos de dato</a></li><li class="chapter-item expanded "><a href="06.html"><strong aria-hidden="true">6.</strong> Imprimiendo '¬°Hola, mundo!'</a></li><li class="chapter-item expanded "><a href="07.html"><strong aria-hidden="true">7.</strong> La visualizaci√≥n y depuraci√≥n</a></li><li class="chapter-item expanded "><a href="08.html"><strong aria-hidden="true">8.</strong> Mutabilidad (cambio)</a></li><li class="chapter-item expanded "><a href="09.html"><strong aria-hidden="true">9.</strong> La pila, la memoria din√°mica y los punteros</a></li><li class="chapter-item expanded "><a href="10.html"><strong aria-hidden="true">10.</strong> M√°s sobre impresi√≥n</a></li><li class="chapter-item expanded "><a href="11.html"><strong aria-hidden="true">11.</strong> Cadenas de caracteres</a></li><li class="chapter-item expanded "><a href="12.html"><strong aria-hidden="true">12.</strong> const y static</a></li><li class="chapter-item expanded "><a href="13.html"><strong aria-hidden="true">13.</strong> Algo m√°s sobre referencias</a></li><li class="chapter-item expanded "><a href="14.html"><strong aria-hidden="true">14.</strong> Referencias modificables (mutables)</a></li><li class="chapter-item expanded "><a href="15.html"><strong aria-hidden="true">15.</strong> Paso de referencias a funciones</a></li><li class="chapter-item expanded "><a href="16.html"><strong aria-hidden="true">16.</strong> Copia</a></li><li class="chapter-item expanded "><a href="17.html"><strong aria-hidden="true">17.</strong> Tipos colecci√≥n</a></li><li class="chapter-item expanded "><a href="18.html"><strong aria-hidden="true">18.</strong> Vectores</a></li><li class="chapter-item expanded "><a href="19.html"><strong aria-hidden="true">19.</strong> Tuplas</a></li><li class="chapter-item expanded "><a href="20.html"><strong aria-hidden="true">20.</strong> Estructuras de control</a></li><li class="chapter-item expanded "><a href="21.html"><strong aria-hidden="true">21.</strong> Estructuras - struct</a></li><li class="chapter-item expanded "><a href="22.html"><strong aria-hidden="true">22.</strong> Enumerados - enum</a></li><li class="chapter-item expanded "><a href="23.html"><strong aria-hidden="true">23.</strong> Bucles</a></li><li class="chapter-item expanded "><a href="24.html"><strong aria-hidden="true">24.</strong> Implementando structs y enums</a></li><li class="chapter-item expanded "><a href="25.html"><strong aria-hidden="true">25.</strong> Desestructurar</a></li><li class="chapter-item expanded "><a href="26.html"><strong aria-hidden="true">26.</strong> Referencias y el operador punto .</a></li><li class="chapter-item expanded "><a href="27.html"><strong aria-hidden="true">27.</strong> Gen√©ricos</a></li><li class="chapter-item expanded "><a href="28.html"><strong aria-hidden="true">28.</strong> Los enumerados Option y Result</a></li><li class="chapter-item expanded "><a href="29.html"><strong aria-hidden="true">29.</strong> Otras colecciones</a></li><li class="chapter-item expanded "><a href="30.html"><strong aria-hidden="true">30.</strong> El operador ?</a></li><li class="chapter-item expanded "><a href="31.html"><strong aria-hidden="true">31.</strong> Traits (Rasgos)</a></li><li class="chapter-item expanded "><a href="32.html"><strong aria-hidden="true">32.</strong> Encadenando m√©todos</a></li><li class="chapter-item expanded "><a href="33.html"><strong aria-hidden="true">33.</strong> Iteradores</a></li><li class="chapter-item expanded "><a href="34.html"><strong aria-hidden="true">34.</strong> Closures - Cierres</a></li><li class="chapter-item expanded "><a href="35.html"><strong aria-hidden="true">35.</strong> La macro dbg! e .inspect()</a></li><li class="chapter-item expanded "><a href="36.html"><strong aria-hidden="true">36.</strong> Tipos de &str</a></li><li class="chapter-item expanded "><a href="37.html"><strong aria-hidden="true">37.</strong> Tiempos de vida (lifetimes)</a></li><li class="chapter-item expanded "><a href="38.html"><strong aria-hidden="true">38.</strong> Mutabilidad interior</a></li><li class="chapter-item expanded "><a href="39.html"><strong aria-hidden="true">39.</strong> Cow</a></li><li class="chapter-item expanded "><a href="40.html"><strong aria-hidden="true">40.</strong> Alias de tipos</a></li><li class="chapter-item expanded "><a href="41.html"><strong aria-hidden="true">41.</strong> La macro todo!</a></li><li class="chapter-item expanded "><a href="42.html"><strong aria-hidden="true">42.</strong> Rc</a></li><li class="chapter-item expanded "><a href="43.html"><strong aria-hidden="true">43.</strong> M√∫ltiples hilos</a></li><li class="chapter-item expanded "><a href="44.html"><strong aria-hidden="true">44.</strong> Cierres en funciones</a></li><li class="chapter-item expanded "><a href="45.html"><strong aria-hidden="true">45.</strong> impl Trait</a></li><li class="chapter-item expanded "><a href="46.html"><strong aria-hidden="true">46.</strong> Arc</a></li><li class="chapter-item expanded "><a href="47.html"><strong aria-hidden="true">47.</strong> Canales</a></li><li class="chapter-item expanded "><a href="48.html"><strong aria-hidden="true">48.</strong> Entender la documentaci√≥n de Rust</a></li><li class="chapter-item expanded "><a href="49.html"><strong aria-hidden="true">49.</strong> Atributos</a></li><li class="chapter-item expanded "><a href="50.html"><strong aria-hidden="true">50.</strong> Box</a></li><li class="chapter-item expanded "><a href="51.html"><strong aria-hidden="true">51.</strong> Box y los rasgos</a></li><li class="chapter-item expanded "><a href="52.html"><strong aria-hidden="true">52.</strong> Default y el patr√≥n constructor (builder)</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust en espa√±ol f√°cil</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="actualizaciones"><a class="header" href="#actualizaciones">Actualizaciones</a></h1>
<p><img src="https://github.com/Dhghomon/easy_rust/workflows/github%20pages/badge.svg" alt="example workflow name" /></p>
<p>23 de mayo de 2021: <a href="https://github.com/ariandy/easy-rust-indonesia">Ahora disponible en indonesio</a> gracias <a href="https://github.com/ariandy">Ariandy</a>/<a href="https://1kilobyte.github.io/">1kb</a>.</p>
<p>2 de abril de 2021: <a href="https://www.buymeacoffee.com/mithridates">A√±adido enlace a BuyMeACoffee</a> para aquellos a los que les gustar√≠a invitarme a un caf√©.</p>
<p>1 de febrero de 2021: <a href="https://www.youtube.com/playlist?list=PLfllocyHVgsRwLkTAhG0E-2QxCf-ozBkk">¬°Ahora disponible en youtube! (en ingl√©s)</a> Dos meses despu√©s: completo el 1 de abril de 2021, 186 v√≠deos en total (un poco m√°s de 23 horas).</p>
<p>22 de diciembre 2020: el libro en mdBook se puede encontrar <a href="https://dhghomon.github.io/easy_rust">aqu√≠</a>.</p>
<p>28 de noviembre de 2020: <a href="https://github.com/kumakichi/easy_rust_chs">Ahora tambi√©n disponible en chino simplificado</a> ¬°Gracias a <a href="https://github.com/kumakichi">kumakichi</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introducci√≥n"><a class="header" href="#introducci√≥n">Introducci√≥n</a></h1>
<p>Rust es un nuevo lenguaje de programaci√≥n que ya tiene buenos libros de texto, pero a veces son dif√≠ciles ya que son para personas cuyo ingl√©s es nativo. Muchas empresas y personas est√°n aprendiendo Rust en estos d√≠as y pueden aprenderlo m√°s r√°pido con un libro que use un ingl√©s f√°cil<sup class="footnote-reference"><a href="#1">1</a></sup>. Este libro es para que estas empresas y personas puedan aprender Rust con un espa√±ol simple.</p>
<p>Rust es un lenguaje que bastante nuevo, pero ya es muy popular. Es popular porque te da la velocidad y control de C o C++, pero tambi√©n ofrece protecci√≥n del acceso a la memoria como otros lenguajes como Python. Esto lo hace usando nuevas ideas que son en parte diferentes a otros lenguajes. Lo que significa que hay que aprender cosas nuevas y no puedes simplemente &quot;descubrirlo seg√∫n vas avanzando&quot;. Rust es un lenguaje en el que tienes que pensar las cosas durante un tiempo para comprenderlo, pero que a√∫n suena a familiar si conoces otros lenguajes y est√° dise√±ado para ayudarte a escribir c√≥digo de calidad.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>N.T.: esta traducci√≥n al espa√±ol trata de seguir el mismo principio utilizando un espa√±ol f√°cil.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="qui√©n-soy"><a class="header" href="#qui√©n-soy">¬øQui√©n soy?</a></h1>
<p>Soy un canadiense que vive en Korea y escrib√≠ Rust F√°cil pensando en c√≥mo hacer m√°s f√°cil su uso para las empresas de aqu√≠<sup class="footnote-reference"><a href="#1">1</a></sup>. Espero que otras empresas que no usan el ingl√©s como primer idioma puedan utilizarlo tambi√©n.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>N.T.: Soy un espa√±ol que vive en Madrid, espero que esta traducci√≥n tambi√©n facilite la comprensi√≥n de este lenguaje que tiene aspectos novedosos incluso para los que conocen C, C++, Java, Python, Ruby, Javascript o Typescript...</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="la-escritura-de-rust-en-ingl√©s-f√°cil"><a class="header" href="#la-escritura-de-rust-en-ingl√©s-f√°cil">La escritura de Rust en ingl√©s f√°cil</a></h1>
<p><em>Rust en ingl√©s f√°cil</em> se escribi√≥ de julio a agosto de 2020 y ocupa unas 400 p√°ginas. Puedes contactarme aqu√≠ o <a href="https://www.linkedin.com/in/davemacleod">en LinkedIn</a> o <a href="https://twitter.com/mithridates">en Twitter</a> si tienes cualquier pregunta. Si ves algo err√≥neo o tienes una petici√≥n de inserci√≥n (pull request) que hacer, adelante. M√°s de 20 personas ya han ayudado a corregir erratas y problemas en el c√≥digo, por lo que t√∫ tambi√©n puedes[1^]. no soy el mejor experto de Rust del mundo, as√≠ que me gusta escuchar nuevas ideas o ver en qu√© puedo hacer el libro mejor.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>N.T.: Esta traducci√≥n, <em>Rust en espa√±ol f√°cil</em>, se inici√≥ en julio de 2021. Para cualquier asunto relacionado con ella, puedes contactarme en <a href="https://github.com/jmgaguilera">github</a> o en <a href="https://es.linkedin.com/in/jmgaguilera">LinkedIn</a>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parte-1---rust-en-tu-navegador"><a class="header" href="#parte-1---rust-en-tu-navegador">Parte 1 - Rust en tu navegador</a></h1>
<p>Este libro tiene dos partes. En la primera, aprender√°s todo solo utilizando tu navegador. Puedes aprender casi todo lo que debes saber sin instalar Rust. Por eso esta primera parte es muy larga. En la segunda parte, mucho m√°s corta, se habla de Rust en tu ordenador. Ah√≠ aprender√°s todo lo que necesitas conocer y que solo se puede hacer fuera del navegador. Algunos ejemplos son: trabajar con ficheros, obtener datos del usuario, gr√°ficos y configuraciones personales. Espero que al finalizar la primera parte te guste Rust lo suficiente para que lo instales en tu equipo. Y si no, no hay problema, esta primera parte de ense√±a tanto que no te importar√°.</p>
<h1 id="el-entorno-de-pruebas-playground-de-rust"><a class="header" href="#el-entorno-de-pruebas-playground-de-rust">El entorno de pruebas (Playground) de Rust</a></h1>
<p><strong><a href="https://youtu.be/-lYeJeQ11OI">Puedes ver este cap√≠tulo en ingl√©s en YouTube</a></strong></p>
<p>Puede que no quieras instalarte a√∫n Rust. No pasa nada. Puedes ir a <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> y comenzar a escribir Rust sin salir del navegador. Puedes escribir ah√≠ el c√≥digo y pulsar <strong>Run</strong> para ver los resultados. Puedes ejecutar la mayor√≠a de los ejemplos de este libro en este entorno. Solamente al final del libro ver√°s ejemplos que van m√°s all√° de lo que se puede hacer aqu√≠ (como abrir ficheros.)</p>
<p>Algunas recomendaciones de uso de este entorno de pruebas (Playground):</p>
<ul>
<li>Ejecuta el c√≥digo con <strong>Run</strong></li>
<li>Cambia de <strong>Debug</strong> a <strong>Release</strong> si quieres que el c√≥digo sea m√°s r√°pdio. <strong>Debug</strong> (Depuraci√≥n) hace que compile m√°s r√°pido, se ejecute m√°s lento y contenga informaci√≥n para la depuraci√≥n de errores. <strong>Release</strong> (Producci√≥n) hace que compile m√°s lento, se ejecute m√°s r√°pido y se suprima la informaci√≥n para la depuraci√≥n de errores.</li>
<li>Pulsa en <strong>Share</strong> (Compartir) para obtener un hiperenlace. Puedes usarlo para compartir tu c√≥digo si necesitas ayuda. Despu√©s de pulsar compartir, puedes pulsar en <code>Open a new thread in de Rust user forum</code>(Abre un nuevo hilo en el foro de usuarios de Rust) para pedir ayuda.</li>
<li><strong>Tools</strong> (Herramientas): <strong>Rustfmt</strong> formatea el c√≥digo correctamente.</li>
<li><strong>Tools</strong> (Herramientas): <strong>Clippy</strong> da informaci√≥n extra sobre c√≥mo hacer mejor el c√≥digo.</li>
<li><strong>Config</strong> (Configuraci√≥n): puedes cambiar aqu√≠ el tema a modo oscuro para que puedas trabajar mejor de noche y otras muchas opciones.</li>
</ul>
<p>Si quieres instalar Rust, ve a <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a> y sigue las instrucciones. Normalmente, usar√°s <code>rustup</code> para instalar y actualizar Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-y-"><a class="header" href="#-y-">üöß y ‚ö†Ô∏è</a></h1>
<p>En ocasiones, el c√≥digo de los ejemplos del libro no funciona. Si un ejemplo no funciona, veras un üöß o un ‚ö†Ô∏è junto a √©l. üöß significa &quot;en construcci√≥n&quot;, es decir, que el c√≥digo no est√° completo. Rust necesita una <code>fn main()</code> (funci√≥n principal) para ejecutarse, pero algunas veces solo queremos observar una parte del c√≥digo por lo que no aparecer√° el c√≥digo <code>fn main ()</code>. Estos ejemplos son correctos, pero necesitan de una funci√≥n <code>fn main()</code> para ejecutarse. En algunos ejemplos el c√≥digo mostrar√° un problema que tendr√°s que resolver. Estos ejemplos podr√≠an tener una funci√≥n <code>fn main()</code> pero generar√°n un error y por eso se acompa√±an de un s√≠mbolo ‚ö†Ô∏è.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comentarios"><a class="header" href="#comentarios">Comentarios</a></h1>
<p><strong><a href="https://youtu.be/fJ7jBZG_Rpo">Puedes ver este cap√≠tulo en ingl√©s en YouTube</a></strong></p>
<p>Los comentarios son para que los lean los programadores, no el ordenador. es bueno escribir comentarios para ayudar a otras personas a entender tu c√≥digo. Es bueno, tambi√©n, para ayudarte a entender tu propio c√≥digo pasado un tiempo (Muchas personas escriben buen c√≥digo, pero olvidan porqu√© lo escribieron). Para escribir comentarios en el c√≥digo, en Rust se suele usar <code>//</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Los programas Rust comienzan en fn main()
    // Pones el c√≥digo en un bloque que comienza con { y termina con }
    let algun_numero = 100; // Aqu√≠ podemos esribir todo lo que queramos ya que el compilador no lo va mirar
}
</code></pre></pre>
<p>Cuando lo haces as√≠, el compilador no mirar√° nada que haya a la derecha de <code>//</code>.</p>
<p>Existe otra clase de comentario que se escribe con <code>/*</code> para iniciarlo y se termina con `*/. Este tipo de comentario es √∫til para escribirlo entre el c√≥digo.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let algun_numero/*: i16*/ = 100;
}
</code></pre></pre>
<p>Para el compilador <code>let algun_numero/*: i16*/ = 100;</code> es igual que <code>let algun_numero = 100;</code>.</p>
<p>Esta forma <code>/* */</code> tambi√©n es √∫til para los comentarios de gran longitud que necesiten m√°s de una l√≠nea. En este ejemplo se puede ver que necesitas escribir <code>//</code> en cada l√≠nea, pero si utilizas <code>/*</code>, el comentario dura hasta que lo finalices con <code>*/</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let algun_numero = 100; /* D√©jame contarte
    un poco sobre este n√∫mero.
    Es el 100, que es mi n√∫mero favorito.
    Se llama algun_numero pero realmente creo que...*/

    let algun_numero = 100; // D√©jame contarte
    // un poco sobre este n√∫mero.
    // Es el 100, que es mi n√∫mero favorito.
    // Se llama algun_numero pero realmente creo que...
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tipos-de-dato"><a class="header" href="#tipos-de-dato">Tipos de dato</a></h1>
<p>Rust tiene muchos tipos de dato que permiten trabajar con n√∫meros, caracteres y otros. Algunos son simples, otros son m√°s complicados e, incluso, puedes crear tus propios tipos de dato.</p>
<h2 id="tipos-de-dato-primitivos"><a class="header" href="#tipos-de-dato-primitivos">Tipos de dato primitivos</a></h2>
<p><strong><a href="https://youtu.be/OxTPU5UGMhs">Puedes ver este cap√≠tulo en YouTube en ingl√©s</a></strong></p>
<p>Rust tiene tipos simples que llaman <strong>tipos primitivos</strong> (primitivo = muy b√°sico). Comenzaremos con los n√∫meros enteros y los <code>char</code> (caracteres). Los enteros son n√∫meros sin coma decimal. Existen dos tipos de enteros:</p>
<ul>
<li>Enteros con signo.</li>
<li>Enteros sin signo.</li>
</ul>
<p>&quot;Con signo&quot; significa que disponen de <code>+</code> (signo m√°s) y <code>-</code> (signo menos), por lo que los enteros con signo pueden ser positivos o negativos (por ejemplo, +8, -8). Por el contratio, los enteros sin signo solo pueden ser positivos ya que no tienen signo.</p>
<p>Los enteros con signo son: <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, e <code>isize</code>.</p>
<p>Los enteros sin signo son: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, e <code>usize</code>.</p>
<p>El n√∫mero tras la <strong>i</strong> o la <strong>u</strong> indica el n√∫mero de bits que se usan para el entero. As√≠, los n√∫meros con m√°s bits pueden ser mayores. 8 bits = un byte por lo que <code>i8</code> ocupa un byte, y puede contener valores entre el -128 y el 127. Por lo tanto <code>i64</code> ocupa 64 bits o, lo que es lo mismo, 8 bytes y puede representar n√∫meros entre el -9223372036854775808 y el 9223372036854775807.</p>
<p>Los tipos num√©ricos con mayor tama√±o pueden representar valores mayores. Por ejemplo, el tipo <code>u8</code>puede representar del 0 al 255, el tipo <code>u16</code> puede representar del 0 al 65635, y el tipo <code>u128</code> puede representar a un n√∫mero entre el 0 y el 340282366920938463463374607431768211455.</p>
<p>¬øY qu√© representan <code>isize</code> y <code>usize</code>? El n√∫mero de bits del tipo nativo del procesador de tu ordenador (El n√∫mero de bits nativo de tu procesador se denomina la <strong>arquitectura</strong> de tu procesador). As√≠ que <code>isize</code> y <code>usize</code> en un ordenador de 32-bits son equivalentes a <code>i32</code> y <code>u32</code>. En un ordenador de 64-bits son equivalentes a <code>i64</code> y <code>u64</code>.</p>
<p>Hay muchas razones para disponer de todos estos tipos de n√∫meros enteros. Una raz√≥n es el rendimiento del ordenador: es m√°s r√°pido procesar un n√∫mero menor de bytes. Por ejemplo, el n√∫mero -10 representado como un <code>i8</code> es <code>11110110</code>, pero como un <code>i128</code> es <code>11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110110</code>. </p>
<p>veamos otros usos:</p>
<p>Los caracteres en Rust se denominan <code>char</code>. Todo <code>char</code> se representa por un n√∫mero: la letra <code>A</code> es lel n√∫mero 65, mientras que el car√°cter <code>Âèã</code> (&quot;amigo&quot; en chino) es el n√∫mero 21451. La lista de estos n√∫meros que representan a caracteres se denomina &quot;Unicode&quot;. Unicode usa n√∫meros m√°s peque√±os para los caracteres que se usan m√°s, como los de la A a la Z, los d√≠gitos de 0 a 9 o el espacio.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let primera_letra = 'A';
    let espacio = ' '; // Un espacio entre ' ' tambi√©n es un char
    let char_en_otro_idioma = '·èÑ'; // Gracias a Unicode, otros lenguajes, como el Cherokee, tambi√©n se visualizan bien
    let cara_gato = 'üò∫'; // Emojis tambi√©n son char
}
</code></pre></pre>
<p>Los caracteres que se utilizan m√°s se representan or n√∫meros menores al 256 y as√≠ pueden caber en un <code>u8</code>. Recuerda que un <code>u8</code> permite n√∫meros entre el 0 y el 255, lo que facilita la representaci√≥n de 256 caracteres en total. Esto significa que Rust puede convertir de forma segura del tipo de datos <code>u8</code> al <code>char</code>, utilizando la palabra reservada del lenguaje <code>as</code> (Considera el dato de este tipo <code>u8</code> como si fuese <code>char</code>).</p>
<p>La conversi√≥n de tipos de datos utilizando <code>as</code> es muy √∫til ya que Rust es muy estricto. Siempre necesita conocer el tipo de dato y, adem√°s, no deja utilizar de forma conjunta dos tipos de datos diferentes incluso aunque sean de la misma familia (como los enteros). Por ejemplo, este c√≥digo no funcionar√°:</p>
<pre><pre class="playground"><code class="language-rust">fn main() { // main() es la funci√≥n a partir de la que se 
            // inician los programas Rust. El c√≥digo entre las llaves {}

    let mi_numero = 100; // No hemos indicado el tipo de datos entero
                         // que Rust debe utilizar,
                         // as√≠ que Rust elige i32. Rust siempre
                         // elige i32 para los enteros si no se le indica
                         // que utilice otro tipo de datos diferente

    println!(&quot;{}&quot;, mi_numero as char); // ‚ö†Ô∏è
}
</code></pre></pre>
<p>Esta es la raz√≥n:</p>
<pre><code class="language-text">error[E0604]: only `u8` can be cast as `char`, not `i32`
 --&gt; src\main.rs:10:20
  |
3 |     println!(&quot;{}&quot;, mi_numero as char);
  |                    ^^^^^^^^^^^^^^^^^ invalid cast
</code></pre>
<p>Afortunadamente, podemos corregir esto f√°cilmente con <code>as</code>. No podemos convertir un <code>i32</code> a <code>char</code>, pero podemos convertir un <code>i32</code> a <code>u8</code>. Y despu√©s, podemos realizar la conversi√≥n de <code>u8</code> a <code>char</code>. Po tanto, en una l√≠nea usamos <code>as</code> para convertir mi_numero a <code>u8</code> y despu√©s lo convertimos a <code>char</code>. Ahora s√≠ compilar√°:</p>
<pre><pre class="playground"><code class="language-rust">fn main() { 
    let mi_numero = 100; 
    println!(&quot;{}&quot;, mi_numero as u8 as char);
}
</code></pre></pre>
<p>Se imprime <code>d</code> porque es el <code>char</code> que est√° representado en Unicode con este n√∫mero.</p>
<p>Existe una forma m√°s f√°cil, sin embargo, de conseguir este resultado: indicarle a Rust que <code>mi_numero</code> es de tipo <code>u8</code>. As√≠:</p>
<pre><pre class="playground"><code class="language-rust">fn main() { 
    let mi_numero: u8 = 100; // se indica de forma expresa que
                             // el tipo de la variable mi_numero es u8
    println!(&quot;{}&quot;, mi_numero as char);
}
</code></pre></pre>
<p>Las anteriores, son dos de las razones para la existencia de todos estos tipos de datos num√©ricos en Rust. Hay otra raz√≥n m√°s: <code>usize</code> es el tama√±o que Rust utiliza para <em>indexar</em> (Indexar significa &quot;conocer cual elemento va primero&quot;, &quot;cual va segundo&quot;, etc.). <code>usize</code> es el mejor tama√±o para el indexado porque:</p>
<ul>
<li>Un √≠ndice no puede ser negativo, por lo que tiene que ser uno de los tipos de dato con una <strong>u</strong>.</li>
<li>Debe ser grande porque en muchas ocasiones necesitas indexar muchas cosas, pero</li>
<li>No puede ser un u64 porque los ordenadores de 32-bits no lo pueden manejar.</li>
</ul>
<p>Por eso Rust usa <code>usize</code> para indexar y facilitar que tu ordenador pueda utilizar el tipo de datos mayor de que disponga.</p>
<p>Vamos a aprender algo m√°s sobre <code>char</code>. Ya vimos que <code>char</code>siempre es un car√°cter y utiliza <code>''</code> en lugar de <code>&quot;&quot;</code>.</p>
<p>Todos los <code>char</code> usan 4 bytes de memoria, puesto que son necesarios 4 bytes para contener cualquier clase de car√°cter:</p>
<ul>
<li>Las letras y s√≠mbolos b√°sicos suelen necesitar solo 1 de los 4 bytes: <code>a b 1 2 + - = $ @</code></li>
<li>Otras letras como las di√©resis y tildes necesitan 2 de los 4 bytes: <code>√§ √∂ √º √ü √® √© √† √±</code></li>
<li>Los caracteres coreanos, japoneses o chinos necesitan 3 de los cuatro bytes: <code>ÂõΩ Ïïà ÎÖï</code></li>
</ul>
<p>Cuando los caracteres se usan como parte de una cadena, esta se codifica para usar la menor cantidad de memoria necesaria para cada car√°cter<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<p><sup class="footnote-reference"><a href="#1">1</a></sup> N.T.: Rust codifica las cadenas en UTF-8.</p>
<p>Para observar esto podemos usar <code>.len()</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Tama√±o de un char: {}&quot;, std::mem::size_of::&lt;char&gt;()); // 4 bytes
    // .len() devuelve el tama√±o de una cadena de texto en bytes
    println!(&quot;Tama√±o de una cadena que contiene la 'a': {}&quot;, &quot;a&quot;.len());
    println!(&quot;Tama√±o de una cadena que contiene la '√ü': {}&quot;, &quot;√ü&quot;.len());
    println!(&quot;Tama√±o de una cadena que contiene la 'ÂõΩ': {}&quot;, &quot;ÂõΩ&quot;.len());
    println!(&quot;Tama√±o de una cadena que contiene la 'ìÖ±': {}&quot;, &quot;ìÖ±&quot;.len());
}
</code></pre></pre>
<p>Lo que imprime:</p>
<pre><code class="language-text">Tama√±o de un char: 4
Tama√±o de una cadena que contiene la 'a': 1
Tama√±o de una cadena que contiene la '√ü': 2
Tama√±o de una cadena que contiene la 'ÂõΩ': 3
Tama√±o de una cadena que contiene la 'ìÖ±': 4
</code></pre>
<p>Puedes ver que la <code>a</code> ocupa un byte, la '√ü' alemana ocupa dos, la japonesa <code>ÂõΩ</code> ocupa tres, y el car√°cter del antiguo egipto <code>ìÖ±</code> ocupa cuatro bytes.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let fragmento = &quot;¬°Hola!&quot;;
    println!(&quot;El fragmento ocupa {} bytes.&quot;, fragmento.len());
    let fragmento2 = &quot;ÏïàÎÖï!&quot;; // Coreano de &quot;hola&quot;
    println!(&quot;El fragmento2 ocupa {} bytes.&quot;, fragmento2.len());
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">El fragmento ocupa 7 bytes.
El fragmento2 ocupa 7 bytes.
</code></pre>
<p>El primer fragmento consta de seis caracteres y ocupa 7 bytes (la apertura de exclamaci√≥n ocupa dos bytes). El segundo fragmento consta de tres caracteres y ocupa 7 bytes (los dos primeros caracteres ocupan tres bytes cada uno).</p>
<p>Si <code>.len()</code> devuelve el tama√±o en bytes, ¬øc√≥mo se puede conocer el tama√±o de una cadena de texto en caracteres? Aprenderemos esto m√°s tarde, en este momento basta con recordar que se hace con <code>.chars().count()</code>. La primera funci√≥n <code>.chars()</code> devuelve los caracteres separados y luego cuenta cu√°ntos son.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let fragmento = &quot;¬°Hola!&quot;;
    println!(&quot;El fragmento ocupa {} bytes y son {} caracteres.&quot;,
        fragmento.len(), fragmento.chars().count());
    let fragmento2 = &quot;ÏïàÎÖï!&quot;;
    println!(&quot;El fragmento2 ocupa {} bytes y son {} caracteres.&quot;,
        fragmento2.len(), fragmento2.chars().count());
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">El fragmento ocupa 7 bytes y son 6 caracteres.
El fragmento2 ocupa 7 bytes y son 3 caracteres.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inferencia-de-tipos-de-dato"><a class="header" href="#inferencia-de-tipos-de-dato">Inferencia de tipos de dato</a></h1>
<p><strong><a href="https://youtu.be/q1D2vpy3kEI">Puedes ver este cap√≠tulo en YouTube en ingl√©s</a></strong></p>
<p>La inferencia de tipos de datos consiste en que si no se le indica el tipo de datos al compilador, pero lo puede determinar por s√≠ mismo, √©l decide que tipo utilizar. El compilador siempre necesita conocer el tipo de las variables, pero no siempre es necesario dec√≠rselo expresamente. En realidad, normalmente no necesitas indic√°rselo. Por ejemplo, en la sentencia <code>let mi_numero = 8</code>, <code>mi_numero</code> ser√° de tipo <code>i32</code>. Esto se debe a que el compilador elige siempre el tipo <code>i32</code> para los n√∫meros enteros si no se le indica uno. Sin embargo, en la siguiente sentencia <code>let mi_numero: u8 = 8</code>, la variable <code>mi_numero</code> es de tipo <code>u8</code> ya que as√≠ se le ha indicado.</p>
<p>As√≠ que normalmente el compilador puede deducir el tipo de datos, pero en ocasiones ser√° necesario indic√°rselo por una de las siguientes dos razones:</p>
<ol>
<li>Est√°s programando algo muy complejo y el compilador no puede deducir el tipo de datos que es necesario.</li>
<li>Quieres usar un tipo de datos diferente (por ejemplo, quieres un <code>i128</code>, no el <code>i32</code> que se usa por defecto).</li>
</ol>
<p>Para especificar un tipo, se a√±aden dos puntos despu√©s del nombre de la variable seguido del tipo.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numerito: u8 = 10;
}
</code></pre></pre>
<p>Para los n√∫meros, se puede especificar el tipo despu√©s del n√∫mero, no se necesita un espacio - solo teclearlo justo despu√©s del n√∫mero.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numerito = 10u8; // 10u8 = 10 de tipo u8
}
</code></pre></pre>
<p>Tambi√©n se puede a√±adir <code>_</code> para a√±adir claridad a la lectura.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numerito = 10_u8; // Esto es m√°s f√°cil de leer
    let numerazo = 100_000_000_i32; // 100 millones es de f√°cil lectura con _
}
</code></pre></pre>
<p>El <code>_</code> no modifica el n√∫mero. Solo lo hace m√°s f√°cil de leer. Y no importa el cuantos <code>_</code> se utilizan.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numero = 0________u8;
    let numero2 = 1___6______2____4______i32;
    println!(&quot;{}, {}&quot;, numero, numero2);
}
</code></pre></pre>
<p>Lo anterior imprime <code>0, 1624</code>.</p>
<h2 id="n√∫meros-decimales"><a class="header" href="#n√∫meros-decimales">N√∫meros decimales</a></h2>
<p>Los n√∫meros decimales son aquellos que tienen coma decimal<sup class="footnote-reference"><a href="#1">1</a></sup>. <code>5.5</code> es un n√∫mero decimal y <code>6</code> es un n√∫mero entero. <code>5.0</code> tambi√©n es un n√∫mero decimal e incluso <code>5.</code> lo es.</p>
<p><sup class="footnote-reference"><a href="#1">1</a></sup> N.T.: en espa√±ol se usa una coma como car√°cter para separar la parte entera de un n√∫mero de su parte decimal. En Rust, la coma decimal espa√±ola se sustituye por el punto decimal que es el que se usa habitualmente en los lenguajes de programaci√≥n.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_decimal = 5.; // Rust ve un . y sabe que es un decimal (float, en ingl√©s)
}
</code></pre></pre>
<p>Rust utiliza diversos tipos de dato para almacenar n√∫meros decimales, son el <code>f32</code> y el <code>f64</code>. Al igual que en los n√∫meros enteros, el n√∫mero tras <code>f</code> muestra el n√∫mero de bits utilizados en cada caso para almacenar el dato. Si no se indica el tipo, Rust elige <code>f64</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_decimal: f64 = 5.0; // Esta variable es de tipo f64
    let mi_otro_decimal: f32 = 8.5; // Esta es de tipo f32
    let tercer_decimal = mi_decimal + mi_otro_decimal; // ‚ö†Ô∏è
}
</code></pre></pre>
<p>Cuanto se intenta ejecutar el c√≥digo anterior, Rust se queja diciendo:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:4:39
  |
5 |     let tercer_decimal = mi_decimal + mi_otro_decimal; // ‚ö†Ô∏è
  |                                       ^^^^^^^^^^^^^^^ expected `f64`, found `f32`
</code></pre>
<p>El compilador indica &quot;expected (tipo), found (type)&quot; cuando se usa el tipo err√≥neo. Rust lee el c√≥digo de esta forma:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_decimal: f64 = 5.0; // El compilador ve un f64
    let mi_otro_decimal: f32 = 8.5; // El compilador ve un f64. Es un tipo diferente.
    let tercer_decimal = mi_decimal + // Se quiere sumar mi_decimal, que es f64 a alg√∫n
                                      // otro n√∫mero. Ahora espera otro f64...  
        mi_otro_decimal; // ‚ö†Ô∏è pero se encuentra un f32, no se pueden sumar.
}
</code></pre></pre>
<p>As√≠ que cuando veas que el compilador indica &quot;expected (tipo), found (type)&quot;, debes buscar la causa por la que el compilador esperaba un tipo de datos diferente.</p>
<p>Con los n√∫meros simples es f√°cil arreglarlo. Puedes convertir el <code>f32</code> a <code>f64</code> con un <code>as</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_decimal: f64 = 5.0;
    let mi_otro_decimal: f32 = 8.5;
    // En la siguiente l√≠nea, se utiliza mi_otro decimal como un f64
    let tercer_decimal = mi_decimal + mi_otro_decimal as f64;
}
</code></pre></pre>
<p>O simplemente, se pueden eliminar las declaraciones de tipo, Rust elegir√° tipos que se puedan sumar entre s√≠.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_decimal = 5.0; // Rust elige f64
    let mi_otro_decimal = 8.5; // Rust elige de nuevo f64
    let tercer_decimal = mi_decimal + mi_otro_decimal;
}
</code></pre></pre>
<p>El compilador de Rust es inteligente y no elegir√° f64 si necesitas f32:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_decimal: f32 = 5.0; // Rust elige f64
    let mi_otro_decimal = 8.5; // Normalmente Rust elegir√≠a f64
    // pero al conocer que lo vamos a sumar a un f32, elige un f32 para mi_otro_decimal
    let tercer_decimal = mi_decimal + mi_otro_decimal;
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="imprimiendo-hola-mundo"><a class="header" href="#imprimiendo-hola-mundo">Imprimiendo '¬°Hola, mundo!'</a></h1>
<p><strong>Puedes ver este cap√≠tulo en YouTube en ingl√©s: <a href="https://youtu.be/yYlPHRl2geQ">Video 1</a>, <a href="https://youtu.be/DTCSfBJJZb8">Video 2</a></strong></p>
<p>Cuando creas un nuevo programa Rust, siempre contiene este c√≥digo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<ul>
<li><code>fn</code> significa funci√≥n.</li>
<li><code>main</code> es el nombre de la funci√≥n que inicia el programa.</li>
<li><code>()</code> significa que en este caso no se le pasan variables a esta funci√≥n.</li>
<li><code>{}</code> es un <strong>bloque de c√≥digo</strong>. Es donde se encuentra el c√≥digo.</li>
<li><code>println!</code> es una <strong>macro</strong>, que es como una funci√≥n que sirve para escribir c√≥digo por ti. Las macros siempre tienen un <code>!</code> al final de su nombre. Por ahora, recuerda que <code>!</code> significa que es una macro.</li>
</ul>
<p>Para aprender lo que hace <code>;</code>, crearemos otra funci√≥n. Primero, en <code>main</code> imprimiremos el n√∫mero 8<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<p><sup class="footnote-reference"><a href="#1">1</a></sup> N.T.: aprovechamos para cambiar el saludo a espa√±ol. En Rust, cuando se utiliza la aplicaci√≥n <code>cargo</code> para crear un programa, siempre se incorpora el c√≥digo de <code>main</code> con &quot;Hello, world!&quot; de forma autom√°tica. </p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;¬°Hola, mundo n√∫mero {}!&quot;, 8);
}
</code></pre></pre>
<p>Las <code>{}</code> dentro de <code>println!</code> indican a Rust que &quot;ponga la variable en este lugar&quot;. Este c√≥digo imprime <code>¬°Hola, mundo n√∫mero 8!</code>.</p>
<p>Podemos poner m√°s cosas ampliando lo anterior.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;¬°Hola, mundos n√∫mero {} y {}!&quot;, 8, 9);
}
</code></pre></pre>
<p>El codigo anterior imprime <code>¬°Hola, mundos n√∫mero 8 y 9!</code>.</p>
<p>Ahora vamos a crear una funci√≥n.</p>
<pre><pre class="playground"><code class="language-rust">fn numero() -&gt; i32 {
    8
}

fn main() {
    println!(&quot;¬°Hola, mundo n√∫mero {}!&quot;, numero());
}
</code></pre></pre>
<p>El c√≥digo anterior tambi√©n imprime <code>¬°Hola, mundo n√∫mero 8!</code>. Cuando Rust encuentra <code>numero()</code> entiende que es una funci√≥n. Esta funci√≥n:</p>
<ul>
<li>No toma ning√∫n par√°metro (porque tiene una llamada con <code>()</code>).</li>
<li>Devuelve un <code>i32</code>. El s√≠mbolo de flecha <code>-&gt;</code> muestra el tipo que devuelve la funci√≥n.</li>
<li>La funci√≥n en s√≠ misma solo contiene un <code>8</code>. Al no terminar en <code>;</code> este valor es el que devuelve al terminar de ejecutarse. Si tuviera un <code>;</code> detr√°s, la funci√≥n no devolver√≠a nada (devolver√≠a un <code>()</code>). Rust no compilar√≠a si contuviera un <code>;</code> al final ya que se ha indicado que (tras la flecha) debe devolver un valor de tipo <code>i32</code> y con el <code>;</code> se devuelve <code>()</code> que no es de tipo <code>i32</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn numero() -&gt; i32 {
    8;
}

fn main() {
    println!(&quot;¬°Hola, mundo n√∫mero {}!&quot;, numero());
}
</code></pre></pre>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:1:16
  |
1 | fn numero() -&gt; i32 {
  |    ------      ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
2 |     8;
  |      - help: consider removing this semicolon
</code></pre>
<p>Esto significa que &quot;me dijiste que <code>numero()</code> devuelve un <code>i32</code>, pero a√±adiste un <code>;</code> por lo que esta funci√≥n no devuelve nada&quot;. As√≠ que el compilador sugiere que se elimine el punto y coma.</p>
<p>Tambi√©n se puede escribir lo siguiente <code>return 8;</code>, pero en Rust lo normal es simplemente eliminar el <code>;</code> para ejecutar el <code>return</code>.</p>
<p>Cuando se quiere pasar variables a una funci√≥n, se deben poner dentro de <code>()</code>. Hay que darles un nombre e indicar su tipo.</p>
<pre><pre class="playground"><code class="language-rust">// Entran a la funci√≥n dos i32s. Se llaman num_uno y num_dos
fn multiplicar(num_uno: i32, num_dos: i32) {
    let resultado = num_uno * num_dos;
    println!(&quot;{} por {} es {}&quot;, num_uno, num_dos, resultado);
}

fn main() {
    multiplicar(8, 9); // Pasamos unos n√∫meros directamente
    let algun_numero = 10; // o podemos declarar dos variables
    let algun_otro_numero = 2;
    multiplicar(algun_numero, algun_otro_numero); // y pasarlos a la funci√≥n
}
</code></pre></pre>
<p>Tambi√©n se puede devolver un <code>i32</code>. Basta con poner la variable <code>resultado</code> como la √∫ltima de la funci√≥n sin <code>;</code> al final.</p>
<pre><pre class="playground"><code class="language-rust">fn multiplicar(num_uno: i32, num_dos: i32) -&gt; i32 {
    let resultado = num_uno * num_dos;
    println!(&quot;{} por {} es {}&quot;, num_uno, num_dos, resultado);
    resultado // este es el valor i32 que se retorna
}

fn main() {
    // multiplicar() imprime el resultado y lo devuelve,
    // lo que permite asignarlo a resultado_mult
    let resultado_mult = multiplicar(8, 9);
}
</code></pre></pre>
<h2 id="la-declaraci√≥n-de-variables-y-los-bloques-de-c√≥digo"><a class="header" href="#la-declaraci√≥n-de-variables-y-los-bloques-de-c√≥digo">La declaraci√≥n de variables y los bloques de c√≥digo</a></h2>
<p>Se usa <code>let</code>para declarar una variable (para decirle a Rust que construya una variable).</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_numero = 8;
    println!(&quot;¬°Hola, mundo n√∫mero {}!&quot;, mi_numero);
}
</code></pre></pre>
<p>Las variables existen dentro de un bloque de c√≥digo <code>{}</code>. En el siguiente ejemplo <code>mi_numero</code> desaparece antes de llamar a <code>println!</code> porque se encuentra dentro de su propio c√≥digo.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    {
        let mi_numero = 8; // mi_numero se crea aqu√≠
                           // mi_numero se extingue aqu√≠
    }
    println!(&quot;¬°Hola, mundo n√∫mero {}!&quot;, mi_numero);// ‚ö†Ô∏è  mi_numero no existe y
                                                   // println!() no lo puede encontrar
}
</code></pre></pre>
<p>Se puede usar un bloque de c√≥digo para devolver un valor, como en el siguiente c√≥digo.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_numero = {
        let segundo_num = 8;
        segundo_num + 9 // sin punto y coma, por lo que el
                        // bloque de c√≥digo devuelve 8 + 9 = 17
    }; 
    println!(&quot;¬°Hola, mundo n√∫mero {}!&quot;, mi_numero);
}
</code></pre></pre>
<p>Si se a√±adiera un punto y coma en la sentencia final del bloque, devolver√≠a <code>()</code> (nada).</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_numero = {
        let segundo_num = 8; // declara el segundo n√∫mero
        segundo_num + 9;     // suma 9 con el segundo n√∫mero
                             // pero no se devuelve
                             // segundo_num desaparece aqu√≠
    }; 
    println!(&quot;¬°Hola, mundo n√∫mero {:?}!&quot;, mi_numero); // mi_numero es ()
}
</code></pre></pre>
<p>Si has observado bien, hemos cambiado <code>{}</code> por <code>{:?}</code>. El motivo se ver√° en el siguiente cap√≠tulo.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="la-visualizaci√≥n-y-depuraci√≥n"><a class="header" href="#la-visualizaci√≥n-y-depuraci√≥n">La visualizaci√≥n y depuraci√≥n</a></h1>
<p><strong><a href="https://youtu.be/jd3pC248c0o">Puedes ver este cap√≠tulo en YouTube en ingl√©s</a></strong></p>
<p>En Rust, las variables simples se pueden imprimir usyo <code>{}</code> en <code>println!</code>.  Pero hay variables que no pueden imprimirse y es necesario usar <strong>la impresi√≥n de depuraci√≥n</strong>. La impresi√≥n de depuraci√≥n es para los programadores, porque habitualmente muestra m√°s informaci√≥n. En ocasiones, esta impresi√≥n no es &quot;bonita&quot;, no queda bien, porque muestra informaci√≥n extra para ayudarte.</p>
<p>¬øC√≥mo puedes conocer si necesitas usar <code>{:?}</code> y no <code>{}</code>? El compilador te avesar√°. Por ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let no_imprime = ();
    println!(&quot;Esto no se imprimir√°: {}&quot;, no_imprime); // ‚ö†Ô∏è
}
</code></pre></pre>
<p>Cuyo se compila el c√≥digo anterior, el compilador se queja as√≠:</p>
<pre><code class="language-text">error[E0277]: `()` doesn't implement `std::fmt::Desplay`
 --&gt; src/main.rs:3:42
  |
3 |     println!(&quot;Esto no se imprimir√°: {}&quot;, no_imprime); // ‚ö†Ô∏è
  |                                          ^^^^^^^^^^ `()` cannot be formatted with el default formatter
  |
  = help: el trait `std::fmt::Desplay` es not implemented for `()`
  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
  = note: required by `std::fmt::Desplay::fmt`
  = note: thes error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)
</code></pre>
<p>Esto es mucha informaci√≥n, pero la parte importante es <code>you may be able to use {:?} (or {:#?} for pretty-print) instead</code>. Esto significa que puedes intentar usar <code>{:?}</code> o tambi√©n <code>{:#?}</code>. La segunda opci√≥n, <code>{:#?}</code> se llama &quot;impresi√≥n atractiva&quot;. Es igual que <code>{:?}</code> pero usyo un formateo diferente en m√°s l√≠neas.</p>
<p>En resumen, <code>Desplay</code> (vesualizaci√≥n) supone la impresi√≥n con <code>{}</code>, y <code>Debug</code> (depuraci√≥n) supone la impresi√≥n con <code>{:?}</code>.</p>
<p>Una √∫ltima cosa, puedes usar <code>print!</code> sin <code>ln</code> si no quieres que haya un salto de l√≠nea al final de la impresi√≥n.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    print!(&quot;Esto no imprimir√° un salto de l√≠nea&quot;);
    println!(&quot; as√≠ que esto estar√° en la mesma l√≠nea&quot;);
}
</code></pre></pre>
<p>Que imprimir√° <code>Esto no imprimir√° un salto de l√≠nea as√≠ que esto estar√° en la mesma l√≠nea</code>.</p>
<h2 id="el-n√∫mero-menor-y-el-n√∫mero-mayor"><a class="header" href="#el-n√∫mero-menor-y-el-n√∫mero-mayor">El n√∫mero menor y el n√∫mero mayor</a></h2>
<p>Si se quiere ver el menor y mayor n√∫mero que se puede representar, se puede usar MIN y MAX. <code>std</code> es la &quot;librer√≠a est√°ndar del lenguaje&quot; y contiene las funciones y otros elementos importantes del lenguaje Rust. M√°s adelante se explicar√°n elementos de la librer√≠a estyar. Mientras tanto, puedes recordar que esta es la forma de obtener los numeros menor y mayor de un tipo de datos.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // pista: std::i8::MIN significa
    // &quot;el valor de MIN de la secci√≥n i8 de la librer√≠a estandar&quot;
    println!(&quot;El menor i8 es {} y el mayor i8 es {}.&quot;, std::i8::MIN, std::i8::MAX); 
    println!(&quot;El menor u8 es {} y el mayor u8 es {}.&quot;, std::u8::MIN, std::u8::MAX);
    println!(&quot;El menor i16 es {} y el mayor i16 es {}.&quot;, std::i16::MIN, std::i16::MAX);
    println!(&quot;El menor u16 es {} y el mayor u16 es {}.&quot;, std::u16::MIN, std::u16::MAX);
    println!(&quot;El menor i32 es {} y el mayor i32 es {}.&quot;, std::i32::MIN, std::i32::MAX);
    println!(&quot;El menor u32 es {} y el mayor u32 es {}.&quot;, std::u32::MIN, std::u32::MAX);
    println!(&quot;El menor i64 es {} y el mayor i64 es {}.&quot;, std::i64::MIN, std::i64::MAX);
    println!(&quot;El menor u64 es {} y el mayor u64 es {}.&quot;, std::u64::MIN, std::u64::MAX);
    println!(&quot;El menor i128 es {} y el mayor i128 es {}.&quot;, std::i128::MIN, std::i128::MAX);
    println!(&quot;El menor u128 es {} y el mayor u128 es {}.&quot;, std::u128::MIN, std::u128::MAX);
}
</code></pre></pre>
<p>Que imprimir√°:</p>
<pre><code class="language-text">El menor i8 es -128 y el mayor i8 es 127.
El menor u8 es 0 y el mayor u8 es 255.
El menor i16 es -32768 y el mayor i16 es 32767.
El menor u16 es 0 y el mayor u16 es 65535.
El menor i32 es -2147483648 y el mayor i32 es 2147483647.
El menor u32 es 0 y el mayor u32 es 4294967295.
El menor i64 es -9223372036854775808 y el mayor i64 es 9223372036854775807.
El menor u64 es 0 y el mayor u64 es 18446744073709551615.
El menor i128 es -170141183460469231731687303715884105728 y el mayor i128 es 170141183460469231731687303715884105727.
El menor u128 es 0 y el mayor u128 es 340282366920938463463374607431768211455.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutabilidad-cambio"><a class="header" href="#mutabilidad-cambio">Mutabilidad (cambio)</a></h1>
<p><strong><a href="https://youtu.be/Nyyd6qn7dZY">Puedes ver este cap√≠tulo en YouTube en ingl√©s</a></strong></p>
<p>Cuando se declara una variable con `let, es inmutable (no se puede cambiar su valor).</p>
<p>El c√≥digo siguiente no funciona.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_numero = 8;
    mi_numero = 10; // ‚ö†Ô∏è
}
</code></pre></pre>
<p>El compilador indica <code>error[E0384]: cannot assign twice to immutable variable mi_numero</code>.</p>
<pre><code class="language-text">error[E0384]: cannot assign twice to immutable variable `mi_numero`
 --&gt; src/main.rs:3:5
  |
2 |     let mi_numero = 8;
  |         ---------
  |         |
  |         first assignment to `mi_numero`
  |         help: consider making this binding mutable: `mut mi_numero`
3 |     mi_numero = 10; // ‚ö†Ô∏è
  |     ^^^^^^^^^^^^^^ cannot assign twice to immutable variable
</code></pre>
<p>Esto es porque las variables son inmutables si solo se escribe <code>let</code>.</p>
<p>Muchas veces, ser√° necesario modificar la variable. Para ello, se debe a√±adir <code>mut</code> despu√©s de <code>let</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut mi_numero = 8;
    mi_numero = 10;
}
</code></pre></pre>
<p>El c√≥digo anterior funciona sin problema alguno.</p>
<p>Sin embargo, no se le puede cambiar el tipo. Esto no funciona:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut mi_numero = 8; // La variable es i32. 
                           // El tipo no se puede cambiar.
    mi_numero = &quot;¬°Hola, mundo!&quot;; // ‚ö†Ô∏è
}
</code></pre></pre>
<p>Si se intenta compilar el programa anterior, se obtendr√° el mismo mensaje &quot;expected&quot; por parte del compilador: <code>expected integer, found &amp;str</code>. <code>&amp;str</code>es un tipo de cadena que aprenderemos pronto.</p>
<h3 id="ocultaci√≥n-shadowing"><a class="header" href="#ocultaci√≥n-shadowing">Ocultaci√≥n (Shadowing)</a></h3>
<p>La ocultaci√≥n de una variable sucede cuando se usa <code>let</code> para declarar una nueva variable con el mismo nombre que otra. A primera vista se parece a la mutabilidad, pero es totalmente diferente. En el siguiente ejemplo, se oculta una variable:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_numero = 8; // Esta variable es i32
    println!(&quot;{}&quot;, mi_numero); // imprime 8
    let mi_numero = 9.2; // Esta variable es f64 y tiene el mismo nombre
    // pero es una variable nueva, completamente diferente.
    println!(&quot;{}&quot;, mi_numero) // imprime 9.2
}
</code></pre></pre>
<p>Se dice que hemos &quot;ocultado&quot; <code>mi_numero</code>con un nuevo &quot;enlace&quot;.</p>
<p>¬øSe ha destruido la anterior variable <code>mi_numero</code>? No, pero cuando se llama a <code>mi_numero</code> ahora se accede a la segunda variable de tipo <code>f64</code>. Y como ambas declaraciones se encuentran en el mismo bloque de c√≥digo (mismo √°mbito, mismo <code>{}</code>), se deja de tener acceso al <code>mi_numero</code> de tipo <code>i32</code>.</p>
<p>Si estuvieran en diferentes bloques de c√≥digo, podr√≠amos volver a acceder a la primera variable <code>mi_numero</code>. Por ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_numero = 8; // Esta variable es i32
    println!(&quot;{}&quot;, mi_numero); // imprime 8
    {
        let mi_numero = 9.2; // Esta variable es f64 y tiene el mismo nombre
        // pero es una variable nueva, completamente diferente.
        println!(&quot;{}&quot;, mi_numero) // imprime 9.2
                                  // pero la nueva variable mi_numero
                                  // solo existe hasta aqu√≠
                                  // la anterior ¬°sigue viva!
    }
    println!(&quot;{}&quot;, mi_numero); // imprime 8
}
</code></pre></pre>
<p>En resumen, cuando ocultas una variable, no la destruyes. La <strong>bloqueas</strong>.</p>
<p>Qu√© ventajas tiene el ocultar variables. Es una buena pr√°ctica cuando necesitas modificar una variable en muchas ocasiones. Imagina que quieres hacer un conjunto de c√°lculos matem√°ticos simples con una variable:</p>
<pre><pre class="playground"><code class="language-rust">fn dos_veces(numero: i32) -&gt; i32 {
    numero * 2
}

fn main() {
    let numero_final = {
        let y = 10;
        let x = 9; // x comienza con 9
        let x = dos_veces(x); // se oculta con el nuevo x: 18
        let x = x + y; // se oculta con el nuevo x: 28
        x // devuelve x: a numero_final se asigna este valor de x
    };
    println!(&quot;El n√∫mero ahora es: {}&quot;, numero_final)
}
</code></pre></pre>
<p>Sin ocultar las variables anteriores, habr√≠a sido necesario pensar diferentes nombres, incluso aunque no nos importen estos valores intermedios:</p>
<pre><pre class="playground"><code class="language-rust">fn dos_veces(numero: i32) -&gt; i32 {
    numero * 2
}

fn main() {
    // Ejemplo sin usar las capacidades de ocultar variables
    let numero_final = {
        let y = 10;
        let x = 9; // x comienza con 9
        let x2 = dos_veces(x); // segundo nombre para x
        let x2_y = x2 + y; // ¬°tercer nombre para x!
        x2_y // qu√© pena no tener disponible la ocultaci√≥n
             // habr√≠amos podido usar solo una variable x
    };
    println!(&quot;El n√∫mero ahora es: {}&quot;, numero_final)
}
</code></pre></pre>
<p>En general, se usa la ocultaci√≥n de variables en estos casos. Cuando se quiere usar una variable para un c√°lculo y luego otro m√°s, sin tener mucho inter√©s por los valores intermedios.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="la-pila-la-memoria-din√°mica-y-los-punteros"><a class="header" href="#la-pila-la-memoria-din√°mica-y-los-punteros">La pila, la memoria din√°mica y los punteros</a></h1>
<p>La pila (&quot;stack&quot; en ingl√©s), la memoria din√°mica (&quot;heap&quot; en ingl√©s) y los punteros son elementos muy importantes en Rust.</p>
<p>La pila y la memoria din√°mica son dos tipos de almacenamiento de los datos de un programa durante su ejecuci√≥n. Sus diferencias m√°s importantes son:</p>
<ul>
<li>La pila es muy r√°pida, la memoria din√°mica no lo es tanto. Tampoco es lenta, pero siempre es m√°s r√°pido acceder a la pila. Aunque no es posible utilizar la pila siempre porque:</li>
<li>Rust necesita conocer el tama√±o de una variable en durante su compilaci√≥n para poder guardarla en la pila. As√≠, las variables simples como <code>i32</code> van a la pila ya que se conoce su tama√±o exacto. Se sabe que va a ocupar 4 bytes, 32 bits = 4 bytes. Por lo tanto, los datos de tipo <code>i32</code> pueden ir siempre a la pila.</li>
<li>Algunos tipos no tienen un tama√±o conocido en tiempo de compilaci√≥n. No pueden guardarse en la pila. ¬øQu√© se puede hacer? En primer lugar, se pone la informaci√≥n en la memoria din√°mica ya que esta puede contener datos de cualquier tama√±o. En segundo lugar, se guarda un puntero en la pila. El tama√±o de los punteros es conocid. As√≠, para recuperar un valor de una variable que est√° en la memoria din√°mica, el ordenador va primero a la pila, obtiene el puntero y lo sigue hasta la memoria din√°mica para localizr el dato que se busca.</li>
</ul>
<p>Los punteros parecen complicados, pero no lo son. Son como una tabla de contenidos de un libro. Imagina este libro:</p>
<pre><code class="language-text">MI LIBRO

TABLA DE CONTENIDO

Cap√≠tulo                        P√°gina
Cap√≠tulo 1: mi vida              1
Cap√≠tulo 2: mi gato              15
Cap√≠tulo 3: mi trabajo           23
Cap√≠tulo 4: mi familia           30
Cap√≠tulo 5: mis planes futuros   43
</code></pre>
<p>La tabla de contenido es como una &quot;pila&quot; que, en este caso, contiene cinco punteros. Puedes leerlos y encontrar la informaci√≥n sobre la que tratan. ¬øD√≥nde est√° el cap√≠tulo sobre &quot;mi vida&quot;? Est√° en la p√°gina 1 (<em>Apunta</em> a la p√°gina 1). ¬øD√≥nde est√° el cap√≠tulo sobre &quot;mi trabajo&quot;? Est√° en la p√°gina 23.</p>
<p>El puntero que se ve habitualmente en Rust se denomina <strong>referencia</strong>. Esto es lo importante que se debe saber: una referencia apunta a la memoria de otro valor. Una referencia supone que <em>se tome prestado</em> el valor, pero no se apropia de √©l. Es lo mismo que en el libro anterior: la tabla de contenidos no posee la informaci√≥n. Se encuentra en los cap√≠tulos que son los que la poseen. En Rust, las referencias llevan el s√≠mbolo <code>&amp;</code> al principio de ellas. As√≠.</p>
<ul>
<li><code>let mi_variable = 8</code> crea una variable normal, pero</li>
<li><code>let mi_referencia = &amp;mi_variable</code> crea una referencia. Se lee como &quot;mi_referencia es una referencia a mi_variable&quot; o como &quot;mi_referencia se refiere a mi_variable&quot;.</li>
</ul>
<p>Esto significa que <code>mi_referencia</code> solo mira a los datos de <code>mi_variable</code>. <code>mi_variable</code> sigue siendo propietaria de sus datos.
Tambi√©n es posible tener una referencia que &quot;apunte&quot; a otra referencia. Hasta culquier n√∫mero de referencias.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_numero = 15; // Esto es un i32
    let referencia_simple = &amp;mi_numero; //  Esto es una &amp;i32
    let referencia_doble = &amp;referencia_simple; // Esto es una &amp;&amp;i32
    let referencia_quintuple = &amp;&amp;&amp;&amp;&amp;mi_numero; // Esto es una &amp;&amp;&amp;&amp;&amp;i32
}
</code></pre></pre>
<p>Todos estos son tipos de dato diferentes, de la misma forma que &quot;un amigo de un amigo&quot; es diferente de &quot;un amigo&quot;.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="m√°s-sobre-impresi√≥n"><a class="header" href="#m√°s-sobre-impresi√≥n">M√°s sobre impresi√≥n</a></h1>
<p>En Rust se puede imprimir como se quiera. Por eso, interesa conocer algunas cosas m√°s sobre este tema.</p>
<p>Si se a√±ade <code>\n</code> se imprimir√° una nueva l√≠nea. Si se a√±ade <code>\t</code> se insertar√° un tabulador:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Observa: la funci√≥n usada es print!, no println!
    print!(&quot;\tComienza con un tabulador\ny salta a una nueva l√≠nea&quot;);
}
</code></pre></pre>
<p>El c√≥digo anterior imprime lo siguiente:</p>
<pre><code class="language-text">        Comienza con un tabulador
y salta a una nueva l√≠nea
</code></pre>
<p>Dentro de <code>&quot;&quot;</code> se puede escribir en diferentes l√≠neas, pero es necesario tener cuidado con los espacios:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Nota: despu√©s de la primera l√≠nea tienes que comenzar la siguiente l√≠nea
    // en la primera columna (pegado a la izquierda).
    println!(&quot;Dentro de comillas
se puede escribir
en muchas l√≠neas
y se imprimir√° correctamente.&quot;);
    // Si se escribe directamente bajo la sentencia, se a√±adir√°n los espacios
    // correspondientes de la izquierda
    println!(&quot;Si se olvida que hay que
    escribir pegado al lado izquierdo
    estos espacios se a√±adir√°n
    a la impresi√≥n.&quot;);
}
</code></pre></pre>
<p>El c√≥digo anterior imprime:</p>
<pre><code class="language-text">Dentro de comillas
se puede escribir
en muchas l√≠neas
y se imprimir√° correctamente.
Si se olvida que hay que
    escribir pegado al lado izquierdo
    estos espacios se a√±adir√°n
    a la impresi√≥n.
</code></pre>
<p>Si se necesitase imprimir caracteres como <code>\n</code> (caracteres de escape, como el del salto de l√≠nea y el tabulador que se han visto antes), se puede a√±adir un <code>\</code> extra:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Se imprimen caracteres de escape, no inserta nueva l√≠nea y tabulador: \\n y \\t&quot;);
}
</code></pre></pre>
<p>Lo que imprime:</p>
<pre><code class="language-text">Se imprimen caracteres de escape, no inserta nueva l√≠nea y tabulador: \n y \t
</code></pre>
<p>A veces se necesitan muchos <code>&quot;</code> y caracteres de escape en el texto, por lo que Rust proporciona un m√©todo m√°s simple para ignorarlos: se a√±ade <code>r#</code> al comienzo y <code>#</code> al final de la cadena de caracteres.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // En esta l√≠nea hemos usado \ cinco veces
    println!(&quot;√âl dijo, \&quot;Puedes encontrar el fichero en c:\\files\\my_documents\\file.txt\&quot;. Y as√≠ fue como lo encontr√©.&quot;);
    println!(r#&quot;√âl dijo, &quot;Puedes encontrar el fichero en c:\files\my_documents\file.txt&quot;. Y as√≠ fue como lo encontr√©.&quot;#)
}
</code></pre></pre>
<p>Ambas opciones imprimen lo mismo, pero el uso de <code>r#</code> lo hace m√°s simple de entender.</p>
<pre><code class="language-text">√âl dijo, &quot;Puedes encontrar el fichero en c:\files\my_documents\file.txt&quot;. Y as√≠ fue como lo encontr√©.
√âl dijo, &quot;Puedes encontrar el fichero en c:\files\my_documents\file.txt&quot;. Y as√≠ fue como lo encontr√©.
</code></pre>
<p>Si se necesitara imprimir un car√°cter <code>#</code> en el texto, se puede usar <code>r##</code> al comienzo del texto y <code>##</code> al final. Si se usaran m√°s de dos consecutivos, se pueden seguir a√±adiendo <code>#</code> al comienzo y al final, hasta que no coincida con nada contenido en el texto.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

    let my_string = &quot;'Hola, mundo,' dijo.&quot;; // comilla simples
    let quote_string = r#&quot;&quot;Hola, mundo,&quot; dijo.&quot;#; // comillas dobles
    // Contiene # se necesita al menos ##
    let hashtag_string = r##&quot;El hasgtag #holamundo se ha hecho muy popular.&quot;##; 
    // Contiene ### se necesitan al menos ####
    let many_hashtags = r####&quot;&quot;No se tiene que teclear ### para usar un hashtag. Solo hay que usar #.&quot;&quot;####; 

    println!(&quot;{}\n{}\n{}\n{}\n&quot;, my_string, quote_string, hashtag_string, many_hashtags);
}
</code></pre></pre>
<p>Este c√≥digo imprimir√°:</p>
<pre><code class="language-text">'Hola, mundo,' dijo.
&quot;Hola, mundo,&quot; dijo.
El hasgtag #holamundo se ha hecho muy popular.
&quot;No se tiene que teclear ### para usar un hashtag. Solo hay que usar #.&quot;
</code></pre>
<p>Existe otro uso para <code>r#</code>: usar palabras reservadas (como <code>let</code>, <code>fn</code>, etc.) como nombres de variable.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let r#let = 6; // let como nombre de variable
    let mut r#mut = 10; // Esta variable se llama mut
}
</code></pre></pre>
<p>Esta funci√≥n de <code>r#</code> se introdujo porque las versiones m√°s antiguas de Rust ten√≠an menos palabras reservadas que ahora. As√≠ se pueden evitar errores en c√≥digo previo en el que se usaban nombres de variables que ahora son palabras reservadas.</p>
<p>Puede ser que por alguna raz√≥n <em>realmente</em> se necesite una funci√≥n que se denomine como <code>return</code>. As√≠ se puede escribir:</p>
<pre><pre class="playground"><code class="language-rust">fn r#return() -&gt; u8 {
    println!(&quot;Ah√≠ va tu n√∫mero.&quot;);
    8
}

fn main() {
    let mi_numero = r#return();
    println!(&quot;{}&quot;, mi_numero);
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">Ah√≠ va tu n√∫mero.
8
</code></pre>
<p>Esto no se va a necesitar normalmente, pero si <em>realmente</em> hace falta, se puede usar.</p>
<p>Si se necesita imprimir los bytes de un <code>&amp;str</code> o un <code>char</code>, basta con escribir la letra <code>b</code> delante de la cadena.
Esto funciona para todos los caracteres ASCII. Estos son todos los caracteres ASCII.</p>
<pre><code class="language-text">‚ò∫‚òª‚ô•‚ô¶‚ô£‚ô†‚ô´‚òº‚ñ∫‚óÑ‚Üï‚Äº¬∂¬ß‚ñ¨‚Ü®‚Üë‚Üì‚Üí‚àü‚Üî‚ñ≤‚ñº123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
</code></pre>
<p>As√≠, este c√≥digo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // N.T.: no se pueden poner tildes ya que en las 
    // vocales ya que las letras resultantes no forman
    // parte del conjunto de caracteres ASCII
    println!(&quot;{:?}&quot;, b&quot;Esto aparece como una lista de numeros&quot;);
}
</code></pre></pre>
<p>Da el siguiente resultado:</p>
<pre><code class="language-text">[69, 115, 116, 111, 32, 97, 112, 97, 114, 101, 99, 101, 32, 99, 111, 109, 111, 32, 117, 110, 97, 32, 108, 105, 115, 116, 97, 32, 100, 101, 32, 110, 117, 109, 101, 114, 111, 115]
</code></pre>
<p>Para un <code>char</code> esto se llama <em>byte</em> y para el tipo <code>&amp;str</code> se llama <em>byte de cadena de texto</em>.</p>
<p>Tambi√©n existe un sistema de escape para insertar caracteres Unicode: <code>\u{}</code>. As√≠ es posible imprimir cualquier car√°cter Unicode en una cadena de texto. Adem√°s, es posible formatear un n√∫mero en hexadecimal usando <code>{:X}</code>. El siguiente ejemplo demuestra c√≥mo imprimir el c√≥digo hexadecimal que representa al car√°cter Unicode y c√≥mo imprimirlo de nuevo como car√°cter.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Convierte el char a u32 para obtener su valor num√©rico
    println!(&quot;{:X}&quot;, 'Ìñâ' as u32); 
    println!(&quot;{:X}&quot;, 'H' as u32);
    println!(&quot;{:X}&quot;, 'Â±Ö' as u32);
    println!(&quot;{:X}&quot;, '„ÅÑ' as u32);

    // Imprime los caracteres con el sistema de escape \u
    println!(&quot;\u{D589}, \u{48}, \u{5C45}, \u{3044}&quot;); 
}
</code></pre></pre>
<p>Ya se conoce que <code>println!</code> puede imprimir con <code>{}</code> (modo <em>Display</em>) t <code>{:?}</code> (para Depuraci√≥n). Adem√°s de <code>{:#?}</code> para &quot;impresi√≥n bonita&quot;. Pero existen otras muchas formas de imprimir.</p>
<p>Por ejempli, si se dispone de una referencia se puede usar <code>{:p}</code> para imprimir la <em>direcci√≥n del puntero</em>. Es decir, el lugar de la memoria del ordenador a la que <em>apunta</em> la referencia.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 9;
    let number_ref = &amp;number;
    println!(&quot;{:p}&quot;, number_ref);
}
</code></pre></pre>
<p>El c√≥digo anterior imprime algo parecido a <code>0x7ffec9426f4c</code>, depender√° de d√≥nde se ejecute el programa y se almacene el n√∫mero referenciado en la memoria del ordenador.</p>
<p>Los valores num√©ricos se pueden imprimir en binario, hexadecimal u octal:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 555;
    println!(&quot;Binario: {:b}, hexadecimal: {:x}, octal: {:o}&quot;, number, number, number);
}
</code></pre></pre>
<p>Que imprime <code>Binario: 1000101011, hexadecimal: 22b, octal: 1053</code>.</p>
<p>Tambi√©n se pueden a√±adir n√∫meros entre las llaves para indicar qu√© variable utilizar, teniendo en cuenta que la primera tiene como √≠ndice el 0, la segunda el 1 y as√≠ sucesivamente.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nombre_padre = &quot;Jos√© Miguel&quot;;
    let nombre_hijo = &quot;V√≠ctor&quot;;
    let apellido = &quot;Gonz√°lez&quot;;
    println!(&quot;Este es {1} {2}, hijo de {0} {2}.&quot;, nombre_padre, nombre_hijo, apellido);
}
</code></pre></pre>
<p>La variable <code>nombre_padre</code> est√° en la posici√≥n 0, <code>nombre_hijo</code>en la 1 y <code>apellido</code> est√° en la posici√≥n 2. Por eso, el c√≥digo anterior imprime <code>Este es V√≠ctor Gonz√°lez, hijo de Jos√© Miguel Gonz√°lez.</code>.</p>
<p>Puede suceder que sea necesario imprimir una cadena de caracteres compleja con muchas variables dentro de las llaves. O puede que se necesite imprimir la misma variable dos o m√°s veces. Para ello, se pueden a√±adir nombres a las llaves.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(
        &quot;{city1} est√° en {pais} y {city2} tambi√©n est√° en {pais},
pero {city3} no est√° en {pais}.&quot;,
        city1 = &quot;Seul&quot;,
        city2 = &quot;Busan&quot;,
        city3 = &quot;Tokio&quot;,
        pais = &quot;Korea&quot;
    );
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">Seul est√° en Korea y Busan tambi√©n est√° en Korea,
pero Tokio no est√° en Korea.
</code></pre>
<p>Tambi√©n es posible editar de forma compleja el formato de la impresi√≥n. Tiene esta forma:</p>
<p><code>{variable:relleno alineamiento m√≠nimo.m√°ximo}</code></p>
<p>Para entender esta sintaxis:</p>
<ol>
<li>¬øSe quiere usar un nombre de variable? Se escribe primero su nombre, como antes en {pais}. Lo siguiente ser√° a√±adir (opcionalmente) <code>:</code> despu√©s si se quiere formatear de alg√∫n modo.</li>
<li>¬øSe se necesita un car√°cter de relleno? Por ejemplo, 55 con tres &quot;ceros de relleno&quot; se imprimir√≠a como 00055.</li>
<li>¬øQue alineamiento se necesita para el relleno? izquierda, centro o derecha.</li>
<li>¬øSe desea una longitud m√≠nima? solo hay que indicar el n√∫mero deseado.</li>
<li>¬øSe desea una longitud m√°xima? solo hay que indicarla con un <code>.</code> delante.</li>
</ol>
<p>Por ejemplo, si se quiere escribir la letra &quot;a&quot; con cinco caracteres - de relleno (a izquierda y derecha):</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let letra = &quot;a&quot;;
    println!(&quot;{:-^11}&quot;, letra);
}
</code></pre></pre>
<p>Que imprime <code>-----a-----</code>. El ordenador lo interpreta as√≠:</p>
<ul>
<li>¬øHay un nombre de variable? No, ya que lo primero que aparece en <code>{:-^11}</code> son los dos puntos. No hay nombre de variable delante de estos dos puntos.</li>
<li>¬øSe pide un car√°cter de relleno? S√≠, - est√° justo despu√©s de <code>:</code> y lo sigue un <code>^</code>, lo que significa que el texto se inserta en el centro y el car√°cter de relleno se reparte en los espacios sobrantes a izquierda y derecha. Las otras dos posibilidades son: <code>&lt;</code> que indica que el texto va a la izquierda y el car√°cter de relleno a la izquierda, y <code>&gt;</code> que indica que el texto va a la derecha con el relleno a la izquierda.</li>
</ul>
<p>A continuaci√≥n, se muestran diversos ejemplos de tipos de formateo.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let titulo = &quot;NOTICIAS DE HOY&quot;;
    // sin variable, relleno con -, centrado, longitud de 30 caracteres
    println!(&quot;{:-^30}&quot;, titulo); 
    let barra = &quot;|&quot;;
    // sin variable, relleno con espacios, 15 caracters cada uno, una barra a izquierda y otra a derecha
    println!(&quot;{: &lt;15}{: &gt;15}&quot;, barra, barra); 
    let a = &quot;SEUL&quot;;
    let b = &quot;TOKIO&quot;;
     // variables city1 y city2, relleno con -, a izquierda y a derecha
     println!(&quot;{city1:-&lt;15}{city2:-&gt;15}&quot;, city1 = a, city2 = b);
}
</code></pre></pre>
<p>El c√≥digo anterior imprime:</p>
<pre><code class="language-text">-------NOTICIAS DE HOY--------
|                            |
SEUL---------------------TOKIO
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cadenas-de-caracteres"><a class="header" href="#cadenas-de-caracteres">Cadenas de caracteres</a></h1>
<p><strong><a href="https://youtu.be/pSyaGzGg26o">Puedes ver este cap√≠tulo en YouTube en ingl√©s</a></strong></p>
<p>Rust tiene dos tipos de cadenas de caracteres: <code>String</code> y <code>&amp;str</code>. ¬øCu√°l es la diferencia?</p>
<ul>
<li><code>&amp;str</code> es una cadena de caracteres simple que reside en la pila. Cuando se escribe <code>let mi_variable = &quot;¬°Hola, mundo!&quot;</code> se crea una <code>&amp;str</code>. Este tipo es muy r√°pido.</li>
<li><code>String</code> es un tipo de dato m√°s complejo. Es un poco m√°s lento, pero tiene m√°s funciones. Una <code>String</code> es un puntero que almacena los datos en la memoria din√°mica.</li>
</ul>
<p>Hay que destacar que <code>&amp;str</code> tiene <code>&amp;</code> como primer car√°cter debido a que es necesaria una referencia para utilizar el tipo <code>str</code>.  Esto es por la raz√≥n que vimos anteriormente: la pila necesita conocer el tama√±o, as√≠ que se le da una referencia, las referencias siempre tienen el mismo tama√±o. Otro tema a tener en cuenta es que al utilizar <code>&amp;</code> una referencia para interactuar con el tipo <code>str</code>, nunca se es due√±o del tipo. Por el contrario, <code>String</code>es un tipo <em>con due√±o</em>. M√°s adelante se mostrar√° la importancia de esta distinci√≥n.</p>
<p>Ambos tipos, <code>&amp;str</code> y <code>String</code> son UTF-8. Por ejemplo, se puede escribir el siguiente c√≥digo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Nombre en coreano. No da problemas, ya que &amp;str es UTF-8
    let nombre = &quot;ÏÑúÌÉúÏßÄ&quot;;
    // »ö y »ô no son un problema en UTF-8.
    let otro_nombre = String::from(&quot;Adrian Fahrenheit »öepe»ô&quot;);
}
</code></pre></pre>
<p>En el c√≥digo anterior se observa que se puede construir de forma f√°cil una <code>String</code> de una <code>&amp;str</code>. Los dos tipos est√°n muy relacionados, aunque son muy diferentes.</p>
<p>Gracias a UTF-8, incluso se pueden escribir emojis.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nombre = &quot;üòÇ&quot;;
    println!(&quot;Mi nombre real es {}&quot;, nombre);
}
</code></pre></pre>
<p>Si se ejecuta este c√≥digo en el terminal de comandos de tu propio ordenador tiene que aparecer <code>Mi nombre real es üòÇ</code> a menos el terminal de comandos presente limitaciones y no lo pueda imprimir. En cuyo caso imprimir√° algo as√≠ <code>Mi nombre real es ÔøΩ</code>. En todo caso, Rust es capaz de manejar todos los caracteres Unicode.</p>
<p>La raz√≥n para utilizar una referencia <code>&amp;</code>para el tipo <code>str</code> es que <code>str</code> es un tipo de datos de tama√±o din√°mico, su tama√±o puede ser diferente. Por ejmplo, los nombres &quot;ÏÑúÌÉúÏßÄ&quot; y &quot;Adrian Fahrenheit »öepe»ô&quot; no son del mismo tama√±o:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

    // std::mem::size_of::&lt;Type&gt;() devuelve el tama√±o en bytes de un tipo
    println!(&quot;Una String siempre ocupa {:?} bytes. Es de tama√±o fijo.&quot;,
        std::mem::size_of::&lt;String&gt;()); 
    println!(&quot;Y un i8 siempre ocupa {:?} bytes. Es de tama√±o fijo.&quot;, 
        std::mem::size_of::&lt;i8&gt;());
    println!(&quot;Y un f64 siempre ocupa {:?} bytes. Es de tama√±o fijo.&quot;, 
        std::mem::size_of::&lt;f64&gt;());
     // std::mem::size_of_val() devuelve el tama√±o en bytes de una variable
    println!(&quot;¬øY un &amp;str? Puede ocupar cualquier tama√±o. 'ÏÑúÌÉúÏßÄ' ocupa {:?} bytes. No es de tama√±o fijo.&quot;,
        std::mem::size_of_val(&quot;ÏÑúÌÉúÏßÄ&quot;));
    println!(&quot;Y 'Adrian Fahrenheit »öepe»ô' ocupa {:?} bytes. No es de tama√±o fijo.&quot;,
        std::mem::size_of_val(&quot;Adrian Fahrenheit »öepe»ô&quot;));
}
</code></pre></pre>
<p>Lo que da como resultado:</p>
<pre><code class="language-text">Una String siempre ocupa 24 bytes. Es de tama√±o fijo.
Y un i8 siempre ocupa 1 bytes. Es de tama√±o fijo.
Y un f64 siempre ocupa 8 bytes. Es de tama√±o fijo.
¬øY un &amp;str? Puede ocupar cualquier tama√±o. 'ÏÑúÌÉúÏßÄ' ocupa 9 bytes. No es de tama√±o fijo.
Y 'Adrian Fahrenheit »öepe»ô' ocupa 25 bytes. No es de tama√±o fijo.
</code></pre>
<p>Por eso es necesario usar &amp;, porque as√≠ se construye un puntero (tipo de tama√±o fijo) que puede almacenarse en la pila.  Si se escribiera <code>str</code>, Rust no sabr√≠a qu√© hacer al no conocer su tama√±o.</p>
<p>Hay muchas formas de construir un elemento de tipo <code>String</code>. Algunas de ellas son:</p>
<ul>
<li><code>String::from(&quot;Esta es una cadena de texto&quot;);</code> - <code>String::from()</code> es un m√©todo de Strgin que crea un <code>String</code> a partir de una cadena de texto.</li>
<li><code>&quot;Esta es una cadena de texto&quot;.to_string()</code> - <code>&quot;&quot;.to_string()</code> es un m√©todo de <code>&amp;str</code> que crea un <code>String</code>.</li>
<li>La macro <code>format!</code> - Es como <code>println!</code> excepto que crea un String en lugar de imprimir el texto.</li>
</ul>
<p>A continuaci√≥n se muestran algunos ejemplos:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_name = &quot;Billybrobby&quot;;
    let my_country = &quot;USA&quot;;
    let my_home = &quot;Korea&quot;;

    let together = format!(
        &quot;Soy {} y vengo de {}, pero vivo en {}.&quot;,
        my_name, my_country, my_home
    );
}
</code></pre></pre>
<p>As√≠ se construye un objeto String denominado <em>together</em>, pero no se ha impreso.</p>
<p>Otra forma adicional para crear un String es con la funci√≥n <code>into()</code>, pero esta forma es algo diferente ya que no solo sirve para crear String. Algunos tipos se pueden convertir de forma f√°cil en otros utilizando <code>from</code> y <code>into()</code>. Si el tipo tiene <code>from</code>, tiene tambi√©n <code>into()</code>. <code>from</code> resulta m√°s claro ya que con √©l conoces los tipos: al usarlo <code>String::from(&quot;Cadena de texto&quot;)</code> se sabe que se crea una <code>String</code> de <code>&amp;str</code>. Sin embargo, con <code>.into()</code> el compilador, a veces, no lo conoce:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_string = &quot;Intento construir un String&quot;.into(); // ‚ö†Ô∏è
}
</code></pre></pre>
<p>Rust no conoce el tipo al que se quiere convertir la cadena de texto, porque se pueden crear muchos tipos diferentes a partir de un <code>&amp;str</code>. Rust se queja: puedo convertir &amp;str en muchos tipos diferentes. ¬øCu√°l es el que quieres?</p>
<pre><code class="language-text">error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let my_string = &quot;Intento construir un String&quot;.into(); // ‚ö†Ô∏è
  |         ^^^^^^^^^ consider giving `my_string` a type
</code></pre>
<p>Por lo que se puede corregir as√≠:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_string: String = &quot;Intento construir un String&quot;.into();
}
</code></pre></pre>
<p>Y ahora s√≠ se ha creado un objeto String.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="const-y-static"><a class="header" href="#const-y-static">const y static</a></h1>
<p><strong><a href="https://youtu.be/Ky3HqkWUcI0">Puedes ver este cap√≠tulo en YouTube en ingl√©s</a></strong></p>
<p>Adem√°s de <code>let</code>, existen dos maneras m√°s de declarar valores. <code>const</code> y <code>static</code>. Para estas declaraciones, Rust no realiza la inferencia de los tipos: es necesario declarar el tipo de los valores. Existen vamores que no cambian (<code>const</code> significa constante). La diferencia entre ellos es que:</p>
<ul>
<li><code>const</code> se utiliza para los valores que no cambian y el nombre se reemplaza por su valor, all√≠ donde se usa.</li>
<li><code>static</code> define una posici√≥n fija en memoria que puede actuar como una variable global.</li>
</ul>
<p>Por ello, son casi lo mismo. Los programadores de Rust casi siempre utilizan valores constantes con <code>const</code>.</p>
<p>Por convenci√≥n, las constantes se suelen escribir con todas las letras en may√∫sculas, normalmente est√°n fuera del <code>main</code> para que existan en todo el programas.</p>
<p>Dos ejemplos:</p>
<pre><pre class="playground"><code class="language-rust">const NUMERO_DE_MESES: u32 = 12;
static ESTACIONES: [&amp;str; 4] = [&quot;Primavera&quot;, &quot;Verano&quot;, &quot;Oto√±o&quot;, &quot;Invierno&quot;];

fn main() {
    println!(&quot;{}&quot;, NUMERO_DE_MESES);
    println!(&quot;{:?}&quot;, ESTACIONES);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="algo-m√°s-sobre-referencias"><a class="header" href="#algo-m√°s-sobre-referencias">Algo m√°s sobre referencias</a></h1>
<p><strong><a href="https://youtu.be/R13sQ8SNoEQ">Puedes ver este cap√≠tulo en YouTube en ingl√©s</a></strong></p>
<p>Las referencias son muy importantes en Rust. Las utiliza para asegurarse de que son seguros todos los accesos a la memoria. Ya se ha explicado anteriormente que para crear una referencia se utiliza <code>&amp;</code> delante del valor:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let pais = String::from(&quot;Austria&quot;);
    let ref_uno = &amp;pais;
    let ref_dos = &amp;pais;

    println!(&quot;{}&quot;, ref_uno);
}
</code></pre></pre>
<p>El c√≥digo anterior imprime <code>Austria</code>. <code>pais</code> es un <code>String</code>. Se crean dos referencias a <code>pais</code>. Estas referencias son de tipo <code>&amp;String</code>, es decir son dos variables que son &quot;referencias a String&quot;. Se pueden crear tantas referencias a <code>pais</code>como se quiera. Todas &quot;apuntan&quot; al mismo valor, pero son punteros diferentes.</p>
<p>A continuaci√≥n se muestra un ejemplo sobre c√≥mo Rust proteje el acceso a zonas de memoria err√≥neas:</p>
<pre><pre class="playground"><code class="language-rust">fn return_str() -&gt; &amp;str {
    let pais = String::from(&quot;Austria&quot;);
    let pais_ref = &amp;pais;
    pais_ref // ‚ö†Ô∏è
}

fn main() {
    let pais = return_str();
}
</code></pre></pre>
<p>La funci√≥n <code>return_str()</code> crea un valor de tipo String, luego crea una referencia a dicho valor. Cuando se intenta devolver la referencia se produce un error:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:1:20
  |
1 | fn return_str() -&gt; &amp;str {
  |                    ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
  |
1 | fn return_str() -&gt; &amp;'static str {
  |                    ^^^^^^^^
</code></pre>
<p>El valor de <code>pais</code> solo existe dentro de la funci√≥n, al terminar de ejecutarse desaparece. Una vez la variable desaparece, el ordenador libera la memoria que ocupaba y la utiliza para otra cosa. Por eso, despu√©s de que la funci√≥n termina, <code>pais_ref</code> apunta a una zona de memoria que ya no tiene el valor esperado y eso no es correcto. Rust previene este fallo en el c√≥digo e impide que el programa compile.</p>
<p>Este es el efecto importante de la existencia de tipos de dato &quot;con due√±o&quot; en Rust. En el c√≥digo anterior, el valor <code>String</code> tiene como due√±o a la variable <code>pais</code>, por eso se puede &quot;prestar&quot; a otras variables (referencias), pero cuando desaparece la variable due√±a del valor, <code>pais</code>, la referencia tambi√©n desaparece, la referencia tiene &quot;prestado&quot; el valor, por lo que no se puede pasar a otro &quot;due√±o&quot;.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="referencias-modificables-mutables"><a class="header" href="#referencias-modificables-mutables">Referencias modificables (mutables)</a></h1>
<p><strong><a href="https://youtu.be/G48z6Rv76vc">Puedes ver este cap√≠tulo en YouTube en ingl√©s</a></strong></p>
<p>Si se necesita modificar un valor a trav√©s de una referencia, se debe indicar que la referencia sea modificable (mutable). Para ello, se utiliza <code>&amp;mut</code> en lugar de <code>&amp;</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // no hay que olvidar que hay que escribir mut en la variable original
    let mut mi_numero = 8;
    let num_ref = &amp;mut mi_numero;
}
</code></pre></pre>
<p><code>mi_numero</code> es de tipo <code>i32</code>, y <code>num_ref</code> es de tipo <code>&amp;mut i32</code> (es una &quot;referencia modificable/mutable a un valor <code>√¨32</code>).</p>
<p>Si se desea usar esta referencia para sumar 10, no se puede usar <code>num_ref += 10</code> ya que <code>num_ref</code> no es de tipo <code>i32</code>, es <code>&amp;i32</code>. Para obtener el valor de la referencia, se debe usar <code>*</code> que significa que &quot;no se necesita la referencia, sino el valor que al que representa&quot;. En otras palabras, <code>*</code> es lo opuesto a <code>&amp;</code>, un <code>*</code> borra a un <code>&amp;</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut mi_numero = 8;
    let num_ref = &amp;mut mi_numero;
    *num_ref += 10; // Usa * para cambiar el valor i32
    println!(&quot;{}&quot;, mi_numero);

    let segundo_numero = 800;
    let triple_referencia = &amp;&amp;&amp;segundo_numero;
    println!(&quot;segundo_numero = ¬øtriple_referencia? {}&quot;,
        segundo_numero == ***triple_referencia);
}
</code></pre></pre>
<p>El c√≥digo anterior, da como resultado:</p>
<pre><code class="language-text">18
segundo_numero = ¬øtriple_referencia? true
</code></pre>
<p>El uso del operador sobre una variable <code>&amp;</code> se denomina &quot;referenciar&quot;. El uso del operador sobre una variable de referencia <code>*</code> se denomina &quot;<strong>des</strong>referenciar&quot;.</p>
<p>Rust usa dos reglas para las referencias mutables e inmutables. Son muy importantes y f√°ciles de recordar porque tienen sentido.</p>
<ul>
<li><strong>Regla 1</strong>: Si solo existen referencias inmutables a un valor, se pueden tener tantas como se quiera.</li>
<li><strong>Regla 2</strong>: Si existe una referencia mutable a un valor, solo puede existir una referencia. Esto √∫ltimo significa que no pueden existir a la vez referencias inmutables y mutables en el mismo momento.</li>
</ul>
<p>Estas reglas son necesarias debido a que las referencias mutables pueden cambiar los datos. Ser√≠a problem√°tico que se modificara un dato cuando otras referencias lo est√°n usando.</p>
<p>Un forma de entenderlo es pensar en la creaci√≥n de una presentaci√≥n de Powerpoint <sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>No se trata de un ejemplo excesivamente bueno, ya que actualmente es posible editar simult√°neamente en Office 365.</p>
</div>
<p>El primer caso representa el de <strong>la existencia de una referencia mutable</strong>: un empleado est√° editando una presentaci√≥n de Powerpoint. Piode ayuda a su jefe. El empleado entrega sus credenciales de acceso a su jefe para que pueda editar el Powerpoint. Ahora el jefe tiene una &quot;referencia mutable&quot; a la presentaci√≥n de su empleado. El jefe puede hacer los cambios que quiera y devolver el ordenador m√°s tarde. Nadie m√°s tiene acceso a la presentaci√≥n, por lo que este caso no da problemas.</p>
<p>El segundo caso representa el de **la existencia √∫nicamente de referencias inmutables&quot;: El empleado entrega la presentaci√≥n a 100 personas. Todas ellas pueden verla. Tienen una &quot;referencia inmutable&quot; a la presentaci√≥n ya que nadie puede modificarla, por lo que este caso no da problemas.</p>
<p>El tercer caso representa la <strong>situaci√≥n problem√°tica a evitar</strong>: El empleado entrega sus credenciales de acceso a su jefe, que a partir de aqu√≠ dispone de una &quot;referencia mutable&quot;. Adem√°s, el empleado entrega la presentaci√≥n a 100 personas. El jefe puede entrar a editar y estas modificaciones pueden verse o no por parte de las 100 personas, seg√∫n el momento en que accedan sin que puedan controlar.</p>
<p>Se puede ver que el intento de usar una referencia mutable simult√°neamente con una inmutable no es aceptado por el compilador:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut numero = 10;
    let numero_ref = &amp;numero;
    let numero_modif = &amp;mut numero;
    *numero_modif += 10;
    println!(&quot;{}&quot;, numero_ref); // ‚ö†Ô∏è
}
</code></pre></pre>
<p>El compilador muestra un mensaje explicativo muy claro para mostrar el problema:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `numero` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:4:24
  |
3 |     let numero_ref = &amp;numero;
  |                      ------- immutable borrow occurs here
4 |     let numero_modif = &amp;mut numero;
  |                        ^^^^^^^^^^^ mutable borrow occurs here
5 |     *numero_modif += 10;
6 |     println!(&quot;{}&quot;, numero_ref); // ‚ö†Ô∏è
  |                    ---------- immutable borrow later used here
</code></pre>
<p>Sin embargo, este c√≥digo s√≠ funciona. ¬øPor qu√©?</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut numero = 10;
    let numero_modif = &amp;mut numero; // referencia modificable
    *numero_modif += 10; // suma 10
    let numero_ref = &amp;numero; // referencia inmutable
    println!(&quot;{}&quot;, numero_ref); // imprime el valor referenciado
}
</code></pre></pre>
<p>Imprime <code>20</code> sin problemas. Funciona porque el compilador es suficientemente inteligente para comprender el c√≥digo. Conoce que se ha cmabiado <code>numero</code> a trav√©s de la referencia <code>numero_modif</code>, pero despu√©s, esta referencia mutable no se vuelve a usar. Por eso no hay problema aqu√≠. No se usan &quot;a la vez&quot; referencias inmutables y mutables (como s√≠ pasaba en el caso anterior).</p>
<p>En versiones anteriores de Rust, este c√≥digo s√≠ daba error, pero actualmente no lo hace ya que el compilador es m√°s inteligente. Puede entender no solo lo que se ha tecleado, sino como se usa todo.</p>
<h2 id="ocultaci√≥n-shadowing-de-nuevo"><a class="header" href="#ocultaci√≥n-shadowing-de-nuevo">Ocultaci√≥n (shadowing) de nuevo</a></h2>
<p>Es necesario recordar que el ocultamiento de variables no destruye sus valores, sino que los bloquea. Con el uso de las referencias esto se ve m√°s claro.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let pais = String::from(&quot;Austria&quot;);
    let pais_ref = &amp;pais;
    let pais = 8;
    println!(&quot;{}, {}&quot;, pais_ref, pais);
}
</code></pre></pre>
<p>¬øQu√© imprime este c√≥digo? ¬ø<code>Austria, 8</code> o <code>8, 8</code>? Imprime <code>Austria, 8</code>. En la primera l√≠nea, se declara una variable <code>String</code> con el valor <code>Austria</code> y denominada <code>pais</code>. En la segunda l√≠nea se crea una referencia al valor de esta variable. Es decir, a la <code>String</code> que contiene <code>Austria</code>. Despu√©s, se oculta la variable <code>pais</code> con una nueva cuyo valor es <code>8</code> y que es de tipo <code>i32</code>. El primer elemento <code>pais</code> no se destruy√≥ (lo har√° al finalizar el √°mbito en el que est√°, en la llave de cierre de este bloque), por lo que sigue accesible a trav√©s de la referencia <code>pais_ref</code>. Para mayor claridad, se vuelve a mostrar el c√≥digo, ahora con comentarios sobre su comportamiento.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let pais = String::from(&quot;Austria&quot;); // String denominada pais
    let pais_ref = &amp;pais; // pais_ref es una referencia al valor
    let pais = 8; // nueva variable pais con un valor 8. Sin relaci√≥n con la anterior, ni con pais_ref
    println!(&quot;{}, {}&quot;, pais_ref, pais); // pais_ref sigue &quot;apuntando&quot; al dato Austria
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="paso-de-referencias-a-funciones"><a class="header" href="#paso-de-referencias-a-funciones">Paso de referencias a funciones</a></h1>
<p><strong>Puedes ver este cap√≠tulo en Youtube en ingl√©s: <a href="https://youtu.be/mKWXt9YTavc">referencias inmutables</a> y <a href="https://youtu.be/kJV1wIvAbyk">referencias mutables</a></strong></p>
<p>Las referencias son muy √∫tiles en las funciones. La regla de Rust para todos los valores es que un valor solo puede tener una variable propietario.</p>
<p>Este c√≥digo no funcionar√°:</p>
<pre><pre class="playground"><code class="language-rust">fn print_pais(pais_nombre: String) {
    println!(&quot;{}&quot;, pais_nombre);
}

fn main() {
    let pais = String::from(&quot;Austria&quot;);
    print_pais(pais); // Se imprime &quot;Austria&quot;
    print_pais(pais); // ‚ö†Ô∏è Se intenta de nuevo, pero no funciona
}
</code></pre></pre>
<p>Devuelve el siguiente error:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `pais`
 --&gt; src/main.rs:8:16
  |
6 |     let pais = String::from(&quot;Austria&quot;);
  |         ---- move occurs because `pais` has type `String`, which does not implement the `Copy` trait
7 |     print_pais(pais); // Se imprime &quot;Austria&quot;
  |                ---- value moved here
8 |     print_pais(pais); // ‚ö†Ô∏è Se intenta de nuevo, pero no funciona
  |                ^^^^ value used here after move
</code></pre>
<p>La variable <code>pais</code> ya no existen en la √∫ltima l√≠nea. El funcionamiento es el siguiente:</p>
<ul>
<li>Paso 1: Se crea el valor de tipo <code>String</code> cuyo due√±o es la variable <code>pais</code>.</li>
<li>Paso 2: Se pasa <code>pais</code> a la funci√≥n <code>print_pais</code>. Es una funci√≥n que no tiene <code>-&gt;</code> en su declaraci√≥n, por lo que no retorna ning√∫n valor. Al hacer la llamada, la variable <code>pais_nombre</code> (par√°metro) es la nueva due√±a del valor. Despu√©s de que esta funci√≥n finaliza, <code>pais_nombre</code> desaparece, como es la due√±a del valor, este tambi√©n se destruye.</li>
<li>Paso 3: Se intenta pasar por segunda vez <code>pais</code> a la funci√≥n `print_pais, pero ya no existe ya que dej√≥ de ser due√±a del valor y el valor despareci√≥ dentro de la primera llamada a la funci√≥n.</li>
</ul>
<p>Se podr√≠a hacer que la funci√≥n <code>print_pais</code> devolviera de nuevo el valor <code>String</code>, pero es poco ortodoxo.</p>
<pre><pre class="playground"><code class="language-rust">fn print_pais(pais_nombre: String) -&gt; String {
    println!(&quot;{}&quot;, pais_nombre);
    pais_nombre // se devuelve el valor
}

fn main() {
    let pais = String::from(&quot;Austria&quot;);
    let pais = print_pais(pais); // Es necesario crear una nueva variable para recuperar el valor
    print_pais(pais);
}
</code></pre></pre>
<p>Ahora s√≠ funciona e imprime:</p>
<pre><code class="language-text">Austria
Austria
</code></pre>
<p>Es mucho mejor evitar que la variable <code>print_nombre</code>, par√°metro de la funci√≥n, sea due√±a del valor, solamente se &quot;presta&quot;, sin que la variable <code>pais</code> de la funci√≥n <code>main</code> deje de ser su due√±o.</p>
<pre><pre class="playground"><code class="language-rust">fn print_pais(pais_nombre: &amp;String) {
    println!(&quot;{}&quot;, pais_nombre);
}

fn main() {
    let pais = String::from(&quot;Austria&quot;);
    print_pais(&amp;pais); // Se imprime &quot;Austria&quot;
    print_pais(&amp;pais); // Se intenta de nuevo y funciona correctamente
}
</code></pre></pre>
<p>En este caso <code>print_pais()</code> toma una referencia a una <code>String</code>: <code>&amp;String</code>. Cuando se llama <code>print_pais()</code> se pasa una referencia con <code>&amp;pais</code>. Esto significa que &quot;la funci√≥n puede acceder al valor, pero no se hace due√±a de √©l&quot;.</p>
<p>A continuaci√≥n, se muestra un ejemplo similar para observar el comportamiento de las referencias modificables (mutables).</p>
<pre><pre class="playground"><code class="language-rust">fn a√±ade_hungria(pais_nombre: &amp;mut String) { // se pasa una referencia mutable
    pais_nombre.push_str(&quot;-Hungr√≠a&quot;); // push_str() a√±ade un &amp;str a un String
    println!(&quot;Ahora dice: {}&quot;, pais_nombre);
}

fn main() {
    // es importante que la variable se declare
    // como mutable para poder crear referencias mutables
    let mut pais = String::from(&quot;Austria&quot;);
    a√±ade_hungria(&amp;mut pais); // hay que pasar la referencia mutable.
    println!(&quot;Y el valor se ha modificado aqu√≠: {}&quot;, pais);
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">Ahora dice: Austria-Hungr√≠a
Y el valor se ha modificado aqu√≠: Austria-Hungr√≠a
</code></pre>
<p>En resumen:</p>
<ul>
<li><code>fn nombre_de_funcion(variable: String)</code> toma un <code>String</code> y se hace due√±o de √©l.</li>
<li><code>fn nombre_de_funcion(variable: &amp;String)</code> toma prestado un <code>String</code> y puede acceder a su valor.</li>
<li><code>fn nombre_de_funcion(variable: &amp;mut String)</code> toma prestado un <code>String</code>, puede acceder a su valor y modificarlo.</li>
</ul>
<p>El siguiente ejemplo puede parecer similar, pero es muy diferente. Sirve para mostrar c√≥mo quien se hace due√±o de un objeto puede decidir que sea modificable, aunque anteriormente no lo fuese.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let pais = String::from(&quot;Austria&quot;); // pais no es mutable, ni referencia
    a√±adir_hungria(pais);
}

fn a√±adir_hungria(mut pais: String) { // a√±adir_hungria declara su par√°metro como mutable
    pais.push_str(&quot;-Hungr√≠a&quot;);
    println!(&quot;{}&quot;, pais);
}
</code></pre></pre>
<p>La funci√≥n <code>a√±adir_hungria</code> se hace due√±a del valor en su variable <code>mut pais</code>. A partir de ah√≠, puede hacer con este valor lo que quiera.</p>
<p>Si se recuerda el ejemplo anterior sobre el empleado, su jefe y la presentaci√≥n en powerpoint, esta es la situaci√≥n en la que el empleado le da el control completo al jefe. El empleado no puede volver a tocar la presentaci√≥n y el jefe puede hacer lo que quiera con ella.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="copia"><a class="header" href="#copia">Copia</a></h1>
<p>Algunos tipos de Rust son muy simples. Se almacenan todos en la pila ya que el compilador conoce su tama√±o. Esto significa que son f√°ciles de copiar, por lo que el compilador siempre los copia cuando se env√≠an a una funci√≥n. Son valores de tama√±o fijo, conocido y peque√±o. En estos casos, no hay necesidad de preocuparse por qui√©n es el due√±o de estos tipos de dato. A estos tipos, se los denomina <strong>tipos copia</strong> (Copy Types, en ingl√©s).</p>
<p>Estos tipos simples incluyen a los enteros, flotantes, booleanos (<code>true</code> -verdadero- y <code>false</code> -falso-) y <code>char</code>.</p>
<p>Para que los tipos se puedan copiar tienen que <strong>implementar</strong> la posibilidad de copia (copy). Se puede consultar la documentaci√≥n de cada tipo para conocerlo. Por ejemplo, esta es la documentaci√≥n del tipo <code>char</code>:</p>
<p><a href="https://doc.rust-lang.org/std/primitive.char.html">https://doc.rust-lang.org/std/primitive.char.html</a></p>
<p>A la izquierda de esta documentaci√≥n se puede ver <strong>Trait Implementations</strong>. Se muestran, entre otras: <strong>Copy</strong>, <strong>Debug</strong> y <strong>Display</strong>. Lo que permite conocer que <code>char</code> puede:</p>
<ul>
<li>Copiarse cuando se pasa como par√°metro a una funci√≥n (<strong>Copy</strong>).</li>
<li>Puede usar <code>{}</code> para imprimir (<strong>Display</strong>).</li>
<li>Puede usar <code>{:?}</code> para imprimir (<strong>Debug</strong>).</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn prints_number(numero: i32) { // Esta funci√≥n no tiene -&gt;, no devuelve ning√∫n valor
                             // Si el n√∫mero no se copiara, esta funci√≥n se har√≠a au propietaria 
                             // y no se podr√≠a volver a usar
    println!(&quot;{}&quot;, numero);
}

fn main() {
    let mi_numero = 8;
    prints_number(mi_numero); // Imprime 8. prints_number obtiene una copia del n√∫mero
    prints_number(mi_numero); // Imprime 8 de nuevo.
                              // No hay problema ya que mi_numero es un tipo que se copia
}
</code></pre></pre>
<p>Sin embargo, si se revisa la documentaci√≥n de <code>String</code> se ve que no es un tipo que se copie.</p>
<p><a href="https://doc.rust-lang.org/std/string/struct.String.html">https://doc.rust-lang.org/std/string/struct.String.html</a></p>
<p>A la izquierda de esta documentaci√≥n se puede ver <strong>Trait Implementations</strong>, en orden alfab√©tico. En la C no est√° <strong>Copy</strong>. Lo que s√≠ aparece es <strong>Clone</strong>, que es similar a *<em>Copy</em>, solo que es necesario invocarlo expresamente con el m√©todo <code>clone()</code>. Es decir, que no se clona por s√≠ mismo, se tiene que pedir expresamente.</p>
<p>En el siguiente ejemplo, <code>prints_country()</code> imprime el nombre del pa√≠s, que es de tipo <code>String</code>. Se quiere, como en el caso anterior, imprimir dos veces, pero no es posible:</p>
<pre><pre class="playground"><code class="language-rust">fn prints_country(country_name: String) {
    println!(&quot;{}&quot;, country_name);
}

fn main() {
    let country = String::from(&quot;Kiribati&quot;);
    prints_country(country);
    prints_country(country); // ‚ö†Ô∏è
}
</code></pre></pre>
<p>El mensaje es autoexplicativo:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `country`
 --&gt; src\main.rs:4:20
  |
2 |     let country = String::from(&quot;Kiribati&quot;);
  |         ------- move occurs because `country` has type `std::string::String`, which does not implement the `Copy` trait
3 |     prints_country(country);
  |                    ------- value moved here
4 |     prints_country(country);
  |                    ^^^^^^^ value used here after move
</code></pre>
<p>Dice que <code>String</code> no implementa el rasgo necesario para copiar <code>Copy trait</code>. Sin embargo, se ha visto que s√≠ implementa el rasgo <code>Clone</code>, por lo que se puede a√±adir <code>.clone()</code> al c√≥digo para generar de forma expresa una copia del valor. De este modo, se puede enviar un clon del valor a la funci√≥n. As√≠, despu√©s de llamar a la funci√≥n, la variable <code>country</code> contin√∫a vigente y se puede utilizar.</p>
<pre><pre class="playground"><code class="language-rust">fn prints_country(country_name: String) {
    println!(&quot;{}&quot;, country_name);
}

fn main() {
    let country = String::from(&quot;Kiribati&quot;);
    prints_country(country.clone()); // crea un clon y lo pasa a la funci√≥n. country sigue vigente
    prints_country(country);
}
</code></pre></pre>
<p>Evidentemente, si el <code>String</code> es muy largo, generar un clon requiere el uso de mucha memoria. Una cadena de texto <code>String</code> puede ser de la longitud de un libro entero, y cada vez que se llama a <code>.clone()</code> se genera una copia completa. Por eso, es recomendable el uso de <code>&amp;</code> para utilizar una referencia cuando sea posible. Por ejemplo, el c√≥digo siguiente a√±ade una cadena de texto <code>&amp;str</code> en una <code>String</code> y despu√©s crea un clon cada vez que se utiliza en una funci√≥n:</p>
<pre><pre class="playground"><code class="language-rust">fn get_length(input: String) { // Se apropia de la cadena de texto
    println!(&quot;Tiene una longitud de {} palabras.&quot;, input.split_whitespace().count()); // la divide para contar el n√∫mero de palabras
}

fn main() {
    let mut my_string = String::new();
    for _ in 0..50 {
        my_string.push_str(&quot;Aqu√≠ van palabras en espa√±ol &quot;); // a√±ade las palabras
        get_length(my_string.clone()); // obtiene un nuevo clon cada vez
    }
}
</code></pre></pre>
<p>Lo que imprime es:</p>
<pre><code class="language-text">Tiene una longitud de 5 palabras.
Tiene una longitud de 10 palabras.
...
Tiene una longitud de 250 palabras
</code></pre>
<p>Esto genera 50 clones. El siguiente c√≥digo cumple la misma funci√≥n usando referencias y es mucho m√°s eficiente:</p>
<pre><pre class="playground"><code class="language-rust">fn get_length(input: &amp;String) {
    println!(&quot;Tiene una longitud de {} palabras.&quot;, input.split_whitespace().count());
}

fn main() {
    let mut my_string = String::new();
    for _ in 0..50 {
        my_string.push_str(&quot;Aqu√≠ van palabras en espa√±ol &quot;);
        get_length(&amp;my_string);
    }
}
</code></pre></pre>
<p>Con el c√≥digo anterior no se genera ning√∫n clon.</p>
<h2 id="variables-sin-valores"><a class="header" href="#variables-sin-valores">Variables sin valores</a></h2>
<p>Una variables sin valor est√° <em>sin inicializar</em>. Para crear una variable en este estado se usa <code>let</code> y el nombre de la variable:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_variable; // ‚ö†Ô∏è
}
</code></pre></pre>
<p>Rust no compila si hay alguna variable sin inicializar.</p>
<p>Sin embargo, en ocasiones pueden ser √∫tiles. Un claro ejemplo es cuando:</p>
<ul>
<li>Se tiene un bloque de c√≥digo en el que se genera el valor necesario para la variable y...</li>
<li>...la variable tiene que sobrevivir fuera del bloque de c√≥digo.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn loop_then_return(mut counter: i32) -&gt; i32 {
    loop {
        counter += 1;
        if counter % 50 == 0 {
            break;
        }
    }
    counter
}

fn main() {
    let my_number;

    { // Este bloque es innecesario, pero se crea para documentar caso
        let number = {
            // Aqu√≠ podria haber mucho c√≥digo
            // para generar un valor, por ejemplo:
            57
        };

        my_number = loop_then_return(number);
    }

    println!(&quot;{}&quot;, my_number);
}
</code></pre></pre>
<p>Este ejemplo imprime <code>100</code>.</p>
<p>Se observa que <code>my_number</code> se declar√≥n en la funci√≥n <code>main()</code>, por lo que su tiempo de vida dura hasta su finalizaci√≥n. Y obtiene su valor dentro del bucle <code>loop</code>. El valor pasa a ser propiedad de <code>my_number</code> antes de salir del bloque.</p>
<p>Si se hubiera declarado y asignado el valor en la misma l√≠nea con <code>let my_number = loop_then_return(number)</code> dentro del bloque, la variable hubiera desaparecido con el bloque.</p>
<p>De forma simplificada, ayuda a verlo el sustituir la funci√≥n por su valor de retorno, 100. Se ve en el siguiente c√≥digo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number;
    {
        my_number = 100;
    }

    println!(&quot;{}&quot;, my_number);
}
</code></pre></pre>
<p>Es casi como escribir <code>let my_number = { 100 };</code>.</p>
<p>Se debe observar que <code>my_number</code> no es <code>mut</code>. No se le asigna un valor hasta que se asigna el 100, por lo que no ha cambiado de valor. En el fondo el c√≥digo real para <code>my_number</code> es solo <code>let my_number = 100;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tipos-colecci√≥n"><a class="header" href="#tipos-colecci√≥n">Tipos colecci√≥n</a></h1>
<p>Rust tiene muchos tipos para construir una colecci√≥n. La colecciones sirven para almacenar m√°s de un valor en un mismo lugar. Por ejemplo, permiten almacenar la informaci√≥n sobre todas las ciudades de un pa√≠s en una variable.</p>
<p>Se iniciar√° con los arrays, que son los m√°s r√°pidos, pero tambi√©n los que tienen la funcionalidad m√°s limitada. En este sentido, son como el tipo <code>&amp;str</code>.</p>
<h2 id="arrays"><a class="header" href="#arrays">Arrays</a></h2>
<p>Son los datos guardados dentro de corchetes: <code>[]</code>.</p>
<p>Los Arrays:</p>
<ul>
<li>No pueden cambiar de tama√±o.</li>
<li>Tienen datos del mismo tipo.</li>
</ul>
<p>Sin embargo, son muy r√°pidos.</p>
<p>El tipo de un array es: <code>[tipo; longitud]</code>. Por ejemplo, el tipo de <code>[&quot;Uno&quot;, &quot;Dos&quot;]</code> es <code>[&amp;str; 2]</code>. Esto significa que los siguientes dos arrays tienen tipos diferentes:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let array1 = [&quot;One&quot;, &quot;Two&quot;]; // Este es de tipo [&amp;str; 2]
    let array2 = [&quot;One&quot;, &quot;Two&quot;, &quot;Five&quot;]; // Y este de tipo [&amp;str; 3]. ¬°Son dos tipos diferentes!
}
</code></pre></pre>
<p>Para conocer el tipo de una variable se puede &quot;pedir&quot; al compilador que haga algo con ella que no sea v√°lido, por ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let seasons = [&quot;Spring&quot;, &quot;Summer&quot;, &quot;Autumn&quot;, &quot;Winter&quot;];
    let seasons2 = [&quot;Spring&quot;, &quot;Summer&quot;, &quot;Fall&quot;, &quot;Autumn&quot;, &quot;Winter&quot;];
    seasons.ddd(); // ‚ö†Ô∏è
    seasons2.thd(); // ‚ö†Ô∏è tambi√©n
}
</code></pre></pre>
<p>El compilador dice, &quot;¬øQu√© haces? No existe el m√©todo <code>.ddd()</code> para la variable seasons y tampoco existe el m√©todo <code>.thd()</code> para seasons2&quot; como puedes ver:</p>
<pre><code class="language-text">error[E0599]: no method named `ddd` found for array `[&amp;str; 4]` in the current scope
 --&gt; src\main.rs:4:13
  |
4 |     seasons.ddd(); // 
  |             ^^^ method not found in `[&amp;str; 4]`

error[E0599]: no method named `thd` found for array `[&amp;str; 5]` in the current scope
 --&gt; src\main.rs:5:14
  |
5 |     seasons2.thd(); // 
  |              ^^^ method not found in `[&amp;str; 5]`
</code></pre>
<p>Y dice que <code>method not found in `[&amp;str; 4]`</code>, que es el tipo del array.</p>
<p>Si se necesita un array con el mismo valor en todos los elementos, se puede declarar de la siguiente forma:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_array = [&quot;a&quot;; 10];
    println!(&quot;{:?}&quot;, my_array);
}
</code></pre></pre>
<p>Que imprime <code>[&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;]</code>.</p>
<p>Este m√©todo se utiliza mucho para crear buffers. Por ejemplo, <code>let mut buffer = [0;640]</code> crea un array de 640 ceros. Posteriormente, se puede modificar el valor cero por otro dato.</p>
<p>Se pueden indexrar los valores (recuperarlos) con <code>[]</code>. El primer valor es <code>[0]</code>, el segundo <code>[1]</code> y as√≠ sucesivamente.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_numbers = [0, 10, -20];
    println!(&quot;{}&quot;, my_numbers[1]); // imprime 10
}
</code></pre></pre>
<p>Se puede obtener una secci√≥n (slice) de un array. Lo primero que se necesita es una referencia <code>&amp;</code> porque el compilador no conoce el tama√±o. Despu√©s se puede usar <code>..</code> para mostrar el rango.</p>
<p>Por ejemplo, si se utiliza el siguiente array: <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let array_of_ten = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    let three_to_five = &amp;array_of_ten[2..5];
    let start_at_two = &amp;array_of_ten[1..];
    let end_at_five = &amp;array_of_ten[..5];
    let everything = &amp;array_of_ten[..];

    println!(&quot;Tres a cinco: {:?}, comienza en el segundo: {:?}, finaliza en el quinto: {:?}, todo: {:?}&quot;, three_to_five, start_at_two, end_at_five, everything);
}
</code></pre></pre>
<p>Se debe recordar que:</p>
<ul>
<li>Los n√∫meros de √≠ndice comienzan en 0 (no en 1).</li>
<li>los rangos son <strong>excluyentes</strong> (es decir, no incluyen el √∫ltimo n√∫mero).</li>
</ul>
<p>As√≠, <code>[0..2]</code> obtiene el primer y segundo valor (0 y 1). Dicho de otro modo, el √≠ndice cero y uno. No obtiene el tercer valor, cuyo  √≠ndice es dos.</p>
<p>Es posible establecer un rango <strong>inclusivo</strong>, que s√≠ incluya el √∫ltimo n√∫mero del rango. Para ello se escribe <code>..=</code>, en lugar de <code>..</code>. As√≠ que <code>[0..=2]</code> permite obtener el primer, segundo y tercer elemento del array.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vectores"><a class="header" href="#vectores">Vectores</a></h1>
<p><strong><a href="https://youtu.be/Eh-DsRnDKmw">Puedes ver este cap√≠tulo en Youtube en ingl√©s</a></strong></p>
<p>Del mismo modo que se dispone de <code>&amp;str</code> y <code>String</code>, se dispone de arrays y vectores. Los arrays son m√°s r√°pidos, pero tienen menos funcionalidad, y los vectores son m√°s lentos, pero tienen m√°s funcionalidad (Rust siempre es muy r√°pido, solo que los vectores no son tan r√°pidos como los arrays). El tipo es <code>Vec</code> y, por lo tanto, se le puede llamar como &quot;vec&quot;.</p>
<p>Existen principalemente dos formas de declarar un vector. Una es igual a como se crea un <code>String</code>, mediante el uso de <code>new</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let name1 = String::from(&quot;Windy&quot;);
    let name2 = String::from(&quot;Gomesy&quot;);

    let mut my_vec = Vec::new();
    // Si se compilara este programa hasta aqu√≠, el compilador dar√° un error.
    // ya que no conoce el tipo de datos del vec.

    my_vec.push(name1); // Ahora s√≠ lo conoce, es un Vec&lt;String&gt;
    my_vec.push(name2);
}
</code></pre></pre>
<p>Los <code>Vec</code> siempre contienen valores y para eso sirven <code>&lt;&gt;</code> (los par√©ntesis angulares). Un <code>Vec&lt;String&gt;</code> es un vector que contiene elementos <code>String</code>. Algunos otros ejemplos son:</p>
<ul>
<li><code>Vec&lt;(i32, i32)&gt;</code> es un vector en el que cada elemento de contenido es una tupla <code>(i32, i32)</code>.</li>
<li><code>Vec&lt;Vec&lt;String&gt;&gt;</code> es un vector en el que cada elemento es otro vector de <code>String</code>. Por ejemplo, se puede pensar en almacenar el texto de un libro como un <code>Vec&lt;String&gt;</code>. Para almacenar varios libros har√≠a falta crear una lista de elementos del tipo anterior y esto se puede hacer en otro <code>Vec</code> que contiene <code>Vec&lt;String&gt;</code>. Por lo tanto, el tipo resultante ser√≠a as√≠ <code>Vec&lt;Vec&lt;String&gt;&gt;</code>.</li>
</ul>
<p>En lugar de usar <code>.push()</code> para llegar a deducir el tipo de elementos que contiene un vector, se puede declarar el tipo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec: Vec&lt;String&gt; = Vec::new(); // El compilador conoce el tipo
                                              // Por eso no hay error
}
</code></pre></pre>
<p>Como se observa, todos los elementos de un vector tienen que tener un mismo tipo.</p>
<p>Otra forma sencilla de crear un vector es usando la macro <code>vec!</code>, cuya sintaxis recuerda a la declaraci√≥n de un array.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec = vec![8, 10, 10];
}
</code></pre></pre>
<p>El tipo de los elementos, en este ejemplo, es <code>Vec&lt;i32&gt;</code>. Un vector de enteros. </p>
<p>Se pueden obtener secciones de un vector, igual que como se hace para un array.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let vec_of_ten = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    // Todo el c√≥digo es id√©ntico, salvo que se a√±ade vec!.
    let three_to_five = &amp;vec_of_ten[2..5];
    let start_at_two = &amp;vec_of_ten[1..];
    let end_at_five = &amp;vec_of_ten[..5];
    let everything = &amp;vec_of_ten[..];

    println!(&quot;Three to five: {:?},
start at two: {:?}
end at five: {:?}
everything: {:?}&quot;, three_to_five, start_at_two, end_at_five, everything);
}
</code></pre></pre>
<p>Puesto que un vector es m√°s lento que un array, se pueden usar diversos m√©todos para hacerlo m√°s r√°pido. Un vector tiene una <strong>capacidad</strong> de espacio asignada, que permite que al ir insertando nuevos elementos en el vector, se haga r√°pidamente. Cada vez que se hace esto, el vector se acerca al l√≠mite de su capacidad. Cuando esta se supera, Rust crea un nuevo espacio del doble del tama√±o actual y copia todos los elementos al nuevo espacio. Esto se denomina relocalizaci√≥n. Se puede usar el m√©todo <code>.capacity()</code>para ver la capacidad de un vector seg√∫n se le van a√±adiendo elementos.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut num_vec = Vec::new();
    println!(&quot;{}&quot;, num_vec.capacity()); // 0 elementos: immprime 0
    num_vec.push('a'); // a√±ade un car√°cter
    println!(&quot;{}&quot;, num_vec.capacity()); // 1 elemento: imprime 4. Vecs con 1 elemento siempre se inician con una capacidad de 4
    num_vec.push('a'); // a√±ade uno m√°s
    num_vec.push('a'); // a√±ade uno m√°s
    num_vec.push('a'); // a√±ade uno m√°s
    println!(&quot;{}&quot;, num_vec.capacity()); // 4 elementos: a√∫n 4 de capacidad.
    num_vec.push('a'); // a√±ade uno m√°s
    println!(&quot;{}&quot;, num_vec.capacity()); // imprime 8. Son 5 elementos, pero ha doblado la capacidad de 4 a 8 para hacer espacio.
}
</code></pre></pre>
<p>Esto imprime:</p>
<pre><code class="language-text">0
4
4
8
</code></pre>
<p>As√≠ que este vector ha sufrido dos relocalizaciones: de 0 a 4 y de 4 a 8. Para que fuese m√°s r√°pido se puede iniciar as√≠:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut num_vec = Vec::with_capacity(8); // Se crea con una capacidad inicial de 8
    num_vec.push('a'); // se a√±ade un car√°cter
    println!(&quot;{}&quot;, num_vec.capacity()); // imprime 8
    num_vec.push('a'); // a√±ade uno m√°s
    println!(&quot;{}&quot;, num_vec.capacity()); // imprime 8
    num_vec.push('a'); // a√±ade uno m√°s
    println!(&quot;{}&quot;, num_vec.capacity()); // imprime 8.
    num_vec.push('a'); // a√±ade uno m√°s
    num_vec.push('a'); // a√±ade uno m√°s
    // Ahora hay 5 elementos
    println!(&quot;{}&quot;, num_vec.capacity()); // A√∫n 8
}
</code></pre></pre>
<p>Este vector no ha sufrido ninguna relocalizaci√≥n, lo que es mejor. Por eso, si se conoce a priori el n√∫mero de elementos que se necesitar√°, se puede inicializar el vector con <code>Vec::with_capacity()</code> para que funcione m√°s r√°pido.</p>
<p>En el caso de las <code>&amp;str</code> se pod√≠a utilizar <code>.into()</code> para convertirlo en una <code>String</code>. Igualmente, se puede convertir un array en un vector con la misma funci√≥n.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec: Vec&lt;u8&gt; = [1, 2, 3].into();
    let my_vec2: Vec&lt;_&gt; = [9, 0, 10].into(); // Vec&lt;_&gt; significa &quot;elige el tipo del Vector por m√≠&quot;
                                             // Rust elegir√° Vec&lt;i32&gt;
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuplas"><a class="header" href="#tuplas">Tuplas</a></h1>
<p><strong><a href="https://youtu.be/U67Diy6SlTg">Se puede ver este cap√≠tulo en Youtube en ingl√©s</a></strong></p>
<p>En Rust las tuplas usan <code>()</code>. Ya han aparecido muchas tuplas vac√≠as ya que <em>nada</em>, en una funci√≥n, realmente significa una tupla vac√≠a:</p>
<pre><code class="language-text">fn do_something() {}
</code></pre>
<p>realmente es igual a:</p>
<pre><code class="language-text">fn do_something() -&gt; () {}
</code></pre>
<p>Esta funci√≥n no recibe ning√∫n par√°metro (recibe una tupla vac√≠a) y no retorna ning√∫n valor (una tupla vac√≠a). Por eso, se han estado usando ya muchas tuplas en los ejemplos de cap√≠tulos anteriores. Cuando no se retorna ning√∫n valor en una funci√≥n, se est√° retornando una tupla vac√≠a.</p>
<pre><pre class="playground"><code class="language-rust">fn just_prints() {
    println!(&quot;Estoy imprimiendo&quot;); // Al a√±adir un ;
    // como √∫ltimo dato antes de terminar la funci√≥n
    // se est√° indicando que se debe retornar una tupla vac√≠a
}

fn main() {}
</code></pre></pre>
<p>Las tuplas pueden almacenar muchos tipos de elementos diferentes a la vez. Los elementos incluidos se indexan con n√∫meros de 0 en adelante. Para acceder a ellos se utiliza el operador <code>.</code> en lugar de <code>[]</code>. A continuaci√≥n se incorporan datos de diferentes tipos en una √∫nica tupla:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let random_tuple = (&quot;Esto es un texto&quot;, 8, vec!['a'], 'b', [8, 9, 10], 7.7);
    println!(
        &quot;El interior de la tupla contiene: Primer elemento: {:?}
Segundo elemento: {:?}
Tercer elemento: {:?}
Cuarto elemento: {:?}
Quinto elemento: {:?}
Sexto elemento: {:?}&quot;,
        random_tuple.0,
        random_tuple.1,
        random_tuple.2,
        random_tuple.3,
        random_tuple.4,
        random_tuple.5,
    )
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">El interior de la tupla contiene: Primer elemento: &quot;Esto es un texto&quot;
Segundo elemento: 8
Tercer elemento: ['a']
Cuarto elemento: 'b'
Quinto elemento: [8, 9, 10]
Sexto elemento: 7.7
</code></pre>
<p>Esta tupla es de tipo <code>(&amp;str, i32, Vec&lt;char&gt;, char, [i32; 3], f64)</code>.</p>
<p>Se puede usar una tupla para crear m√∫ltiples variables. En el siguiente c√≥digo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let str_vec = vec![&quot;one&quot;, &quot;two&quot;, &quot;three&quot;];
}
</code></pre></pre>
<p><code>str_vec</code> contiene tres elementos. ¬øC√≥mo se pueden recuperar los tres valores de este vector en diferentes variables? Por ejemplo, con una tupla:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let str_vec = vec![&quot;one&quot;, &quot;two&quot;, &quot;three&quot;];

    let (a, b, c) = (str_vec[0], str_vec[1], str_vec[2]); // las variables ser√°n a, b, y c
    println!(&quot;{:?}&quot;, b);
}
</code></pre></pre>
<p>El resultado del c√≥digo anterior imprime <code>&quot;two&quot;</code>, que es lo que contiene la variable <code>b</code>. A esta forma de extraer valores en variables se denomina <em>desestructuramiento</em>.</p>
<p>Si se necesita desestructurar un conjunto de elementos, pero no se quieren todos, se puede utilizar <code>_</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let str_vec = vec![&quot;one&quot;, &quot;two&quot;, &quot;three&quot;];

    let (_, _, variable) = (str_vec[0], str_vec[1], str_vec[2]);
}
</code></pre></pre>
<p>El c√≥digo anterior solo crea una variable denominada <code>variable</code>, pero no las crea para el resto de elementos.</p>
<p>Existen muchos m√°s tipos colecci√≥n y muchas formas adicionales de utilizar a los arrays, vectores y tuplas. Se ense√±ar√° m√°s sobre ellos m√°s adelante, pero primero, se ense√±ar√° la forma de controlar el flujo de ejecuci√≥n de un programa.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="estructuras-de-control"><a class="header" href="#estructuras-de-control">Estructuras de control</a></h1>
<p><strong>Se puede ver este cap√≠tulo en YouTube en ingl√©s: <a href="https://youtu.be/UAymDOpv_us">Parte 1</a> y <a href="https://youtu.be/eqysTfiiQZs">Parte 2</a></strong></p>
<p>Las estructuras de control del flujo de ejecuci√≥n permiten indicar qu√© c√≥digo debe ejecutarse en cada caso. La estructura de control de flujo m√°s simple es <code>if</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 5;
    if my_number == 7 {
        println!(&quot;Es el siete&quot;);
    }
}
</code></pre></pre>
<p>Se utiliza <code>==</code> y no <code>=</code>. <code>==</code> sirve para comparar y <code>=</code> se utiliza para asignar un valor. Tambi√©n hay que destacar que se escribe <code>if my_number == 7</code> y no <code>if (my_number == 7)</code>. La estructura de control <code>if</code> no necesita par√©ntesis en Rust.</p>
<p>Esta estructura se completa con <code>else if</code> y <code>else</code> si resultan necesarias:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 5;
    if my_number == 7 {
        println!(&quot;Es el siete&quot;);
    } else if my_number == 6 {
        println!(&quot;Es el seis&quot;)
    } else {
        println!(&quot;Es un n√∫mero diferente&quot;)
    }
}
</code></pre></pre>
<p>El c√≥digo anterior imprime <code>Es un n√∫mbero diferente</code> porque no es igual a 7 o 6.</p>
<p>Se pueden a√±adir m√°s condiciones con <code>&amp;&amp;</code> (operador <code>y l√≥gico</code>) y <code>||</code> (operador <code>o l√≥gico</code>).</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 5;
    if my_number % 2 == 1 &amp;&amp; my_number &gt; 0 { // % 2 es el resto de la divisi√≥n entre dos
        println!(&quot;Es un n√∫mero impar positivo&quot;);
    } else if my_number == 6 {
        println!(&quot;Es el seis&quot;)
    } else {
        println!(&quot;Es un n√∫mero diferente&quot;)
    }
}
</code></pre></pre>
<p>El c√≥digo anterior imprime <code>Es un n√∫mero impar positivo</code> porque cuando se divide entre 2 el resto es 1, que es mayor que 0.</p>
<p>Se observa que cuando hay demasiados <code>if</code>, <code>else</code> y <code>else if</code> el c√≥digo puede resultar dif√≠cil de leer. En estos casos (y en otros muchos) se puede utilizar <code>match</code>, que resulta mucho m√°s l√≠mpio. <code>match</code> requiere que se contemplen todos los casos posibles para evitar errores. As√≠ que el siguiente c√≥digo no funciona:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number: u8 = 5;
    match my_number {
        0 =&gt; println!(&quot;Es cero&quot;),
        1 =&gt; println!(&quot;Es uno&quot;),
        2 =&gt; println!(&quot;Es dos&quot;),
        // ‚ö†Ô∏è
    }
}
</code></pre></pre>
<p>El compilar indica lo siguiente:</p>
<pre><code class="language-text">error[E0004]: non-exhaustive patterns: `3u8..=std::u8::MAX` not covered
 --&gt; src\main.rs:3:11
  |
3 |     match my_number {
  |           ^^^^^^^^^ pattern `3u8..=std::u8::MAX` not covered
</code></pre>
<p>El compilador se queja de que solo conoce lo que tiene que ejecutar los casos de 0 a 2, pero <code>u8</code> puede tener valores hasta el 255 (es decir <code>std::u8::MAX</code>). Qu√© debe hacer el programa para el resto de valores posibles que pueden aparecer.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number: u8 = 5;
    match my_number {
        0 =&gt; println!(&quot;Es cero&quot;),
        1 =&gt; println!(&quot;Es uno&quot;),
        2 =&gt; println!(&quot;Es dos&quot;),
        _ =&gt; println!(&quot;Es alg√∫n otro n√∫mero&quot;),
    }
}
</code></pre></pre>
<p>Este c√≥digo imprime <code>Es alg√∫n otro n√∫mero</code>.</p>
<p>Para el caso de <code>match</code> hay que recordar que:</p>
<ul>
<li>A todo <code>match</code> le sigue un bloque de c√≥digo <code>{}</code></li>
<li>Se escriben los <em>patrones</em> a la izquierda y se usa <code>=&gt;</code> (flecha gruesa -fat arrow-) para indicar qu√© hay que hacer cuando hay una coincidencia.</li>
<li>A cada l√≠nea con un patr√≥n se le denomina &quot;brazo&quot; del <code>match</code>.</li>
<li>Entre cada &quot;brazo&quot; se pone una coma de separaci√≥n (no se usa el punto y coma).</li>
</ul>
<p>Se puede declarar un valor usando <code>match</code> ya que retorna una valor.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 5;
    let second_number = match my_number {
        0 =&gt; 0,
        5 =&gt; 10,
        _ =&gt; 2,
    };
}
</code></pre></pre>
<p>En el ejemplo anterior, <code>second_number</code> tendr√° el valor 10. El match, en este caso acaba con un ; ya que una vez se ha finalizado su evaluaci√≥n esta sentencia es como si se hubiese escrito <code>let second_number = 10;</code>. Que define y asigna el 10 a <code>second_number</code>.</p>
<p><code>match</code> se puede utilizar para cosas m√°s complejas. Por ejemplo, con tuplas:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let sky = &quot;nuboso&quot;;
    let temperature = &quot;c√°lido&quot;;

    match (sky, temperature) {
        (&quot;nuboso&quot;, &quot;fr√≠o&quot;) =&gt; println!(&quot;El d√≠a es oscuro y desapacible&quot;),
        (&quot;despejado&quot;, &quot;c√°lido&quot;) =&gt; println!(&quot;El d√≠a es agradable&quot;),
        (&quot;nuboso&quot;, &quot;c√°lido&quot;) =&gt; println!(&quot;El d√≠a es oscuro, pero no se est√° mal&quot;),
        _ =&gt; println!(&quot;No s√© c√≥mo es el d√≠a de hoy&quot;),
    }
}
</code></pre></pre>
<p>Este c√≥digo imprime <code>El d√≠a es oscuro, pero no se est√° mal</code> porque coincide con &quot;nuboso&quot; y &quot;c√°lido&quot; para <code>sky</code> y <code>temperature</code>.</p>
<p>Incluso se puede utilizar <code>if</code> en las ramas de un <code>match</code>. Es lo que se llama una &quot;guarda de coincidencia&quot; (match guard):</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let children = 5;
    let married = true;

    match (children, married) {
        (children, married) if married == false =&gt; println!(&quot;Sin casar con {} ni√±os&quot;, children),
        (children, married) if children == 0 &amp;&amp; married == true =&gt; println!(&quot;Casado, pero sin ni√±os&quot;),
        _ =&gt; println!(&quot;¬øCasado? {}. N√∫mero de ni√±os: {}.&quot;, married, children),
    }
}
</code></pre></pre>
<p>Este progrma imprimir√° <code>¬øCasado? true. N√∫mero de ni√±os: 5.</code></p>
<p>Se puede usar <code>_</code> tantas veces como se necesite en un <code>match</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn match_colours(rbg: (i32, i32, i32)) {
    match rbg {
        (r, _, _) if r &lt; 10 =&gt; println!(&quot;No muy rojo&quot;),
        (_, b, _) if b &lt; 10 =&gt; println!(&quot;No muy azul&quot;),
        (_, _, g) if g &lt; 10 =&gt; println!(&quot;No muy verde&quot;),
        _ =&gt; println!(&quot;Cada color tiene al menos 10&quot;),
    }
}

fn main() {
    let first = (200, 0, 0);
    let second = (50, 50, 50);
    let third = (200, 50, 0);

    match_colours(first);
    match_colours(second);
    match_colours(third);

}
</code></pre></pre>
<p>Este c√≥digo imprime:</p>
<pre><code class="language-text">No muy azul
Cada color tiene al menos 10
No muy verde
</code></pre>
<p>Este c√≥digo tambi√©n muestra c√≥mo funcionan las sentencias <code>match</code>, porque en el primer ejemplo solo imprime <code>No muy rojo</code>, aunque tampoco tiene mucho verde. Las sentencias <code>match</code> siempre se detienen cuando encuentran una coincidencia y no chequea el resto de los &quot;brazos&quot;. Es un buen ejemplo de c√≥digo que compila bien, pero no hace lo que se quiere.</p>
<p>Se puede construir una sentencia <code>match</code>gigante para arreglar este c√≥digo, pero probablemente es mejor utilizar un bucle <code>for</code>. M√°s adelante se hablar√° de los bucles.</p>
<p>La sentencia <code>match</code> siempre tiene que devolver el mismo tipo de datos en todas sus ramas. Por eso, este c√≥digo no funciona:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 10;
    let some_variable = match my_number {
        10 =&gt; 8,
        _ =&gt; &quot;Not ten&quot;, // ‚ö†Ô∏è
    };
}
</code></pre></pre>
<p>El compilador indica lo siguiente:</p>
<pre><code class="language-text">error[E0308]: `match` arms have incompatible types
  --&gt; src\main.rs:17:14
   |
15 |       let some_variable = match my_number {
   |  _________________________-
16 | |         10 =&gt; 8,
   | |               - this is found to be of type `{integer}`
17 | |         _ =&gt; &quot;Not ten&quot;,
   | |              ^^^^^^^^^ expected integer, found `&amp;str`
18 | |     };
   | |_____- `match` arms have incompatible types
</code></pre>
<p>El c√≥digo siguiente, por la misma raz√≥n, tampoco funciona:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let some_variable = if my_number == 10 { 8 } else { &quot;something else &quot;}; // ‚ö†Ô∏è
}
</code></pre></pre>
<p>Pero el siguiente c√≥digo s√≠ funciona, porque no es un <code>match</code>y son dos sentencias diferentes:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 10;

    if my_number == 10 {
        let some_variable = 8;
    } else {
        let some_variable = &quot;Something else&quot;;
    }
}
</code></pre></pre>
<p>Tambi√©n se puede usar <code>@</code> para darle un nombre al valor de un patr√≥n <code>match</code> con el fin de poder usarlo en la expresi√≥n correspondiente a ese &quot;brazo&quot;. En este ejemplo, se guarda el valor en una variable <code>number</code> para pasarlo a una funci√≥n. Si es 4 o 13 se usa ese <code>number</code> en la sentencia <code>println!</code>. En otro caso, no se utiliza.</p>
<pre><pre class="playground"><code class="language-rust">fn match_number(input: i32) {
    match input {
    number @ 4 =&gt; println!(&quot;{} da mala suerte en China (suena parecido a Ê≠ª)&quot;, number),
    number @ 13 =&gt; println!(&quot;{} da mala suerte en Norte Am√©rica, ¬°Suerte en Italia! In bocca al lupo&quot;, number),
    _ =&gt; println!(&quot;Es un n√∫mero normal&quot;),
    }
}

fn main() {
    match_number(50);
    match_number(13);
    match_number(4);
}
</code></pre></pre>
<p>Este c√≥digo imprime:</p>
<pre><code class="language-text">Es un n√∫mero normal
13 da mala suerte en Norte Am√©rica, ¬°Suerte en Italia! In bocca al lupo
4 da mala suerte en China (suena parecido a Ê≠ª)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="estructuras---struct"><a class="header" href="#estructuras---struct">Estructuras - struct</a></h1>
<p><strong>Se puede ver este cap√≠tulo en YouTube en ingl√©s: <a href="https://youtu.be/W23uQghBOFk">Parte 1</a> y <a href="https://youtu.be/GSVhrjLCuNA">Parte 2</a></strong></p>
<p>Con las estructuras se pueden crear nuevos tipos de datos. Se utilizan constantemente en Rust, puesto que son muy √∫tiles. Las estructuras se crean con la palabra reservada <code>struct</code>. El nombre de las estructuras deber√≠a estar en UpperCamelCase (una letra may√∫scula por cada palabra sin espacios, ni guiones bajos). Si se escribe todo en min√∫sculas, el compilador avisar√°.</p>
<p>Existen tres tipos de estructuras.</p>
<p>La primera de ellas es la estructura unitaria &quot;unit struct&quot;, que no tiene nada. Simplemente se escribe su nombre seguido de un punto y coma.</p>
<pre><pre class="playground"><code class="language-rust">struct FileDirectory;
fn main() {}
</code></pre></pre>
<p>La segunda de ellas es la estructura tupla, o estructura sin nombres. Solo es necesario escribir los tipos de dato que contiene, sin nombres de campo. Las estructuras de tupla son indicadas cuando se necesita una estructura simple sin necesidad de utilizar nombres.</p>
<pre><pre class="playground"><code class="language-rust">struct Colour(u8, u8, u8);

fn main() {
    let my_colour = Colour(50, 0, 50); // Crea un color RGB (red, green, blue)
    println!(&quot;La segunda parte del color (la componente verde) es: {}&quot;, my_colour.1);
}
</code></pre></pre>
<p>Este c√≥digo imprime <code>La segunda parte del color (la componente verde) es: 0</code>.</p>
<p>El tercer tipo es la estructura con nombres. Que es, probablemente, la m√°s habitual. En estas estructuras se declaran los nombres de los campos y sus tipos en un bloque <code>{}</code>. Estos bloques no se terminan con punto y coma.</p>
<pre><pre class="playground"><code class="language-rust">struct Colour(u8, u8, u8); // Declara la misma estructura tupla para el color

struct SizeAndColour {
    size: u32,
    colour: Colour, // y la inserta en una estructura con nombres
}

fn main() {
    let my_colour = Colour(50, 0, 50);

    let size_and_colour = SizeAndColour {
        size: 150,
        colour: my_colour
    };
}
</code></pre></pre>
<p>Los campos de una estructura con nombres se separan con comas. El √∫ltimo campo puede llevar o no la coma. En el caso anterior, se puso una coma despu√©s de definir el campo <code>colour: Colour,</code>, pero no es necesario. Normalmente, se considera buena idea poner siempre la coma, porque en ocasiones resulta necesario cambiar el orden de los campos o a√±adir uno al final y de este modo es sistem√°tica la modificaci√≥n:</p>
<pre><pre class="playground"><code class="language-rust">struct Colour(u8, u8, u8); 

struct SizeAndColour {
    size: u32,
    colour: Colour // Sin coma
}

fn main() {}
</code></pre></pre>
<p>Se dedice cambiar su orden, cortando y pegando la fila...</p>
<pre><pre class="playground"><code class="language-rust">struct SizeAndColour {
    colour: Colour // ‚ö†Ô∏è ¬°Error! ya que no tiene coma.
    size: u32,
}

fn main() {}
</code></pre></pre>
<p>En todo caso, no es muy importante si se usa la coma o no.</p>
<p>En el siguiente ejemplo, se crea una estructura <code>Pais</code> que tiene los campos <code>poblacion</code>, <code>capital</code>y <code>presidente</code>.</p>
<pre><pre class="playground"><code class="language-rust">struct Pais {
    poblacion: u32,
    capital: String,
    presidente: String
}

fn main() {
    let poblacion = 500_000;
    let capital = String::from(&quot;Elista&quot;);
    let presidente = String::from(&quot;Batu Khasikov&quot;);

    let kalmykia = Pais {
        poblacion: poblacion,
        capital: capital,
        presidente: presidente,
    };
}
</code></pre></pre>
<p>Se observa que resuta prolijo tener que escribir el nombre del campo y su valor. Se escribe doble. <code>poblacion: poblacion</code>, <code>capital: capital</code> y <code>presidente: presidente</code>. Como se trata de alto habitual, Rust proporciona un atajo si tanto el campo, como la variable que contiene el valor se llaman igual. En ese caso, se puede simplificar as√≠:</p>
<pre><pre class="playground"><code class="language-rust">struct Pais {
    poblacion: u32,
    capital: String,
    presidente: String
}

fn main() {
    let poblacion = 500_000;
    let capital = String::from(&quot;Elista&quot;);
    let presidente = String::from(&quot;Batu Khasikov&quot;);

    let kalmykia = Pais {
        poblacion,
        capital,
        presidente,
    };
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enumerados---enum"><a class="header" href="#enumerados---enum">Enumerados - enum</a></h1>
<p><strong>Este cap√≠tulo se puede ver en YouTube en ingl√©s: <a href="https://youtu.be/SRnqNTJUgjs">Parte 1</a>, <a href="https://youtu.be/F_EcbWM63lk">Parte 2</a>, <a href="https://youtu.be/2uh64U9JesA">Parte 3</a> y <a href="https://youtu.be/LOHVUYTc5Us">Parte 4</a></strong></p>
<p>La palabra reservada de Rust <code>enum</code> se usa para los tipos enumerados. Esta es la diferencia con <code>struct</code>:</p>
<ul>
<li>Se utiliza <code>struct</code> cuando un tipo de datos debe representar una cosa <strong>Y</strong> otra cosa a la vez.</li>
<li>Se utiliza <code>enum</code> cuando un tipo de datos puede representar una cosa <strong>O</strong> alguna cosa diferente.</li>
</ul>
<p>Las estructuras sirven para unir diferentes elementos en uno solo, mientras que los enumerados permiten que un tipo de datos represente a diferentes cosas en diferente momento.</p>
<p>Para declarar un enumerado se debe escribir <code>enum</code> seguido de un bloque <code>{}</code> con las diferentes opciones separadas por coma. Como en el caso de los <code>struct</code> la √∫ltima opci√≥n puede llevar la coma o no. A continuaci√≥n se crea un enumerado denominado <code>CosasEnElCielo</code>:</p>
<pre><pre class="playground"><code class="language-rust">enum CosasEnElCielo {
    Sol,
    Estrellas,
}

fn main() {}
</code></pre></pre>
<p>Es un enumerado, por lo tanto, cuando se cree un valor es necesario que se elija entre el <code>Sol</code> o las <code>Estrellas</code>. A cada elemento que forma parte del enumerado se le denomina <strong>variante</strong>.</p>
<pre><pre class="playground"><code class="language-rust">// Crea el enumerado con dos variantes
enum CosasEnElCielo {
    Sol,
    Estrellas,
}

// Con esa funci√≥n se usa un i32 para crear CosasEnElCielo.
fn crear_estadoEnElCielo(time: i32) -&gt; CosasEnElCielo {
    match time {
        6..=18 =&gt; CosasEnElCielo::Sol, // Entre las 6 y 18 horas se ve el sol
        _ =&gt; CosasEnElCielo::Estrellas, // En otro caso se ven las estrellas
    }
}

// Con esta funci√≥n se localiza el estado y se muestran las CosasEnElCielo.
fn comprobar_el_cielo(state: &amp;CosasEnElCielo) {
    match state {
        CosasEnElCielo::Sol =&gt; println!(&quot;¬°Puedo ver el sol!&quot;),
        CosasEnElCielo::Estrellas =&gt; println!(&quot;¬°Puedo ver las estrellas!&quot;)
    }
}

fn main() {
    let time = 8; // Son las ocho de la ma√±ana
    let skystate = crear_estadoEnElCielo(time); // crear_estadoEnElCielo returns a CosasEnElCielo
    comprobar_el_cielo(&amp;skystate); // Se pasa una referencia para que pueda leer el estado del cielo
}
</code></pre></pre>
<p>Este c√≥digo imprime <code>¬°Puedo ver el sol!</code>.</p>
<p>A cada enumerado, se le pueden a√±adir datos (como en los struts):</p>
<pre><pre class="playground"><code class="language-rust">enum CosasEnElCielo {
    Sol(String), // Ahora cada variante tiene una cadena de texto
    Estrellas(String),
}

fn crear_estadoEnElCielo(time: i32) -&gt; CosasEnElCielo {
    match time {
        6..=18 =&gt; CosasEnElCielo::Sol(String::from(&quot;¬°Puedo ver el sol!&quot;)), // Da el valor aqu√≠
        _ =&gt; CosasEnElCielo::Estrellas(String::from(&quot;¬°Puedo ver las estrellas!&quot;)),
    }
}

fn comprobar_el_cielo(state: &amp;CosasEnElCielo) {
    match state {
        CosasEnElCielo::Sol(description) =&gt; println!(&quot;{}&quot;, description), // recupera la descripci√≥n para que se pueda imprimir
        CosasEnElCielo::Estrellas(n) =&gt; println!(&quot;{}&quot;, n), // se puede usar cualquier variable n para obtener la descripci√≥n
    }
}

fn main() {
    let time = 8; // Son las ocho de la ma√±ana
    let skystate = crear_estadoEnElCielo(time); // crear_estadoEnElCielo devuelve un elemento de CosasEnElCielo
    comprobar_el_cielo(&amp;skystate); // Se pasa una referencia para que pueda leer el estado del cielo
}
</code></pre></pre>
<p>Este c√≥digo imprime lo mismo que antes <code>¬°Puedo ver el sol!</code>.</p>
<p>Tambi√©n se puede &quot;importar&quot; un enumerado para que no haya que escribir mucho. A continuaci√≥n se muestra un ejemplo en se escribe <code>Estado::</code> cada vez que se comprueba el &quot;estado de √°nimo&quot;:</p>
<pre><pre class="playground"><code class="language-rust">enum Estado {
    Feliz,
    Cansado,
    NoEstoyMal,
    Enfadado,
}

fn comprueba_estado(mood: &amp;Estado) -&gt; i32 {
    let nivel_de_felicidad = match mood {
        Estado::Feliz =&gt; 10, // Se escribe Estado:: cada vez
        Estado::Cansado =&gt; 6,
        Estado::NoEstoyMal =&gt; 7,
        Estado::Enfadado =&gt; 2,
    };
    nivel_de_felicidad
}

fn main() {
    let my_mood = Estado::NoEstoyMal;
    let nivel_de_felicidad = comprueba_estado(&amp;my_mood);
    println!(&quot;De 1 a 10, mi estado de felicidad es {}&quot;, nivel_de_felicidad);
}
</code></pre></pre>
<p>El c√≥digo anterior imprime <code>De 1 a 10, mi estado de felicidad es 7</code>. A continuaci√≥n, el mismo c√≥digo, pero importando el enumerado para tener que escribir menos. Para importar todo se utiliza <code>*</code>. Es el mismo car√°cter que para desrreferenciar, pero con un uso diferente.</p>
<pre><pre class="playground"><code class="language-rust">enum Estado {
    Feliz,
    Cansado,
    NoEstoyMal,
    Enfadado,
}

fn comprueba_estado(mood: &amp;Estado) -&gt; i32 {
    use Estado::*; // Se importa el conjunto de variantes de Estado. Ahora se puede escribir menos
    let nivel_de_felicidad = match mood {
        Feliz =&gt; 10, // Ya no es necesario escribir Estado::
        Cansado =&gt; 6,
        NoEstoyMal =&gt; 7,
        Enfadado =&gt; 2,
    };
    nivel_de_felicidad
}

fn main() {
    let my_mood = Estado::NoEstoyMal;
    let nivel_de_felicidad = comprueba_estado(&amp;my_mood);
    println!(&quot;De 1 a 10, mi estado de felicidad es {}&quot;, nivel_de_felicidad);
}
</code></pre></pre>
<p>Las partes de un enumerado se pueden convertir a n√∫mero entero. Esto se debe a que Rust da a cada variante de un <code>enum</code> un n√∫mero que comienza con el 0 (para uso interno de Rust). Se puede utilizar en el c√≥digo, siempre que las variantes con contengan ning√∫n dato adicional:</p>
<pre><pre class="playground"><code class="language-rust">enum Estacion {
    Primavera, // If this was Primavera(String) or something it wouldn't work
    Verano,
    Oto√±o,
    Invierno,
}

fn main() {
    use Estacion::*;
    let cuatro_estaciones = vec![Primavera, Verano, Oto√±o, Invierno];
    for estacion in cuatro_estaciones {
        println!(&quot;{}&quot;, estacion as u32);
    }
}
</code></pre></pre>
<p>El c√≥digo anterior imprime:</p>
<pre><code class="language-text">0
1
2
3
</code></pre>
<p>Es posible asignar un n√∫mero entero expresamente a cada variante. A Rust no le importa el n√∫mero concreto que tenga cada una de ellas. Para ello, se a√±ade un s√≠mbolo <code>=</code> y el n√∫mero deseado a cada variante. No es necesario indicar el n√∫mero a cada variante. Si no se a√±ade, Rust utiliza el siguiente disponible (suma 1) a partir de la variante anterior que tuviera n√∫mero:</p>
<pre><pre class="playground"><code class="language-rust">enum Estrella {
    EnanaMarron = 10,
    EnanaRoja = 50,
    EstrellaAmarilla = 100,
    GiganteRoja = 1000,
    EstrellaMuerta, // ¬øQu√© n√∫mero tendr√°?
}

fn main() {
    use Estrella::*;
    let starvec = vec![EnanaMarron, EnanaRoja, EstrellaAmarilla, GiganteRoja];
    for star in starvec {
        match star as u32 {
            size if size &lt;= 80 =&gt; println!(&quot;No es la estrella m√°s grande&quot;),
            size if size &gt;= 80 =&gt; println!(&quot;Esta estrella tiene un buen tama√±o&quot;),
            _ =&gt; println!(&quot;Esta estrella es muy grande&quot;),
        }
    }
    println!(&quot;¬øQu√© n√∫mero tiene EstrellaMuerta? Es el n√∫mero {}.&quot;, EstrellaMuerta as u32);
}
</code></pre></pre>
<p>This prints:</p>
<pre><code class="language-text">No es la estrella m√°s grande
No es la estrella m√°s grande
Esta estrella tiene un buen tama√±o
Esta estrella tiene un buen tama√±o
¬øQu√© n√∫mero tiene EstrellaMuerta? Es el n√∫mero 1001.
</code></pre>
<p><code>EstrellaMuerta</code> hubiera sido el n√∫mero 4 si no se hubiera expresado ning√∫n n√∫mero, pero ahora es el 1001.</p>
<h2 id="los-enumerados-sirven-para-usar-tipos-diferentes"><a class="header" href="#los-enumerados-sirven-para-usar-tipos-diferentes">Los enumerados sirven para usar tipos diferentes</a></h2>
<p>Como ya se sabe, los elementos de un <code>Vec</code>, array, etc. tienen que ser del mismo tipo siempre (solo las tuplas permiten tipos diferentes). Los enumerados permiten incorporar diferentes tipos en las colecciones anteriores. Si se deseara tener un <code>Vec</code> que almacenara de forma indistinta <code>u32</code> o <code>i32</code> se puede declarar el <code>Vec</code> como que contiene un enumerado como en el siguiente ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">enum Numero {
    U32(u32),
    I32(i32),
}

fn main() {}
</code></pre></pre>
<p>As√≠, este enumerado tiene dos variantes: la variante <code>U32</code>con un <code>u32</code>y la variante <code>I32</code> con un <code>i32</code>. <code>U32</code> y <code>I32</code> son solo los nombres de cada variante. Se podr√≠an haber llamado <code>UTreintaYDos</code> o <code>ITreintaYDos</code> o cualquier otra cosa.</p>
<p>Ahora es posible declarar un <code>Vec</code> de la siguiente forma <code>Vec&lt;Numero&gt;</code> y el compilador no se queja porque el vector es de un solo tipo. Al compilador no le preocupa si en un momento dado hay <code>u32</code> o <code>i32</code> porque esa diferencia est√° oculta por el tipo <code>Numero</code>. Y como es un enumerado, es necesario seleccionar una variante cada vez. En el siguiente c√≥digo se usa el m√©todo <code>.is_positive()</code> para seleccionar la variante. Si es <code>true</code> se selecciona <code>U32</code> y si es <code>false</code> se selecciona <code>I32</code>.</p>
<p>Ahora el c√≥digo queda as√≠:</p>
<pre><pre class="playground"><code class="language-rust">enum Numero {
    U32(u32),
    I32(i32),
}

fn get_numero(input: i32) -&gt; Numero {
    let numero = match input.is_positive() {
        true =&gt; Numero::U32(input as u32), // lo cambia a u32 si es positivo
        false =&gt; Numero::I32(input), 
    };
    numero
}


fn main() {
    let my_vec = vec![get_numero(-800), get_numero(8)];

    for item in my_vec {
        match item {
            Numero::U32(numero) =&gt; println!(&quot;Es un u32 con el valor {}&quot;, numero),
            Numero::I32(numero) =&gt; println!(&quot;Es un i32 con el valor {}&quot;, numero),
        }
    }
}
</code></pre></pre>
<p>Este c√≥digo imprime:</p>
<pre><code class="language-text">Es un i32 con el valor -800
Es un u32 con el valor 8
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bucles"><a class="header" href="#bucles">Bucles</a></h1>
<p>Con los bucles se de puede decir a Rust que repita algo hasta que se quiera que se detenga. Se puede utilizar la palabra reservada <code>loop</code> para iniciar un bucle que no tenga fin. Al menos, hasta que se le indique que se pare mediante la palabra reservada <code>break</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() { // Este programa nunca se detiene
    loop {

    }
}
</code></pre></pre>
<p>El siguiente programa s√≠ acaba. En cada repetici√≥n incrementa en uno un contador, hasta que vale 5. En este momento se acaba:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut contador = 0; // Inicia el contador a 0
    loop {
        contador +=1; // Incrementa el contador en 1
        println!(&quot;El contador vale ahora {}&quot;, contador);
        if contador == 5 { // Sale del bucle cuyo contador == 5
            break;
        }
    }
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">El contador vale ahora 1
El contador vale ahora 2
El contador vale ahora 3
El contador vale ahora 4
El contador vale ahora 5
</code></pre>
<p>Si se inserta un bucle dentro de otro, es posible darles nombre para indicar a Rust a qu√© bucle salir cuyo se ejecuta una sentencia <code>break</code>. Para dar nombre se usa el ap√≥strofo <code>'</code> y los dos puntos <code>:</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut contador = 0;
    let mut contador2 = 0;
    println!(&quot;Entryo en el primer bucle.&quot;);

    'primer_bucle: loop {
        // Da nombre al primer bucle
        contador += 1;
        println!(&quot;El contador es ahora: {}&quot;, contador);
        if contador &gt; 9 {
            // Inicia un segundo bucle dentro del primero
            println!(&quot;Entryo en el segundo bucle.&quot;);

            'segundo_bucle: loop {
                // est√° dentro del 'segundo_bucle
                println!(&quot;El segundo contador es ahora: {}&quot;, contador2);
                contador2 += 1;
                if contador2 == 3 {
                    break 'primer_bucle; // Sale del  'primer_bucle para abyonar el programa
                }
            }
        }
    }
}
</code></pre></pre>
<p>Este c√≥digo imprimir√°:</p>
<pre><code class="language-text">Entryo en el primer bucle.
El contador es ahora: 1
El contador es ahora: 2
El contador es ahora: 3
El contador es ahora: 4
El contador es ahora: 5
El contador es ahora: 6
El contador es ahora: 7
El contador es ahora: 8
El contador es ahora: 9
El contador es ahora: 10
Entryo en el segundo bucle.
El segundo contador es ahora: 0
El segundo contador es ahora: 1
El segundo contador es ahora: 2
</code></pre>
<p>Un bucle <code>while</code> es uno que se repite mientras una condici√≥n se cumple (es <code>true</code>). En cada repetici√≥n, Rust valida si la condici√≥n es a√∫n <code>true</code>. Cuyo es <code>false</code>, Rust finaliza el bucle.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut contador = 0;

    while contador &lt; 5 {
        contador +=1;
        println!(&quot;El contador vale ahora: {}&quot;, contador);
    }
}
</code></pre></pre>
<p>Un bucle <code>for</code> repite la ejecuci√≥n un n√∫mero determinado de veces. Este tipo de bucles suele utilizar <strong>rangos</strong> muy a menudo. Se utiliza <code>..</code> y <code>..=</code> para crear un rango.</p>
<ul>
<li><code>..</code> crea un rango <strong>excluyente</strong>: <code>0..3</code> crea un rango con los siguientes tres n√∫meros <code>0, 1, 2</code>.</li>
<li><code>..=</code> crea un rango <strong>incluyente</strong>: <code>0..=3</code> crea un rango con los siguientes cuatro n√∫meros <code>0, 1, 2, 3</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for numero in 0..3 {
        println!(&quot;El numero es: {}&quot;, numero);
    }

    for numero in 0..=3 {
        println!(&quot;El siguiente numero es: {}&quot;, numero);
    }
}
</code></pre></pre>
<p>Este c√≥digo imprime:</p>
<pre><code class="language-text">El numero es: 0
El numero es: 1
El numero es: 2
El siguiente numero es: 0
El siguiente numero es: 1
El siguiente numero es: 2
El siguiente numero es: 3
</code></pre>
<p>En los bucles <code>for</code> se observa que se crea una variable en cada repetici√≥n que contiene el valor de la repetici√≥n (iteraci√≥n) actual. Esta variable se podr√≠a llamar de cualquier forma. La variable se usa, en este caso, en <code>println!</code>.</p>
<p>Si no se necesitara la variable, se puede utilizar <code>_</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for _ in 0..3 {
        println!(&quot;Imprimiendo lo mismo las tres veces&quot;);
    }
}
</code></pre></pre>
<p>Que imprimir√°:</p>
<pre><code class="language-text">Imprimiendo lo mismo las tres veces
Imprimiendo lo mismo las tres veces
Imprimiendo lo mismo las tres veces
</code></pre>
<p>En este caso no se ha usado la variable.</p>
<p>Realmente, si se le hubiera dado nombre a la variable y no se hubiese usado, Rust lo hubiera indicado:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for numero in 0..3 {
        println!(&quot;Imprimiendo lo mismo las tres veces&quot;);
    }
}
</code></pre></pre>
<p>El c√≥digo anterior imprime lo mismo que antes. El programa compila bien, pero Rust lanzar√° un aviso recordyo que la variable <code>numero</code> no se est√° usyo:</p>
<pre><code class="language-text">warning: unused variable: `numero`
 --&gt; src\main.rs:2:9
  |
2 |     for numero in 0..3 {
  |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_number`
</code></pre>
<p>Rust sugiere que se escriba <code>_numero</code> en lugar de <code>_</code>. Para Rust, una variable que comience por <code>_</code> significa que &quot;puede que se use en el futuro&quot;. El uso de <code>_</code> solo, significa &quot;no importa este valor&quot;. Por eso, se pueden poner <code>_</code> guiones bajos delante del nombre de las variables que se vayan a usar m√°s tarde y no se quiera que el compilador avise sobre que no se est√°n usyo.</p>
<p><code>break</code> tambi√©n se puede usar para devolver un valor. Para ello, se escribe un valor detr√°s de √©l y se usa <code>;</code>. A continuaci√≥n se muestra un ejemplo con <code>loop</code> y un uso de <code>break</code>que devuelve <code>mi_numero</code> como valor.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut contador = 5;
    let mi_numero = loop {
        contador +=1;
        if contador % 53 == 3 {
            break contador;
        }
    };
    println!(&quot;{}&quot;, mi_numero);
}
</code></pre></pre>
<p>Este c√≥digo imprime <code>56</code>. <code>break contador;</code> significa &quot;finaliza el bucle y devuelve el valor del contador&quot;. Puesto que el bucle se asigna a la variable <code>mi_numero</code>, el valor devuelto se almacena en ella.</p>
<p>Con el conocimiento de los bucles se puede escribir una soluci√≥n mejor al problema anterior de la comprobaci√≥n de los colores con <code>match</code>. Es una soluci√≥n mejor porque el objetivo es poder comparar todos los componentes de un color.</p>
<pre><pre class="playground"><code class="language-rust">fn match_colores(rbg: (i32, i32, i32)) {
    println!(&quot;Comparaci√≥n de un color con {} rojo, {} azul, y {} verde:&quot;, rbg.0, rbg.1, rbg.2);
    let new_vec = vec![(rbg.0, &quot;rojo&quot;), (rbg.1, &quot;azul&quot;), (rbg.2, &quot;verde&quot;)]; // Coloca los colores en un vec. Dentro son tuplas con los nombres de los colores
    let mut todos_tienen_al_menos_10 = true; // Comienza a verdadero y se cambia a falso si alg√∫n compomente no tiene 10
    for item in new_vec {
        if item.0 &lt; 10 {
            todos_tienen_al_menos_10 = false; // Ahora es false
            println!(&quot;No mucho {}.&quot;, item.1) // Y se imprime el nombre del color.
        }
    }
    if todos_tienen_al_menos_10 { // Comprueba si es verdadero e imprime si lo es
        println!(&quot;Cada compomente de color tiene al menos 10.&quot;)
    }
    println!(); // A√±ade una l√≠nea vac√≠a para separar
}

fn main() {
    let first = (200, 0, 0);
    let second = (50, 50, 50);
    let third = (200, 50, 0);

    match_colores(first);
    match_colores(second);
    match_colores(third);
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">Comparaci√≥n de un color con 200 rojo, 0 azul, y 0 verde:
No mucho azul.
No mucho verde.

Comparaci√≥n de un color con 50 rojo, 50 azul, y 50 verde:
Cada compomente de color tiene al menos 10.

Comparaci√≥n de un color con 200 rojo, 50 azul, y 0 verde:
No mucho verde.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementando-funciones-para-structs-y-enums"><a class="header" href="#implementando-funciones-para-structs-y-enums">Implementando funciones para structs y enums</a></h1>
<p>Los <code>struct</code> y <code>enum</code> permiten que se puedan definir funciones asociadas a los tipos definidos como tal. Esto da mucha capacidad al lenguaje. Para ello, se utiliza el bloque <code>impl</code> sobre el tipo de datos definido con <code>struct</code> o <code>enum</code>. A estas funciones se las llama <strong>m√©todos</strong>.</p>
<p>En un bloque <code>impl</code> se pueden definir dos tipos diferentes de m√©todos:</p>
<ul>
<li>M√©todos: que toman como primer par√°metro uno denominado <code>self</code> (o <code>&amp;self</code> o <code>&amp;mut self</code>). Estos m√©todos, para utilizarlos, usan <code>.</code> (un punto) sobre una variable del tipo <code>struct</code> o <code>enum</code> correspondiente. Por ejemplo, <code>x.clone()</code> es un m√©todo del tipo de la variable <code>x</code>.</li>
<li>Funciones asociadas (al tipo). Que en otros lenguajes se conocen como m√©todos est√°ticos: No tienen el primer par√°metros <code>self</code>. Son funciones &quot;relacionadas con el tipo de datos&quot;. Se llaman utilizando <code>::</code>. Por ejemplo: <code>String::from()</code> es una llamada a una funci√≥n asociada. Tambi√©n <code>Vec::new()</code>. Normalmente se utilizan para crear valores de variables del tipo correspondiente.</li>
</ul>
<p>El ejemplo que se presenta a continuaci√≥n, crea animales y los imprime.</p>
<p>En el siguiente ejemplo, tambi√©n conviene observar que para poder usar <code>{:?}</code> al imprimir un tipo, este debe tener el rasgo de ser depurable, lo que se consigue mediante <code>#derive(Debug)</code> colocado al inicio del tipo de datos. A este tipo de etiquetado con <code>#</code> seguido de un nombre, se le denomina en Rust <em>atributo</em>. Se utilizan para indicar acciones al compilador. En este caso, para que se implemente de forma autom√°tica la posibilidad de depuraci√≥n al tipo de datos correspondiente. Existen muchos atributos diferentes que se pueden utilizar en un programa Rust, m√°s adelante se ver√°n otros. El m√°s com√∫n es <code>derive</code> y se encuentra muchas veces precediendo la definici√≥n de un <code>struct</code> o <code>enum</code>.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Animal {
    edad: u8,
    tipo_animal: TipoAnimal,
}

#[derive(Debug)]
enum TipoAnimal {
    Gato,
    Perro,
}

impl Animal {
    fn new() -&gt; Self {
        // Self, aqu√≠, significa Animal.
        // Tambi√©n se podr√≠a haber usado Animal
        // en lugar de Self

        Self {
            // Cuando se escriba Animal::new(), se obtendr√° siempre un gato de 10 a√±os
            edad: 10,
            tipo_animal: TipoAnimal::Gato,
        }
    }

    fn cambiar_a_perro(&amp;mut self) { // como est√° dentro de Animal, &amp;mut self significa &amp;mut Animal
                                  // usa .cambiar_a_perro() para convertir el cato en un perro
                                  // con &amp;mut self se puede modificar
        println!(&quot;¬°Cambiando el animal a perro!&quot;);
        self.tipo_animal = TipoAnimal::Perro;
    }

    fn cambiar_a_gato(&amp;mut self) {
        // usa .cambiar_a_gato() para cambiar el perro a gato
        // con &amp;mut self se puede modificar
        println!(&quot;¬°Cambiando el animal a gato!&quot;);
        self.tipo_animal = TipoAnimal::Gato;
    }

    fn comprobar_tipo(&amp;self) {
        // se lee a s√≠ mismo self
        match self.tipo_animal {
            TipoAnimal::Perro =&gt; println!(&quot;El animal es un perro&quot;),
            TipoAnimal::Gato =&gt; println!(&quot;El animal es un gato&quot;),
        }
    }
}



fn main() {
    let mut animal_nuevo = Animal::new(); // Funci√≥n asociada para crear una variable Animal
                                        // Es un gato de 10 a√±os
    animal_nuevo.comprobar_tipo();
    animal_nuevo.cambiar_a_perro();
    animal_nuevo.comprobar_tipo();
    animal_nuevo.cambiar_a_gato();
    animal_nuevo.comprobar_tipo();
}
</code></pre></pre>
<p>Esto imprime:</p>
<pre><code class="language-text">El animal es un gato
¬°Cambiando el animal a perro!
El animal es un perro
¬°Cambiando el animal a gato!
El animal es un gato
</code></pre>
<p>Se debe recordar que <code>Self</code> (el tipo Self) y <code>self</code> (la variable self) funcionan como abreviaturas del tipo que sea en cada momento.</p>
<p>En el c√≥digo anterior, <code>Self</code> es igual a <code>Animal</code>. Y en <code>fn cambiar_a_perro(&amp;mut self)</code> significa que el par√°metro primero es un <code>Animal</code>. Este par√°metro es la variable <code>animal_nuevo</code> cuando se llama de la siguiente forma <code>animal_nuevo.cambiar_a_perro()</code>.</p>
<p>A continuaci√≥n se muestra un ejemplo m√°s de <code>impl</code>. En este caso, con <code>enum</code>.</p>
<pre><pre class="playground"><code class="language-rust">enum Estado {
    Bueno,
    Malo,
    Somnoliento,
}

impl Estado {
    fn consultar(&amp;self) {
        match self {
            Estado::Bueno =&gt; println!(&quot;¬°Me siento bien!&quot;),
            Estado::Malo =&gt; println!(&quot;Eh, no me siento tan bien&quot;),
            Estado::Somnoliento =&gt; println!(&quot;Necesito dormir AHORA&quot;),
        }
    }
}

fn main() {
    let mi_estado = Estado::Somnoliento;
    mi_estado.consultar();
}
</code></pre></pre>
<p>This prints <code>Necesito dormir AHORA</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="desestructurar"><a class="header" href="#desestructurar">Desestructurar</a></h1>
<p>A continuaci√≥n se presentan algunos aspectos adicionales sobre c√≥mo desestructurar los valores de un <code>struct</code> o <code>enum</code>. Ya se vio que se pod√≠a realizar mediante <code>let</code> y el uso de variables que recuperan parte o todo el contenido de la estructura o enumerado. De esta forma, se tienen los valores de forma separada. Se puede observar en el siguiente ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">struct Persona { // crea una estructura simple para Persona
    nombre: String,
    real_nombre: String,
    altura: u8,
    felicidad: bool
}

fn main() {
    let papa_doc = Persona { // se crea la variable papa_doc
        nombre: &quot;Papa Doc&quot;.to_string(),
        real_nombre: &quot;Clarence&quot;.to_string(),
        altura: 170,
        felicidad: false
    };

    let Persona { // Se &quot;desestructura&quot; a  papa_doc
        nombre: a,
        real_nombre: b,
        altura: c,
        felicidad: d
    } = papa_doc;

    println!(&quot;Lo llaman {} pero su nombre real es {}. Es {} cm de alto y ¬øes feliz? {}&quot;, a, b, c, d);
}
</code></pre></pre>
<p>Que imprime: <code>Lo llaman Papa Doc pero su nombre real es Clarence. Es 170 cm de alto y ¬øes feliz? false</code></p>
<p>Primero se crea la estructura <code>let papa_doc = Persona { campos }</code>. Luego, de forma sim√©trica, se escribe <code>let Persona { campos } = papa_doc</code> para desestructurarla.</p>
<p>No es necesario escribir <code>nombre: a</code> - se puede escribir solo <code>nombre</code>. Pero aqu√≠ se escribe <code>nombre: a</code> porque se quiere usar este valor de forma independiente mediante la variable <code>a</code>.</p>
<p>A continuaci√≥n se presenta un ejemplo m√°s amplio.  En este ejemplo, se usa la estructura <code>Ciudad</code>. Se utiliza una funci√≥n asociada <code>new</code> para crear ciudades. Posteriormente, se utiliza la funci√≥n <code>procesar_valores_ciudad</code> para hacer cosas con sus valores. En la funci√≥n, se crea un <code>Vec</code>, pero se pueden imaginar muchas m√°s operaciones sobre estos datos despu√©s de desestructurarlos.</p>
<pre><pre class="playground"><code class="language-rust">struct Ciudad {
    nombre: String,
    nombre_antes: String,
    poblacion: u32,
    fecha_fundacion: u32,
}

impl Ciudad {
    fn new(nombre: String, nombre_antes: String, poblacion: u32, fecha_fundacion: u32) -&gt; Self {
        Self {
            nombre,
            nombre_antes,
            poblacion,
            fecha_fundacion,
        }
    }
}

fn procesar_valores_ciudad(ciudad: &amp;Ciudad) {
    let Ciudad {
        nombre,
        nombre_antes,
        ..
    } = ciudad;
        // se dispone de los valores separados
    let dos_nombres = vec![nombre, nombre_antes];
    println!(&quot;Los dos nombres de la ciudad son {:?}&quot;, dos_nombres);
}

fn main() {
    let tallinn = Ciudad::new(&quot;Tallinn&quot;.to_string(), &quot;Reval&quot;.to_string(), 426_538, 1219);
    procesar_valores_ciudad(&amp;tallinn);
}
</code></pre></pre>
<p>El c√≥digo anterior imprime <code>Los dos nombres de la ciudad son [&quot;Tallinn&quot;, &quot;Reval&quot;]</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="referencias-y-el-operador-punto-"><a class="header" href="#referencias-y-el-operador-punto-">Referencias y el operador punto .</a></h1>
<p>Se ha aprendido que cuyo se dispone de una referencia, se necesita utilizar el operador <code>*</code> para acceder al valor. Una referencia tiene su propio tipo, por lo que este c√≥digo no funcionar√°:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_numero = 9;
    let referencia = &amp;mi_numero;

    println!(&quot;{}&quot;, mi_numero == referencia); // ‚ö†Ô∏è
}
</code></pre></pre>
<p>El compilador imprime lo siguiente:</p>
<pre><code class="language-text">error[E0277]: can't comp¬øSon `{integer}` with `&amp;{integer}`
 --&gt; src\main.rs:5:30
  |
5 |     println!(&quot;{}&quot;, mi_numero == referencia);
  |                              ^^ no implementation for `{integer} == &amp;{integer}`
</code></pre>
<p>Es necesario cambiar la l√≠nea 5 a <code>println!(&quot;{}&quot;, mi_numero == *referencia);</code> para que funcione e imprima <code>true</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_numero = 9;
    let referencia = &amp;mi_numero;

    println!(&quot;{}&quot;, mi_numero == *referencia); // ahora funciona
</code></pre></pre>
<p>Esto se debe a que ahora ya se est√° comparyo <code>i32</code> == <code>i32</code> y no <code>i32</code>== <code>&amp;i32</code> como suced√≠a antes. A esto se le llama desreferenciar.</p>
<p>Sin embargo, cuyo se utiliza un m√©todo sobre una variable, Rust realiza la desreferenciaci√≥n de forma autom√°tica. En concreto, el operador <code>.</code> (punto) es quien est√° definido en Rust de forma que realiza la desreferenciaci√≥n cuyo se utiliza sobre una variable de tipo referencia. Adem√°s, esto se realiza tantas veces como sea necesario hasta llegar al valor concreto.</p>
<p>A continuaci√≥n, se crea un <code>struct</code> con un campo byte sin signo <code>u8</code>. Despu√©s, se crea una referencia y se intenta comparar, lo que no funcionar√°:</p>
<pre><pre class="playground"><code class="language-rust">struct Item {
    numero: u8,
}

fn main() {
    let item = Item {
        numero: 8,
    };

    let referencia_numero = &amp;item.numero; // el tipo de referencia_numero es &amp;u8

    println!(&quot;{}&quot;, referencia_numero == 8); // ‚ö†Ô∏è &amp;u8 y u8 no se pueden comparar entre s√≠
}
</code></pre></pre>
<p>Para que funcione, es necesario desreferenciarlo. Por ejemplo, cambiyo <code>println!(&quot;{}&quot;, *referencia_numero == 8)</code>:</p>
<pre><pre class="playground"><code class="language-rust">struct Item {
    numero: u8,
}

fn main() {
    let item = Item {
        numero: 8,
    };

    let referencia_numero = &amp;item.numero; // el tipo de referencia_numero es &amp;u8

    println!(&quot;{}&quot;, *referencia_numero == 8); // as√≠ s√≠ funciona
}
</code></pre></pre>
<p>Pero no es necesario hacerlo de forma anterior. Con el operador punto, se desreferencia de forma autom√°tica;</p>
<pre><pre class="playground"><code class="language-rust">struct Item {
    numero: u8,
}

fn main() {
    let item = Item {
        numero: 8,
    };

    let referencia_item = &amp;item; // el tipo de referencia_item es &amp;Item

    println!(&quot;{}&quot;, referencia_item.numero == 8); // as√≠ s√≠ funciona
}
</code></pre></pre>
<p>De forma autom√°tica, mediante el operador <code>.</code>, se ha realizado una desreferenciaci√≥n que de otro modo habr√≠a que haber escrito as√≠ <code>(*referencia_item).numero</code>.</p>
<p>A continuaci√≥n, se crea un m√©todo para la estructura <code>Item</code> que compara el <code>numero</code> con otro. Como se ve, no se necesita usar <code>*</code> en ning√∫n lugar:</p>
<pre><pre class="playground"><code class="language-rust">struct Item {
    numero: u8,
}

impl Item {
    fn compara_numero(&amp;self, otro_numero: u8) { // tiene una referencia a self
        println!(&quot;¬øSon {} y {} iguales? {}&quot;, self.numero, otro_numero, self.numero == otro_numero);
            // No se necesita escribir (*self).numero
    }
}

fn main() {
    let item = Item {
        numero: 8,
    };

    let item_referencia = &amp;item; // De tipo &amp;Item
    let item_referencia_dos = &amp;item_referencia; // De tipo &amp;&amp;Item

    item.compara_numero(8); // El m√©todo funciona
    item_referencia.compara_numero(8); // Este m√©todo tambi√©n funciona
    item_referencia_dos.compara_numero(8); // y este
}
</code></pre></pre>
<p>Se concluye as√≠ que cuando se usa el operador <code>.</code>, no se necesita utilizar el operador <code>*</code> para desreferenciar.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gen√©ricos"><a class="header" href="#gen√©ricos">Gen√©ricos</a></h1>
<p>En las funciones es necesario definir el tipo de cada par√°metro de entrada:</p>
<pre><pre class="playground"><code class="language-rust">fn devuelve_numero(numero: i32) -&gt; i32 {
    println!(&quot;Ah√≠ va tu numero.&quot;);
    numero
}

fn main() {
    let numero = devuelve_numero(5);
}
</code></pre></pre>
<p>Pero si lo que se necesita es una funci√≥n que haga lo mismo para cualquier tipo de datos diferente de <code>i32</code>, se pueden usar gen√©ricos. Un tipo gen√©rico sirve para indicar que algo puede ser de diferente tipo.</p>
<p>Tambi√©n se puede decir que la funci√≥n tiene un <em>par√°metro de tipo</em>.</p>
<p>Los par√°metros de tipo gen√©rico se definen con los s√≠mbolos de menor y mayo que encierran el nombre que representa al par√°metro de tipo. Normalmente se utiliza un car√°cter en may√∫scula para representarlos (T, U, V, etc.), aunque no es obligatorio utilizar solo una letra.</p>
<p>La funci√≥n anterior se puede convertir en gen√©rica as√≠:</p>
<pre><pre class="playground"><code class="language-rust">fn devuelve_numero&lt;T&gt;(numero: T) -&gt; T {
    println!(&quot;Ah√≠ va tu numero.&quot;);
    numero
}

fn main() {
    let numero = devuelve_numero(5);
    let numero_decimal = devuelve_numero(5.4);
}
</code></pre></pre>
<p>Se observa que el par√°metro de tipo gen√©rico <code>&lt;T&gt;</code> va despu√©s del nombre de la funci√≥n. Puede resultar m√°s sencillo de comprender si se sustituye la <code>T</code> por un nombre m√°s descriptivo como <code>MiTipo</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn devuelve_numero&lt;MiTipo&gt;(numero: MiTipo) -&gt; MiTipo {
    println!(&quot;Ah√≠ va tu numero.&quot;);
    numero
}

fn main() {
    let numero = devuelve_numero(5);
    let numero_decimal = devuelve_numero(5.4);
}
</code></pre></pre>
<p>As√≠ que la parte de despu√©s del nombre de la funci√≥n es lo que hace que la funci√≥n tenga un par√°metro de tipo gen√©rico que el compilador &quot;sustituye&quot; por el tipo concreto generyo un funci√≥n diferente para cada tipo que se use en el c√≥digo.</p>
<p>Adem√°s, como se ha visto, en Rust existen algunos tipos que implementan determinados rasgos, como son <strong>Copy</strong>, <strong>Clone</strong>, <strong>Display</strong>, <strong>Debug</strong> y otros. Si un tipo es <strong>Debug</strong>, puede usar <code>{:?}</code> para imprimirlo. Esto genera un posible problema si en la funci√≥n gen√©rica se quisiera imprimir:</p>
<pre><pre class="playground"><code class="language-rust">fn imprime_numero&lt;T&gt;(numero: T) {
    println!(&quot;Aqu√≠ est√° tu numero: {:?}&quot;, numero); // ‚ö†Ô∏è
}

fn main() {
    imprime_numero(5);
}
</code></pre></pre>
<p><code>imprime_numero</code> necesita que el par√°metro de tipo gen√©rico implemente <strong>Debug</strong> para poder utilizar <code>{:?}</code>. Con la definici√≥n actual de la funci√≥n, no es posible conocer si realmente <code>T</code> implementa o no <strong>Debug</strong>. Por lo tanto, el compilador emite error:</p>
<pre><code class="language-text">error[E0277]: `T` doesn't implement `Debug`
 --&gt; src/main.rs:2:43
  |
2 |     println!(&quot;Aqu√≠ est√° tu numero: {:?}&quot;, numero); // ‚ö†Ô∏è
  |                                           ^^^^^^ `T` cannot be formatted using `{:?}` because it doesn't implement `Debug`
</code></pre>
<p>La soluci√≥n es que se le indique a Rust que esta funci√≥n gen√©rica solo puede utilizar par√°metros de tipo gen√©rico que implementen <strong>Debug</strong>:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Debug;
// Debug se encuentra en el m√≥dulo std::fmt.
// Ahora es posible usar solo Debug.

fn imprime_numero&lt;T: Debug&gt;(numero: T) { // Esto es lo importante &lt;T: Debug&gt;
    println!(&quot;Aqu√≠ est√° tu numero: {:?}&quot;, numero);
}

fn main() {
    imprime_numero(5);
    imprime_numero(5.4);
}
</code></pre></pre>
<p>Ahora el compilador conoce que los tipos que van a usar esta funci√≥n tienen definido <strong>Debug</strong>. Como tanto <code>i32</code>, como <code>f64</code> tienen <code>Debug</code> definido, el c√≥digo funciona.</p>
<p>Si se amplia el ejemplo, creyo una estructura que implemente <strong>Debug</strong> mediante <code>#[derive(Debug)]</code>, se observa que la funci√≥n tambi√©n es v√°lida:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Debug;

#[derive(Debug)]
struct Animal {
    nombre: String,
    edad: u8,
}

fn imprime_elemento&lt;T: Debug&gt;(item: T) {
    println!(&quot;Aqu√≠ est√° tu elemento: {:?}&quot;, item);
}

fn main() {
    let charlie = Animal {
        nombre: &quot;Charlie&quot;.to_string(),
        edad: 1,
    };

    let numero = 55;

    imprime_elemento(charlie);
    imprime_elemento(numero);
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">Aqu√≠ est√° tu elemento: Animal { nombre: &quot;Charlie&quot;, edad: 1 }
Aqu√≠ est√° tu elemento: 55
</code></pre>
<p>En ocasiones se necesita m√°s de un tipo gen√©rico para definir una funci√≥n gen√©rica. Para ello, se puede escribir cada tipo y pensar c√≥mo se utiliza cada uno de ellos. En el siguiente ejemplo, se muestran dos tipos gen√©ricos. Se desea imprimir un texto con el tipo <code>T</code> con <code>{}</code>, por lo que este tipo deber√° implementar <code>Display</code>.</p>
<p>El segundo tipo es <code>U</code> y las dos variables <code>num_1</code> y <code>num_2</code> son de este tipo (<code>U</code> es alg√∫n tipo de n√∫mero). Se trata de compararlas entre ellas, por lo que estos tipos deben implementar el rasgo <code>PartialOrd</code>, que es el que permite que los elementos de un tipo puedan usar <code>&lt;</code>, <code>&gt;</code> y <code>==</code>, entre otros. Tambi√©n se quiere imprimir los n√∫meros, por lo que el tipo <code>U</code> requiere <code>Display</code>.</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;
use std::cmp::PartialOrd;

fn compara_e_imprime&lt;T: Display, U: Display + PartialOrd&gt;(texto: T, num_1: U, num_2: U) {
    println!(&quot;{} ¬øEs {} mayor que {}? {}&quot;, texto, num_1, num_2, num_1 &gt; num_2);
}

fn main() {
    compara_e_imprime(&quot;¬°¬°Escucha!!&quot;, 9, 8);
}
</code></pre></pre>
<p>El resultado es <code>¬°¬°Escucha!! ¬øEs 9 mayor que 8? true</code>.</p>
<p>La declaraci√≥n de la funci√≥n <code>fn compara_e_imprime&lt;T: Display, U: Display + PartialOrd&gt;(texto: T, num_1: U, num_2: U)</code> significa:</p>
<ul>
<li>El nombre de la funci√≥n es <code>compara_e_imprime</code>.</li>
<li>El primer tipo es T y es gen√©rico. Y debe poder usar <code>{}</code> para imprimir.</li>
<li>El segundo tipo es U y es gen√©rico. Debe ser un tipo que pueda usar <code>{}</code> y tambi√©n se tienen que poder comparar sus elementos con <code>&lt;</code>, <code>&gt;</code> y <code>==</code>.</li>
</ul>
<p>De este modo, se pueden pasar par√°metros de distintos tipos a la funci√≥n <code>compara_e_imprime</code>. Por ejemplo, el par√°metro <code>texto</code> puede ser <code>String</code>, <code>&amp;str</code>, <code>i32</code> o cualquier otro que se pueda imprimir.</p>
<p>Para que las funciones gen√©ricas sean m√°s f√°cil de leer, tambi√©n existe la siguiente sintaxis equivalente al c√≥digo anterior. Se utiliza <code>where</code> para simplificar la declaraci√≥n de la funci√≥n.</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;
use std::cmp::PartialOrd;

fn compara_e_imprime&lt;T, U&gt;(texto: T, num_1: U, num_2: U)
where
    T: Display,
    U: Display + PartialOrd,
{
    println!(&quot;{} ¬øEs {} mayor que {}? {}&quot;, texto, num_1, num_2, num_1 &gt; num_2);
}

fn main() {
    compara_e_imprime(&quot;¬°¬°Escucha!!&quot;, 9, 8);
}
</code></pre></pre>
<p>Cuyo se tienen muchos tipos gen√©ricos con rasgos concretos de implementaci√≥n, resulta m√°s legible esta sintaxis con <code>where</code>.</p>
<p>Hay que destacar tambi√©n que:</p>
<ul>
<li>Si se tiene un par√°metro de tipo T y otro par√°metro de tipo T, ambos tienen que ser del mismo tipo.</li>
<li>Si se tiene un par√°metro de tipo T y otro par√°metro de tipo U, pueden ser de diferente tipo, pero tambi√©n pueden ser del mismo tipo.</li>
</ul>
<p>Por ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

fn diga_dos&lt;T: Display, U: Display&gt;(statement_1: T, statement_2: U) {
// El tipo T necesita Display, el tipo U necesita Display
    println!(&quot;Tengo dos cosas que decir: {} y {}&quot;, statement_1, statement_2);
}

fn main() {

    diga_dos(&quot;¬°Hola!&quot;, String::from(&quot;Odio la arena.&quot;)); // Tipo T es &amp;str, pero el tipo U es String.
    diga_dos(String::from(&quot;¬øD√≥nde est√° Padme?&quot;), String::from(&quot;¬øEst√° bien?&quot;)); // Ambos tipos son String.
}
</code></pre></pre>
<p>Esto imprime:</p>
<pre><code class="language-text">Tengo dos cosas que decir: ¬°Hola! y Odio la arena.
Tengo dos cosas que decir: ¬øD√≥nde est√° Padme? y ¬øEst√° bien?
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="los-enumerados-option-y-result"><a class="header" href="#los-enumerados-option-y-result">Los enumerados Option y Result</a></h1>
<p>Ahora que se conocen los enumerados (enum) y los gen√©ricos, se pueden comprender dos enumerados fundamentales en Rust que permiten hacer que el c√≥digo sea m√°s seguro: <code>Option</code> y <code>Result</code>.</p>
<p>En primer lugar se trata <code>Option</code>.</p>
<h2 id="option"><a class="header" href="#option">Option</a></h2>
<p>Tiene dos posibilidades: <code>Some(valor)</code> y <code>None</code> y se utiliza cuando se da el caso de que un valor pueda existir o no.</p>
<p>Cuando el valor existe, se usa <code>Some(valor)</code>. Cuando no existe es <code>None</code>.</p>
<p>El c√≥digo siguiente, sin <code>Option</code>, da error (panic).</p>
<pre><pre class="playground"><code class="language-rust">    // ‚ö†Ô∏è
fn toma_el_quinto(valor: Vec&lt;i32&gt;) -&gt; i32 {
    valor[4]
}

fn main() {
    let new_vec = vec![1, 2];
    let index = toma_el_quinto(new_vec);
}
</code></pre></pre>
<p>Muestra el siguiente mensaje de error:</p>
<pre><code class="language-text">thread 'main' panicked at 'index out of bounds: the len is 2 but the index is 4', src\main.rs:34:5
</code></pre>
<p>Que el programa &quot;entre en p√°nico&quot; (panicked) significa que se detiene de forma controlada antes de que suceda el error. Rust comprueba que la funci√≥n quiere obtener un valor imposible y se detiene antes del error. Recorre la pila de llamadas de funci√≥n para tratar de encontrar un lugar en que se contemple el error y si no lo encuentra, como es el caso, se detiene y viene a decir &quot;lo siento, no puedo obtener el quinto valor de este vector&quot;.</p>
<p>Para evitar este error, se modificar√° el tipo que devuelve la funci√≥n de <code>i32</code> a <code>Option&lt;i32&gt;</code>. Que significa que a partir de ahora esta funci√≥n puede devolver <code>Some(i32)</code> si existe el √≠ndice, o <code>None</code> cuando no existe. En este caso, el valor de retorno cuando existe, <code>i32</code>, estar√° &quot;envuelto&quot; en un tipo <code>Option</code>, es decir: la funci√≥n lo devuelve dentro de un <code>Option</code>, en concreto <code>Some(i32)</code>. Por lo tanto, al terminar la funci√≥n, hace falta alg√∫n tipo de c√≥digo para que el valor embebido en <code>Some</code> se pueda usar.</p>
<pre><pre class="playground"><code class="language-rust">fn toma_el_quinto(valor: Vec&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    if valor.len() &lt; 5 { // .len() devuelve la longitud del vector (el n√∫mero de elementos).
                         // Deber√≠a ser al menos 5 si se quiere recuperar el dato en esa posici√≥n.
        None            // cuando no lo es, devuelve None
    } else {
        Some(valor[4])
    }
}

fn main() {
    let new_vec = vec![1, 2];
    let bigger_vec = vec![1, 2, 3, 4, 5];
    println!(&quot;{:?}, {:?}&quot;, toma_el_quinto(new_vec), toma_el_quinto(bigger_vec));
}
</code></pre></pre>
<p>El c√≥digo anterior imprime <code>None, Some(5)</code>. Ya no falla &quot;en p√°nico&quot;. Pero, ¬øc√≥mo se recupera ahora el valor 5?.</p>
<p>Para obtenerlo, se puede usar alguna de las funciones que tiene el tipo <code>Option</code>. La funci√≥n <code>unwrap()</code> recupera el valor contenido en el <code>Some</code>, pero tambi√©n entra en p√°nico si contiene un <code>None</code>. Es decir, que solo se debe usar cuando se sabe que el valor retornado es un <code>Some(valor)</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn toma_el_quinto(valor: Vec&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    if valor.len() &lt; 5 { 
        None            
    } else {
        Some(valor[4])
    }
}

fn main() {
    let new_vec = vec![1, 2];
    let bigger_vec = vec![1, 2, 3, 4, 5];
    println!(&quot;{:?}, {:?}&quot;, 
        toma_el_quinto(new_vec).unwrap(), // esta fila falla ya que contiene None.
        toma_el_quinto(bigger_vec).unwrap());
}
</code></pre></pre>
<p>El mensaje que devuelve el c√≥digo anterior es:</p>
<pre><code class="language-text">thread 'main' panicked at 'called `Option::unwrap()` on a `None` valor', src/main.rs:13:33
</code></pre>
<p>La forma correcta de recuperar el valor de un <code>Option</code>, contemplando previamente ambas posibilidades es utilizar <code>match</code>. De este forma, se puede decidir qu√© acci√≥n realizar, imprimir o no el valor, en funci√≥n del resultado. Por ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">fn toma_el_quinto(valor: Vec&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    if valor.len() &lt; 5 {
        None
    } else {
        Some(valor[4])
    }
}

fn manejar_opcion(mi_opcion: Vec&lt;Option&lt;i32&gt;&gt;) {
  for item in mi_opcion {
    match item {
      Some(numero) =&gt; println!(&quot;¬°Encontr√© un {}!&quot;, numero),
      None =&gt; println!(&quot;¬°Encontr√© un None!&quot;),
    }
  }
}

fn main() {
    let new_vec = vec![1, 2];
    let bigger_vec = vec![1, 2, 3, 4, 5];
    let mut option_vec = Vec::new(); // se crea un vector para guardar los valores option
                                     // El vector es de tipo: Vec&lt;Option&lt;i32&gt;&gt;. Es decir, un vector de Option&lt;i32&gt;.

    option_vec.push(toma_el_quinto(new_vec)); // guarda &quot;None&quot; en el vec
    option_vec.push(toma_el_quinto(bigger_vec)); // guarda &quot;Some(5)&quot; en el vec

    manejar_opcion(option_vec); // revisa el vector y realiza la acci√≥n que corresponda
                               // Imprime el valor si es un Some. Y no lo toca, y lo indica, si es un None.
}
</code></pre></pre>
<p>Da como resultado:</p>
<pre><code class="language-text">¬°Encontr√© un None!
¬°Encontr√© un 5!
</code></pre>
<p><code>Option</code> utiliza gen√©ricos en su definici√≥n, para poder definir el contenido de <code>Some</code> en cada caso:</p>
<pre><pre class="playground"><code class="language-rust">enum Option&lt;T&gt; {
    None,
    Some(T),
}

fn main() {}
</code></pre></pre>
<p>El punto importante a recordar es que con <code>Some</code> se incluye un valor de tipo <code>T</code> (cualquier tipo). Se observa que los s√≠mbolos de <code>&lt;</code> y <code>&gt;</code> despu√©s del nombre del enumerado <code>Option</code> contienen el par√°metro de tipo, que es lo que le indica al compilador que este enumerado es gen√©rico. En este caso, el enumerado puede ser uno de los dos structs: <code>None</code> o <code>Some(T)</code>. Adem√°s, se observa que <code>T</code> no tiene ning√∫n trait (rasgo) obligatorio como <code>Display</code> u otro que limite los posibles tipos de datos que se puedan incluir dentro de <code>Some</code>. Adem√°s, en el caso de <code>None</code>, ni siquiera existe un tipo de datos (ni siquiera se usa el par√°metro de tipo <code>T</code>).</p>
<p>Por esto √∫ltimo, no se puede usar lo siguiente en la sentencia <code>match</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
Some(valor) =&gt; println!(&quot;El valor es {}&quot;, valor),
None(valor) =&gt; println!(&quot;El valor es {}&quot;, valor),
<span class="boring">}
</span></code></pre></pre>
<p><code>None</code> solo es <code>None</code>...</p>
<p>Hay formas m√°s f√°ciles de usar <code>Option</code>. En el c√≥digo siguiente, se usa el m√©todo <code>.is_some()</code> para preguntar si el tipo del <code>Option</code> es <code>Some</code> (tambi√©n hay otro m√©todo complementario denominado <code>.is_none()</code>).</p>
<pre><pre class="playground"><code class="language-rust">fn toma_el_quinto(valor: Vec&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    if valor.len() &lt; 5 {
        None
    } else {
        Some(valor[4])
    }
}

fn main() {
    let new_vec = vec![1, 2];
    let bigger_vec = vec![1, 2, 3, 4, 5];
    let vec_of_vecs = vec![new_vec, bigger_vec];
    for vec in vec_of_vecs {
        let numero_interno = toma_el_quinto(vec);
        if numero_interno.is_some() {
            // .is_some() devuelve true si es Some, false si es None
            println!(&quot;Tenemos: {}&quot;, numero_interno.unwrap()); // ahora es seguro usar .unwrap() ya que es seguro que es Some
        } else {
            println!(&quot;No tenemos nada.&quot;);
        }
    }
}
</code></pre></pre>
<p>Esto imprime:</p>
<pre><code class="language-text">No tenemos nada.
Tenemos: 5
</code></pre>
<h2 id="result"><a class="header" href="#result">Result</a></h2>
<p>Es similar a <code>Option</code>, pero su uso es diferente:</p>
<ul>
<li><code>Option</code> trata sobre <code>Some</code> o <code>None</code>. La existencia o no de un valor.</li>
<li><code>Result</code> trata sobre <code>Ok</code> o <code>Error</code>. La existencia de un resultado correcto o no (la existencia de un error).</li>
</ul>
<p>Por eso, se debe usar <code>Option</code> cuando el razonamiento es &quot;puede que haya un valor o puede que no&quot;. Pero se debe usar <code>Result</code> cuando el razonamiento es &quot;puede que esto falle&quot;.</p>
<p>Si se comparan las definiciones de ambos enumerados:</p>
<pre><pre class="playground"><code class="language-rust">enum Option&lt;T&gt; {
    None,
    Some(T),
}

enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}

fn main() {}
</code></pre></pre>
<p>Se observa que <code>Result</code> tiene un valor dentro de <code>Ok</code> y tambi√©n el caso de <code>Err</code>. Se trata de poder gestionar la informaci√≥n espec√≠fica que describe el error que haya sucedido cuando este se produzca.</p>
<p>Al tener dos par√°metros de tipo, <code>Result&lt;T, E&gt;</code>, se debe indicar qu√© se devuelve cuando el resultado es correcto, <code>Ok(T)</code>, y qu√© se devuelve cuando el resultado es err√≥neo, <code>Err(E)</code>. Puede ser cualquier cosa que se decida, incluso:</p>
<pre><pre class="playground"><code class="language-rust">fn check_error() -&gt; Result&lt;(), ()&gt; {
    Ok(())
}

fn main() {
    check_error();
}
</code></pre></pre>
<p><code>check_error</code> indica que se devuelva <code>()</code>, tanto en el caso de <code>Ok</code>, como en el caso de <code>Err</code>. Aunque en el ejemplo, siempre devuelve <code>Ok(())</code>.</p>
<p>En todo caso, con este c√≥digo, el compilador da un aviso interesante:</p>
<pre><code class="language-text">warning: unused `std::result::Result` that must be used
 --&gt; src\main.rs:6:5
  |
6 |     check_error();
  |     ^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: this `Result` may be an `Err` variant, which should be handled
</code></pre>
<p>El compilador avisa de que se prev√© que devuelva <code>Result</code>, por lo que el c√≥digo podr√≠a haber devuelto un <code>Err</code>, pero no se est√° tratando dicha posibilidad de error.</p>
<p>A continuaci√≥n se presenta un c√≥digo que trata el posible caso de error:</p>
<pre><pre class="playground"><code class="language-rust">fn dar_resultado(input: i32) -&gt; Result&lt;(), ()&gt; {
    if input % 2 == 0 {
        return Ok(())
    } else {
        return Err(())
    }
}

fn main() {
    if dar_resultado(5).is_ok() {
        println!(&quot;Es correcto&quot;)
    } else {
        println!(&quot;Es un error&quot;)
    }
}
</code></pre></pre>
<p>Este c√≥digo imprime <code>Es un error</code>. As√≠ se ha gestionado el error.</p>
<p>Se puede recordar que para <code>Option</code> y para <code>Result</code>, dos m√©todos, respectivamente, para chequear de forma sencilla el tipo concreto, son: <code>.is_some()</code>, <code>is_none()</code>, <code>is_ok()</code> y <code>is_err()</code>.</p>
<p>En ocasiones, una funci√≥n con <code>Result</code> usar√° <code>String</code> para el valor contenido en <code>Err</code>. Aunque no es la mejor forma, es mejor que lo visto hasta el momento:</p>
<pre><pre class="playground"><code class="language-rust">fn comprueba_si_es_cinco(numero: i32) -&gt; Result&lt;i32, String&gt; {
    match numero {
        5 =&gt; Ok(numero),
        _ =&gt; Err(&quot;Lo siento, el n√∫mero no era cinco.&quot;.to_string()), // Este es el mensaje de error
    }
}

fn main() {
    let mut result_vec = Vec::new(); // Crea un vector para contener el resultado

    for numero in 2..7 {
        result_vec.push(comprueba_si_es_cinco(numero)); // guarda cada resultado
    }

    println!(&quot;{:?}&quot;, result_vec);
}
</code></pre></pre>
<p>El vector imprime lo siguiente:</p>
<pre><code class="language-text">[Err(&quot;Lo siento, el numero no era cinco.&quot;), Err(&quot;Lo siento, el numero no era cinco.&quot;), Err(&quot;Lo siento, el numero no era cinco.&quot;), Ok(5),
Err(&quot;Lo siento, el numero no era cinco.&quot;)]
</code></pre>
<p>Igual que en el caso de <code>Option</code>, <code>.unwrap()</code> sobre un valor de tipo <code>Err</code> &quot;provoca el p√°nico&quot; del programa.</p>
<pre><pre class="playground"><code class="language-rust">    // ‚ö†Ô∏è
fn main() {
    let valor_error: Result&lt;i32, &amp;str&gt; = Err(&quot;Hubo un error&quot;); // Crea un Result que es un Err
    println!(&quot;{}&quot;, valor_error.unwrap()); // Intenta recuperar el valor del resultado (asumiendo que ser√≠a correcto, cosa que no es)
}
</code></pre></pre>
<p>El programa falla (panic) e imprime:</p>
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: &quot;Hubo un error&quot;', src/main.rs:4:32
</code></pre>
<p>Esta informaci√≥n, <code>src/main.rs:4:32</code> significa que el p√°nico se ha producido en &quot;main.rs en el directorio src, en la l√≠nea 4 y columna 32&quot;. Por lo que se puede mirar ah√≠ para ver cu√°l es el problema y resolverlo.</p>
<p>Tambi√©n se pueden crear nuevos tipos de error, que es lo habitual. Las funciones de la librer√≠a est√°ndar y otras librer√≠as lo suelen hacer. Por ejemplo, esta funci√≥n de la librer√≠a est√°ndar:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
pub fn from_utf8(vec: Vec&lt;u8&gt;) -&gt; Result&lt;String, FromUtf8Error&gt;
<span class="boring">}
</span></code></pre></pre>
<p>Esta funci√≥n toma un vector de bytes (<code>u8</code>) e intenta convertirlo en una <code>String</code>. Como puede ser que los bytes no se correspondan con c√≥digos v√°lidos en UTF8, en lugar de devolver un <code>String</code>, devuelve un <code>Result</code> con un <code>String</code> en el caso de √©xito y un error <code>FromUtf8Error</code> en el caso de que falle la conversi√≥n. Se puede usar cualquier nombre para el caso de fallo.</p>
<p>En ocasiones, el uso de <code>match</code> con <code>Option</code> y <code>Result</code> requiere mucho c√≥digo. Por ejemplo, el m√©todo <code>.get()</code> devuelve un <code>Option</code> sobre un <code>Vec</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![2, 3, 4];
    let get_one = my_vec.get(0); // recupera el primer n√∫mero
    let get_two = my_vec.get(10); // recupera None
    println!(&quot;{:?}&quot;, get_one);
    println!(&quot;{:?}&quot;, get_two);
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">Some(2)
None
</code></pre>
<p>Para obtener los valores, se puede usar <code>match</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![2, 3, 4];

    for index in 0..10 {
      match my_vec.get(index) {
        Some(number) =&gt; println!(&quot;El n√∫mero es: {}&quot;, number),
        None =&gt; {}
      }
    }
}
</code></pre></pre>
<p>Este c√≥digo es correcto, pero queremos hacer nada en el caso de <code>None</code>. En estos casos, se puede optar por escribir un c√≥digo m√°s compacto mediante el uso de <code>if let</code> que permite &quot;hacer algo si coincide un valor&quot; y &quot;no hacer nada en el resto de casos&quot;.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![2, 3, 4];

    for index in 0..10 {
      if let Some(number) = my_vec.get(index) {
        println!(&quot;The n√∫mero es: {}&quot;, number);
      }
    }
}
</code></pre></pre>
<p><strong>Importante, a recordar:</strong> <code>if let Some(number) = my_vec(index)</code> significa que &quot;compruebe si el valor de <code>my_vec(index)</code> es compatible con <code>Some(number)</code>.</p>
<p>Adem√°s, hay que tener en cuenta que se usa <code>=</code>.</p>
<p>Tambi√©n existe <code>while let</code> que es un bucle for en el que se comprueba como en <code>if let</code>. Por ejemplo, si se dispone de los siguientes datos del tiempo procedentes de estaciones meteorol√≥gicas:</p>
<pre><code class="language-text">[&quot;Berlin&quot;, &quot;cloudy&quot;, &quot;5&quot;, &quot;-7&quot;, &quot;78&quot;]
[&quot;Athens&quot;, &quot;sunny&quot;, &quot;not humid&quot;, &quot;20&quot;, &quot;10&quot;, &quot;50&quot;]
</code></pre>
<p>Y se desea obtener solo los n√∫meros. Para ello, se puede usar el m√©todo <code>parse::&lt;i32&gt;()</code>. Este m√©todo intenta convertir un <code>&amp;str</code> en un <code>i32</code> y lo entrega en un valor de tipo <code>Result</code>ya que podr√≠a no funcionar si se le pasa algo que no es un n√∫mero entero.</p>
<p>En el siguiente ejemplo, tambi√©n se usar√° <code>.pop()</code> para extraer el √∫ltimo elemento del vector.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let weather_vec = vec![
        vec![&quot;Berlin&quot;, &quot;cloudy&quot;, &quot;5&quot;, &quot;-7&quot;, &quot;78&quot;],
        vec![&quot;Athens&quot;, &quot;sunny&quot;, &quot;not humid&quot;, &quot;20&quot;, &quot;10&quot;, &quot;50&quot;],
    ];
    for mut city in weather_vec {
        println!(&quot;Para la ciudad de {}:&quot;, city[0]); // En los datos, el primer elemento siempre es el nombre de la ciudad
        while let Some(information) = city.pop() {
            // Esto significa: continua mientras hay valores
            // Cuando no queden valores pop retorna None
            // y se saldr√° del bucle while
            if let Ok(number) = information.parse::&lt;i32&gt;() {
                // Intenta obtener un entero
                // Devuelve un Result. Si es Ok(number), se imprimir√°
                println!(&quot;El n√∫mero es: {}&quot;, number);
            }  // No se hace nada, si no era un n√∫mero, casos en los que se devuelve Err
        }
    }
}
</code></pre></pre>
<p>Que imprimir√°:</p>
<pre><code class="language-text">Para la ciudad de Berlin:
El n√∫mero es: 78
El n√∫mero es: -7
El n√∫mero es: 5
Para la ciudad de Athens:
El n√∫mero es: 50
El n√∫mero es: 10
El n√∫mero es: 20
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="otras-colecciones"><a class="header" href="#otras-colecciones">Otras colecciones</a></h1>
<p>Rust tiene muchos tipos de colecci√≥n m√°s. Se pueden consultar en la librer√≠a est√°ndar: <a href="https://doc.rust-lang.org/beta/std/collections/">https://doc.rust-lang.org/beta/std/collections/</a>. Esta p√°gina dispone de buenas explicaciones en cuanto a cu√°ndo cada tipo, as√≠ que es el lugar en que consultar cuando no se tiene claro qu√© tipo usar. Todas estas colecciones se encuentran dentro de <code>std::collections</code> en la librer√≠a est√°ndar de Rust. La mejor forma de usarlas es mediante <code>use</code>, como se hizo con los enumerados. Se presenta primero <code>HashMap</code> por ser de uso com√∫n.</p>
<h2 id="hashmap-y-btreemap"><a class="header" href="#hashmap-y-btreemap">HashMap (y BTreeMap)</a></h2>
<p>Un HashMap es una colecci√≥n compuesta por <em>claves</em> y <em>valores</em>. Se puede usar la clave para recuperar el valor que se almacen√≥ con ella. Se puede crear un <code>HashMap</code> con <code>HashMap::new()</code> y se pueden insertar nuevos elementos mediante <code>.insert(clave, valor)</code>.</p>
<p>Los <code>HashMap</code> no est√°n ordenados, por lo que si se imprimen todas las claves almacenadas, probablemente saldr√°n en cualquier orden. Se puede ver con un ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap; // As√≠, bastar√° con escribir
// HashMap cada vez, en lugar de std::collections::HashMap

struct Ciudad {
    nombre: String,
    poblacion: HashMap&lt;u32, u32&gt;, // Almacenar√° el a√±o
    //y la poblaci√≥n de cada a√±o
}

fn main() {

    let mut tallinn = Ciudad {
        nombre: &quot;Tallinn&quot;.to_string(),
        poblacion: HashMap::new(), // En este momento el HashMap est√° vac√≠o
    };

    tallinn.poblacion.insert(1372, 3_250); // inserta tres fechas
    tallinn.poblacion.insert(1851, 24_000);
    tallinn.poblacion.insert(2020, 437_619);


    for (a√±o, poblacion) in tallinn.poblacion { // El tipo del Hashmap es HashMap&lt;u32, u32&gt;. Obtiene en cada iteraci√≥n un par clave/valor
        println!(&quot;En el a√±o {} la ciudad de {} ten√≠a una poblaci√≥n de {}.&quot;, a√±o, tallinn.nombre, poblacion);
    }
}
</code></pre></pre>
<p>Que puede imprimir:</p>
<pre><code class="language-text">En el a√±o 1372 la ciudad de Tallinn ten√≠a una poblaci√≥n de 3250.
En el a√±o 2020 la ciudad de Tallinn ten√≠a una poblaci√≥n de 437619.
En el a√±o 1851 la ciudad de Tallinn ten√≠a una poblaci√≥n de 24000.
</code></pre>
<p>Pero tambi√©n podr√≠a imprimir:</p>
<pre><code class="language-text">En el a√±o 1851 la ciudad de Tallinn ten√≠a una poblaci√≥n de 24000.
En el a√±o 2020 la ciudad de Tallinn ten√≠a una poblaci√≥n de 437619.
En el a√±o 1372 la ciudad de Tallinn ten√≠a una poblaci√≥n de 3250.
</code></pre>
<p>Se puede observar que no est√° en orden.</p>
<p>Si se necesita una colecci√≥n para almacenar parejas de clave y valor, se puede utilizar <code>BTreeMap</code>, que funciona igual que <code>HashMap</code>, pero mantiene el orden por clave.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::BTreeMap; // As√≠, bastar√° con cambiar HashMap a BTreeMap

struct Ciudad {
    nombre: String,
    poblacion: BTreeMap&lt;u32, u32&gt;, 
}

fn main() {

    let mut tallinn = Ciudad {
        nombre: &quot;Tallinn&quot;.to_string(),
        poblacion: BTreeMap::new(), 
    };

    tallinn.poblacion.insert(1372, 3_250); 
    tallinn.poblacion.insert(1851, 24_000);
    tallinn.poblacion.insert(2020, 437_619);


    for (a√±o, poblacion) in tallinn.poblacion {
        println!(&quot;En el a√±o {} la ciudad de {} ten√≠a una poblaci√≥n de {}.&quot;, a√±o, tallinn.nombre, poblacion);
    }
}
</code></pre></pre>
<p>Ahora, siempre se imprime:</p>
<pre><code class="language-text">En el a√±o 1372 la ciudad de Tallinn ten√≠a una poblaci√≥n de 3250.
En el a√±o 1851 la ciudad de Tallinn ten√≠a una poblaci√≥n de 24000.
En el a√±o 2020 la ciudad de Tallinn ten√≠a una poblaci√≥n de 437619.
</code></pre>
<p>Volviendo a los <code>HashMap</code>. Se puede recuperar un valor determinado simplemente escribiendo la clave entre <code>[]</code> corchetes. En el siguiente ejemplo se recuperar√° el valor de la clave <code>Bielefeld</code> que est√° en <code>Alemania</code>. La aplicaci√≥n fallar√° si no existe la clave. Si se escribe <code>println!((&quot;{:?}&quot;, ciudad_hashmap[&quot;Bielefeldd&quot;]);</code>, fallar√°, porque <code>Bielefeldd</code>no existe.</p>
<p>Si no se est√° seguro de que exista una clave determinada, se puede usar <code>get()</code> que devuelve un tipo <code>Option</code>. Si existe sera <code>Some(value)</code> y si no, contendr√° <code>None</code>, pero no fallar√° la aplicaci√≥n. Por eso, la forma adecuada de recuperar un valor de un <code>HashMap</code> es usar <code>get()</code>.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let ciudades_canadieneses = vec![&quot;Calgary&quot;, &quot;Vancouver&quot;, &quot;Gimli&quot;];
    let ciudades_alemanas = vec![&quot;Karlsruhe&quot;, &quot;Bad Doberan&quot;, &quot;Bielefeld&quot;];

    let mut ciudad_hashmap = HashMap::new();

    for ciudad in ciudades_canadieneses {
        ciudad_hashmap.insert(ciudad, &quot;Canad√°&quot;);
    }
    for ciudad in ciudades_alemanas {
        ciudad_hashmap.insert(ciudad, &quot;Alemania&quot;);
    }

    println!(&quot;{:?}&quot;, ciudad_hashmap[&quot;Bielefeld&quot;]);
    println!(&quot;{:?}&quot;, ciudad_hashmap.get(&quot;Bielefeld&quot;));
    println!(&quot;{:?}&quot;, ciudad_hashmap.get(&quot;Bielefeldd&quot;));
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">&quot;Alemania&quot;
Some(&quot;Alemania&quot;)
None
</code></pre>
<p>Esto sucede porque <em>Bielefeld</em> existe, pero <em>Bielefeldd</em> no.</p>
<p>Si un <code>HashMap</code>ya contiene una clave y se intenta insertar un nuevo valor, el antiguo se sobreescribe.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut book_hashmap = HashMap::new();

    book_hashmap.insert(1, &quot;L'Allemagne Moderne&quot;);
    book_hashmap.insert(1, &quot;Le Petit Prince&quot;);
    book_hashmap.insert(1, &quot;ÏÑÄÎèÑÏö∞ Ïò§Î∏å Ïú†Ïñ¥ Ïä§ÎßàÏùº&quot;);
    book_hashmap.insert(1, &quot;Eye of the World&quot;);

    println!(&quot;{:?}&quot;, book_hashmap.get(&amp;1));
}
</code></pre></pre>
<p>Que imprime <code>Some(&quot;Eye of the World&quot;)</code>, porque fue el √∫ltimo valor utilizado en al insertar con <code>.insert()</code>.</p>
<p>Es f√°cil comprobar si un valor existe cotejando el enumerado <code>Option</code> que devuelve <code>.get()</code>.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut book_hashmap = HashMap::new();

    book_hashmap.insert(1, &quot;L'Allemagne Moderne&quot;);

    if book_hashmap.get(&amp;1).is_none() { // is_none() devuelve un bool: true si es None, false si es Some
        book_hashmap.insert(1, &quot;Le Petit Prince&quot;);
    }

    println!(&quot;{:?}&quot;, book_hashmap.get(&amp;1));
}
</code></pre></pre>
<p>Que imprime <code>Some(&quot;L\'Allemagne Moderne&quot;)</code> porque exist√≠a ya una clave <code>1</code>, por lo que no se lleg√≥ a insertar <code>Le Petit Prince</code>.</p>
<p><code>HashMap</code> tiene un m√©todo muy interesante denominado <code>.entry()</code> que se puede utilizar. Con el resultado de este m√©todo (que devuelve un valor de tipo enumerado <code>Entry</code>) se puede utilizar el m√©todo <code>.or_entry()</code> para insertar un valor solo si no existe una clave. La parte interesante es que devuelve una referencia modificable por polo que se puede modificar si se quiere. En el siguiente ejemplo e inserta <code>true</code> cada vez que se inserta un libro en el <code>HashMap</code>.</p>
<p>Se quiere llevar el seguimiento de los libros de un biblioteca.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let book_collection = vec![&quot;L'Allemagne Moderne&quot;, &quot;Le Petit Prince&quot;, &quot;Eye of the World&quot;, &quot;Eye of the World&quot;]; // Eye of the World aparece dos veces

    let mut book_hashmap = HashMap::new();

    for book in book_collection {
        book_hashmap.entry(book).or_insert(true);
    }
    for (book, true_or_false) in book_hashmap {
        println!(&quot;¬øTenemos el libro {}? {}&quot;, book, true_or_false);
    }
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">¬øTenemos el libro Eye of the World? true
¬øTenemos el libro Le Petit Prince? true
¬øTenemos el libro L'Allemagne Moderne? true
</code></pre>
<p>Pero esto no es exactamente lo que se quiere. Ser√≠a mejor contar el n√∫mero de copias de cada libro para que se pueda conocer que existen dos copias de <em>Eye of the world</em>.</p>
<p>En primer lugar, se va a estudiar lo que hace el m√©todo <code>.entry()</code> y el m√©todo <code>.or_insert()</code>. <code>.entry()</code> devuelve un <code>enum</code> llamado <code>Entry</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn entry(&amp;mut self, key: K) -&gt; Entry&lt;K, V&gt; // üöß
<span class="boring">}
</span></code></pre></pre>
<p><a href="https://doc.rust-lang.org/std/collections/hash_map/enum.Entry.html">Esta es la p√°gina de Entry</a>. Esa es una versi√≥n simplificada de su c√≥digo. <code>K</code> representa el tipo de la clave y <code>V</code> representa el tipo del valor.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
use std::collections::hash_map::*;

enum Entry&lt;K, V&gt; {
    Occupied(OccupiedEntry&lt;K, V&gt;),
    Vacant(VacantEntry&lt;K, V&gt;),
}
<span class="boring">}
</span></code></pre></pre>
<p>Cuando se llama a <code>.or_insert()</code> se observa el tipo concreto del enumerado y se decide qu√© hacer:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn or_insert(self, default: V) -&gt; &amp;mut V { // üöß
    match self {
        Occupied(entry) =&gt; entry.into_mut(),
        Vacant(entry) =&gt; entry.insert(default),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Lo m√°s interesante es que se devuelve una referencia modificable: <code>&amp;mut V</code>. Esto significa que se puede usar <code>let</code> para asignarla a una variable y cambiar la variable para cambiar el valor del <code>HashMap</code>. As√≠, para cada libro se insertar√° un 0 si no hay una entrada. Si hay una, se utilizar√° <code>+=1</code> en la referencia para incrementar la cuenta. El c√≥digo queda as√≠:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let book_collection = vec![&quot;L'Allemagne Moderne&quot;, &quot;Le Petit Prince&quot;, &quot;Eye of the World&quot;, &quot;Eye of the World&quot;];

    let mut book_hashmap = HashMap::new();

    for book in book_collection {
        let return_value = book_hashmap.entry(book).or_insert(0); // return_value es una referencia mutable.
        // Si no contiene nada, se asigna un cero.
        *return_value +=1; // Ahora return_value vale al menos 1.
        // Y si ya ten√≠a alg√∫n valor, lo incrementa en uno
    }

    for (book, numero) in book_hashmap {
        println!(&quot;{}, {}&quot;, book, numero);
    }
}
</code></pre></pre>
<p>Lo important es <code>let return_value = book_hashmap.entry(book).or_insert(0);</code>. Si no se asignara el valor a una variable, se asignar√≠a el 0 cuando no hubiera valor, pero se perder√≠a la referencia modificable. Al conservarla en la variable <code>return_value</code>, se puede modificar el valor sum√°ndole 1 en este caso. Cuando esto sucede por segunda vez para un mismo valor, no se crea ninguna entrada nueva con un valor 0, sino que simplemente se devuelve el valor para que se pueda incrementar. As√≠ el resultado de este programa es:</p>
<pre><code class="language-text">L'Allemagne Moderne, 1
Le Petit Prince, 1
Eye of the World, 2
</code></pre>
<p>Tambi√©n se pueden hacer otras cosas con <code>.or_insert()</code> como insertar un vector y luego insertar en el vector. Por ejemplo, si se supone que se pregunta a hombres y mujeres qu√© opinan de un pol√≠tico para que les asignen una valoraci√≥n de 0 a 10, se pueden clasificar juntos los puntos para saber si un pol√≠tico es m√°s popular entre los hombres o entre las mujeres, el c√≥digo podr√≠a ser as√≠:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let data = vec![ // Estos son los datos puros
        (&quot;hombre&quot;, 9),
        (&quot;mujer&quot;, 5),
        (&quot;hombre&quot;, 0),
        (&quot;mujer&quot;, 6),
        (&quot;mujer&quot;, 5),
        (&quot;hombre&quot;, 10),
    ];

    let mut survey_hash = HashMap::new();

    for item in data { // Devuelve una tupla de (&amp;str, i32)
        survey_hash.entry(item.0)
            .or_insert(Vec::new())
            .push(item.1); // A√±ade el n√∫mero al vector contenido en el valor correspondiente del HashMap
    }

    for (hombre_or_mujer, numeros) in survey_hash {
        println!(&quot;{:?}: {:?}&quot;, hombre_or_mujer, numeros);
    }
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">&quot;mujer&quot;, [5, 6, 5]
&quot;hombre&quot;, [9, 0, 10]
</code></pre>
<p>La l√≠nea de c√≥digo importante es <code>survey_hash.entry(item.0).or_insert(Vec::new()).push(item.1);</code> que si recibe una &quot;mujer&quot; comprobar√° si ya existe en el <code>HashMap</code>. Si no existe, insertar√° <code>Vec::new()</code> y despu√©s insertar√° el n√∫mero en el vector. Si existe, no insertar√° ning√∫n vector nuevo, lo recuperar√° e insertar√° el n√∫mero en el vector.</p>
<h2 id="hashset-y-btreeset"><a class="header" href="#hashset-y-btreeset">HashSet y BTreeSet</a></h2>
<p>Un <code>HashSet</code> es un <code>HashMap</code> que solo tiene claves. En <a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html">la p√°gina para HashSet</a> explica lo siguiente:</p>
<p>&quot;Es un hash set implementado con HashMap en el que el valor es ().&quot; Es un <code>HashMap</code> con claves y sin valores.</p>
<p>Se utiliza frecuentemente para saber si una clave existe o no.</p>
<p>Por ejemplo, si se tienen 100 n√∫meros aleatorios y cada uno de ellos se encuentra entre el 1 y el 100, habr√° n√∫meros entre el 1 y el 100 que aparezcan varias veces y algunos que no aparecer√°n. Si se insertan en un <code>HashSet</code> se obtendr√° una lista de todos los n√∫meros que s√≠ han aparecido sin tener en cuenta el n√∫mero de veces que lo han hecha.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashSet;

fn main() {
    let many_numeros = vec![
        94, 42, 59, 64, 32, 22, 38, 5, 59, 49, 15, 89, 74, 29, 14, 68, 82, 80, 56, 41, 36, 81, 66,
        51, 58, 34, 59, 44, 19, 93, 28, 33, 18, 46, 61, 76, 14, 87, 84, 73, 71, 29, 94, 10, 35, 20,
        35, 80, 8, 43, 79, 25, 60, 26, 11, 37, 94, 32, 90, 51, 11, 28, 76, 16, 63, 95, 13, 60, 59,
        96, 95, 55, 92, 28, 3, 17, 91, 36, 20, 24, 0, 86, 82, 58, 93, 68, 54, 80, 56, 22, 67, 82,
        58, 64, 80, 16, 61, 57, 14, 11];

    let mut numero_hashset = HashSet::new();

    for numero in many_numeros {
        numero_hashset.insert(numero);
    }

    let hashset_length = numero_hashset.len(); // Cu√°ntos n√∫meros contiene
    println!(&quot;Hay {} n√∫meros √∫nicos, por lo que faltan {}.&quot;, hashset_length, 100 - hashset_length);

    // Veamos cu√°les son los que faltan
    let mut missing_vec = vec![];
    for numero in 0..100 {
        if numero_hashset.get(&amp;numero).is_none() { // Si .get() devuelve None,
            missing_vec.push(numero);
        }
    }

    print!(&quot;No contiene: &quot;);
    for numero in missing_vec {
        print!(&quot;{} &quot;, numero);
    }
}
</code></pre></pre>
<p>Este c√≥digo imprime:</p>
<pre><code class="language-text">Hay 66 n√∫meros √∫nicos, por lo que faltan 34.
No contiene: 1 2 4 6 7 9 12 21 23 27 30 31 39 40 45 47 48 50 52 53 62 65 69 70 72 75 77 78 83 85 88 97 98 99
</code></pre>
<p>Un <code>BTreeSet</code> es similar a un <code>HashSet</code> de la misma manera que un <code>BTreeMap</code> lo es a un <code>HashMap</code>. Si se imprimen los elementos de un <code>HashSet</code> lo har√°n en cualquier orden:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for entry in numero_hashset { // üöß
    print!(&quot;{} &quot;, entry);
}
<span class="boring">}
</span></code></pre></pre>
<p>Puede que imprima: <code>67 28 42 25 95 59 87 11 5 81 64 34 8 15 13 86 10 89 63 93 49 41 46 57 60 29 17 22 74 43 32 38 36 76 71 18 14 84 61 16 35 90 56 54 91 19 94 44 3 0 68 80 51 92 24 20 82 26 58 33 55 96 37 66 79 73</code>. Pero casi nunca lo imprimir√° en el mismo orden en distintas repeticiones.</p>
<p>De nuevo, es muy f√°cil cambiar un <code>HashSet</code> a <code>BTreeSet</code> si se decide que se necesita mantenerlo ordenado. En el c√≥digo anterior, basta con cambiar en dos sitios de <code>HashSet</code> a <code>BTreeSet</code>.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::BTreeSet; // HashSet a BTreeSet

fn main() {
    let many_numeros = vec![
        94, 42, 59, 64, 32, 22, 38, 5, 59, 49, 15, 89, 74, 29, 14, 68, 82, 80, 56, 41, 36, 81, 66,
        51, 58, 34, 59, 44, 19, 93, 28, 33, 18, 46, 61, 76, 14, 87, 84, 73, 71, 29, 94, 10, 35, 20,
        35, 80, 8, 43, 79, 25, 60, 26, 11, 37, 94, 32, 90, 51, 11, 28, 76, 16, 63, 95, 13, 60, 59,
        96, 95, 55, 92, 28, 3, 17, 91, 36, 20, 24, 0, 86, 82, 58, 93, 68, 54, 80, 56, 22, 67, 82,
        58, 64, 80, 16, 61, 57, 14, 11];

    let mut numero_btreeset = BTreeSet::new(); // HashSet a BTreeSet

    for numero in many_numeros {
        numero_btreeset.insert(numero);
    }
    for entry in numero_btreeset {
        print!(&quot;{} &quot;, entry);
    }
}
</code></pre></pre>
<p>Que lo imprimir√° en orden: <code>0 3 5 8 10 11 13 14 15 16 17 18 19 20 22 24 25 26 28 29 32 33 34 35 36 37 38 41 42 43 44 46 49 51 54 55 56 57 58 59 60 61 63 64 66 67 68 71 73 74 76 79 80 81 82 84 86 87 89 90 91 92 93 94 95 96</code>.</p>
<h2 id="binaryheap"><a class="header" href="#binaryheap">BinaryHeap</a></h2>
<p>Un <code>BinaryHeap</code> es un tipo de colecci√≥n mayormente desordenada, pero que tiene un bit de orden. Mantiene el elemento mayor al comienzo, pero los dem√°s elementos est√°n en cualquier orden.</p>
<p>Se usar√° otra lista de elementos para el ejemplo, pero esta vez, ser√° m√°s peque√±a.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::BinaryHeap;

fn muestra_contenido(input: &amp;BinaryHeap&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    // Esta funci√≥n recupera el contenido de un BinaryHeap.
    // Un iterador ser√≠a m√°s r√°pido que esta funci√≥n
    // se aprender√°n m√°s adelante
    let mut remainder_vec = vec![];
    for numero in input {
        remainder_vec.push(*numero)
    }
    remainder_vec
}

fn main() {
    let many_numeros = vec![0, 5, 10, 15, 20, 25, 30]; // Estos n√∫meros est√°n ordenados

    let mut my_heap = BinaryHeap::new();

    for numero in many_numeros {
        my_heap.push(numero);
    }

    while let Some(numero) = my_heap.pop() { // .pop() devuelve Some(numero) si est√°, None si no est√°. Lo recupera del comienzo
        println!(&quot;Se extrae el {}. Los restantes n√∫meros son: {:?}&quot;, numero, muestra_contenido(&amp;my_heap));
    }
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">Se extrae el 30. Los restantes n√∫meros son: [25, 15, 20, 0, 10, 5]
Se extrae el 25. Los restantes n√∫meros son: [20, 15, 5, 0, 10]
Se extrae el 20. Los restantes n√∫meros son: [15, 10, 5, 0]
Se extrae el 15. Los restantes n√∫meros son: [10, 0, 5]
Se extrae el 10. Los restantes n√∫meros son: [5, 0]
Se extrae el 5. Los restantes n√∫meros son: [0]
Se extrae el 0. Los restantes n√∫meros son: []
</code></pre>
<p>Se observa que siempre est√° el n√∫mero mayor en el √≠ndice 0. A partir del √≠ndice 1 no existe orden.</p>
<p>Un buen uso para <code>BinaryHeap</code> es como colecci√≥n de cosas a hacer. Se puede crear un <code>BinaryHeap&lt;(u8, &amp;str)&gt;</code> en el que el <code>u8</code> indica la importancia de la tarea. La cadena de texto <code>&amp;str</code> es la descripci√≥n de lo que hay que hacer:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::BinaryHeap;

fn main() {
    let mut tareas = BinaryHeap::new();

    // A√±ade las tareas a hacer durante el d√≠a
    tareas.push((100, &quot;Contestar correo al CEO&quot;));
    tareas.push((80, &quot;Finalizar el informe hoy&quot;));
    tareas.push((5, &quot;Ver algo en YouTube&quot;));
    tareas.push((70, &quot;Dar las gracias a tu equipo por trabajar siempre duro&quot;));
    tareas.push((30, &quot;Planear a qui√©n contratar parar el equipo&quot;));

    while let Some(job) = tareas.pop() {
        println!(&quot;Tienes que hacer: {}&quot;, job.1);
    }
}
</code></pre></pre>
<p>Lo que siempre imprimir√°:</p>
<pre><code class="language-text">Tienes que hacer: Contestar correo al CEO
Tienes que hacer: Finalizar el informe hoy
Tienes que hacer: Dar las gracias a tu equipo por trabajar siempre duro
Tienes que hacer: Planear a qui√©n contratar parar el equipo
Tienes que hacer: Ver algo en YouTube
</code></pre>
<h2 id="vecdeque"><a class="header" href="#vecdeque">VecDeque</a></h2>
<p>Un <code>VecDeque</code> es un <code>Vec</code> que tiene buen rendimiento extrayendo elementos tanto por el inicio, como por el final. Rust tiene <code>VecDeque</code> porque <code>Vec</code> solo tiene buen rendimiento extrayendo elementos por el final. Cuando se usa <code>.pop()</code> en un <code>Vec</code>, solamente se tiene que recuperar el √∫ltimo elemento de la derecha y nada m√°s se mueve. Pero si se recupera cualquier otro elemento, todos los que quedan a su derecha se tienen que mover hacia la izquierda. Se puede ver esto en la descripci√≥n del m√©todo <code>.remove()</code> de <code>Vec</code>:</p>
<pre><code class="language-text">Quita y devuelve el elemento en la posici√≥n con el √≠ndice indicado, desplazando todos los elementos posteriores hacia la izquierda.
</code></pre>
<p>Por eso, si se hace lo siguiente:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec = vec![9, 8, 7, 6, 5];
    my_vec.remove(0);
}
</code></pre></pre>
<p>Se eliminar√° el <code>9</code>. El <code>8</code> en el √≠ndice 1 se mover√° al √≠ndice 0, el <code>7</code> en el √≠ndice 2 se mover√° al 1 y as√≠ sucesivamente. Se puede imaginar lo complejo que ser√≠a que un aparcamiento de veh√≠culos funcionara as√≠ cada vez que un coche sale de √©l...</p>
<p>Esta forma de eliminar el primer elemento supone mucho trabajo para el ordenador. De hecha, si se ejecuta esto en el Playground de rust, problamente lo abanhecha debido a que es mucho esfuerzo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec = vec![0; 600_000];
    for i in 0..600000 {
        my_vec.remove(0);
    }
}
</code></pre></pre>
<p>El c√≥digo anterior construye un <code>Vec</code> de 600.000 ceros. Cada vez que usa <code>.remove(0)</code> se tiene que mover cada cero una posici√≥n a la izquierda. Y esto se tiene que hacer hasta 600.000 veces.</p>
<p>Esto no es un problema para <code>VecDeque</code>. En general, puede ser un poco m√°s lento que un <code>Vec</code>, pero si es necesario realizar operaciones en ambos lados es much√≠simo m√°s eficiente. Se puede construir a partir de un vector mediante <code>VecDeque::from</code>. El c√≥digo anterior quedar√≠a modificado as√≠:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::VecDeque;

fn main() {
    let mut my_vec = VecDeque::from(vec![0; 600_000]);
    for i in 0..600000 {
        my_vec.pop_front();
    }
}
</code></pre></pre>
<p>Que ahora es mucho m√°s r√°pido y en el Playground de Rust se acaba en menos de un segundo en lugar de fallar.</p>
<p>En el siguiente ejemplo se dispone de un <code>Vec</code> de cosas para hacer. Se convierte a un <code>VecDeque</code> y se usa <code>.push_front()</code> para a√±adir elementos al inicio. As√≠ el primer elemento a√±adido estar√° a la derecha. Cada elemento que se inserta es una tupla <code>(&amp;str, bool)</code>: <code>&amp;str</code> es la descripci√≥n de la tarea y <code>false</code> significa que no se ha ejecutado a√∫n. Se usa la funci√≥n <code>.hecha()</code> para extraer un elemento del final, pero sin eliminarlo. En su lugar, se cambia de <code>false</code> a <code>true</code> y se inserta al inicio para conservarlo.</p>
<p>Queda as√≠:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::VecDeque;

fn comprueba_restantes(input: &amp;VecDeque&lt;(&amp;str, bool)&gt;) { // Cada elemento es un (&amp;str, bool)
    for item in input {
        if item.1 == false {
            println!(&quot;Tienes que: {}&quot;, item.0);
        }
    }
}

fn hecha(input: &amp;mut VecDeque&lt;(&amp;str, bool)&gt;) {
    let mut tarea_hecha = input.pop_back().unwrap(); // extrae del final
    tarea_hecha.1 = true;                            // ahora est√° hecha - se marca como true
    input.push_front(tarea_hecha);                   // y se inserta al inicio
}

fn main() {
    let mut my_vecdeque = VecDeque::new();
    let things_to_do = vec![&quot;enviar correo al cliente&quot;, &quot;a√±adir un producto a la lista&quot;, &quot;devolver la llamada a Loki&quot;];

    for thing in things_to_do {
        my_vecdeque.push_front((thing, false));
    }

    hecha(&amp;mut my_vecdeque);
    hecha(&amp;mut my_vecdeque);

    comprueba_restantes(&amp;my_vecdeque);

    for tarea in my_vecdeque {
        print!(&quot;{:?} &quot;, tarea);
    }
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">Tienes que: devolver la llamada a Loki
(&quot;a√±adir un producto a la lista&quot;, true) (&quot;enviar correo al cliente&quot;, true) (&quot;devolver la llamada a Loki&quot;, false)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="el-operador-"><a class="header" href="#el-operador-">El operador ?</a></h1>
<p>Existe una forma m√°s corta de gestionar un valor de tipo <code>Result</code> (y <code>Option</code>). m√°s corta que <code>match</code> y que <code>if let</code>. Es el &quot;operador interrogaci√≥n&quot; y es <code>?</code>. Despu√©s de una funci√≥n devuelve un resultado, se puede a√±adir <code>?</code> para:</p>
<ul>
<li>devolver el valor contenido en <code>Ok</code>, si es el tipo concreto de <code>Result</code>.</li>
<li>o elevar el error si es <code>Err</code>.</li>
</ul>
<p>En otras palabras, hace casi todo por ti.</p>
<p>Por ejemplo, se puede probar esto con <code>.parse()</code>.  En el siguiente ejemplo se presenta la funci√≥n <code>parse_str</code> que intenta convertir un <code>&amp;str</code> a <code>i32</code>:</p>
<pre><pre class="playground"><code class="language-rust">use std::num::ParseIntError;

fn parse_str(input: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let parsed_number = input.parse::&lt;i32&gt;()?; // Aqu√≠ est√° el ?
    Ok(parsed_number)
}

fn main() {}
</code></pre></pre>
<p>Esta funci√≥n toma un <code>&amp;str</code>. Si es <code>Ok</code>, devuelve un <code>i32</code> envuelto en un <code>Ok</code>. Si es un <code>Err</code>, devuelve <code>ParseIntError</code>. Al intentar obtener el n√∫mero y haberse a√±adido <code>?</code> lo que se hace es comprobar si esta llamada a <code>parse</code> ha devuelto <code>Ok</code> y obtener el contenido de este. Si no es correcto, devolver√° un error y finalizar√° en la linea de <code>parse</code>. Pero si es correcto avanza hasta la l√≠nea siguiente para devolver <code>Ok(i32)</code>. Es necesario envolver el n√∫mero para que sea compatible con el valor de retorno de la funci√≥n <code>Result&lt;i32, ParseIntError&gt;</code>, no <code>i32</code>.</p>
<p>Ahora, se puede probar a ejecutar la funci√≥n. Se observa a continuaci√≥n lo que sucede con un vector de <code>&amp;str</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn parse_str(input: &amp;str) -&gt; Result&lt;i32, std::num::ParseIntError&gt; {
    let parsed_number = input.parse::&lt;i32&gt;()?;
    Ok(parsed_number)
}

fn main() {
    let str_vec = vec![&quot;Siete&quot;, &quot;8&quot;, &quot;9.0&quot;, &quot;bien&quot;, &quot;6060&quot;];
    for item in str_vec {
        let parsed = parse_str(item);
        println!(&quot;{:?}&quot;, parsed);
    }
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">Err(ParseIntError { kind: InvalidDigit })
Ok(8)
Err(ParseIntError { kind: InvalidDigit })
Err(ParseIntError { kind: InvalidDigit })
Ok(6060)
</code></pre>
<p>¬øC√≥mo se puede conocer que el error de esta funci√≥n <code>parse</code> era <code>std::num::ParseIntError</code>? Una forma f√°cil es &quot;ped√≠rselo&quot; al compilador:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let failure = &quot;No es un n√∫mero&quot;.parse::&lt;i32&gt;();
    failure.rbrbrb(); // ‚ö†Ô∏è Compilador: &quot;¬øQu√© es rbrbrb()???&quot;
}
</code></pre></pre>
<p>El compilador se &quot;queja&quot; con:</p>
<pre><code class="language-text">error[E0599]: no method named `rbrbrb` found for enum `std::result::Result&lt;i32, std::num::ParseIntError&gt;` in the current scope
 --&gt; src\main.rs:3:13
  |
3 |     failure.rbrbrb();
  |             ^^^^^^ method not found in `std::result::Result&lt;i32, std::num::ParseIntError&gt;`
</code></pre>
<p>As√≠ se deduce que la definici√≥n de tipo que devuelve <code>parse</code> es <code>std::result::Result&lt;i32, std::num::ParseIntError&gt;</code>.</p>
<p>No se necesita escribir <code>std::result::Result</code> porque <code>Result</code> est√° siempre visible en el alcance (alcance = listo para su uso). Rust hace esto para todos los tipos que se utilizan mucho para que no sea necesario escribir o usar <code>std::result::Result</code>, <code>std::collections::Vec</code>, etc.</p>
<p>A√∫n no se han presentado recursos como los ficheros, por lo que el operador <code>?</code> no parece a√∫n muy √∫til. El siguiente ejemplo muestra c√≥mo se puede ilustrar este uso en una sola l√≠nea. En lugar de construir un <code>i32</code> con <code>.parse()</code>, se hace mucho m√°s. Se construye un <code>u16</code>, luego se convierte a <code>String</code>, despu√©s se convierte a <code>u32</code> y de nuevo se pasa a <code>String</code> para, finalmente, convertirlo en un <code>i32</code>.</p>
<pre><pre class="playground"><code class="language-rust">use std::num::ParseIntError;

fn parse_str(input: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let parsed_number = input.parse::&lt;u16&gt;()?.to_string().parse::&lt;u32&gt;()?.to_string().parse::&lt;i32&gt;()?; // Se a√±ade ? a cada funci√≥n para validar la correcci√≥n y pasar el valor
    Ok(parsed_number)
}

fn main() {
    let str_vec = vec![&quot;Siete&quot;, &quot;8&quot;, &quot;9.0&quot;, &quot;bien&quot;, &quot;6060&quot;];
    for item in str_vec {
        let parsed = parse_str(item);
        println!(&quot;{:?}&quot;, parsed);
    }
}
</code></pre></pre>
<p>Esto imprime lo mismo, pero despu√©s de haber procesado tres <code>Result</code> en una sola l√≠nea. Despu√©s, se mostrar√° un ejemplo parecido con ficheros, puesto que las funciones asociadas siempre devuelven <code>Result</code> ya que pueden ir mal muchas cosas cuando se accede a ellos.</p>
<p>Se puede imaginar lo siguiente: se quiere abrir un fichero, escribir y cerrarlo. Lo primero es encontrar el fichero con √©xito (eso es un <code>Result</code>); despu√©s, escribir en √©l sin fallos (esto es otro <code>Result</code>). Con <code>?</code> se puede hacer todo en una sola l√≠nea.</p>
<h2 id="cuando-panic-y-unwrap-son-buenos"><a class="header" href="#cuando-panic-y-unwrap-son-buenos">Cuando <code>panic</code> y <code>unwrap</code> son buenos</a></h2>
<p>Rust dispone de una macro <code>panic!</code> que se puede utilizar para que &quot;entre en p√°nico&quot;.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    panic!(&quot;¬°hora de entrar en p√°nico!&quot;);
}
</code></pre></pre>
<p>Cuando se ejecuta este programa se muestra el siguiente mensaje: <code>thread 'main' panicked at '¬°hora de entrar en p√°nico!', src/main.rs:2:5</code>.</p>
<p>Se muestra el programa, la l√≠nea de c√≥digo y columna <code>2:5</code> en el que se &quot;entr√≥ en p√°nico&quot;. Con esta informaci√≥n, se puede buscar la l√≠nea de c√≥digo y arreglarla.</p>
<p><code>panic!</code> tiene utilidad para asegurar que algo no cambia. Por ejemplo, la siguiente funci√≥n <code>imprime_tres_cosas</code> siempre imprime los √≠ndices [0], [1] y [2] de un vector. Esto est√° bien siempre que reciba un vector con tres elementos.</p>
<pre><pre class="playground"><code class="language-rust">fn imprime_tres_cosas(vector: Vec&lt;i32&gt;) {
    println!(&quot;{}, {}, {}&quot;, vector[0], vector[1], vector[2]);
}

fn main() {
    let my_vec = vec![8, 9, 10];
    imprime_tres_cosas(my_vec);
}
</code></pre></pre>
<p>Esto imprime <code>8</code>, <code>9</code> y <code>10</code> correctamente.</p>
<p>Si posteriormente se escribe m√°s c√≥digo y se olvida que <code>my_vec</code> tiene que ser siempre de tres elementos, se puede acabar un vector de seis elementos como en el caso siguiente:</p>
<pre><pre class="playground"><code class="language-rust">fn imprime_tres_cosas(vector: Vec&lt;i32&gt;) {
  println!(&quot;{}, {}, {}&quot;, vector[0], vector[1], vector[2]);
}

fn main() {
  let my_vec = vec![8, 9, 10, 10, 55, 99]; // Ahora tiene seis elementos
  imprime_tres_cosas(my_vec);
}
</code></pre></pre>
<p>Con este ejemplo, parece que todo est√° bien, no hay error. Pero si es importante que el vector solo tenga tres cosas, no se detectar√≠a el fallo. Se podr√≠a hacer lo siguiente:</p>
<pre><pre class="playground"><code class="language-rust">fn imprime_tres_cosas(vector: Vec&lt;i32&gt;) {
    if vector.len() != 3 {
        panic!(&quot;my_vec siempre tiene que tener tres elementos&quot;) // entrar√° en p√°nico si tiene longitud 3
    }
    println!(&quot;{}, {}, {}&quot;, vector[0], vector[1], vector[2]);
}

fn main() {
    let my_vec = vec![8, 9, 10];
    imprime_tres_cosas(my_vec);
}
</code></pre></pre>
<p>Ahora, si el vector tuviera seis elementos, el programa fallar√≠a (N.T. a las condiciones que se deben cumplir siempre en una funci√≥n -en sus par√°metros o valores de retorno o durante su ejecuci√≥n- se le denomina &quot;invariante&quot;. Rust proporciona macros espec√≠ficas para ello <code>assert!</code> y <code>assert_debug!</code>):</p>
<pre><pre class="playground"><code class="language-rust">    // ‚ö†Ô∏è
fn imprime_tres_cosas(vector: Vec&lt;i32&gt;) {
    if vector.len() != 3 {
        panic!(&quot;my_vec siempre tiene que tener tres&quot;)
    }
    println!(&quot;{}, {}, {}&quot;, vector[0], vector[1], vector[2]);
}

fn main() {
    let my_vec = vec![8, 9, 10, 10, 55, 99];
    imprime_tres_cosas(my_vec);
}
</code></pre></pre>
<p>Este programa devuelve <code>thread 'main' panicked at 'my_vec siempre tiene que tener tres', src/main.rs:4:9</code>. Gracias a <code>panic!</code>, se alerta de que solo deber√≠a tener tres elementos el vector <code>my_vec</code>. Es una macro √∫til para meter recordatorios en el c√≥digo.</p>
<p>Existen otras tres macros que son similares y que se utilizan mucho durante las pruebas. Son: <code>assert!</code>, <code>assert_eq!</code> y <code>assert_ne!</code>. Esto es lo que hacen:</p>
<ul>
<li><code>assert!()</code>: el programa entra en p√°nico cuando la evaluaci√≥n del contenido entre <code>()</code> no es cierta.</li>
<li><code>assert_eq!()</code>: el programa entra en p√°nico cuando los dos elementos contenidos entre <code>()</code> no son iguales.</li>
<li><code>assert_ne!()</code>: el programa entra en p√°nico cuando los dos elementos contenidos entre <code>()</code> son iguales.</li>
</ul>
<p>Algunos ejemplos son:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_name = &quot;Loki Laufeyson&quot;;

    assert!(my_name == &quot;Loki Laufeyson&quot;);
    assert_eq!(my_name, &quot;Loki Laufeyson&quot;);
    assert_ne!(my_name, &quot;Mithridates&quot;);
}
</code></pre></pre>
<p>El c√≥digo anterior funciona sin problemas ya que en este caso todas las macros comprueban con √©xito los valores que reciben como par√°metro.</p>
<p>Tambi√©n es posible a√±adir un mensaje a cada macro:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_name = &quot;Loki Laufeyson&quot;;

    assert!(
        my_name == &quot;Loki Laufeyson&quot;,
        &quot;{} should be Loki Laufeyson&quot;,
        my_name
    );
    assert_eq!(
        my_name, &quot;Loki Laufeyson&quot;,
        &quot;{} and Loki Laufeyson should be equal&quot;,
        my_name
    );
    assert_ne!(
        my_name, &quot;Mithridates&quot;,
        &quot;You entered {}. Input must not equal Mithridates&quot;,
        my_name
    );
}
</code></pre></pre>
<p>Estos mensajes se mostrar√°n solamente si el programa entra en p√°nico (no se cumple la condici√≥n que establece la macro). Por eso, si se ejecuta lo siguiente:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_name = &quot;Mithridates&quot;;

    assert_ne!(
        my_name, &quot;Mithridates&quot;,
        &quot;You enter {}. Input must not equal Mithridates&quot;,
        my_name
    );
}
</code></pre></pre>
<p>Se mostrar√°:</p>
<pre><code class="language-text">thread 'main' panicked at 'assertion failed: `(left != right)`
  left: `&quot;Mithridates&quot;`,
 right: `&quot;Mithridates&quot;`: You entered Mithridates. Input must not equal Mithridates', src\main.rs:4:5
</code></pre>
<p>Esta respuesta est√° diciendo que se esperaba que los valores fuesen distintos <code>left != right</code>, pero se han recibido valores iguales.</p>
<p>Tambi√©n es √∫til el uso de <code>unwrap</code> cuando se escribe un programa y se quiere que falle (entre en p√°nico) cuando haya un problema. Posteriormente, cuando el c√≥digo est√© completo, conviene eliminar <code>unwrap</code> por una alternativa m√°s robusta que impida que el programa se pare.</p>
<p>Tambi√©n se puede usar <code>expect</code>, que es como <code>unwrap</code>, pero permite que se le pase un mensaje que se mostrar√° en el momento del error. Los libros de texto suelen tener el siguiente aviso: &quot;si se utiliza <code>unwrap()</code> mucho, al menos se deber√≠a usar <code>expect()</code> para tener mensajes de error adecuados.</p>
<p>Esto fallar√°:</p>
<pre><pre class="playground"><code class="language-rust">   // ‚ö†Ô∏è
fn get_cuatro(input: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    let cuatro = input.get(3).unwrap();
    *cuatro
}

fn main() {
    let my_vec = vec![9, 0, 10];
    let cuatro = get_cuatro(&amp;my_vec);
}
</code></pre></pre>
<p>El mensaje de error es: <code>thread 'main' panicked at 'called Option::unwrap() on a None value', src\main.rs:7:18</code>.</p>
<pre><pre class="playground"><code class="language-rust">   // ‚ö†Ô∏è
fn get_cuatro(input: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    let cuatro = input.get(3).expect(&quot;Input vector needs at least 4 items&quot;);
    *cuatro
}

fn main() {
    let my_vec = vec![9, 0, 10];
    let cuatro = get_cuatro(&amp;my_vec);
}
</code></pre></pre>
<p>Vuelve a fallar, pero el mensaje de error es mejor: <code>thread 'main' panicked at 'Input vector needs at least 4 items', src\main.rs:7:18</code>. <code>.expect()</code> es un poco mejor que <code>.unwrap()</code>, pero sigue fallando con <code>None</code>. A continuaci√≥n se muestra un ejemplo de una <strong>mala pr√°ctica</strong> una funci√≥n que intenta <code>unwrap</code> dos veces. Toma como par√°metros un <code>Vec&lt;Option&lt;i32&gt;&gt;</code>, por lo que puede que cada parte contenta un <code>Some&lt;i32&gt;</code> o un <code>None</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn intenta_dos_unwraps(input: Vec&lt;Option&lt;i32&gt;&gt;) {
    println!(&quot;√çndice 0 es: {}&quot;, input[0].unwrap());
    println!(&quot;√çndice 1 es: {}&quot;, input[1].unwrap());
}

fn main() {
    let vector = vec![None, Some(1000)]; // Este vector tiene un None, por lo que entrar√° en p√°nico
    intenta_dos_unwraps(vector);
}
</code></pre></pre>
<p>El mensaje es &quot;<code>thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', src/main.rs:2:42</code>. No se puede saber en qu√© <code>unwrap</code> sucedi√≥ hasta revisar la l√≠nea. Ser√≠a mejor valorar la longitud y no <code>unwrap</code>. Pero con <code>.expect()</code> al menos ser√° <em>un poco</em> mejor:</p>
<pre><pre class="playground"><code class="language-rust">fn intenta_dos_unwrap(input: Vec&lt;Option&lt;i32&gt;&gt;) {
    println!(&quot;Index 0 is: {}&quot;, input[0].expect(&quot;¬°El primer unwrap conten√≠a un None!&quot;));
    println!(&quot;Index 1 is: {}&quot;, input[1].expect(&quot;¬°El segundo unwrap conten√≠a un None!&quot;));
}

fn main() {
    let vector = vec![None, Some(1000)];
    intenta_dos_unwrap(vector);
}
</code></pre></pre>
<p>Ahora el resultado es algo mejor: <code>thread 'main' panicked at '¬°El primer unwrap conten√≠a un None!', src/main.rs:2:41</code>. Y se dispone tambi√©n de la l√≠nea en la que ha sucedido para encontrarlo.</p>
<p>Tambi√©n se puede utilizar <code>unwrap_or</code> si siempre existe un valor a usar por defecto cuando se devuelve <code>None</code>. Esta funci√≥n no entra en p√°nico. Esto es:</p>
<ol>
<li>Bueno, porque el programa no entra en p√°nico, pero...</li>
<li>no tan bueno si se quiere detectar un problema en el c√≥digo.</li>
</ol>
<p>En todo caso, lo habitual es que no se quiera que el programa entre en p√°nico, por lo que <code>unwrap_or</code> es muy √∫til.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![8, 9, 10];

    let cuatro = my_vec.get(3).unwrap_or(&amp;0); // Si .get no funciona, 
    // se toma por defecto el &amp;0.
    // .get devuelve una referencia, por eso se necesita &amp;0

    println!(&quot;{}&quot;, cuatro);
}
</code></pre></pre>
<p>Esto imprime <code>0</code> porque <code>.unwrap_or(&amp;0)</code> devuelve 0 cuando el <code>Option</code> es un <code>None</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits-rasgos"><a class="header" href="#traits-rasgos">Traits (Rasgos)</a></h1>
<p>Anteriormente, se han visto algunos <em>traits</em><sup class="footnote-reference"><a href="#1">1</a></sup> (rasgos). <code>Debug</code>, <code>Copy</code> y <code>Clone</code> son traits  (rasgos). Para que un tipo tenga un trait (rasgo) hay que implementarlo. Puesto que algunos traits son tan comunes (como <code>Debug</code>), existen atributos en Rust que los implementan autom√°ticamente (con una implementaci√≥n por defecto). Esto es lo que sucede cuando se escribe <code>#[derive(Debug)]</code>: se implementa de forma autom√°tica el trait <code>Debug</code>.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct MiStruct {
    numero: usize,
}

fn main() {}
</code></pre></pre>
<p>Pero hay otros traits que son m√°s dif√≠ciles de implementar y hay que hacerlo a mano con <code>impl</code>. Por ejemplo, el trait <code>Add</code>, que se encuentra en <code>std::ops::Add</code> y se utiliza para sumar dos cosas. Pero Rust no puede adivinar c√≥mo se pueden sumar dos cosas cualquiera, por lo que hay qu√© codificarlo.</p>
<pre><pre class="playground"><code class="language-rust">struct CosasASumar {
    primera_cosa: u32,
    segunda_cosa: f32,
}

fn main() {}
</code></pre></pre>
<p>Se pueden sumar <code>primera_cosa</code> y <code>segunda_cosa</code>, pero hay que dar m√°s informaci√≥n. Puede que se quiera sumar <code>f32</code>, algo as√≠:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
let resultado = self.segunda_cosa + self.primera_cosa as f32
<span class="boring">}
</span></code></pre></pre>
<p>O puede que se quiera poner <code>self.primera_cosa</code> junto a <code>self.segunda_cosa</code> y que sea as√≠ como se quiera sumar. As√≠ la suma de 55 a 33.4 ser√≠a 5533.4 y no 88.4.</p>
<p>A continuaci√≥n, se analiza en primer lugar como se crea un trait. Lo importante es recordar que los trait sirven para describir un comportamiento determinado de quien los implementen. Para crear un trait, se escribe <code>trait</code> y se crean algunas funciones (o ninguna).</p>
<pre><pre class="playground"><code class="language-rust">struct Animal { // Un simple struct - un Animal que solo contiene su nombre
    nombre: String,
}

trait Perro { // El trait Perro asigna alguna funcionalidad
    fn ladrar(&amp;self) { // Puede ladrar
        println!(&quot;¬°Guau, guau!&quot;);
    }
    fn correr(&amp;self) { // y puede correr
        println!(&quot;¬°El perro est√° corriendo!&quot;);
    }
}

impl Perro for Animal {} // Ahora el Animal implementa el trait Perro

fn main() {
    let rover = Animal {
        nombre: &quot;Rover&quot;.to_string(),
    };

    rover.ladrar(); // El Animal puede usar ladrar()
    rover.correr();  // y puede usar correr()
}
</code></pre></pre>
<p>As√≠ est√° bien, pero no se quiere imprimir &quot;¬°El perro est√° corriendo!&quot;. Se pueden modificar los m√©todos que implementa por defecto un trait, para ello la nueva implementaci√≥n tiene que tener la misma declaraci√≥n. Esto significa que tiene que tomar los mismos par√°metros y devolver el mismo tipo de resultado. Por ejemplo, se puede modificar el m√©todo <code>.correr()</code>. La declaraci√≥n indica:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
fn correr(&amp;self) {
    println!(&quot;¬°El perro est√° corriendo!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p><code>fn correr(&amp;self)</code> significa que la funci√≥n <code>correr()</code> tiene de par√°metro <code>&amp;self</code> y no devuelve ning√∫n valor. Por lo que no se puede definir una nueva implementaci√≥n as√≠:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn correr(&amp;self) -&gt; i32 { // ‚ö†Ô∏è
    5
}
<span class="boring">}
</span></code></pre></pre>
<p>Rust se quejar√° as√≠:</p>
<pre><code class="language-text">   = note: expected fn pointer `fn(&amp;Animal)`
              found fn pointer `fn(&amp;Animal) -&gt; i32`
</code></pre>
<p>Pero s√≠ se puede hacer esto:</p>
<pre><pre class="playground"><code class="language-rust">struct Animal { // Un simple struct - un Animal que solo contiene su nombre
    nombre: String,
}

trait Perro { // El trait Perro asigna alguna funcionalidad
    fn ladrar(&amp;self) { // Puede ladrar
        println!(&quot;¬°Guau, guau!&quot;);
    }
    fn correr(&amp;self) { // y puede correr
        println!(&quot;¬°El perro est√° corriendo!&quot;);
    }
}

impl Perro for Animal { // Ahora el Animal implementa el trait Perro
    fn correr(&amp;self) {
        println!(&quot;¬°{} est√° corriendo!&quot;, self.nombre);
    }
}

fn main() {
    let rover = Animal {
        nombre: &quot;Rover&quot;.to_string(),
    };

    rover.ladrar(); // El Animal puede usar ladrar()
    rover.correr();  // y puede usar correr()
}
</code></pre></pre>
<p>Ahora imprime <code>¬°Rover est√° corriendo!</code>. Esta funci√≥n es correcta porque devuelve <code>()</code> o nada, que es lo que indica la implementaci√≥n del trait.</p>
<p>Cuando se define un trait, se puede escribir solo la declaraci√≥n de las funciones. Esto obliga a que quien lo quiera implementar tenga que escribir el c√≥digo que desea para las funciones que solo est√°n declaradas en el trait (sin implementar). En el c√≥digo siguiente el trait solo declara las funciones sin aportar una definici√≥n por defecto de <code>ladrar()</code> y <code>correr()</code>, por eso se obliga a escribir el c√≥digo en la implementaci√≥n del trait por parte del Perro.</p>
<pre><pre class="playground"><code class="language-rust">struct Animal {
    nombre: String,
}

trait Perro {
    fn ladrar(&amp;self); // Solo se indica que necesita el par√°metro &amp;self y que no devuelva nada

    fn correr(&amp;self); // necesita &amp;self y que no devuelva nada
    // Ahora se tiene que escribir el c√≥digo en la implementaci√≥n del Perro
}

impl Perro for Animal {

    fn ladrar(&amp;self) {
        println!(&quot;¬°{}, para de ladrar!&quot;, self.nombre);
    }
    
    fn correr(&amp;self) {
        println!(&quot;¬°{} est√° corriendo!&quot;, self.nombre);
    }

}

fn main() {
    let rover = Animal {
        nombre: &quot;Rover&quot;.to_string(),
    };

    rover.ladrar();
    rover.correr();
}
</code></pre></pre>
<p>Cuando se crea un trait (rasgo), se debe pensar: ¬øQu√© funciones deber√° tener? ¬øqu√© funciones se pueden implementar en el propio trait? y ¬øqu√© funciones deber√° implementar el propio usuario?</p>
<p>A continuaci√≥n se implementa el trait <code>Display</code> para el siguiente struct simple:</p>
<pre><pre class="playground"><code class="language-rust">struct Gato {
    nombre: String,
    edad: u8,
}

fn main() {
    let mr_mantle = Gato {
        nombre: &quot;Reggie Mantle&quot;.to_string(),
        edad: 4,
    };
}
</code></pre></pre>
<p>Se quiere imprimir <code>mr_mantle</code>. <code>Debug</code> es f√°cil de derivar:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Gato {
    nombre: String,
    edad: u8,
}

fn main() {
    let mr_mantle = Gato {
        nombre: &quot;Reggie Mantle&quot;.to_string(),
        edad: 4,
    };

    println!(&quot;Mr. Mantle es un {:?}&quot;, mr_mantle);
}
</code></pre></pre>
<p>Pero la implementaci√≥n de Debug no es muy bonita. Este es el resultado:</p>
<pre><code class="language-text">Mr. Mantle es un Gato { nombre: &quot;Reggie Mantle&quot;, edad: 4 }
</code></pre>
<p>Por eso, se tiene que implementar <code>Display</code> para un <code>Gato</code> si se quiere que la impresi√≥n sea bonita. En <a href="https://doc.rust-lang.org/std/fmt/trait.Display.html">https://doc.rust-lang.org/std/fmt/trait.Display.html</a> se puede ver la informaci√≥n detallada para Display con un ejemplo que dice:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Position {
    longitude: f32,
    latitude: f32,
}

impl fmt::Display for Position {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.longitude, self.latitude)
    }
}

fn main() {}
</code></pre></pre>
<p>Hay algunas cosas que a√∫n no se entienden en este c√≥digo, como <code>&lt;'_&gt;</code> y lo que hace <code>f</code>. Pero se entiende que el struct <code>Position</code> tiene √∫nicamente dos valores <code>f32</code>. Los campos de este struct son <code>self.longitude</code> y <code>self.latitude</code>. As√≠ que posiblemente se pueda utilizar este c√≥digo ara implementar la versi√≥n que se necesita para <code>Gato</code>, cambiando los campos por <code>self.nombre</code> y <code>self.edad</code>. Por √∫ltimo, <code>write!</code> se parece mucho a <code>println!</code>. As√≠, el c√≥digo queda:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Gato {
    nombre: String,
    edad: u8,
}

impl fmt::Display for Gato {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;{} es un gato de {} a√±os.&quot;, self.nombre, self.edad)
    }
}

fn main() {}
</code></pre></pre>
<p>Si ahora se a√±ade una funci√≥n <code>fn main()</code>, el c√≥digo queda as√≠:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Gato {
    nombre: String,
    edad: u8,
}

impl fmt::Display for Gato {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;{} es un gato de {} a√±os.&quot;, self.nombre, self.edad)
    }
}

fn main() {
    let mr_mantle = Gato {
        nombre: &quot;Reggie Mantle&quot;.to_string(),
        edad: 4,
    };

    println!(&quot;{}&quot;, mr_mantle);
}
</code></pre></pre>
<p>¬°Estupendo! Ahora, cuando se usa <code>{}</code> para imprimir a un Gato, se obtiene <code>Reggie Mantle es un gato de 4 a√±os.</code>, que queda mucho mejor.</p>
<p>Por cierto, cuando se implementa el trait <code>Display</code> se dispone del trait <code>ToString</code> sin nada que hacer adicionalmente. Esto pasa al usar la macro <code>format!</code> que facilita la creaci√≥n de un <code>String</code> con la funci√≥n <code>.to_string()</code>. As√≠ que se puede hacer algo como lo siguiente cuando se pasa la variable <code>reggie_mantle</code> a una funci√≥n que necesite un <code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;
struct Gato {
    nombre: String,
    edad: u8,
}

impl fmt::Display for Gato {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;{} es un gato de {} a√±os.&quot;, self.nombre, self.edad)
    }
}

fn print_gatos(mascota: String) {
    println!(&quot;{}&quot;, mascota);
}

fn main() {
    let mr_mantle = Gato {
        nombre: &quot;Reggie Mantle&quot;.to_string(),
        edad: 4,
    };

    print_gatos(mr_mantle.to_string()); // Lo convierte en un String
    println!(&quot;La cadena de caracteres de Mr. Mantle tiene {} letras.&quot;,
        mr_mantle.to_string().chars().count()); // Los convierte en caracteres y los cuenta
}
</code></pre></pre>
<p>Lo anterior imprime:</p>
<pre><code class="language-text">Reggie Mantle es un gato de 4 a√±os.
La cadena de caracteres de Mr. Mantle tiene 35 letras.
</code></pre>
<p>Lo que se debe recordar sobre los rasgos es que tratan sobre el comportamiento de algo. ¬øC√≥mo se comporta un determinado <code>struct</code>? ¬øQu√© puede hacer? Para eso son los rasgos. Si se revisan los rasgos que se han visto hasta el momento, todos tratan sobre alg√∫n comportamiento: <code>Copy</code>es algo que un tipo determinado puede hacer. <code>Display</code> tambi√©n es algo que un tipo puede hacer. <code>ToString</code> es otro rasgo y tambi√©n es algo que un tipo puede hacer: convertirse en una <code>String</code>. En el rasgo <code>Perro</code> la palabra <em>perro</em> no significa algo que se pueda hacer, pero proporciona algunos m√©todos que le permiten hacer cosas. Se puede implementar para una estructura <code>Caniche</code> o para una <code>Chucho</code> y as√≠ ambas podr√≠an disponer de los m√©todos de <code>Perro</code>.</p>
<p>A continuaci√≥n se presenta otro ejemplo a√∫n m√°s conectado con algo que solo es comportamiento. Se imaginar√° un juego de fantas√≠a con algunos personajes simples. Uno es un <code>Monstruo</code>, los otros dos son <code>Mago</code> y <code>Cazador</code>. El <code>Monstruo</code> tiene <code>salud</code> y se le puede atacar, los otros dos no tendr√°n nada a√∫n. Se crear√°n dos rasgos (traits). Uno llamado <code>LuchaCercana</code> que permite luchar de cerca y otro <code>LuchaADistancia</code> que permite lugar desde lejos. Solo el <code>Cazador</code> puede usar <code>LuchaADistancia</code>. Este es el c√≥digo resultante:</p>
<pre><pre class="playground"><code class="language-rust">struct Monstruo {
    salud: i32,
}

struct Mago {}
struct Cazador {}

trait LuchaCercana {
    fn atacar_con_espada(&amp;self, oponente: &amp;mut Monstruo) {
        oponente.salud -= 10;
        println!(
            &quot;Atacaste con espada. Tu oponente tiene ahora {} de salud.&quot;,
            oponente.salud
        );
    }
    fn atacar_con_la_mano(&amp;self, oponente: &amp;mut Monstruo) {
        oponente.salud -= 2;
        println!(
            &quot;Atacaste con la mano. tu oponente tiene ahora {} de salud.&quot;,
            oponente.salud
        );
    }
}
impl LuchaCercana for Mago {}
impl LuchaCercana for Cazador {}

trait LuchaADistancia {
    fn atacar_con_arco(&amp;self, oponente: &amp;mut Monstruo, distancia: u32) {
        if distancia &lt; 10 {
            oponente.salud -= 10;
            println!(
                &quot;Atacaste con el arco. Tu oponente tiene ahora {} de salud.&quot;,
                oponente.salud
            );
        }
    }
    fn atacar_con_piedra(&amp;self, oponente: &amp;mut Monstruo, distancia: u32) {
        if distancia &lt; 3 {
            oponente.salud -= 4;
        }
        println!(
            &quot;Atacaste con una piedra. Your oponente tiene ahora {} de salud.&quot;,
            oponente.salud
        );
    }
}
impl LuchaADistancia for Cazador {}

fn main() {
    let radagast = Mago {};
    let aragorn = Cazador {};

    let mut uruk_hai = Monstruo { salud: 40 };

    radagast.atacar_con_espada(&amp;mut uruk_hai);
    aragorn.atacar_con_arco(&amp;mut uruk_hai, 8);
}
</code></pre></pre>
<p>Lo anterior imprime:</p>
<pre><code class="language-text">Atacaste con espada. Tu oponente tiene ahora 30 de salud.
Atacaste con el arco. Tu oponente tiene ahora 20 de salud.
</code></pre>
<p>En este ejemplo, se pasa constantemente <code>self</code> a los m√©todos de los rasgos, pero solo se conoce que se trata de un tipo que implementa el propio rasgo. Puede ser un <code>Mago</code> o un <code>Cazador</code>. O podr√≠a ser una nueva <code>struct</code> llamada <code>Toefocfgetobjtnode</code> o cualquier otra que implementara el rasgo correspondiente. Para facilitar que <code>self</code> tenga m√°s funcionalidad, se puede a√±adir restricciones a un <code>trait</code>. Se puede a√±adir otros <code>trait</code> que son necesarios para el <code>trait</code> que se define. Por ejemplo, si que se quiere que en los m√©todos de un <code>trait</code> se pueda usar <code>{:?}</code> para imprimir, se necesita que implemente el trait <code>Debug</code>. Eso se puede indicar mediante la escritura de <code>:</code> (dos puntos). As√≠ quedar√≠a el c√≥digo:</p>
<pre><pre class="playground"><code class="language-rust">struct Monstruo {
    salud: i32,
}

#[derive(Debug)] // Ahora el mago tiene Debug
struct Mago {
    salud: i32, // Ahora el mago tiene salud
}

#[derive(Debug)] // Ahora el Cazador tiene Debug
struct Cazador {
    salud: i32, // Ahora el cazador tiene salud
}

trait LuchaCercana: std::fmt::Debug {
    // Ahora el tipo necesita tener Debug 
    // para poder implementar LuchaCercana
    fn atacar_con_espada(&amp;self, oponente: &amp;mut Monstruo) {
        oponente.salud -= 10;
        println!(
            &quot;Atacaste con espada. Tu oponente tiene ahora {} de salud. Ahora tienes {:?}&quot;,
            // se puede usar {:?} porque se dispone de Debug
            oponente.salud, &amp;self
        );
    }
    fn atacar_con_la_mano(&amp;self, oponente: &amp;mut Monstruo) {
        oponente.salud -= 2;
        println!(
            &quot;Atacaste con la mano. tu oponente tiene ahora {} de salud. Ahora tienes {:?}&quot;,
            oponente.salud, &amp;self
        );
    }
}
impl LuchaCercana for Mago {}
impl LuchaCercana for Cazador {}

trait LuchaADistancia: std::fmt::Debug {
    // tambi√©n se podr√≠a haber escrito LuchaADistancia: LuchaCercana
    // porque LuchaCercana implementa ya Debug
    fn atacar_con_arco(&amp;self, oponente: &amp;mut Monstruo, distancia: u32) {
        if distancia &lt; 10 {
            oponente.salud -= 10;
            println!(
                &quot;Atacaste con el arco. Tu oponente tiene ahora {} de salud. Ahora tienes {:?}&quot;,
                oponente.salud, &amp;self
            );
        }
    }
    fn atacar_con_piedra(&amp;self, oponente: &amp;mut Monstruo, distancia: u32) {
        if distancia &lt; 3 {
            oponente.salud -= 4;
        }
        println!(
            &quot;Atacaste con una piedra. Your oponente tiene ahora {} de salud. Ahora tienes {:?}&quot;,
            oponente.salud, &amp;self
        );
    }
}
impl LuchaADistancia for Cazador {}

fn main() {
    let radagast = Mago { salud: 60 };
    let aragorn = Cazador { salud: 80 };

    let mut uruk_hai = Monstruo { salud: 40 };

    radagast.atacar_con_espada(&amp;mut uruk_hai);
    aragorn.atacar_con_arco(&amp;mut uruk_hai, 8);
}
</code></pre></pre>
<p>Ahora, se imprime:</p>
<pre><code class="language-text">Atacaste con espada. Tu oponente tiene ahora 30 de salud. Ahora tienes Mago { salud: 60 }
Atacaste con el arco. Tu oponente tiene ahora 20 de salud. Ahora tienes Cazador { salud: 80 }
</code></pre>
<p>En un juego real ser√≠a mejor reescribir esto para cada tipo, ya que <code>Ahora tienes Mago { salud: 60 }</code> queda muy raro. Por eso, los m√©todos predefinidos de los rasgos suelen ser muy simples, porque no se conoce el tipo que lo va a usar. No se puede escribir algo como <code>self.0 += 10</code>, por ejemplo. En cualquier caso, el ejemplo anterior muestra c√≥mo se puede usar otro trait dentro de uno que se est√© escribiendo y disponer as√≠ de los m√©todos de ese otro.</p>
<p>Otra forma de usar un rasgo es mediante lo que se llama <code>trait bounds</code> (N.T.: l√≠mites de un rasgo). Son f√°ciles de implementar ya que no necesitan nada. A continuaci√≥n, se reescribe el ejemplo anterior sin que los rasgos implementen ning√∫n m√©todo, a cambio, se dispone de funciones que necesitan rasgos para que se puedan usar.</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Debug;  // para no tener que escribir todo el camino al rasgo

struct Monstruo {
    salud: i32,
}

#[derive(Debug)]
struct Mago {
    salud: i32,
}
#[derive(Debug)]
struct Cazador {
    salud: i32,
}

trait Magia{} // todos los traits sin m√©todos. Son l√≠mites de rasgo


trait LuchaCercana {}
trait LuchaADistancia {}

impl LuchaCercana for Cazador{} // Cada tipo tiene LuchaCercana,
impl LuchaCercana for Mago {}
impl LuchaADistancia for Cazador{} // Pero solo el cazador lucha a distancia
impl Magia for Mago{}  // y solo el mago hace magia

fn atacar_con_flecha&lt;T: LuchaADistancia + Debug&gt;(personaje: &amp;T, oponente: &amp;mut Monstruo, distancia: u32) {
    if distancia &lt; 10 {
        oponente.salud -= 10;
        println!(
            &quot;Atacaste con el arco. Tu oponente tiene ahora {} de salud. Ahora tienes {:?}&quot;,
            oponente.salud, personaje
        );
    }
}

fn atacar_con_espada&lt;T: LuchaCercana + Debug&gt;(personaje: &amp;T, oponente: &amp;mut Monstruo) {
    oponente.salud -= 10;
    println!(
        &quot;Atacaste con la espada. Tu oponente tiene ahora {} de salud. Ahora tienes {:?}&quot;,
        oponente.salud, personaje
    );
}

fn atacar_con_bola_de_fuego&lt;T: Magia + Debug&gt;(personaje: &amp;T, oponente: &amp;mut Monstruo, distancia: u32) {
    if distancia &lt; 15 {
        oponente.salud -= 20;
        println!(&quot;¬°Levantas las manos y conjuras una bola de fuego! Tu oponente tiene ahora {} de salud. Ahora tienes: {:?}&quot;,
    oponente.salud, personaje);
    }
}

fn main() {
    let radagast = Mago { salud: 60 };
    let aragorn = Cazador { salud: 80 };

    let mut uruk_hai = Monstruo { salud: 40 };

    atacar_con_espada(&amp;radagast, &amp;mut uruk_hai);
    atacar_con_flecha(&amp;aragorn, &amp;mut uruk_hai, 8);
    atacar_con_bola_de_fuego(&amp;radagast, &amp;mut uruk_hai, 8);
}
</code></pre></pre>
<pre><code class="language-text">Atacaste con la espada. Tu oponente tiene ahora 30 de salud. Ahora tienes Mago { salud: 60 }
Atacaste con el arco. Tu oponente tiene ahora 20 de salud. Ahora tienes Cazador { salud: 80 }
¬°Levantas las manos y conjuras una bola de fuego! Tu oponente tiene ahora 0 de salud. Ahora tienes: Mago { salud: 60 }
</code></pre>
<p>Se puede ver que hay varias formas de obtener el mismo resultado cuando se usan rasgos. Todo depende de lo que tenga m√°s sentido en el programa que se est√° escribiendo.</p>
<p>A continuaci√≥n, se echa un vistazo a c√≥mo implementar algunos de los rasgos m√°s usados en Rust.</p>
<h2 id="el-rasgo-from"><a class="header" href="#el-rasgo-from">El rasgo From</a></h2>
<p><em>From</em> es un rasgo muy √∫til que ya se ha usado. Con <em>From</em> se puede crear una <code>String</code> a partir de una <code>&amp;str</code>, pero se puede usar para convertir cualquier tipo en otro. Por ejemplo, <code>Vec</code> utiliza <em>From</em> para lo siguiente:</p>
<pre><code class="language-text">From&lt;&amp;'_ [T]&gt;
From&lt;&amp;'_ mut [T]&gt;
From&lt;&amp;'_ str&gt;
From&lt;&amp;'a Vec&lt;T&gt;&gt;
From&lt;[T; N]&gt;
From&lt;BinaryHeap&lt;T&gt;&gt;
From&lt;Box&lt;[T]&gt;&gt;
From&lt;CString&gt;
From&lt;Cow&lt;'a, [T]&gt;&gt;
From&lt;String&gt;
From&lt;Vec&lt;NonZeroU8&gt;&gt;
From&lt;Vec&lt;T&gt;&gt;
From&lt;VecDeque&lt;T&gt;&gt;
</code></pre>
<p>Implementa un mont√≥n de <code>Vec::from()</code> que no se han usado a√∫n en este manual. Se pueden usar algunos para ver qu√© pasa.</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display; // se usar√° Display para crear una funci√≥n gen√©rica y mostrar el resultado

fn print_vec&lt;T: Display&gt;(input: &amp;Vec&lt;T&gt;) { // Toma cualquier Vec&lt;T&gt; cuyo tipo T que tenga Display
    for item in input {
        print!(&quot;{} &quot;, item);
    }
    println!();
}

fn main() {

    let array_vec = Vec::from([8, 9, 10]); // &quot;from&quot; un array
    print_vec(&amp;array_vec);

    let str_vec = Vec::from(&quot;¬øQu√© clase de vector ser√©?&quot;); // Array &quot;from&quot; un &amp;str
    print_vec(&amp;str_vec);

    let string_vec = Vec::from(&quot;Un String ¬øQu√© clase de vector ser√°?&quot;.to_string()); // Tambi√©n &quot;from&quot; un String
    print_vec(&amp;string_vec);
}
</code></pre></pre>
<p>Se imprime lo siguiente:</p>
<pre><code class="language-text">8 9 10
87 104 97 116 32 107 105 110 100 32 111 102 32 118 101 99 32 119 105 108 108 32 73 32 98 101 63
87 104 97 116 32 107 105 110 100 32 111 102 32 118 101 99 32 119 105 108 108 32 97 32 83 116 114 105 110 103 32 98 101 63
</code></pre>
<p>Si se observa el tipo, los segundo y tercer vector son de tipo <code>Vec&lt;u8&gt;</code>, lo que significa que contiene los bytes de <code>&amp;str</code> y <code>String</code>. Se ve as√≠ que <code>From</code> es muy flexible y se usa mucho.</p>
<p>El siguiente ejemplo implemente <code>From</code> en tipos desarrollados en el c√≥digo. Se construyen dos structs y luego implementan <code>From</code> para una de ellas. Una ser√° una <code>Ciudad</code> y la otra un <code>Pais</code>. Se quiere que sea posible hacer esto: <code>let country_nombre = Pais::from(vector_de_ciudades)</code>.</p>
<p>Queda as√≠ el c√≥digo:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)] // Para poder imprimir la Ciudad
struct Ciudad {
    nombre: String,
    poblacion: u32,
}

impl Ciudad {
    fn new(nombre: &amp;str, poblacion: u32) -&gt; Self { // funci√≥n new
        Self {
            nombre: nombre.to_string(),
            poblacion,
        }
    }
}
#[derive(Debug)] // Pais necesita imprimirse
struct Pais {
    ciudades: Vec&lt;Ciudad&gt;, // Las ciudades van aqu√≠
}

impl From&lt;Vec&lt;Ciudad&gt;&gt; for Pais { // Note: no se crea From&lt;Ciudad&gt;, se crea
    // From&lt;Vec&lt;Ciudad&gt;&gt;. Es decir, sobre un tipo, Vec, que no se ha creado en el c√≥digo
    fn from(ciudades: Vec&lt;Ciudad&gt;) -&gt; Self {
        Self { ciudades }
    }
}

impl Pais {
    fn imprimir_ciudades(&amp;self) { // funci√≥n para imprimir las ciudades del Pais
        for ciudad in &amp;self.ciudades {
            // &amp; porque Vec&lt;Ciudad&gt; no es Copy
            println!(&quot;{:?} tiene una poblaci√≥n de {:?}.&quot;, ciudad.nombre, ciudad.poblacion);
        }
    }
}

fn main() {
    let helsinki = Ciudad::new(&quot;Helsinki&quot;, 631_695);
    let turku = Ciudad::new(&quot;Turku&quot;, 186_756);

    let finland_ciudades = vec![helsinki, turku]; // Esto es  el Vec&lt;Ciudad&gt;
    let finland = Pais::from(finland_ciudades); // En este punto se usa From

    finland.imprimir_ciudades();
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">&quot;Helsinki&quot; tiene una poblaci√≥n de 631695.
&quot;Turku&quot; tiene una poblaci√≥n de 186756.
</code></pre>
<p>Se observa que es f√°cil implementar <code>From</code> para tipos que no se han creado por el desarrollador, por ejemplo, <code>Vec</code>, <code>i32</code> o cualquier otro.</p>
<p>A continuaci√≥n, se muestra otro ejemplo en el que se crea un vector que contiene dos vectores. El primer vector contiene n√∫meros pares y el segundo, impares. Con <code>From</code> se puede tomar un vector de <code>i32</code> y convertirlo en <code>Vec&lt;Vec&lt;i32&gt;&gt;</code>: un vector que contiene vectores de <code>i32</code>.</p>
<pre><pre class="playground"><code class="language-rust">use std::convert::From;

struct ParImparVec(Vec&lt;Vec&lt;i32&gt;&gt;);

impl From&lt;Vec&lt;i32&gt;&gt; for ParImparVec {
    fn from(input: Vec&lt;i32&gt;) -&gt; Self {
        let mut par_impar_vec: Vec&lt;Vec&lt;i32&gt;&gt; = vec![vec![], vec![]]; // Un vec con dos vecs vac√≠os dentro
        // se rellena para despu√©s retornarlo 
        for item in input {
            if item % 2 == 0 {
                par_impar_vec[0].push(item);
            } else {
                par_impar_vec[1].push(item);
            }
        }
        Self(par_impar_vec) // una vez relleno se devuelve como Self (Self = ParImparVec)
    }
}

fn main() {
    let varios_numero = vec![8, 7, -1, 3, 222, 9787, -47, 77, 0, 55, 7, 8];
    let new_vec = ParImparVec::from(varios_numero);

    println!(&quot;N√∫meros pares: {:?}\nN√∫meros impares: {:?}&quot;, new_vec.0[0], new_vec.0[1]);
}
</code></pre></pre>
<p>Lo anterior imprime:</p>
<pre><code class="language-text">N√∫meros pares: [8, 222, 0, 8]
N√∫meros impares: [7, -1, 3, 9787, -47, 77, 55, 7]
</code></pre>
<p>Un tipo como <code>ParImparVec</code> es mejor definirlo como gen√©rico <code>T</code> para poder usarlo en muchos tipos de n√∫meros. Se deja esta idea como pr√°ctica.</p>
<h2 id="paso-de-par√°metros-string-y-str-a-funciones"><a class="header" href="#paso-de-par√°metros-string-y-str-a-funciones">Paso de par√°metros String y &amp;str a funciones</a></h2>
<p>En ocasiones se necesita que una funci√≥n pueda recibir tanto <code>String</code> como <code>&amp;str</code> en el mismo par√°metro. Esto se puede conseguir con gen√©ricos y con el rasgo <code>AsRef</code>. <code>AsRef</code> se utiliza para pasar una referencia de un tipo a otro tipo. Si se observa la documentaci√≥n de <code>String</code>, se ve que implementa <code>AsRef</code> para muchos tipos:</p>
<p><a href="https://doc.rust-lang.org/std/string/struct.String.html">https://doc.rust-lang.org/std/string/struct.String.html</a></p>
<p>Estas son algunas de las declaraciones de funci√≥n:</p>
<p><code>AsRef&lt;str&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
impl AsRef&lt;str&gt; for String

fn as_ref(&amp;self) -&gt; &amp;str
<span class="boring">}
</span></code></pre></pre>
<p><code>AsRef&lt;[u8]&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
impl AsRef&lt;[u8]&gt; for String

fn as_ref(&amp;self) -&gt; &amp;[u8]
<span class="boring">}
</span></code></pre></pre>
<p><code>AsRef&lt;OsStr&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
impl AsRef&lt;OsStr&gt; for String

fn as_ref(&amp;self) -&gt; &amp;OsStr
<span class="boring">}
</span></code></pre></pre>
<p>Se observa que implementa la funci√≥n <code>as_ref</code> que recibe como par√°metro <code>&amp;self</code> y devuelve una referencia a otro tipo. Esto permite que si se dispone de un tipo gen√©rico T, se pueda indicar que ese tipo necesita <code>AsRef&lt;str&gt;</code>. As√≠, ser√° posible que se pase como un <code>&amp;str</code> o un <code>String</code>.</p>
<p>El c√≥digo siguiente implementa la funci√≥n gen√©rica, pero da error:</p>
<pre><pre class="playground"><code class="language-rust">fn imprimelo&lt;T&gt;(input: T) {
    println!(&quot;{}&quot;, input) // ‚ö†Ô∏è
}

fn main() {
    imprimelo(&quot;Por favor, impr√≠meme&quot;);
}
</code></pre></pre>
<p>Rust dice <code>error[E0277]: </code>T<code> doesn't implement std::fmt::Display</code>. Se necesita que lo implemente:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

fn imprimelo&lt;T: Display&gt;(input: T) {
    println!(&quot;{}&quot;, input)
}

fn main() {
    imprimelo(&quot;Por favor, impr√≠meme&quot;);
}
</code></pre></pre>
<p>Ahora funciona e imprime <code>Por favor, impr√≠meme</code>. Eso es mejor, pero T puede ser muchas cosas a√∫n. Puede ser <code>i8</code>, <code>f32</code> o cualquier cosa que tenga <code>Display</code>. Si se a√±ade ahora <code>AsRef&lt;str&gt;</code>, T necesita ambos rasgos.</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

fn imprimelo&lt;T: AsRef&lt;str&gt; + Display&gt;(input: T) {
    println!(&quot;{}&quot;, input)
}

fn main() {
    imprimelo(&quot;Por favor, impr√≠meme&quot;);
    imprimelo(&quot;Tambi√©n, por favor, impr√≠meme&quot;.to_string());
    // imprimelo(7); &lt;- Esto no compilar√°
}
</code></pre></pre>
<p>Ahora no dejar√° pasar tipos como <code>i8</code>.</p>
<p>No se puede olvidar que se puede utilizar <code>where</code> ara escribir de forma m√°s compacta la declaraci√≥n de la funci√≥n cuando esta se hace muy larga. Si se a√±adiera Debug la l√≠nea quedar√≠a muy larga, <code>fn imprimelo&lt;T: AsRef&lt;str&gt; + Display + Debug&gt;(input: T)</code>, as√≠ que se puede escribir de la siguiente forma.</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::{Debug, Display}; // a√±ade Debug

fn imprimelo&lt;T&gt;(input: T) // Ahora la l√≠nea es m√°s f√°cil de leer
where
    T: AsRef&lt;str&gt; + Debug + Display, // y tambi√©n se leen bien los rasgos del tipo
{
    println!(&quot;{}&quot;, input)
}

fn main() {
    imprimelo(&quot;Por favor, impr√≠meme&quot;);
    imprimelo(&quot;Tambi√©n, por favor, impr√≠meme&quot;.to_string());
}
</code></pre></pre>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>N.T.: Este concepto de Rust se puede traducir como <em>rasgo</em>. Est√° relacionado con la programaci√≥n orientada a aspectos. Los rasgos de Rust describen determinados aspectos de los tipos, funciones o variables que los implementen.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="encadenando-m√©todos"><a class="header" href="#encadenando-m√©todos">Encadenando M√©todos</a></h1>
<p>Rust es un lenguaje de programaci√≥n de sistemas como C y C++ y su c√≥digo se puede escribir mediante √≥rdenes (comandos) separados en l√≠neas separadas, pero tambi√©n es un lenguaje que permite un estilo de programaci√≥n funcional. Ambos estilos de programaci√≥n son correctos, pero el estilo funcional suele ser m√°s sint√©tico. Produce c√≥digo m√°s conciso y breve. A continuaci√≥n se muestra un ejemplo del estilo no funcional (denominado <em>estilo imperativo</em>) en el que se construye un <code>Vec</code> que contiene n√∫meros de 1 a 10:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut new_vec = Vec::new();
    let mut counter = 1;

    while counter &lt; 11 {
        new_vec.push(counter);
        counter += 1;
    }

    println!(&quot;{:?}&quot;, new_vec);
}
</code></pre></pre>
<p>Esto imprime <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>.</p>
<p>A continuaci√≥n, se muestra c√≥mo se codificar√≠a mediante un estilo funcional:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let new_vec = (1..=10).collect::&lt;Vec&lt;i32&gt;&gt;();
    // Tambi√©n se podr√≠a haber escrito as√≠
    // let new_vec: Vec&lt;i32&gt; = (1..=10).collect();
    println!(&quot;{:?}&quot;, new_vec);
}
</code></pre></pre>
<p><code>.collect()</code> crea colecciones de muchos tipos posibles, por eso hay que indicar el tipo.</p>
<p>Con el estilo funcional de programaci√≥n se pueden encadenar m√©todos. <em>Encadenar m√©todos</em> significa que se pueden unir para formar una √∫nica sentencia. A continuaci√≥n se muestra un ejemplo de muchos m√©todos unidos:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    let new_vec = my_vec.into_iter().skip(3).take(4).collect::&lt;Vec&lt;i32&gt;&gt;();

    println!(&quot;{:?}&quot;, new_vec);
}
</code></pre></pre>
<p>El ejemplo anterior crea un <code>Vec</code> que contiene <code>[3, 4, 5, 6]</code>. La sentencia contiene mucha informaci√≥n en una sola l√≠nea. Si se separan en diferentes l√≠neas para hacerlo m√°s f√°cil de leer (y se a√±aden comentarios explicativos):</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    let new_vec = my_vec
        .into_iter() // Itera a trav√©s de todos los elementos.
                     // Esta funci√≥n devuelve los elementos, no referencias a ellos.
        .skip(3) // se salta tres elementos, en este caso: 0, 1 y 2
        .take(4) // obtiene los cuatro primeros que quedan: 3, 4, 5 y 6
        .collect::&lt;Vec&lt;i32&gt;&gt;(); // los coloca en un nuevo Vec&lt;i32&gt;

    println!(&quot;{:?}&quot;, new_vec);
}
</code></pre></pre>
<p>Se puede utilizar este estilo funcional de forma amplia cuando se estudien los <em>closures</em> (cierres) y los <em>iteradores</em>. Por ello, estos conceptos se ven a continuaci√≥n.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iteradores"><a class="header" href="#iteradores">Iteradores</a></h1>
<p>Un iterador es una construcci√≥n del lenguaje Rust que recupera los elementos contenidos en una colecci√≥n uno a uno. En realidad, ya se han utilizado de forma frecuente los iteradores en los cap√≠tulos anteriores: el bucle <code>for</code> entrega un iterador. Para obtener un iterador para otros usos, es necesario indicar el tipo que se requiere:</p>
<ul>
<li><code>.iter()</code> para iterar a trav√©s de referencias a los elementos.</li>
<li><code>.iter_mut()</code> para iterar mediante referencias modificables (mutables).</li>
<li><code>.into_iter()</code> para obtener un iterador sobre valores, no referencias.</li>
</ul>
<p>Un bucle <code>for</code> es solo un iterador que es propietario de sus valores. Es por eso que se puede hacer modificable y se pueden cambiar los valores cuando se utiliza.</p>
<p>Los iteradores se pueden usar como sigue:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let vector1 = vec![1, 2, 3]; // Se usar√° .iter() y .into_iter() sobre este vector
    let vector1_a = vector1.iter().map(|x| x + 1).collect::&lt;Vec&lt;i32&gt;&gt;();
    let vector1_b = vector1.into_iter().map(|x| x * 10).collect::&lt;Vec&lt;i32&gt;&gt;();

    let mut vector2 = vec![10, 20, 30]; // Se usar√° .iter_mut() sobre este otro vector
    vector2.iter_mut().for_each(|x| *x +=100);

    println!(&quot;{:?}&quot;, vector1_a);
    println!(&quot;{:?}&quot;, vector2);
    println!(&quot;{:?}&quot;, vector1_b);
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">[2, 3, 4]
[110, 120, 130]
[10, 20, 30]
</code></pre>
<p>En los primeros dos casos se ha utilizado el m√©todo <code>map()</code> que permite ejecutar alg√∫n c√≥digo sobre cada elemento antes de pasarlo a la siguiente funci√≥n. En el √∫ltimo caso se hay utilizado el m√©todo <code>for_each()</code>. Este m√©todo ejecuta el c√≥digo que contiene sobre cada elemento que recibe. El uso de <code>.iter_mut()</code> junto con <code>for_each()</code> equivalen a un bucle <code>for</code>. Dentro de cada m√©todo se puede dar un nombre a cada elemento (en el ejemplo, se ha utilizado <code>x</code>) y se ha modificado. A este tipo de funciones se las denomina <em>closures</em> y se ven en la siguiente secci√≥n.</p>
<p>Si se revisa el c√≥digo anterior paso a paso:</p>
<ol>
<li>
<p>En primer lugar se usa <code>.iter()</code> en el <code>vector1</code> para obtener unas referencias a los elementos. Despu√©s se ha usado <code>map()</code> para sumar 1 y devolver nuevos valores en un nuevo vector. El <code>vector1</code> a√∫n est√° disponible ya que solo se han usado referencias a sus elementos: se ha tomado ning√∫n valor. Al final, resulta necesario utilizar <code>collect()</code> para crear un nuevo vector con los nuevos elementos que <code>map()</code> ha ido generando.</p>
</li>
<li>
<p>En segundo lugar, se usa <code>.into_iter()</code> para obtener un iterador sobre los valores (directamente, sin referencias). Esto destruye <code>vector1</code>. As√≠ que despu√©s de construir el nuevo <code>vector1_b</code>, no se puede volver a usar <code>vector1</code>.</p>
</li>
<li>
<p>Por √∫ltimo, se usa <code>.iter_mut()</code> sobre el <code>vector2</code>. Es mutable, por lo que no se necesita utilizar <code>.collect()</code> para crear un nuevo <code>Vec</code>. En vez de ello, se modifican difectamente los valores del <code>Vec</code> con referencias modificables. Por eso, <code>vector2</code> sigue existiendo con los valores modificados. Por ello, se utiliza <code>for_each</code> en lugar de <code>map()</code>.</p>
</li>
</ol>
<h3 id="c√≥mo-funciona-un-iterador"><a class="header" href="#c√≥mo-funciona-un-iterador">C√≥mo funciona un iterador</a></h3>
<p>Un iterador funciona mediante el uso de un m√©todo denominado <code>.next()</code>, que devuelve un <code>Option</code>. Cuando se usa un iterador, Rust llama a la funci√≥n <code>.next()</code> una y otra vez. Sigue haci√©ndolo siempre que obtenga un elemento de tipo <code>Some</code>. Se detiene cuando recupera un elemento de tipo <code>None</code>.</p>
<p>Se recordar√° por un apartado anterior que existe la macro <code>assert_eq!</code>. En la documentaci√≥n de las librer√≠as de Rust se usa mucho. A continuaci√≥n, se muestra un ejemplo que la usa para mostrar c√≥mo funciona un iterador:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec!['a', 'b', 'Í±∞', 'Êü≥']; // Es un Vector &quot;normal&quot;

    let mut my_vec_iter = my_vec.iter(); // Esta variable contiene un objeto iterador
                                         // que a√∫n no se ha usado

    assert_eq!(my_vec_iter.next(), Some(&amp;'a'));  // Recupera el primer elemento con next()
    assert_eq!(my_vec_iter.next(), Some(&amp;'b'));  // Recupera el siguiente
    assert_eq!(my_vec_iter.next(), Some(&amp;'Í±∞')); // Y el siguiente
    assert_eq!(my_vec_iter.next(), Some(&amp;'Êü≥')); // Y el siguiente
    assert_eq!(my_vec_iter.next(), None);        // Ya no queda ninguno, recupera None
    assert_eq!(my_vec_iter.next(), None);        // Si se sigue llamando a .next() se sigue obteniendo None
}
</code></pre></pre>
<p>Se puede implementar el rasgo <code>Iterator</code> en cualquier <code>struct</code> o <code>enum</code> sin mucha dificultad. En primer lugar, se crea una biblioteca de libros como base para demostrar c√≥mo se puede hacer.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)] // Se quiere usar print con {:?}
struct Library {
    library_type: LibraryType, // Este es el enum
    books: Vec&lt;String&gt;, // lista de libros
}

#[derive(Debug)]
enum LibraryType { // las bibliotecas pueden ser de la ciudad o del pa√≠s
    City,
    Country,
}

impl Library {
    fn add_book(&amp;mut self, book: &amp;str) { // Se usa add_book para a√±adir nuevos libros
        self.books.push(book.to_string()); // Se toma un &amp;str y lo convierte en String, para a√±adirlo despu√©s a Vec
    }

    fn new() -&gt; Self { // Esta funci√≥n crea una nueva biblioteca
        Self {
            library_type: LibraryType::City, // La mayor√≠a son de ciudades, por lo qu ese usa como valor por defecto
                                             // la mayor parte de las veces.
            books: Vec::new(),
        }
    }
}

fn main() {
    let mut my_library = Library::new(); // crea una nueva biblioteca
    my_library.add_book(&quot;The Doom of the Darksword&quot;); // se a√±aden algunos libros
    my_library.add_book(&quot;Demian - die Geschichte einer Jugend&quot;);
    my_library.add_book(&quot;Íµ¨Ïö¥Î™Ω&quot;);
    my_library.add_book(&quot;ÂêæËº©„ÅØÁå´„Åß„ÅÇ„Çã&quot;);

    println!(&quot;{:?}&quot;, my_library.books); // se puede imprimir la lista de libros
}
</code></pre></pre>
<p>Ahora se puede implementar <code>Iterator</code> para la biblioteca para que se pueda utilizar en un bucle <code>for</code>. Con la implementaci√≥n anterior, antes de implementar <code>Iterator</code>, el bucle <code>for</code> no funciona.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for item in my_library {
    println!(&quot;{}&quot;, item); // ‚ö†Ô∏è
}
<span class="boring">}
</span></code></pre></pre>
<p>Devuelve lo siguente:</p>
<pre><code class="language-text">error[E0277]: `Library` is not an iterator
  --&gt; src\main.rs:47:16
   |
47 |    for item in my_library {
   |                ^^^^^^^^^^ `Library` is not an iterator
   |
   = help: the trait `std::iter::Iterator` is not implemented for `Library`
   = note: required by `std::iter::IntoIterator::into_iter`
</code></pre>
<p>Pero se puede hacer que la biblioteca implemente un iterador con <code>impl Iterator for Library</code>. La informaci√≥n sobre el rasgo <code>Iterator</code> se encuentra en la documentaci√≥n de la librer√≠a est√°ndar: <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">https://doc.rust-lang.org/std/iter/trait.Iterator.html</a></p>
<p>En la parte superior izquierda de esta p√°gina indica <code>Associated Types: Item</code> y <code>Required Methods: next</code>. Un <em>tipo asociado</em> es otro tipo que va junto con este. En este caso, el tipo asociado ser√° <code>String</code> ya que se quiere que el iterador a implementar devuelva cadenas de texto.</p>
<p>En la p√°gina de la documentaci√≥n hay un ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">// an iterator which alternates between Some and None
struct Alternate {
    state: i32,
}

impl Iterator for Alternate {
    type Item = i32;

    fn next(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let val = self.state;
        self.state = self.state + 1;

        // if it's even, Some(i32), else None
        if val % 2 == 0 {
            Some(val)
        } else {
            None
        }
    }
}

fn main() {}
</code></pre></pre>
<p>Se puede observa que bajo <code>impl Iterator for Alternate</code> dice <code>type Item = i32</code>. Este es el tipo asociado para este ejemplo. En el caso del ejemplo de la Librer√≠a, el iterador devolver√° libros de la lista que es de tipo <code>Vec&lt;String&gt;</code>. Cuando se llame a <code>.next()</code> devolver√° un <code>String</code> de los incluidos en el vector. Por lo tanto, el tipo asociado ser√° <code>type Item = String</code>.</p>
<p>Para implementar <code>Iterator</code> se debe escribir la funci√≥n <code>fn next()</code>. En ella se indicar√° lo que debe hacer el iterador. Para este caso, se quiere que entregue primero los √∫ltimos libros del vector. En el ejemplo que sigue, se usa <code>match</code> para ver el tipo de elemento que ha devuelvo <code>.pop()</code> y seleccionar qu√© debe devolver <code>next()</code>. Adem√°s, se imprimir√° &quot; encontrado&quot; para cada elemento:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug, Clone)]
struct Library {
    library_type: LibraryType,
    books: Vec&lt;String&gt;,
}

#[derive(Debug, Clone)]
enum LibraryType {
    City,
    Country,
}

impl Library {
    fn add_book(&amp;mut self, book: &amp;str) {
        self.books.push(book.to_string());
    }

    fn new() -&gt; Self {
        Self {
            library_type: LibraryType::City,
            // la mayor parte de las veces, valor por defecto
            books: Vec::new(),
        }
    }
}

impl Iterator for Library {
    type Item = String;

    fn next(&amp;mut self) -&gt; Option&lt;String&gt; {
        match self.books.pop() {
            Some(book) =&gt; Some(book + &quot; encontrado&quot;), // Rust permite String + &amp;str
            None =&gt; None,
        }
    }
}

fn main() {
    let mut my_library = Library::new();
    my_library.add_book(&quot;The Doom of the Darksword&quot;);
    my_library.add_book(&quot;Demian - die Geschichte einer Jugend&quot;);
    my_library.add_book(&quot;Íµ¨Ïö¥Î™Ω&quot;);
    my_library.add_book(&quot;ÂêæËº©„ÅØÁå´„Åß„ÅÇ„Çã&quot;);

    for item in my_library.clone() { // ahora s√≠ funciona el bucle for. Se le pasa un clon de la biblioteca para que no se destruya
        println!(&quot;{}&quot;, item);
    }
}
</code></pre></pre>
<p>Esto imprime:</p>
<pre><code class="language-text">ÂêæËº©„ÅØÁå´„Åß„ÅÇ„Çãencontrado
Íµ¨Ïö¥Î™Ω encontrado
Demian - die Geschichte einer Jugend encontrado
The Doom of the Darksword encontrado
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="closures---cierres"><a class="header" href="#closures---cierres">Closures - Cierres</a></h1>
<p>Los cierres o closures (en ingl√©s) son una especie de funciones r√°pidas que no necesitan un nombre. En ocasiones se les denomina funciones lambdas. Son f√°ciles de encontrar en el c√≥digo debido a que utilizan <code>||</code> en lugar de <code>()</code>. Son muy habituales en Rust y una vez se aprenden a utilizar uno se pregunta como ha podido vivir sin ellos.</p>
<p>Se puede asociar un closure a una variable y en ese caso funciona y parece exactamente como una funci√≥n:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_closure = || println!(&quot;Esto es un cierre&quot;);
    my_closure();
}
</code></pre></pre>
<p>Este closure no recibe nada coomo par√°metro <code>||</code> e imprime el mensaje <code>Esto es un cierre</code>.</p>
<p>Entre los s√≠mbolos <code>||</code> se pueden a√±adir variables de entrada y tipos, como se hace en las funciones dentro de <code>()</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_closure = |x: i32| println!(&quot;{}&quot;, x);

    my_closure(5);
    my_closure(5+5);
}
</code></pre></pre>
<p>Imprime:</p>
<pre><code class="language-text">5
10
</code></pre>
<p>Cuando un cierre se hace m√°s complejo, se puede escribir con un bloque de c√≥digo que puede ser tan largo como se requiera:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_closure = || {
        let number = 7;
        let other_number = 10;
        println!(&quot;Los dos n√∫meros son {} y {}.&quot;, number, other_number);
          // Este cierre puede ser tan largo como se necesite, como sucede con las funciones.
    };

    my_closure();
}
</code></pre></pre>
<p>Pero los cierres son especiales porque pueden guardarse valores de variables que se encuentren fuera del ellos incluso aunque no reciban par√°metros (es decir, incluso habiendo escrito <code>||</code>). Por ello, se puede escribir:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_one = 6;
    let number_two = 10;

    let my_closure = || println!(&quot;{}&quot;, number_one + number_two);
    my_closure();
}
</code></pre></pre>
<p>Este c√≥digo imprime <code>16</code>. No ha sido necesario a√±adir par√°metros a <code>||</code> porque se pueden usar las variables dentro del c√≥digo del cierre y sumarlas ah√≠.</p>
<p>Por cierto, por eso se llaman <strong>closures</strong>. Porque pueden tomar unas variables y <em>encerrarlas</em> dentro. Esto significa que si se quiere hablar con precisi√≥n:</p>
<ul>
<li>Una <code>||</code> que no encierra ninguna variable exterior en su interior es una <em>funci√≥n an√≥nima</em>. No es, estrictamente, un <em>closure</em>.</li>
<li>Una <code>||</code> que s√≠ encierra una variable exterior en su interior s√≠ es un <em>cierre</em>.</li>
</ul>
<p>Sin embargo, esta precisi√≥n no se suele hacer en el habla coloquial. As√≠ que en este texto simplemente se llaman <em>cierres</em> a todos los <code>||</code>.</p>
<p>¬øPor qu√© es bueno conocer la diferencia? Porque las funciones an√≥nimas generan realmente el mismo c√≥digo que el de las funciones con nombre. Aunque pueda parecer que el c√≥digo m√°quina de una funci√≥n an√≥nima ser√° m√°s complejo, no lo es. Es igual (y, por lo tanto, igual de r√°pido) que el c√≥digo de una funci√≥n habitual.</p>
<p>Para qu√© pueden servir los cierres. Por ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_one = 6;
    let number_two = 10;

    let my_closure = |x: i32| println!(&quot;{}&quot;, number_one + number_two + x);
    my_closure(5);
}
</code></pre></pre>
<p>Este cierre guarda en su interior a dos variables <code>number_one</code> y <code>number_two</code>. Pero tambi√©n recibe como par√°metro una nueva variable <code>x</code> y cuando se ejecuta, se le pasa 5 al par√°metro <code>x</code>. Suma los tres valores y, en este caso, devuelve <code>21</code>.</p>
<p>Normalmente, se usan los cierres para pasarlos como par√°metros a determinados m√©todos. En la √∫ltima secci√≥n se usaron cierres con <code>.map()</code>y <code>.for_each()</code>. En esa secci√≥n, se escribi√≥ <code>|x|</code> para obtener el siguiente elemento en un iterador; eso era un cierre.</p>
<p>Otro ejemplo: el m√©todo <code>unwrap_or</code> que se usa para asignar un valor cuando no funciona <code>unwrap</code>. Igual que se puede escribir la siguiente funci√≥n <code>let fourth = my_vec.get(3).unwrap_or(&amp;0);</code>, existe tambi√©n el m√©todo <code>unwrap_or_else</code> que recibe un cierre como par√°metro. Por ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![8, 9, 10];

    let fourth = my_vec.get(3).unwrap_or_else(|| { // Intenta &quot;desenvolver&quot;. Si no funciona:
        if my_vec.get(0).is_some() {               // observa si el vector contiene algo en el √≠ndice [0]
            &amp;my_vec[0]                             // Utiliza ese valor si existe algo.
        } else {
            &amp;0 // en otro caso, usa el &amp;0
        }
    });

    println!(&quot;{}&quot;, fourth);
}
</code></pre></pre>
<p>Por supuesto, los cierres pueden ser muy simples. Se puede escribir, simplemente <code>let fourth = my_vec.get(3).unwrap_or_else(|| &amp;0);</code>. No siempre se necesita usar <code>{}</code> y escribir c√≥digo complejo solo porque es un cierre. Solo con escribir <code>||</code> el compilador conoce que hay un cierre.</p>
<p>Quiz√°s el uso m√°s habitual de un cierre sea en la funci√≥n <code>.map()</code>. A continuaci√≥n se muestra otro ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let num_vec = vec![2, 4, 6];

    let double_vec = num_vec        // usa el vector
        .iter()                     // para recorrerlo (iterar)
        .map(|number| number * 2)   // para cada elemento, lo multiplica por 2
        .collect::&lt;Vec&lt;i32&gt;&gt;();     // y crea un nuevo vector a partir de ello
    println!(&quot;{:?}&quot;, double_vec);
}
</code></pre></pre>
<p>Otro buen ejemplo es su uso con <code>.for_each()</code> despu√©s de <code>.enumerate()</code>. El m√©todo <code>.enumerate()</code> devuelve un iterador con el n√∫mero de √≠ndice del elemento y el propio elemento. Por ejemplo, de <code>[10, 9, 8 ]</code> se obtiene <code>(0, 10), (1, 9), (2, 8)</code>. Con los tipos <code>(usize, i32)</code>. </p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let num_vec = vec![10, 9, 8];

    num_vec
        .iter()      // itera sobre num_vec
        .enumerate() // obtiene pares de (√≠ndice, valor)
        .for_each(|(index, number)| println!(&quot;El √≠ndice {} contiene el valor {}&quot;, index, number)); // imprime para cada elemento
}
</code></pre></pre>
<p>Este c√≥digo imprime:</p>
<pre><code class="language-text">El √≠ndice 0 contiene el valor 10
El √≠ndice 1 contiene el valor 9
El √≠ndice 2 contiene el valor 8
</code></pre>
<p>En este caso se usa <code>for_each</code> en lugar de <code>map</code>. <code>map</code> es para ejecutar algo en cada elemento y pasarlo al siguiente paso (es un iterador en s√≠ mismo) y actua de forma <em>perezosa</em>, es decir, si no hay nadie a quien pasarle el valor, no hace nada. <code>for_each</code> realiza la operaci√≥n cuando recibe cada elemento. Por eso en caso de <code>map</code> hace falta usar un m√©todo como <code>collect</code> para obtener un resultado.</p>
<p>Esta es una caracter√≠stica muy interesante de los iteradores. Si se intenta ejecutar un <code>map</code> sin utilizar un m√©todo como <code>collect</code>, el compilador observar√° que ese c√≥digo no hace nada. No fallar√°, pero lo indicar√°:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let num_vec = vec![10, 9, 8];

    num_vec
        .iter()
        .enumerate()
        .map(|(index, number)| println!(&quot;El √≠ndice {} contiene el valor {}&quot;, index, number));

}
</code></pre></pre>
<p>Mostrar√°:</p>
<pre><code class="language-text">warning: unused `std::iter::Map` that must be used
 --&gt; src\main.rs:4:5
  |
4 | /     num_vec
5 | |         .iter()
6 | |         .enumerate()
7 | |         .map(|(index, number)| println!(&quot;Index number {} has number {}&quot;, index, number));
  | |_________________________________________________________________________________________^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: iterators are lazy and do nothing unless consumed
</code></pre>
<p>Se trata de un aviso <strong>warning</strong>, no es un error. El programa funciona correctamente. Pero no suma nada. Si se observa el tipo del resultado de cada fila, se entender√°:</p>
<ul>
<li><code>let num_vec = vec![10, 9, 8];</code> En este momento se tiene un <code>Vec&lt;i32&gt;</code>.</li>
<li><code>.iter()</code> El valor de retorno de esta funci√≥n es un <code>Iter&lt;i32&gt;</code>. Es decir, un iterador sobre elementos de tipo <code>i32</code>.</li>
<li><code>.enumerate()</code> Ahora es de tipo enumerado <code>Enumerate&lt;Iter&lt;i32&gt;&gt;</code>. Es decir, un <code>Enumerate</code> sobre un <code>Iter</code> de <code>i32</code>s.</li>
<li><code>.map()</code> Y ahora el tipo es <code>Map&lt;Enumerate&lt;Iter&lt;i32&gt;&gt;&gt;</code>. Es decir, un <code>Map</code> sobre un <code>Enumerate</code> sobre un <code>Iter</code> de <code>i32</code>s.</li>
</ul>
<p>Hasta el momento, todo lo que han hecho las funciones es ir construyendo una estructura compleja que est√° lista para usarse, solo que hay que decirle de alg√∫n modo que lo haga. Rust hace todo esto porque necesita ejecutarse r√°pido. No quiere hacer:</p>
<ul>
<li>itera sobre todos los <code>i32</code> en el vector</li>
<li>luego enumera todos los <code>i32</code> del iterador</li>
<li>luego ejecuta la funci√≥n sobre todos los <code>i32</code></li>
</ul>
<p>Rust realiza un √∫nico &quot;bucle&quot; solo cuando lo necesita. En el momento que se ejecuta una funci√≥n como <code>.collect::&lt;Vec&lt;i32&gt;&gt;()</code> Rust sabe que se le est√° pidiendo construir un vector y comienza a pedir los diferentes valores. Esto es lo que significa que <em>los iteradores son perezosos y no hacen nada a no ser que se consuman</em>.</p>
<p>Se pueden crear cosas muy complejas como <code>HashMap</code> mediante el uso de <code>.collect()</code>. A continuaci√≥n se muestra un ejemplo sobre como construir un <code>HashMap</code> a partir de dos vectores. En primer lugar, se construyen ambos vectores. Despu√©s se usar√° <code>into_iter()</code> para obtener un interador sobre los valores. Posteriormente se usar√° <code>.zip()</code> para unir ambos iteradores como un una cremallera, emparejando cada elemento de un iterador con el obtenido del otro. Por √∫ltimo, se utilizar√° <code>.collect()</code> para crear el <code>HashMap</code>:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let some_numbers = vec![0, 1, 2, 3, 4, 5]; // un Vec&lt;i32&gt;
    let some_words = vec![&quot;cero&quot;, &quot;uno&quot;, &quot;dos&quot;, &quot;tres&quot;, &quot;cuatro&quot;, &quot;cinco&quot;]; // un Vec&lt;&amp;str&gt;

    let number_word_hashmap = some_numbers
        .into_iter()                 // obtiene un iter
        .zip(some_words.into_iter()) // se combinan con .zip() dos iter.
        .collect::&lt;HashMap&lt;_, _&gt;&gt;();

    println!(&quot;Para la clave {} se obtiene {}.&quot;, 2, number_word_hashmap.get(&amp;2).unwrap());
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">Para la clave 2 se obtiene dos.
</code></pre>
<p>Se observa que se escribi√≥ <code>&lt;HashMap&lt;_, _&gt;&gt;</code>, que es informaci√≥n suficiente para que Rust sepa decidir el tipo del objeto como <code>&lt;HashMap&lt;i32, &amp;str&gt;&gt;</code>. Tambi√©n habr√≠a sido posible haber escrito <code>.collect::&lt;HashMap&lt;i32, &amp;str&gt;&gt;();</code>. E incluso as√≠:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let some_numbers = vec![0, 1, 2, 3, 4, 5]; // un Vec&lt;i32&gt;
    let some_words = vec![&quot;cero&quot;, &quot;uno&quot;, &quot;dos&quot;, &quot;tres&quot;, &quot;cuatro&quot;, &quot;cinco&quot;]; // un Vec&lt;&amp;str&gt;
    let number_word_hashmap: HashMap&lt;_, _&gt; = some_numbers  // Puesto que se indica el tipo aqu√≠...
        .into_iter()
        .zip(some_words.into_iter())
        .collect(); // no es necesario indicarlo aqu√≠
}
</code></pre></pre>
<p>Hay otro m√©todo que es como <code>.enumerate()</code>, pero para el tipo <code>char</code>: <code>.char_indices()</code>. Se usa de la misma forma. Si se supone que se tiene una cadena que est√° formada por n√∫meros de tres d√≠gitos:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numbers_together = &quot;140399923481800622623218009598281&quot;;

    for (index, number) in numbers_together.char_indices() {
        match (index % 3, number) {
            (0..=1, number) =&gt; print!(&quot;{}&quot;, number), // solo imprime el n√∫mero si hay resto
            _ =&gt; print!(&quot;{}\t&quot;, number), // en otro caso, imprime el n√∫mero y un tabulador
        }
    }
}
</code></pre></pre>
<p>Esto imprime: <code>140     399     923     481     800     622     623     218     009     598    281</code>.</p>
<h2 id="_-en-un-cierre-closure"><a class="header" href="#_-en-un-cierre-closure">|_| en un cierre (closure)</a></h2>
<p>En ocasiones se puede ver <code>|_|</code> en un cierre. Esto significa que el cierre (closure) necesita un argumento (como podr√≠a ser una variable x), pero no se va a usar. As√≠ que esta expresi√≥n en los par√°metros de un cierre significa: vale, el cierre recibe un par√°metro, pero no le doy un nombre porque no lo uso&quot;.</p>
<p>A continuaci√≥n, se muestra un ejemplo que da error por no expresar el par√°metro:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![8, 9, 10];

    println!(&quot;{:?}&quot;, my_vec.iter().for_each(|| println!(&quot;No usamos la variable que se necesita&quot;))); // ‚ö†Ô∏è
}
</code></pre></pre>
<p>Rust da un error que dice:</p>
<pre><code class="language-text">error[E0593]: closure ¬øEst√° expected to take 1 argument, but it takes 0 arguments
 --&gt; src/main.rs:4:36
  |
4 |     println!(&quot;{:?}&quot;, my_vec.iter().for_each(|| println!(&quot;No usamos la variable que se necesita&quot;))); // ‚ö†Ô∏è
  |                                    ^^^^^^^^ -- takes 0 arguments
  |                                    |
  |                                    expected closure that takes 1 argument
</code></pre>
<p>El propio compilador da alguna pista:</p>
<pre><code class="language-text">help: consider changing the closure to take and ignore the expected argument
  |
4 |     println!(&quot;{:?}&quot;, my_vec.iter().for_each(|_| println!(&quot;No usamos la variable que se necesita&quot;))); // ‚ö†Ô∏è
  |                                             ~~~
</code></pre>
<p>Es decir, que se debe pasar el argumento que necesita cualquier cierre que se pase como par√°metro a la funci√≥n <code>for_each</code>.</p>
<p>Si se cambia de este modo, funcionar√°:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![8, 9, 10];

    println!(&quot;{:?}&quot;, my_vec.iter().for_each(|_| println!(&quot;No usamos la variable que se necesita&quot;)));
}
</code></pre></pre>
<h2 id="m√©todos-√∫tiles-para-su-uso-con-cierres-e-iteradores"><a class="header" href="#m√©todos-√∫tiles-para-su-uso-con-cierres-e-iteradores">M√©todos √∫tiles para su uso con cierres e iteradores</a></h2>
<p>Rust es un lenguaje muy divertido cuando se dominan los cierres. Con ellos se pueden <em>encadenar</em> m√©todos para hacer mucho con poco c√≥digo. A continuaci√≥n, se muestrans algunos m√©todos que se utilizan con cierres que a√∫n no se hab√≠an visto:</p>
<p><code>.filter()</code>: a partir de un iterador, permite conservar los elementos que se deseen. El siguiente ejemplo filtra los meses del a√±o:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let meses = vec![&quot;Enero&quot;, &quot;Febrero&quot;, &quot;Marzo&quot;, &quot;Abril&quot;, &quot;Mayo&quot;, &quot;Junio&quot;, &quot;Julio&quot;, &quot;Agosto&quot;, &quot;Septiembre&quot;, &quot;Octubre&quot;, &quot;Noviembre&quot;, &quot;Diciembre&quot;];

    let filtered_meses = meses
        .into_iter()                         // crea un iterador
        .filter(|month| month.len() &lt;= 5)     // Solo los meses con cinco o menos caracters (byte)
                                             // En este caso, todos los caracteres son de un byte, por eso funciona usar .len()
        .filter(|month| month.contains(&quot;u&quot;)) // Se seleccionan solo los meses que contengan la letra u
        .collect::&lt;Vec&lt;&amp;str&gt;&gt;();

    println!(&quot;{:?}&quot;, filtered_meses);
}
</code></pre></pre>
<p>Esto imprime: <code>[&quot;Junio&quot;, &quot;Julio&quot;]</code>.</p>
<p><code>.filter_map()</code>: este m√©todo realiza de una vez la funci√≥n de <code>.filter()</code> y <code>.map()</code>. El cierre que se pasa como par√°metro,debe devolver un <code>Option&lt;T&gt;</code>. El m√©todo <code>filter_map()</code> extraer√° <code>T</code> para aquellos elementos que tengan valor (que sean de tipo <code>Some&lt;T&gt;</code>) y desechar√° los que sean de tipo <code>None</code>. Por ejemplo, el uso de <code>.filter_map()</code> con un vector como <code>vec![Some(2), None, Some(3)]</code> devuelve <code>[2, 3]</code>.</p>
<p>A continuaci√≥n se muestra un ejemplo con un <code>struct</code> de una <code>Empresa</code>. Cada empresa tiene un campo <code>nombre</code> de tipo <code>String</code>, y un campo <code>ceo</code> para describir a su responsable. El ceo puede haber dimitido, por lo que es de tipo <code>Option&lt;String&gt;</code> En el ejemplo, se filtran las empresas para mostrar el valor de los CEO.</p>
<pre><pre class="playground"><code class="language-rust">struct Empresa {
    nombre: String,
    ceo: Option&lt;String&gt;,
}

impl Empresa {
    fn new(nombre: &amp;str, ceo: &amp;str) -&gt; Self {
        let ceo = match ceo {
            &quot;&quot; =&gt; None,
            ceo =&gt; Some(ceo.to_string()),
        }; // Se crea el valor del campo ceo y debajo se crea el elemento struct
        Self {
            nombre: nombre.to_string(),
            ceo,
        }
    }

    fn get_ceo(&amp;self) -&gt; Option&lt;String&gt; {
        self.ceo.clone() // Devuelve un clone del CEO (struct no es tipo Copy)
    }
}

fn main() {
    let empresa_vec = vec![
        Empresa::new(&quot;Umbrella Corporation&quot;, &quot;Unknown&quot;),
        Empresa::new(&quot;Ovintiv&quot;, &quot;Doug Suttles&quot;),
        Empresa::new(&quot;The Red-Headed League&quot;, &quot;&quot;),
        Empresa::new(&quot;Stark Enterprises&quot;, &quot;&quot;),
    ];

    let all_the_ceos = empresa_vec
        .into_iter()
        .filter_map(|empresa| empresa.get_ceo()) // filter_map recibe Option&lt;T&gt; que es lo que necesita
        .collect::&lt;Vec&lt;String&gt;&gt;();

    println!(&quot;{:?}&quot;, all_the_ceos);
}
</code></pre></pre>
<p>Esto imprime: <code>[&quot;Unknown&quot;, &quot;Doug Suttles&quot;]</code></p>
<p>Para facilitar el uso de <code>.filter_map()</code> con valores <code>Result&lt;T, E&gt;</code>, este √∫ltimo tiene el m√©todo <code>.ok()</code> que lo convierte en <code>Option&lt;T&gt;</code> usando <code>None</code> para los casos de error.</p>
<p>En el siguiente ejemplo se utiliza <code>.parse()</code> para convertir la entrada de usuario en n√∫meros <code>f32</code>. En el resultado se registran los errores que pueda haber en la entrada del usuario, al usar <code>.filter_map()</code> junto con <code>.ok()</code> se descartan los valores err√≥neos.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let user_input = vec![&quot;8.9&quot;, &quot;Nine point nine five&quot;, &quot;8.0&quot;, &quot;7.6&quot;, &quot;eleventy-twelve&quot;];

    let actual_numbers = user_input
        .into_iter()
        .filter_map(|input| input.parse::&lt;f32&gt;().ok())
        .collect::&lt;Vec&lt;f32&gt;&gt;();

    println!(&quot;{:?}&quot;, actual_numbers);
}
</code></pre></pre>
<p>Lo anterior imprime: <code>[8.9, 8.0, 7.6]</code></p>
<p>En sentido contrario de <code>.ok()</code>, los <code>Option&lt;T&gt;</code> disponen de los m√©todos <code>.ok_or()</code> y <code>.ok_or_else()</code>. Estas funcones convierten un <code>Option&lt;T&gt;</code> en <code>Resutl&lt;T, E&gt;</code>. La funci√≥n <code>.ok_or()</code> devuelve un <code>Ok</code> o un <code>Err</code>, por lo que necesita que se le indique de qu√© tipo debe ser este error. Esto se debe a que los casos <code>None</code> de <code>Option</code> no disponen de informaci√≥n adicionales.</p>
<p>En estas funciones, <code>.ok_or()</code> y <code>.ok_or_else()</code>, el par√°metro closure se utiliza para obtener el valor para los casos en los que el <code>Option</code> sea <code>None</code>.</p>
<p>En el siguiente ejemplo, se toma el <code>Option</code> del <code>struct</code> de <code>Empresa</code> para convertirlo en un <code>Result</code>. Para el manejo de errores a largo plazo, es bueno que la aplicaci√≥n tenga sus propios tipos de error. En este caso solo se incluye un mensaje de error, por lo que el tipo del resultado es <code>Result&lt;String, &amp;str&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust">// El c√≥digo es id√©ntico, salvo en la funci√≥n main()
struct Empresa {
    nombre: String,
    ceo: Option&lt;String&gt;,
}

impl Empresa {
    fn new(nombre: &amp;str, ceo: &amp;str) -&gt; Self {
        let ceo = match ceo {
            &quot;&quot; =&gt; None,
            ceo =&gt; Some(ceo.to_string()),
        };
        Self {
            nombre: nombre.to_string(),
            ceo,
        }
    }

    fn get_ceo(&amp;self) -&gt; Option&lt;String&gt; {
        self.ceo.clone()
    }
}

fn main() {
    let empresa_vec = vec![
        Empresa::new(&quot;Umbrella Corporation&quot;, &quot;Unknown&quot;),
        Empresa::new(&quot;Ovintiv&quot;, &quot;Doug Suttles&quot;),
        Empresa::new(&quot;The Red-Headed League&quot;, &quot;&quot;),
        Empresa::new(&quot;Stark Enterprises&quot;, &quot;&quot;),
    ];

    let mut results_vec = vec![]; // Para guardar los valores resultantes

    empresa_vec
        .iter()
        .for_each(|empresa| results_vec.push(empresa.get_ceo().ok_or(&quot;No CEO found&quot;)));

    for item in results_vec {
        println!(&quot;{:?}&quot;, item);
    }
}
</code></pre></pre>
<p>El resultado de este c√≥digo es el siguiente:</p>
<pre><code class="language-text">Ok(&quot;Unknown&quot;)
Ok(&quot;Doug Suttles&quot;)
Err(&quot;No CEO found&quot;)
Err(&quot;No CEO found&quot;)
</code></pre>
<p>En este caso, se dispone de las cuatro entradas del usuario y se indica cu√°les son err√≥neas.</p>
<p>A continuaci√≥n se usa <code>.ok_or_else()</code> para que se pueda pasar como par√°metro un cierre y obtener un mensaje de error mejor incluyendo el nombre de la empresa.</p>
<pre><pre class="playground"><code class="language-rust">// El c√≥digo es id√©ntico, salvo en la funci√≥n main()
struct Empresa {
    nombre: String,
    ceo: Option&lt;String&gt;,
}

impl Empresa {
    fn new(nombre: &amp;str, ceo: &amp;str) -&gt; Self {
        let ceo = match ceo {
            &quot;&quot; =&gt; None,
            ceo =&gt; Some(ceo.to_string()),
        };
        Self {
            nombre: nombre.to_string(),
            ceo,
        }
    }

    fn get_ceo(&amp;self) -&gt; Option&lt;String&gt; {
        self.ceo.clone()
    }
}

fn main() {
    let empresa_vec = vec![
        Empresa::new(&quot;Umbrella Corporation&quot;, &quot;Unknown&quot;),
        Empresa::new(&quot;Ovintiv&quot;, &quot;Doug Suttles&quot;),
        Empresa::new(&quot;The Red-Headed League&quot;, &quot;&quot;),
        Empresa::new(&quot;Stark Enterprises&quot;, &quot;&quot;),
    ];

    let mut results_vec = vec![]; // Para guardar los valores resultantes

    empresa_vec
        .iter()
        .for_each(|empresa| {
            results_vec.push(empresa.get_ceo().ok_or_else(|| {
                let mensaje_error = format!(&quot;No CEO found for {}&quot;, empresa.nombre);
                mensaje_error
            }))
        });

    for item in results_vec {
        println!(&quot;{:?}&quot;, item);
    }
}
</code></pre></pre>
<p>El c√≥digo anterior, imprime:</p>
<pre><code class="language-text">Ok(&quot;Unknown&quot;)
Ok(&quot;Doug Suttles&quot;)
Err(&quot;No CEO found for The Red-Headed League&quot;)
Err(&quot;No CEO found for Stark Enterprises&quot;)
</code></pre>
<p><code>.and_then()</code>: es un m√©todo que toma como par√°metro un <code>Option</code> y permite realizar una operaci√≥n con su valor pasando el resultado al siguiente m√©todo que exista. El resultado tambi√©n debe ser de tipo <code>Option</code>. Es una forma segura de obtener el contenido del elemento <code>Some</code>, realizar la operaci√≥n deseada y encapsular el resultado de nuevo en un <code>Option</code>.</p>
<p>Un ejemplo sencillo se puede ver a partir del resultado de la operaci√≥n <code>.get()</code> sobre un vector, puesto que devuelve un <code>Option</code>. En este caso, se obtiene un n√∫mero, se realiza un c√°lculo y se vuelve a convertir a <code>Option</code>. Los valores <code>None</code> se pasan sin procesar, siguen siendo <code>None</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let new_vec = vec![8, 9, 0]; // solo un vec con n√∫meros
    let number_to_add = 5;       // Se usa en el c√°lculo m√°s adelante
    let mut empty_vec = vec![];  // El resultado va aqu√≠


    for index in 0..5 {
        empty_vec.push(
            new_vec
               .get(index)
                .and_then(|number| Some(number + 1))
                .and_then(|number| Some(number + number_to_add))
        );
    }
    println!(&quot;{:?}&quot;, empty_vec);
}
</code></pre></pre>
<p>Esto imprime: <code>[Some(14), Some(15), Some(6), None, None]</code>. Se observa que no se filtran los <code>None</code>.</p>
<p><code>.and()</code>: es parecido a <code>bool</code> para <code>Option</code>. Se pueden encadenar muchos y si todos son <code>Some</code> el resultado ser√° el del √∫ltimo. Si existe alg√∫n <code>None</code>, el resultado ser√° <code>None</code>.</p>
<p>Se muestra en primer lugar un ejemplo con booleanos para ayudar a entender el funcionamiento de <code>.and()</code> en base al funcionamiento de <code>&amp;&amp;</code>(and). Un solo <code>false</code> lo convierte todo en <code>false</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let one = true;
    let two = false;
    let three = true;
    let four = true;

    println!(&quot;{}&quot;, one &amp;&amp; three); // prints true
    println!(&quot;{}&quot;, one &amp;&amp; two &amp;&amp; three &amp;&amp; four); // prints false
}
</code></pre></pre>
<p>A continuaci√≥n, se muestra el mismo tipo de ejemplo con la funci√≥n <code>.and()</code>. Se puede imagina que se ejecutaron cinco operaciones y para cada una de ellas, si el resultado fue correcto se guardar en un <code>Vec&lt;Option&lt;&amp;str&gt;&gt;</code> un valor <code>Some(&quot;√©xito&quot;)</code>. Se repiten tres veces estas cinco operaciones. Despu√©s se usa <code>.and()</code> para comparar si en cada operaci√≥n se obtubo resultado en todas las ocasiones.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let first_try = vec![Some(&quot;√©xito&quot;), None, Some(&quot;√©xito&quot;), Some(&quot;√©xito&quot;), None];
    let second_try = vec![None, Some(&quot;√©xito&quot;), Some(&quot;√©xito&quot;), Some(&quot;√©xito&quot;), Some(&quot;√©xito&quot;)];
    let third_try = vec![Some(&quot;√©xito&quot;), Some(&quot;√©xito&quot;), Some(&quot;√©xito&quot;), Some(&quot;√©xito&quot;), None];

    for i in 0..first_try.len() {
        println!(&quot;{:?}&quot;, first_try[i].and(second_try[i]).and(third_try[i]));
    }
}
</code></pre></pre>
<p>El resultado es el siguiente:</p>
<pre><code class="language-text">None
None
Some(&quot;√©xito&quot;)
Some(&quot;√©xito&quot;)
None
</code></pre>
<p>La cadena de <code>.and()</code> de la primera operaci√≥n en los tres intentos devuelve <code>None</code> ya que el segundo intento tiene <code>None</code> en la primera posici√≥n (√≠ndice cero). La segunda operaci√≥n tambi√©n es <code>None</code> debido a que el primer intento dio un resultado <code>None</code>. La tercera operaci√≥n s√≠ tiene √©xito debido a que los tres intentos tiene un resultado distinto de <code>None</code>.</p>
<p><code>.any()</code> y <code>.all()</code>. Se utilizan de forma sencilla en iteradores. Devuelven un <code>bool</code> en funci√≥n del par√°metro de entrada. En el siguiente ejemplo, se crea un vector muy grande, de unos 20.000 elementos, con toods los caracteres desde la 'a' a la 'ÂÉç'. Despu√©s, se comprueba si contiene un determinado car√°cter.</p>
<p>A continuaci√≥n, se crea un vector m√°s peque√±o y se comprueba si es totalmente alfab√©tico (con <code>.is_alphabetic()</code>). POr √∫ltimo, se comprueba si todos los caracteres son menores que el car√°cter coreano 'Ìñâ'.</p>
<p>Se debe observar que se usan referencias all√≠ donde es necesario ya que es lo que entrega <code>.iter()</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn in_char_vec(char_vec: &amp;Vec&lt;char&gt;, check: char) {
    println!(&quot;¬øEst√° {} dentro? {}&quot;, check, char_vec.iter().any(|&amp;char| char == check));
}

fn main() {
    let char_vec = ('a'..'ÂÉç').collect::&lt;Vec&lt;char&gt;&gt;();
    in_char_vec(&amp;char_vec, 'i');
    in_char_vec(&amp;char_vec, 'Î∑Å');
    in_char_vec(&amp;char_vec, 'Èëø');

    let smaller_vec = ('A'..'z').collect::&lt;Vec&lt;char&gt;&gt;();
    println!(&quot;¬øEs todo alfab√©tico? {}&quot;, smaller_vec.iter().all(|&amp;x| x.is_alphabetic()));
    println!(&quot;¬øEs todo menor que el car√°cter Ìñâ? {}&quot;, smaller_vec.iter().all(|&amp;x| x &lt; 'Ìñâ'));
}
</code></pre></pre>
<p>Lo anterior imprime:</p>
<pre><code class="language-text">¬øEst√° i dentro? true
¬øEst√° Î∑Å dentro? false
¬øEst√° Èëø dentro? false
¬øEs todo alfab√©tico? false
¬øEs todo menor que el car√°cter Ìñâ? true
</code></pre>
<p>Por cierto, <code>.any()</code> solo comprueba hasta que encuentra un elemento que coincida. Funciona en modo cortocircuito. No sigue comprobando si ya ha encontrado una coincidencia. Por este motivo, si se va a usar esta funci√≥n <code>.any()</code> con un <code>Vec</code>, puede ser buena idea que los elementos que puedan coincidir est√©n lo m√°s cerca del inicio del iterador. Por ejemplo, usando <code>.rev()</code> despu√©s de <code>.iter()</code> si pueden estar por el final. Por ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut big_vec = vec![6; 1000];
    big_vec.push(5);
}
</code></pre></pre>
<p>Que es un vector con 1000 n√∫meros 6 seguidos de un 5. Si se quiere comprobar si contiene el n√∫mero 5, lo √≥ptimo ser√≠a obtener un iterador en sentido inverso con <code>.rev()</code>.</p>
<p>En primer lugar, se puede revisar el funcionamiento esta funci√≥n <code>.rev()</code>con el siguiente c√≥digo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut big_vec = vec![6; 1000];
    big_vec.push(5);

    let mut iterator = big_vec.iter().rev();
    println!(&quot;{:?}&quot;, iterator.next());
    println!(&quot;{:?}&quot;, iterator.next());
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">Some(5)
Some(6)
</code></pre>
<p>Por lo tanto, lo eficiente, en este caso, para buscar un 5 ser√≠a buscarlo a trav√©s del iterador que comienza por el final:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut big_vec = vec![6; 1000];
    big_vec.push(5);

    println!(&quot;{:?}&quot;, big_vec.iter().rev().any(|&amp;number| number == 5));
}
</code></pre></pre>
<p>As√≠, solo necesita iterar a trav√©s del primer elemento y luego se para. Si no se usara, en este ejemplo se iterar√≠a a trav√©s de los 1001 elementos. El siguiente c√≥digo permite observarlo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut big_vec = vec![6; 1000];
    big_vec.push(5);

    let mut counter = 0; // Inicia la cuenta
    let mut big_iter = big_vec.into_iter(); // Crea un Iterator

    loop {
        counter +=1;
        if big_iter.next() == Some(5) { // Continua llamando a .next() hasta que obtiene un Some(5)
            break;
        }
    }
    println!(&quot;Final counter is: {}&quot;, counter);
}
</code></pre></pre>
<p>Esto imprime <code>Final counter is: 1001</code>, por lo que queda claro que llam√≥ a <code>.next()</code> 1001 veces antes de encontrar el 5.</p>
<p><code>.find()</code> indica si un iterador contiene algo y <code>.position()</code> indica d√≥nde est√°. <code>.find()</code> es diferente de <code>.any()</code> en que devuelve un <code>Option</code> que cotiene el valor buscado en un <code>Some</code> o <code>None</code>. <code>.position()</code>, por otra parte devuelve un <code>Option</code> con un <code>Some</code>que contiene el n√∫mero de posici√≥n o <code>None</code>. En otras palabras:</p>
<ul>
<li><code>.find()</code>: intentar√° extraer el valor.</li>
<li><code>.position()</code>: intentar√° indicar la posici√≥n en la que est√° el valor.</li>
</ul>
<p>A continuaci√≥n, se muestra un ejemplo simple:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let num_vec = vec![10, 20, 30, 40, 50, 60, 70, 80, 90, 100];

    println!(&quot;{:?}&quot;, num_vec.iter().find(|&amp;number| number % 3 == 0)); // find takes a reference, so we give it &amp;number
    println!(&quot;{:?}&quot;, num_vec.iter().find(|&amp;number| number * 2 == 30));

    println!(&quot;{:?}&quot;, num_vec.iter().position(|&amp;number| number % 3 == 0));
    println!(&quot;{:?}&quot;, num_vec.iter().position(|&amp;number| number * 2 == 30));
}
</code></pre></pre>
<p>Este c√≥digo imprime: </p>
<pre><code class="language-text">Some(30) // Devuelve el primer valor que cumple la condici√≥n
None // No hay ning√∫n n√∫mero que multplicado por 2 == 30
Some(2) // Esta es la posici√≥n del elemneto
None
</code></pre>
<p><code>.cycle()</code> puede crear un iterador infinito que nunca termina. Este tipo de iterador funciona muy bien con <code>.zip()</code> para crear un objeto nuevo <code>Vec&lt;(i32, &amp;str)&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let even_odd = vec![&quot;par&quot;, &quot;impar&quot;];
    let even_odd_vec = (0..6)
        .zip(even_odd.into_iter().cycle())
        .collect::&lt;Vec&lt;(i32, &amp;str)&gt;&gt;();
    println!(&quot;{:?}&quot;, even_odd_vec);
}
</code></pre></pre>
<p>Aunque <code>.cycle()</code> devuelve un iterador que no acaba nunca, en este caso, el iterador de <code>.zip()</code> solo se ejecuta seis veces antes de acabarse (cuando se agota el iterable de mayor longitud). La salida de este programa es:</p>
<pre><code class="language-text">[(0, &quot;par&quot;), (1, &quot;impar&quot;), (2, &quot;par&quot;), (3, &quot;impar&quot;), (4, &quot;par&quot;), (5, &quot;impar&quot;)]
</code></pre>
<p>Algo parecido se puede consguir que no tiene fin. Si se escribe <code>0..</code> se crea un rango con un l√≠mite superior infinito y que nunca se completa. Es f√°cil de utilizar:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let ten_chars = ('a'..).take(10).collect::&lt;Vec&lt;char&gt;&gt;();
    let skip_then_ten_chars = ('a'..).skip(1300).take(10).collect::&lt;Vec&lt;char&gt;&gt;();

    println!(&quot;{:?}&quot;, ten_chars);
    println!(&quot;{:?}&quot;, skip_then_ten_chars);
}
</code></pre></pre>
<p>Ambos imprimen 10 caracteres, pero el segundo se salta 1.300 lugares e imprime diez letras en Armenio.</p>
<pre><code class="language-text">['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']
['’µ', '’∂', '’∑', '’∏', '’π', '’∫', '’ª', '’º', '’Ω', '’æ']
</code></pre>
<p><code>.fold()</code> es otro popular m√©todo que se utliza para sumar elementos de un iterador, pero se puede hacer mucho m√°s. Es similar en cierta medida a <code>.for_each()</code>. En <code>.fold()</code> primero se a√±ade un valor inicial (que puede ser 0 para poder sumar los valores), seguido del cierre. El cierre recibe dos par√°metros, el valor total hasta el momento y el siguiente elemento. Se ve a continuaci√≥n un ejemplo simple para utlizar <code>.fold()</code> para sumar elementos.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let some_numbers = vec![9, 6, 9, 10, 11];

    println!(&quot;{}&quot;, some_numbers
        .iter()
        .fold(0, |total_so_far, next_number| total_so_far + next_number)
    );
}
</code></pre></pre>
<p>As√≠:</p>
<ul>
<li>En el paso 1, comienza con 0 y suma el siguiente n√∫mero: 9.</li>
<li>En el paso 2, toma el 9 y le suma el 6: 15.</li>
<li>En el paso 3, toma el 15 y le suma el 9: 24.</li>
<li>En el paso 4, toma el 24 y le suma el 10: 34.</li>
<li>En el paso 5, toma el 34 y le suma el 11: 45, se imprime 45.</li>
</ul>
<p>Pero no es necesario usarlo solo para sumar. En el siguiente ejemplo se a√±ade '-' a cada car√°cter para construir una cadena de caracteres de tipo <code>String</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a_string = &quot;No tengo guiones.&quot;;

    println!(
        &quot;{}&quot;,
        a_string
            .chars() // iterator sobre cada car√°cter
            .fold(&quot;-&quot;.to_string(), |mut string_so_far, next_char| { // Comienza con una &quot;-&quot;
                string_so_far.push(next_char); // Incorpora el siguiente caracter, seguido de '-'
                string_so_far.push('-');
                string_so_far} // y se pasa al siguiente bucle
            ));
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">-N-o- -t-e-n-g-o- -g-u-i-o-n-e-s-.-
</code></pre>
<p>Hay muchos otros m√©todos de gran utilidad como:</p>
<ul>
<li><code>.take_while()</code> que va leyendo elementos de un iterador mientras retorna <code>true</code>.</li>
<li><code>.cloned()</code> que crea un clones de los elementos del iterador. Convierte una referencia en un valor.</li>
<li><code>.by_ref()</code> que convierte en referencias los elementos del iterador. Es bueno para asegurarse de que se puede usar un <code>Vec</code> o similar despu√©s de que se haya iterado a trav√©s de √©l.</li>
<li>Existen muchos m√©todos acabados en <code>_while</code>: <code>.skip_while()</code>, <code>.map_while()</code>.</li>
<li><code>.sum()</code>: simplemente suma todos los elementos en un solo valor.</li>
</ul>
<p><code>.chunks()</code> y <code>.windows()</code> son dos formas de partir un vector en el tama√±o que se desee. Se indica el tam√±ao que se desea como par√°metro. Por ejemplo, si se tiene un vector de 10 elementos <code>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code>, y se pasa un par√°metro de 3, se debe trabajar de la siguiente forma:</p>
<ul>
<li><code>.chunk()</code> dar√° lugar a cuatro fragmentos (slices): [0, 1, 2]. [3, 4, 5], [6, 7, 8] y [9]. El par√°metro fija el n√∫mero de elementos en cada fragmento. Con un posible fragmento de tama√±o inferior al final.</li>
<li><code>.windows()</code> dar√° lugar a m√°s fragmentos en este caso ya que crear√° fragmentos del tama√±o indicado y se desplazar√° de uno en uno: [0, 1, 2], [1, 2, 3], [2, 3, 4], ...., [7, 8, 9].</li>
</ul>
<p>Se observa el funcionamiento con el siguiente c√≥digo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let num_vec = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 0];

    for chunk in num_vec.chunks(3) {
        println!(&quot;{:?}&quot;, chunk);
    }
    println!();
    for window in num_vec.windows(3) {
        println!(&quot;{:?}&quot;, window);
    }
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">[1, 2, 3]
[4, 5, 6]
[7, 8, 9]
[0]

[1, 2, 3]
[2, 3, 4]
[3, 4, 5]
[4, 5, 6]
[5, 6, 7]
[6, 7, 8]
[7, 8, 9]
[8, 9, 0]
</code></pre>
<p>Hay que tener en cuenta que <code>.chunks()</code> lanzar√° <code>panic!</code> si no se le indica ning√∫n tama√±o. Se puede escribir <code>.chunks(1000)</code> para un vector de un solo elemento, pero no se puede escribir <code>.chunks()</code> con algo de longitud 0. La funci√≥n valida <code>assert!(chunk_size != 0)</code>.</p>
<p><code>.match_indices()</code> permite extraer de un <code>String</code> o <code>&amp;str</code> todo lo que coincida con el par√°metro e indica el √≠ndice tambi√©n. Es similar a <code>.enumerate()</code> en que retorna una tupla con dos elementos.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let rules = &quot;Regla n√∫mero 1: No luchar. Regla n√∫mero 2: ve a la cama a las 8 pm. Regla n√∫mero 3: lev√°ntate a las 6 am.&quot;;
    let rule_locations = rules.match_indices(&quot;Regla&quot;).collect::&lt;Vec&lt;(_, _)&gt;&gt;(); // Es Vec&lt;usize, &amp;str&gt;
    println!(&quot;{:?}&quot;, rule_locations);
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">[(0, &quot;Regla&quot;), (28, &quot;Regla&quot;), (70, &quot;Regla&quot;)]
</code></pre>
<p><code>.peekable()</code> crea un iterador que permite <em>echar un vistazo</em> al siguiente elemento. Es como llmar a <code>.next()</code>(devuelve un <code>Option</code>) solo que sin avanzar el iterador. Se puede usar tanto como se necesite. A continuaci√≥n, se muestra un ejemplo de uso de <code>.peek()</code> tres veces para cada elemento.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let just_numbers = vec![1, 5, 100];
    let mut number_iter = just_numbers.iter().peekable(); // Esto crea un tipo de iterator denominado Peekable

    for _ in 0..3 {
        println!(&quot;Me encanta el n√∫mero {}&quot;, number_iter.peek().unwrap());
        println!(&quot;Me encanta tanto el n√∫mero {}&quot;, number_iter.peek().unwrap());
        println!(&quot;{} es un n√∫mero tan bonito&quot;, number_iter.peek().unwrap());
        number_iter.next();
    }
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">Me encanta el n√∫mero 1
Me encanta tanto el n√∫mero 1
1 es un n√∫mero tan bonito
Me encanta el n√∫mero 5
Me encanta tanto el n√∫mero 5
5 es un n√∫mero tan bonito
Me encanta el n√∫mero 100
Me encanta tanto el n√∫mero 100
100 es un n√∫mero tan bonito
</code></pre>
<p>A continuaci√≥n se muestra otro ejemplo que usa <code>.peek()</code> para contrastar con <code>match</code> previamente a llamar a <code>.next()</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let locations = vec![
        (&quot;Nevis&quot;, 25),
        (&quot;Taber&quot;, 8428),
        (&quot;Markerville&quot;, 45),
        (&quot;Cardston&quot;, 3585),
    ];
    let mut location_iter = locations.iter().peekable();
    while location_iter.peek().is_some() {
        match location_iter.peek() {
            Some((name, number)) if *number &lt; 100 =&gt; { // .peek() da una referencia, se necesita *
                println!(&quot;Encontrada una aldea: {} con {} personas&quot;, name, number)
            }
            Some((name, number)) =&gt; println!(&quot;Encontrado un pueblo: {} con {} personas&quot;, name, number),
            None =&gt; break,
        }
        location_iter.next();
    }

</code></pre></pre>
<p>El c√≥digo anterior da como resultado:</p>
<pre><code class="language-text">Encontrada una aldea: Nevis con 25 personas
Encontrado un pueblo: Taber con 8428 personas
Encontrada una aldea: Markerville con 45 personas
Encontrado un pueblo: Cardston con 3585 personas
</code></pre>
<p>Finalmente, se muestra un ejemplo en que se se usa tambi√©n <code>.match_indices()</code>. En este caso, introducen nombres en un <code>struct</code> dependiendo del n√∫mero de espacios de la <code>&amp;str</code>.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Nombres {
    una_palabra: Vec&lt;String&gt;,
    dos_palabras: Vec&lt;String&gt;,
    tres_palabras: Vec&lt;String&gt;,
}

fn main() {
    let vec_of_Nombres = vec![
        &quot;Caesar&quot;,
        &quot;Frodo Baggins&quot;,
        &quot;Bilbo Baggins&quot;,
        &quot;Jean-Luc Picard&quot;,
        &quot;Data&quot;,
        &quot;Rand Al'Thor&quot;,
        &quot;Paul Atreides&quot;,
        &quot;Barack Hussein Obama&quot;,
        &quot;Bill Jefferson Clinton&quot;,
    ];

    let mut iter_of_Nombres = vec_of_Nombres.iter().peekable();

    let mut all_Nombres = Nombres { // inicia un struct sin nombres
        una_palabra: vec![],
        dos_palabras: vec![],
        tres_palabras: vec![],
    };

    while iter_of_Nombres.peek().is_some() {
        let next_item = iter_of_Nombres.next().unwrap(); // Se puede usar .unwrap() ya que se sabe que contiene algo
        match next_item.match_indices(' ').collect::&lt;Vec&lt;_&gt;&gt;().len() { // Crea un vector utilizando .match_indices y comprueba la longitud
            0 =&gt; all_Nombres.una_palabra.push(next_item.to_string()),
            1 =&gt; all_Nombres.dos_palabras.push(next_item.to_string()),
            _ =&gt; all_Nombres.tres_palabras.push(next_item.to_string()),
        }
    }

    println!(&quot;{:?}&quot;, all_Nombres);
}
</code></pre></pre>
<p>El c√≥digo anterior imprime:</p>
<pre><code class="language-text">Nombres { una_palabra: [&quot;Caesar&quot;, &quot;Data&quot;], dos_palabras: [&quot;Frodo Baggins&quot;, &quot;Bilbo Baggins&quot;, &quot;Jean-Luc Picard&quot;, &quot;Rand Al'Thor&quot;, &quot;Paul Atreides&quot;], tres_palabras: [&quot;Barack Hussein Obama&quot;, &quot;Bill Jefferson Clinton&quot;] }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="la-macro-dbg-e-inspect"><a class="header" href="#la-macro-dbg-e-inspect">La macro <code>dbg!</code> e <code>.inspect()</code></a></h1>
<h2 id="dbg"><a class="header" href="#dbg"><code>dbg!</code></a></h2>
<p><code>dbg!</code> es una macro muy √∫til para volcar informaci√≥n. Es una buena alternativa a <code>println!</code> porque es m√°s f√°cil de teclear y da m√°s informaci√≥n.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 8;
    dbg!(my_number);
}
</code></pre></pre>
<p>Esto imprime <code>[src\main.rSs:4] my_number = 8</code>.</p>
<p>Adem√°s, <code>dbg!</code> se puede poner en muchos otros lugares, incluso envolviendo c√≥digo en ella. Por ejemplo, en el siguiente c√≥digo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_number = 9;
    my_number += 10;

    let new_vec = vec![8, 9, 10];

    let double_vec = new_vec.iter().map(|x| x * 2).collect::&lt;Vec&lt;i32&gt;&gt;();
}
</code></pre></pre>
<p>Se crea una variable mutable y se modifica despu√©s. A continuaci√≥n se crea un <code>vec</code> y se utiliza <code>iter</code>, <code>map</code> y <code>collect</code> para crear un nuevo <code>vec</code>. Se puede a√±adir <code>dbg!</code> en casi cualquier sitio del c√≥digo anterior. Lo que hace esta macro es pedirle al compilador que &quot;le diga qu√© est√° haciendo en este momento&quot; y este se lo dice.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_number = dbg!(9);
    dbg!(my_number += 10);

    let new_vec = dbg!(vec![8, 9, 10]);

    let double_vec = dbg!(new_vec.iter().map(|x| x * 2).collect::&lt;Vec&lt;i32&gt;&gt;());

    dbg!(double_vec);
}
</code></pre></pre>
<p>El c√≥digo anterior imprime primero:</p>
<pre><code class="language-test">[src\main.rs:3] 9 = 9
</code></pre>
<p>y despu√©s:</p>
<pre><code class="language-text">[src\main.rs:4] my_number += 10 = ()
</code></pre>
<p>y sigue con:</p>
<pre><code class="language-text">[src\main.rs:6] vec![8, 9, 10] = [
    8,
    9,
    10,
]
</code></pre>
<p>y la siguiente muestra incluso el valor de la expresi√≥n:</p>
<pre><code class="language-text">[src\main.rs:8] new_vec.iter().map(|x| x * 2).collect::&lt;Vec&lt;i32&gt;&gt;() = [
    16,
    18,
    20,
]
</code></pre>
<p>y:</p>
<pre><code class="language-text">[src\main.rs:10] double_vec = [
    16,
    18,
    20,
]
</code></pre>
<h2 id="inspect"><a class="header" href="#inspect"><code>.inspect()</code></a></h2>
<p><code>.inspect()</code> es parecido a <code>dbg!</code>, pero se usa como <code>.map</code> en un iterador. Recibe un elemento iterador y se puede hacer lo que se quiera con √©l, el valor continuar√° en la cadena de funciones sin modificar. Por ejemplo, en el siguiente c√≥digo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let new_vec = vec![8, 9, 10];

    let double_vec = new_vec
        .iter()
        .map(|x| x * 2)
        .collect::&lt;Vec&lt;i32&gt;&gt;();
}
</code></pre></pre>
<p>Se quiere tener informaci√≥n sobre lo que va haciendo el c√≥digo. As√≠ que se puede a√±adir <code>.inspect()</code> en dos puntos:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let new_vec = vec![8, 9, 10];

    let double_vec = new_vec
        .iter()
        .inspect(|first_item| println!(&quot;El elemento contiene: {}&quot;, first_item))
        .map(|x| x * 2)
        .inspect(|next_item| println!(&quot;Y despu√©s vale: {}&quot;, next_item))
        .collect::&lt;Vec&lt;i32&gt;&gt;();
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">El elemento contiene: 8
Y despu√©s vale: 16
El elemento contiene: 9
Y despu√©s vale: 18
El elemento contiene: 10
Y despu√©s vale: 20
</code></pre>
<p>Como <code>.inspect()</code> recibe de par√°metro un cierre (closure), se puede codificar todo lo que se necesite:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let new_vec = vec![8, 9, 10];

    let double_vec = new_vec
        .iter()
        .inspect(|first_item| {
            println!(&quot;El elemento es: {}&quot;, first_item);
            match **first_item % 2 { // eL primer elemento es un &amp;i32 **
                0 =&gt; println!(&quot;Es par.&quot;),
                _ =&gt; println!(&quot;Es impar.&quot;),
            }
            println!(&quot;En binario es {:b}.&quot;, first_item);
        })
        .map(|x| x * 2)
        .collect::&lt;Vec&lt;i32&gt;&gt;();
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">El elemento es: 8
Es par.
En binario es 1000.
El elemento es: 9
Es impar.
En binario es 1001.
El elemento es: 10
Es par.
En binario es 1010.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tipos-de-str"><a class="header" href="#tipos-de-str">Tipos de <code>&amp;str</code></a></h1>
<p>Existe m√°s de un tipo de <code>&amp;str</code>:</p>
<ul>
<li>Cadenas de caracteres literales: que se construyen cuando se escribe c√≥digo como <code>let mi_cadena = &quot;Soy un &amp;str&quot;</code>. Este tipo de <code>&amp;str</code> dura toda la ejecuci√≥n del programa ya que est√°n escritas directamente en el c√≥digo fuente y as√≠ se traspasa al c√≥digo binario. El tipo real que tienen estas variables es <code>&amp;'static str</code>. El apostrofo <code>'</code> indica el tiempo o ciclo de vida (lifetime) de este valor. Las cadenas de caracteres literales tienen un tiempo de vida llamado <code>'static</code>, que sirve para expresar que la cadena existe durante toda la ejecuci√≥n del programa.</li>
<li><code>&amp;str prestados</code>: Es la forma habitual del tipo <code>&amp;str</code>. No tiene un tiempo de vida <code>'static</code>, su tiempo de vida es menor a la duraci√≥n de todo el programa. Por ejemplo, si se crea un <code>String</code> y se obtiene una referencia a ella, Rust la convertir√° a <code>&amp;str</code> si se necesita. Por ejemplo:</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn prints_str(my_str: &amp;str) { // Esta funci√≥n puede recibir &amp;String y &amp;str
    println!(&quot;{}&quot;, my_str);
}

fn main() {
    let my_string = String::from(&quot;I am a string&quot;);
    prints_str(&amp;my_string); // Se pasa a prints_str u &amp;String
}
</code></pre></pre>
<p>En Rust, todas las referencias tienen un tiempo de vida asociado. ¬øY qu√© es el tiempo de vida? Se ver√° a continuaci√≥n.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tiempos-de-vida-lifetimes"><a class="header" href="#tiempos-de-vida-lifetimes">Tiempos de vida (lifetimes)</a></h1>
<p>El tiempo de vida asociado a todos los valores y variables indica &quot;cu√°nto vive una variable&quot;. Solo es necesario pensar en ellos cuando se trabaja con referencias. Esto se debe a que las referencias no pueden vivir m√°s tiempo que el propio objeto al que referencian. Por ejemplo, esta funci√≥n no compila:</p>
<pre><pre class="playground"><code class="language-rust">fn returns_reference() -&gt; &amp;str {
    let my_string = String::from(&quot;I am a string&quot;);
    &amp;my_string // ‚ö†Ô∏è
}

fn main() {}
</code></pre></pre>
<p>El problema es que <code>my_string</code> solo vive dentro de la propia funci√≥n, pero la funci√≥n intenta devolver una referencia <code>&amp;my_string</code> y esta no podr√° existir cuando se libere <code>my_string</code> al terminar de ejecutarse la funci√≥n. Por eso el compilador falla.</p>
<p>Este otro c√≥digo tampoco funciona:</p>
<pre><pre class="playground"><code class="language-rust">fn returns_str() -&gt; &amp;str {
    let my_string = String::from(&quot;I am a string&quot;);
    &quot;I am a str&quot; // ‚ö†Ô∏è
}

fn main() {
    let my_str = returns_str();
    println!(&quot;{}&quot;, my_str);
}
</code></pre></pre>
<p>Aunque por poco. El compilador indica:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; src\main.rs:6:21
  |
6 | fn returns_str() -&gt; &amp;str {
  |                     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
  |
6 | fn returns_str() -&gt; &amp;'static str {
  |                     ^^^^^^^^
</code></pre>
<p>El mensaje <code>missing lifetieme specifier</code> significa que tenemos que a√±adir <code>'</code> con un tiempo de vida.</p>
<p>Despu√©s indica <code>contains a borrowed value, but there is no value for it to be borrowed from</code>. Esto signfiica que <code>I am a str</code> no se obtiene de ning√∫n sitio. Adem√°s, indica <code>consider using the 'static lifetime</code> escribiendo <code>&amp;'static str</code>. Por lo que el compilador piensa que se debe indicar que la variable es de tipo cadena de caracteres literal (como es el caso).</p>
<p>Con la modificaci√≥n, lo siguiente funciona:</p>
<pre><pre class="playground"><code class="language-rust">fn returns_str() -&gt; &amp;'static str {
    let my_string = String::from(&quot;I am a string&quot;);
    &quot;I am a str&quot;
}

fn main() {
    let my_str = returns_str();
    println!(&quot;{}&quot;, my_str);
}
</code></pre></pre>
<p>Que funcione, se debe a que se ha indicado al compilador que esta funci√≥n devuelve un <code>&amp;str</code> con un tiempo de vida est√°tico. Si se quisiera evolver <code>my_string</code> solo podr√≠a hacerse como <code>String</code>, no como referencia. El fallo del paso por referencia del primer ejemplo de este apartado, se debe a que la propiedad no se traspasar√≠a al c√≥digo que llamara a la funci√≥n y en la siguiente l√≠nea se eliminar√≠a el valor de <code>my_string</code>. Rust evita que exista una referencia cuyo tiempo de vida sea mayor que el del valor al que referencia.</p>
<p>Ahora <code>fn returns_str() -&gt; &amp;'static str</code> le dice a Rust que no debe preocuparse, se retorna una cadena de caracteres literal. La cadena de caracteres literal dura toda la ejecuci√≥n del programa. Se observa que se asemeja a los gen√©ricos. Cuando se indica al compilador algo como <code>&lt;T: Display&gt;</code>, se le est√° diciendo que solo se va a usar este c√≥digo con tipos <code>Display</code>. Los  tiempos de vida son similares: no se est√° cambiando nada en las propias variables, solo se est√° indicando al compilador cuales ser√°n los tiempos de vida de cada variable de entrada y de salida.</p>
<p>L√≥gicamente, <code>'static</code> no es el √∫nico tiempo de vida posible. Cada variable tiene su tiempo de vida, aunque normalmente no es necesario indicarlo en el c√≥digo. El compilador es inteligente y puede deducirlo por s√≠ mismo. Solo es necesario expresarlo en el c√≥digo cuando el compilador no puede hacerlo.</p>
<p>A continuaci√≥n se muestra un ejemplo de otro tiempo de vida. Si se quiere crear un struct <code>Ciudad</code> y pasarle un <code>&amp;str</code> para el nombre (por ejemplo, para que su rendimiento sea mejor que con un <code>String</code>). Se puede intentar as√≠ (este c√≥digo no funciona):</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Ciudad {
    name: &amp;str, // ‚ö†Ô∏è
    date_founded: u32,
}

fn main() {
    let mi_ciudad = Ciudad {
        name: &quot;Ichinomiya&quot;,
        date_founded: 1921,
    };
}
</code></pre></pre>
<p>El compilador indica:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; src\main.rs:3:11
  |
3 |     name: &amp;str,
  |           ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
2 | struct Ciudad&lt;'a&gt; {
3 |     name: &amp;'a str,
  |
</code></pre>
<p>Rust necesita un tiempo de vida para <code>&amp;str</code> porque <code>&amp;str</code> es una referencia. ¬øQu√© sucede cuando el valor al que apunta <code>name</code> se libera? No ser√≠a seguro usar este c√≥digo.</p>
<p>¬øQu√© pasa si se pone <code>'static</code>? ¬øfuncionar√° como en los casos anteriores? Si se prueba:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Ciudad {
    name: &amp;'static str, 
    date_founded: u32,
}

fn main() {
    let mi_Ciudad = Ciudad {
        name: &quot;Ichinomiya&quot;,
        date_founded: 1921,
    };

println!(&quot;{} se fund√≥ en {}&quot;, mi_Ciudad.name, mi_Ciudad.date_founded);

}
</code></pre></pre>
<p>En este caso funciona. Sin embargo, solo se le pueden pasar cadenas de caracteres literales, no referencias a otro tipo de valores. Por eso, este otro c√≥digo no funciona:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Ciudad {
    name: &amp;'static str, // debe existir el valor durante todo el programa
    date_founded: u32,
}

fn main() {
    let Ciudad_names = vec![&quot;Ichinomiya&quot;.to_string(), &quot;Kurume&quot;.to_string()]; // Ciudad_names no vive durante todo el programa

    let my_Ciudad = Ciudad {
        name: &amp;Ciudad_names[0], // ‚ö†Ô∏è Es un &amp;str, pero no &amp;'static str. Es una referencia a un valor interno de Ciudad_names
        date_founded: 1921,
    };

    println!(&quot;{} se fund√≥ en {}&quot;, my_Ciudad.name, my_Ciudad.date_founded);
}
</code></pre></pre>
<p>El compilador dice:</p>
<pre><code class="language-text">error[E0597]: `Ciudad_names` does not live long enough
  --&gt; src\main.rs:12:16
   |
12 |         name: &amp;Ciudad_names[0],
   |                ^^^^^^^^^^
   |                |
   |                borrowed value does not live long enough
   |                requires that `Ciudad_names` is borrowed for `'static`
...
18 | }
   | - `Ciudad_names` dropped here while still borrowed
</code></pre>
<p>Este ejemplo es importante entenderlo, ya que la referencia que se pasa s√≠ que vive lo suficiente. Pero lo que se ha indicado en el c√≥digo es que solo se le va a pasar <code>'static str'</code> y ese es el problema.</p>
<p>As√≠ que se va a intentar lo que el compilador suger√≠a antes: escribir <code>struct Ciudad&lt;'a&gt;</code> y <code>name: &amp;'a str</code>. Que significa que la referencia a <code>name</code> solo existe mientras exista el valor <code>struct Ciudad</code>.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Ciudad&lt;'a&gt; { // City has lifetime 'a
    name: &amp;'a str, // and name also has lifetime 'a.
    date_founded: u32,
}

fn main() {
    let ciudad_names = vec![&quot;Ichinomiya&quot;.to_string(), &quot;Kurume&quot;.to_string()];

    let my_Ciudad = Ciudad {
        name: &amp;ciudad_names[0],
        date_founded: 1921,
    };

    println!(&quot;{} se fund√≥ en {}&quot;, my_Ciudad.name, my_Ciudad.date_founded);
}
</code></pre></pre>
<p>Es necesario recordar que se puede escribir cualquier cosa en lugar de  <code>'a</code>. Vuelve a ser similar a los gen√©ricos en los que se escribe <code>T</code> y <code>U</code>, pero se puede escribir cualquier palabra.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct City&lt;'city&gt; { // El tiempo de vida se llama ahora 'city
    name: &amp;'city str, // y name vive solo lo que 'city
    date_founded: u32,
}

fn main() {}
</code></pre></pre>
<p>En todo caso, se suelen usar por convenci√≥n <code>'a</code>, <code>'b</code>, <code>'c</code>, etc. En caso de usar otros nombres, es conveniente aprovechar para que tengan sentido para los humanos.</p>
<p>Se presenta de nuevo una comparaci√≥n con los rasgos y gen√©ricos. Por ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

fn prints&lt;T: Display&gt;(input: T) {
    println!(&quot;T is {}&quot;, input);
}

fn main() {}
</code></pre></pre>
<p><code>T:Display</code> significa que solo se puede usar un valor si este implementa <code>Display</code>. No significa que doy <code>Display</code> a <code>T</code>.</p>
<p>Lo mismo sucede con los tiempos de vida. Si se escribe:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct City&lt;'a&gt; {
    name: &amp;'a str,
    date_founded: u32,
}

fn main() {}
</code></pre></pre>
<p>Significa que solo se permiten valores de referencia para <code>name</code> que duren al menos lo mismo que el <code>struct</code> de <code>City</code> que se est√° creando. No significa que el valor asignado a <code>name</code> pase a dura lo mismo que el <code>struct</code> de <code>City</code> creado.</p>
<p>Ahora se puede entender <code>&lt;'_&gt;</code> que se apareci√≥ anteriormente. Se denomina &quot;tiempo de vida an√≥nimo&quot; y es un indicador de que se est√°n usando referencias. Rust lo sugiere cuando se implementan <code>struct</code>. Por ejemplo: este es un c√≥digo que no funciona:</p>
<pre><pre class="playground"><code class="language-rust">    // ‚ö†Ô∏è
struct Adventurer&lt;'a&gt; {
    name: &amp;'a str,
    hit_points: u32,
}

impl Adventurer {
    fn take_damage(&amp;mut self) {
        self.hit_points -= 20;
        println!(&quot;{} has {} hit points left!&quot;, self.name, self.hit_points);
    }
}

fn main() {}
</code></pre></pre>
<p>Se ha hecho todo lo necesario para que la referencia en el <code>name</code> requira tener el tiempo de vida del <code>struct</code> como m√≠nimo. Sin embargo, Rust se queja de la parte de la implementaci√≥n.</p>
<pre><code class="language-text">error[E0726]: implicit elided lifetime not allowed here
 --&gt; src\main.rs:6:6
  |
6 | impl Adventurer {
  |      ^^^^^^^^^^- help: indicate the anonymous lifetime: `&lt;'_&gt;`
</code></pre>
<p>Pide que se a√±ada una tiempo de vida an√≥nimo para que quede claro en la implementaci√≥n que existe una referencia en este c√≥digo que se est√° usando. Basta con atender a la sugerencia:</p>
<pre><pre class="playground"><code class="language-rust">struct Adventurer&lt;'a&gt; {
    name: &amp;'a str,
    hit_points: u32,
}

impl Adventurer&lt;'_&gt; {
    fn take_damage(&amp;mut self) {
        self.hit_points -= 20;
        println!(&quot;{} has {} hit points left!&quot;, self.name, self.hit_points);
    }
}

fn main() {}
</code></pre></pre>
<p>Este tiempo de vida an√≥nimo simplifica la forma general que tendr√≠a que haber tenido en este caso <code>impl&lt;'a&gt; Adventurer&lt;'a&gt;</code>.</p>
<p>Los tiempos de vida son uno de los temas que puede ser m√°s dif√≠cil en Rust. A continuaci√≥n se muestran algunas sugerencias para que sirvan de ayuda:</p>
<ul>
<li>Se pueden evitar las referencias pasando clones y con objetos copy, etc.</li>
<li>La mayor parte de las veces en las que el compilador necesita un tiempo de vida, simplemente habr√° que escribir <code>'a</code> en un par de sitios y funcionar√°.</li>
<li>Se puede ir aprendiendo este tema en peque√±as dosis. Se puede escribir el c√≥digo con valores propietarios, sin referencias, luego convertir uno de ellos en referencia. El compilador empezar√° a quejarse y a dar sugerencias. Si se complica mucho, se puede deshacer el cambio e intentarlo m√°s tarde.</li>
</ul>
<p>Se presenta aqu√≠ un ejemplo que ya contiene una referencia y no indica tiempo de vida alguno. Se seguir√°n las indicaciones para subsanarlo.</p>
<pre><pre class="playground"><code class="language-rust">// ‚ö†Ô∏è
struct Adventurer {
    name: &amp;str,
    hit_points: u32,
}

impl Adventurer {
    fn take_damage(&amp;mut self) {
        self.hit_points -= 20;
        println!(&quot;{} has {} hit points left!&quot;, self.name, self.hit_points);
    }
}

impl std::fmt::Display for Adventurer {
        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
            write!(f, &quot;{} has {} hit points.&quot;, self.name, self.hit_points)
        }
}

fn main() {}
</code></pre></pre>
<p>La primera queja es:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; src\main.rs:2:11
  |
2 |     name: &amp;str,
  |           ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 | struct Adventurer&lt;'a&gt; {
2 |     name: &amp;'a str,
  |
</code></pre>
<p>Sugiere qu√© es lo que hay que hacer:</p>
<pre><pre class="playground"><code class="language-rust">// ‚ö†Ô∏è
struct Adventurer&lt;'a&gt; {
    name: &amp;'a str,
    hit_points: u32,
}

impl Adventurer {
    fn take_damage(&amp;mut self) {
        self.hit_points -= 20;
        println!(&quot;{} has {} hit points left!&quot;, self.name, self.hit_points);
    }
}

impl std::fmt::Display for Adventurer {
        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
            write!(f, &quot;{} has {} hit points.&quot;, self.name, self.hit_points)
        }
}

fn main() {}
</code></pre></pre>
<p>Ahora no tiene problema con esa parte de c√≥digo, pero se queja de otra parte:</p>
<pre><code class="language-text">error[E0726]: implicit elided lifetime not allowed here
 --&gt; src\main.rs:6:6
  |
6 | impl Adventurer {
  |      ^^^^^^^^^^- help: indicate the anonymous lifetime: `&lt;'_&gt;`

error[E0726]: implicit elided lifetime not allowed here
  --&gt; src\main.rs:12:28
   |
12 | impl std::fmt::Display for Adventurer {
   |                            ^^^^^^^^^^- help: indicate the anonymous lifetime: `&lt;'_&gt;`
</code></pre>
<p>As√≠ que se sigue la sugerencia y se modifica como pide:</p>
<pre><pre class="playground"><code class="language-rust">struct Adventurer&lt;'a&gt; {
    name: &amp;'a str,
    hit_points: u32,
}

impl Adventurer&lt;'_&gt; {
    fn take_damage(&amp;mut self) {
        self.hit_points -= 20;
        println!(&quot;{} has {} hit points left!&quot;, self.name, self.hit_points);
    }
}

impl std::fmt::Display for Adventurer&lt;'_&gt; {

        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
            write!(f, &quot;{} has {} hit points.&quot;, self.name, self.hit_points)
        }
}

fn main() {
    let mut billy = Adventurer {
        name: &quot;Billy&quot;,
        hit_points: 100_000,
    };
    println!(&quot;{}&quot;, billy);
    billy.take_damage();
}
</code></pre></pre>
<p>Esto da como salida:</p>
<pre><code class="language-text">Billy has 100000 hit points.
Billy has 99980 hit points left!
</code></pre>
<p>As√≠ se puede observar que los tiempos de vida en muchas ocasiones sirven para que el compilador se asegure de que no se est√° cometiendo un error. Normalmente es lo suficientemente inteligente para determinar qu√© tiempo de vida tiene cada valor y solo &quot;pregunta&quot; cuando no lo puede saber con seguridad.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutabilidad-interior"><a class="header" href="#mutabilidad-interior">Mutabilidad interior</a></h1>
<h2 id="cell"><a class="header" href="#cell">Cell</a></h2>
<p>La <strong>mutabilidad interior</strong> permite modificar el interior de un elemento sin necesidad de que la variable sea <code>mut</code>.</p>
<p>Rust permite hacer esto en algunos casos de forma segura, modificando los valores internos de un struct que es inmutable. Cada uno de los mecanismos que se tienen a disposici√≥n, sigue unas reglas que aseguran que la modificaci√≥n es segura.</p>
<p>En primer lugar, se presenta el siguiente ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">struct PhoneModel {
    company_name: String,
    model_name: String,
    screen_size: f32,
    memory: usize,
    date_issued: u32,
    on_sale: bool,
}

fn main() {
    let super_phone_3000 = PhoneModel {
        company_name: &quot;YY Electronics&quot;.to_string(),
        model_name: &quot;Super Phone 3000&quot;.to_string(),
        screen_size: 7.5,
        memory: 4_000_000,
        date_issued: 2020,
        on_sale: true,
    };

}
</code></pre></pre>
<p>En este ejemplo, es mejor que los campos de <code>PhoneModel</code> sean inmutables. Por ejemplo, <code>date_issued</code> y <code>screen_size</code> nunca cambian.</p>
<p>Pero en su interior, tambi√©n existe un campo denominado <code>on_sale</code>. Un modelo de tel√©fono empieza su vida estando a la venta (<code>true</code> en este campo), pero m√°s tarde se deja de vender. ¬øSe puede hacer que solo este campo sea modificable sin que se tenga que hacer todo el struct modificable? Es decir, sin tener que hacer <code>let mut super_phone_3000 = ...</code>, ya que de hacerlo as√≠, todos los campos ser√≠an modificables.</p>
<p>Rust tiene varias formas de permitir la modificaci√≥n segura dentro de un lugar que es inmutable en general. La forma m√°s simple es el uso de <code>Cell</code>. Se tiene que incluir <code>use std::cell::Cell</code> para poder usarlo y a partir de ah√≠ usar normalmente <code>Cell</code>.</p>
<pre><pre class="playground"><code class="language-rust">use std::cell::Cell;

struct PhoneModel {
    company_name: String,
    model_name: String,
    screen_size: f32,
    memory: usize,
    date_issued: u32,
    on_sale: Cell&lt;bool&gt;,
}

fn main() {
    let super_phone_3000 = PhoneModel {
        company_name: &quot;YY Electronics&quot;.to_string(),
        model_name: &quot;Super Phone 3000&quot;.to_string(),
        screen_size: 7.5,
        memory: 4_000_000,
        date_issued: 2020,
        on_sale: Cell::new(true),
    };

    // 10 years later, super_phone_3000 is not on sale anymore
    super_phone_3000.on_sale.set(false);
}
</code></pre></pre>
<p><code>Cell</code>funciona para todos los tipos, pero funciona mejor para los tipos simples <code>Copy</code> porque <code>Cell</code> no usa referencias. Tiene un m√©todo denominado <code>get()</code> que solo funciona en tipos <code>Copy</code>.</p>
<p>Otro tipo que se puede usar es <code>RefCell</code>.</p>
<h2 id="refcell"><a class="header" href="#refcell">RefCell</a></h2>
<p>Un <code>RefCell</code> es otra forma de cambiar valores sin necesidad de declararlos <code>mut</code>. Es como <code>Cell</code>, pero utiliza referencias en lugar de copias.</p>
<p>El ejemplo a continuaci√≥n permite ver c√≥mo es similar a <code>Cell</code>.</p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;

#[derive(Debug)]
struct User {
    id: u32,
    year_registered: u32,
    username: String,
    active: RefCell&lt;bool&gt;,
    // Many other fields
}

fn main() {
    let user_1 = User {
        id: 1,
        year_registered: 2020,
        username: &quot;User 1&quot;.to_string(),
        active: RefCell::new(true),
    };

    println!(&quot;{:?}&quot;, user_1.active);
}
</code></pre></pre>
<p>Este ejemplo imprime <code>RefCell { value: true }</code>.</p>
<p><code>RefCell</code> tiene muchos m√©todos. Dos de ellos son <code>.borrow()</code> y <code>.borrow_mut()</code>. Con estos m√©todos, se puede hacer lo mismo que con <code>&amp;</code> y <code>&amp;mut</code>. Las reglas son las mismas:</p>
<ul>
<li>Se pueden hacer muchos pr√©stamos simult√°neos.</li>
<li>Solo se puede hacer un pr√©stamo modificable.</li>
<li>No se pueden hacer pr√©stamos simult√°neos de ambos tipos.</li>
</ul>
<p>Modificar el valor de un <code>RefCell</code> es as√≠ de f√°cil:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
user_1.active.replace(false);
println!(&quot;{:?}&quot;, user_1.active);
<span class="boring">}
</span></code></pre></pre>
<p>Dispone tambi√©n de otros m√©todos como <code>replace_with</code> que utiliza un cierre (closure):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
let date = 2020;

user_1
    .active
    .replace_with(|_| if date &lt; 2000 { true } else { false });
println!(&quot;{:?}&quot;, user_1.active);
}
<span class="boring">}
</span></code></pre></pre>
<p>Es necesario prestar atenci√≥n al uso de <code>RefCell</code> ya que valida si los pr√©stamos son correctos en tiempo de ejecuci√≥n. No en tiempo de compilaci√≥n. Es decir, cuando el programa ya se est√° ejecutando. Por eso, cosas como esta compilar√°n, aunque sean err√≥neas:</p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;

#[derive(Debug)]
struct User {
    id: u32,
    year_registered: u32,
    username: String,
    active: RefCell&lt;bool&gt;,
    // Many other fields
}

fn main() {
    let user_1 = User {
        id: 1,
        year_registered: 2020,
        username: &quot;User 1&quot;.to_string(),
        active: RefCell::new(true),
    };

    let borrow_one = user_1.active.borrow_mut(); // primer pr√©stamo modificable - correcto
    let borrow_two = user_1.active.borrow_mut(); // segundo pr√©stamo modificable (sigue el primero) - incorrectos
}
</code></pre></pre>
<p>Si se ejecuta el c√≥digo anterior, Rust entrar√° en <em>p√°nico</em>:</p>
<pre><code class="language-text">thread 'main' panicked at 'already borrowed: BorrowMutError', src/main.rs:21:36
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
error: process didn't exit successfully: `target\debug\rust_book.exe` (exit code: 101)
</code></pre>
<p>Lo destacable del mensaje de error es <code>already borrowed: BorrowMutError</code>. As√≠ que cuando se usan <code>RefCell</code> resulta conveniente ejecutar el c√≥digo y pasar un conjunto de pruebas.</p>
<h2 id="mutex"><a class="header" href="#mutex">Mutex</a></h2>
<p>Los <code>Mutex</code> posibilitan otra forma de modificar valores sin declararlos como <code>mut</code>. Significa <em>exclusi√≥n mutua</em>, lo que significa que &quot;solo puede modificarlo un proceso cada vez&quot;. Por eso, el uso de <code>mutex</code> es seguro, porque permite la modificaci√≥n interna, pero solo a un proceso cada vez.  Es √∫til en la programaci√≥n concurrente. Para ello, este tipo utiliza <code>.lock()</code>. Esta funci√≥n es como cerrar la puerta con un candado desde dentro: se entra en una habitaci√≥n, se cierra con llave y a partir de ah√≠, se puede modificar lo que contenga la habitaci√≥n. Ning√∫n otro proceso puede entrar a detener o contradecir los cambios.</p>
<p>Los <code>mutex</code> son m√°s f√°ciles de explicar a trav√©s de ejemplos:</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let my_mutex = Mutex::new(5); // Un nuevo Mutex&lt;i32&gt;. No se dice que sea mut
    let mut mutex_changer = my_mutex.lock().unwrap(); // mutex_changer es un MutexGuard
                                // Esta veriable tiene que ser  mut para cambiarla
                                // Con ella se tiene acceso al contenido de Mutex
                                // Si se intenta imprimir el mutex:

    println!(&quot;{:?}&quot;, my_mutex); // Se imprime &quot;Mutex { data: &lt;locked&gt; }&quot;
                                // El mensaje indica que no es posible acceder al valor,
                                // est√° bloquedo y solo puede acceder mutex_changer
                                // mientras mantenga el bloqueo

    println!(&quot;{:?}&quot;, mutex_changer); // Esto s√≠ funciona, imprime 5. Se cambiara a 6.

    *mutex_changer = 6; // mutex_changer es un MutexGuard&lt;&amp;i32&gt; se usa * para cambiar el valor i32

    println!(&quot;{:?}&quot;, mutex_changer); // Ahora indica 6
}
</code></pre></pre>
<p>¬øC√≥mo se puede &quot;reabrir la puerta&quot;? ¬øC√≥mo se puede liberar el bloqueo del valor que a√∫n mantiene <code>mutex_changer</code> para que otro lo pueda usar? Es necesario que la variable <code>MutexGuard</code> salga fuera de √°mbito. Que su c√≥digo finalice. Por ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let my_mutex = Mutex::new(5);
    {
        let mut mutex_changer = my_mutex.lock().unwrap();
        *mutex_changer = 6;
    } // mutex_changer sale de √°mbito - desaparece. Ya no est√° bloquedo el valor.

    println!(&quot;{:?}&quot;, my_mutex); // Ahora indica: Mutex { data: 6 }
}
</code></pre></pre>
<p>Es necesario tener cuidado en la programaci√≥n concurrente ya que se pueden producir interbloqueos debido a que un segundo intento de bloqueo sobre un <code>mutex</code> mientras est√° bloquedo por otra variable producir√° la parada y espera del segundo intento. Sin programaci√≥n concurrente, se puede ver en el siguiente ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let my_mutex = Mutex::new(5);
    let mut mutex_changer = my_mutex.lock().unwrap(); // mutex_changer tiene el bloqueo
    let mut other_mutex_changer = my_mutex.lock().unwrap(); // other_mutex_changer quiere bloquear
                                    // el programa se queda parado esperando
                                    // y esperando
                                    // y esperar√° para siempre.

    println!(&quot;Esto nunca se imprimir√°...&quot;);
}
</code></pre></pre>
<p>Existe otro m√©todo <code>try_lock()</code> que intenta obtener el bloqueo una vez y si no lo consigue abando. En este caso, no se debe usar <code>try_lock().unwrap()</code> ya que si no consigue el bloqueo, la aplicaci√≥n entrar√° en <em>p√°nico</em>. En este caso no se puede renunciar a <code>let</code> o <code>match</code> para validar correctamente:</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let my_mutex = Mutex::new(5);
    let mut mutex_changer = my_mutex.lock().unwrap();
    let mut other_mutex_changer = my_mutex.try_lock(); // intenta obtener el bloqueo

    if let Ok(value) = other_mutex_changer {
        println!(&quot;El  MutexGuard contiene: {}&quot;, value)
    } else {
        println!(&quot;No se pudo obtener el bloqueo&quot;)
    }
}
</code></pre></pre>
<p>Tampoco es necesario crear una variable para modificar el valor:</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let my_mutex = Mutex::new(5);

    *my_mutex.lock().unwrap() = 6;

    println!(&quot;{:?}&quot;, my_mutex);
}
</code></pre></pre>
<p>La l√≠nea de c√≥digo <code>*my_mutex.lock().unwrap() = 6;</code> significa que *bloquea para mi uso el valor contenido en el mutex y convi√©rtela en el 6&quot;. De esta forma, no existe variable y, por lo tanto, no es necesario desbloquear el mutex saliendo del √°mbito de una variable. Esto se puede hacer tantas veces como se quiera:</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let my_mutex = Mutex::new(5);

    for _ in 0..100 {
        *my_mutex.lock().unwrap() += 1; // bloquea y desbloquea 100 veces
    }

    println!(&quot;{:?}&quot;, my_mutex);
}
</code></pre></pre>
<h2 id="rwlock"><a class="header" href="#rwlock">RwLock</a></h2>
<p><code>RwLock</code> significa &quot;bloqueo de lectura y escritura&quot;. Es como un <code>Mutex</code>, pero tambi√©n como un <code>RefCell</code>. Se utiliza <code>.write().unwrap()</code> para modificarlo, en lugar de <code>.lock().unwrap()</code>. Y tambi√©n se puede usar <code>.read().unwrap()</code> para obtener acceso de lectura. Es como <code>RefCell</code>ya que sigue las reglas:</p>
<ul>
<li>se pueden tener muchas varaibles <code>.read()</code>.</li>
<li>se puede tener una sola variable <code>.write()</code>.</li>
<li>no se puede tener a la vez una variable <code>.write()</code> con otras variables.</li>
</ul>
<p>El programa se quedar√° bloqueado para siempre si se intenta <code>.write()</code> cuando no se puede obtener acceso.</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::RwLock;

fn main() {
    let my_rwlock = RwLock::new(5);

    let read1 = my_rwlock.read().unwrap(); // un .read() es correcto
    let read2 = my_rwlock.read().unwrap(); // dos.read() tambi√©n es correcto

    println!(&quot;{:?}, {:?}&quot;, read1, read2);

    let write1 = my_rwlock.write().unwrap(); // uh oh, aqu√≠ el programa se ejecutar√° para siempre
}
</code></pre></pre>
<p>Se debe liberar el bloqueo previo. Para ello se usa <code>std::mem::drop</code>. Igual que se pod√≠a hacer con <code>mutex</code>.</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::RwLock;
use std::mem::drop; // We will use drop() many times

fn main() {
    let my_rwlock = RwLock::new(5);

    let read1 = my_rwlock.read().unwrap();
    let read2 = my_rwlock.read().unwrap();

    println!(&quot;{:?}, {:?}&quot;, read1, read2);

    drop(read1);
    drop(read2); // descartamos las dos variables, para oder usar .write()

    let mut write1 = my_rwlock.write().unwrap();
    *write1 = 6;
    drop(write1);
    println!(&quot;{:?}&quot;, my_rwlock);
}
</code></pre></pre>
<p>Tambi√©n se puede usar <code>try_read()</code> y <code>try_write()</code>.</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::RwLock;

fn main() {
    let my_rwlock = RwLock::new(5);

    let read1 = my_rwlock.read().unwrap();
    let read2 = my_rwlock.read().unwrap();

    if let Ok(mut number) = my_rwlock.try_write() {
        *number += 10;
        println!(&quot;Ahora el n√∫emro es {}&quot;, number);
    } else {
        println!(&quot;No se puede obtener acceso, lo siento.&quot;)
    };
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cow"><a class="header" href="#cow">Cow</a></h1>
<p><code>Cow</code> es un tipo de enumerado que significa &quot;clone on write&quot; (clonq en escritura). Permite devolver una referencia <code>&amp;str</code> si no se necesita un <code>String</code>. Y devuelve un <code>String</code>, cuando se necesita. Lo mismo sucede para cualquier otro tipo, como arrays vs. Vec, etc.</p>
<p>Para entenderlo, se puede observar su definici√≥n:</p>
<pre><pre class="playground"><code class="language-rust">pub enum Cow&lt;'a, B&gt;
where
    B: 'a + ToOwned + ?Sized,
 {
    Borrowed(&amp;'a B),
    Owned(&lt;B as ToOwned&gt;::Owned),
}

fn main() {}
</code></pre></pre>
<p>En el momento en que se aparece una indicaci√≥n de tiempo de vida como <code>'a</code>, se tiene conocimiento de que este tipo funciona con referencias, ya que, como se ha visto, es para lo que tienen sentido las indicaciones de tiempo de vida.</p>
<p>El rasgo <code>ToOwned</code> significa que <code>B</code> debe ser un tipo que puede convertirse en un tipo &quot;adue√±ado&quot;, que tiene &quot;una variable propietario&quot;. Por ejemplo, <code>str</code> que normalmente se usa a trav√©s de pr√©stamo por referencia, se puede convertir en una <code>String</code> que tendr√° una variable propietario.</p>
<p>Lo siguiente que aparece es <code>?Sized</code>, que significa que &quot;puede ser Sized o no&quot;. Casi todos los tipos de Rust son <code>Sized</code>, pero hay algunos, como <code>str</code>, que no. Es el motivo por el que este tipo se debe usar siempre por referencia, porque el compilador no conoce su tama√±o. Por ello, si se quiere que una definici√≥n use tipos como <code>str</code>, resulta necesario que admita <code>?Sized</code>.</p>
<p>A continuaci√≥n, el c√≥digo presenta las variantes del enumerado. Que son <code>Borrowed</code> y <code>Owned</code>.</p>
<p>Por ejemplo, si se imagina una funci√≥n que devolviera <code>Cow&lt;'static, str&gt;</code>. Si a esa funci√≥n se le dice que devuelva <code>&quot;Mi mensaje&quot;.into()</code>, Rust mirar√° el tipo de &quot;Mi mensaje&quot;, que es un <code>str</code>. Se trata de un tipo <code>Borrowed</code>, por lo que el tipo seleccionado del enumerado ser√° <code>Borrowed(&amp;'a, B)</code> y el tipo concreto que se devuelve es <code>Cow::Borrowed(&amp;'static str)</code>.</p>
<p>Si en vez de lo anterior, se le pidiera devolver <code>format!(&quot;{}&quot;, &quot;Mi mensaje&quot;).into()</code>, entonces el tipo es <code>String</code>, porque <code>format!</code> crea <code>String</code>. Y el tipo enumerado seleccionado ser√° <code>Owned</code>.</p>
<p>A continuaci√≥n se presenta un ejemplo para probar <code>Cow</code>. Se pasar√° un n√∫mero a una funci√≥n que devuelve <code>Cow&lt;'static, str&gt;</code>. Dependiendo del n√∫mero, se crear un <code>&amp;str</code> o una <code>String</code>. Despu√©s, se usa <code>.into()</code> para convertirlo en un <code>Cow</code>. De esta forma, Rust seleccionar√° <code>Cow::Borrowed</code> o <code>Cow::Owned</code>. Se usa un <code>match</code> al finalizar, para ver qu√© se ha seleccionado:</p>
<pre><pre class="playground"><code class="language-rust">use std::borrow::Cow;

fn modulo_3(input: u8) -&gt; Cow&lt;'static, str&gt; {
    match input % 3 {
        0 =&gt; &quot;El resto es 0&quot;.into(),
        1 =&gt; &quot;El resto es 1&quot;.into(),
        remainder =&gt; format!(&quot;El resto es {}&quot;, remainder).into(),
    }
}

fn main() {
    for number in 1..=6 {
        match modulo_3(number) {
            Cow::Borrowed(message) =&gt; println!(&quot;{}, es el valor que se pasa. El Cow es prestado en este mensaje: {}&quot;, number, message),
            Cow::Owned(message) =&gt; println!(&quot;{}, es el valor que se pasa. El Cow es propietario en este mensaje: {}&quot;, number, message),
        }
    }
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">1, es el valor que se pasa. El Cow es prestado en este mensaje: El resto es 1
2, es el valor que se pasa. El Cow es propietario en este mensaje: El resto es 2
3, es el valor que se pasa. El Cow es prestado en este mensaje: El resto es 0
4, es el valor que se pasa. El Cow es prestado en este mensaje: El resto es 1
5, es el valor que se pasa. El Cow es propietario en este mensaje: El resto es 2
6, es el valor que se pasa. El Cow es prestado en este mensaje: El resto es 0
</code></pre>
<p><code>Cow</code> tiene otros m√©todos como <code>into_owned</code>o <code>into_borrowed</code> para cambiar el tipo manualmente si resulta necesario.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="alias-de-tipos"><a class="header" href="#alias-de-tipos">Alias de tipos</a></h1>
<p>Un alias para un tipo permite darle un nuevo nombre. Normalmente, se usan cuando se tiene un nombre de tipo muy largo que no se quiere escribir cada vez. Tambi√©n sirve para cuando se quiere dar un nombre m√°s apropiado o f√°cil de recordar en el contexto de la aplicaci√≥n. A continuaci√≥n se muestran dos ejemplos de alias.</p>
<p>El siguiente ejemplo sirve para darle un nombre m√°s f√°cil de comprender en el c√≥digo:</p>
<pre><pre class="playground"><code class="language-rust">type CharacterVec = Vec&lt;char&gt;;

fn main() {}
</code></pre></pre>
<p>EL siguiente ejemplo sirve para mostrar un caso con un tipo dif√≠cil de entender:</p>
<pre><pre class="playground"><code class="language-rust">// this return type is extremely long
fn returns&lt;'a&gt;(input: &amp;'a Vec&lt;char&gt;) -&gt; std::iter::Take&lt;std::iter::Skip&lt;std::slice::Iter&lt;'a, char&gt;&gt;&gt; {
    input.iter().skip(4).take(5)
}

fn main() {}
</code></pre></pre>
<p>Con un alias queda mucho m√°s claro:</p>
<pre><pre class="playground"><code class="language-rust">type SkipFourTakeFive&lt;'a&gt; = std::iter::Take&lt;std::iter::Skip&lt;std::slice::Iter&lt;'a, char&gt;&gt;&gt;;

fn returns&lt;'a&gt;(input: &amp;'a Vec&lt;char&gt;) -&gt; SkipFourTakeFive {
    input.iter().skip(4).take(5)
}

fn main() {}
</code></pre></pre>
<p>L√≥gicamente, tambi√©n se puede importar un tipo para hacer las definiones m√°s simples. El ejemplo anterior quedar√≠a as√≠:</p>
<pre><pre class="playground"><code class="language-rust">use std::iter::{Take, Skip};
use std::slice::Iter;

fn returns&lt;'a&gt;(input: &amp;'a Vec&lt;char&gt;) -&gt; Take&lt;Skip&lt;Iter&lt;'a, char&gt;&gt;&gt; {
    input.iter().skip(4).take(5)
}

fn main() {}
</code></pre></pre>
<p>As√≠ que se puede decidir qu√© es mejor en cada caso.</p>
<p>Los alias no crean un tipo nuevo. Solo se trata de un nuevo nombre que representa al tipo ya existente. Por ello, si se escribe el siguiente c√≥digo <code>type File = String;</code>, el compilador solo ve el tipo <code>String</code>. Por ello, imprimir√° <code>true</code>:</p>
<pre><pre class="playground"><code class="language-rust">type File = String;

fn main() {
    let my_file = File::from(&quot;I am file contents&quot;);
    let my_string = String::from(&quot;I am file contents&quot;);
    println!(&quot;{}&quot;, my_file == my_string);
}
</code></pre></pre>
<p>¬øC√≥mo se har√≠a si realmente se quisiera un tipo nuevo? Lo m√°s simple es usar el tipo de <code>struct</code> que representa tuplas incluyendo el tipo preexistente (Se trata de un uso idiom√°tico de Rust que se denomina <code>newtype</code>).</p>
<pre><pre class="playground"><code class="language-rust">struct File(String); // File es un envoltorio de String

fn main() {
    let my_file = File(String::from(&quot;I am file contents&quot;));
    let my_string = String::from(&quot;I am file contents&quot;);
}
</code></pre></pre>
<p>Ahora, el siguiente c√≥digo ya no funciona debido a que son dos tipos diferentes:</p>
<pre><pre class="playground"><code class="language-rust">struct File(String); // File es un envoltorio de String

fn main() {
    let my_file = File(String::from(&quot;I am file contents&quot;));
    let my_string = String::from(&quot;I am file contents&quot;);
    println!(&quot;{}&quot;, my_file == my_string);  // ‚ö†Ô∏è no se puede comparar File con String
}
</code></pre></pre>
<p>Para poder compararlos, hay que recuperar la cadena de texto incluida en <code>File</code> con <code>my_file.0</code>:</p>
<pre><pre class="playground"><code class="language-rust">struct File(String);

fn main() {
    let my_file = File(String::from(&quot;I am file contents&quot;));
    let my_string = String::from(&quot;I am file contents&quot;);
    println!(&quot;{}&quot;, my_file.0 == my_string); // my_file.0 es String, as√≠ que imprime true
}
</code></pre></pre>
<p>El nuevo tipo creado, no tienen ning√∫n rasgo, pero se pueden implementar como siempre.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug)]
struct File(String);
<span class="boring">}
</span></code></pre></pre>
<p>En el c√≥digo anterior, el tipo <code>File</code> se puede clonar y depurar (imprimir sus valores), pero no dispone de los dem√°s rasgos de <code>String</code>. Quien s√≠ sigue teniendo dichos rasgos es la cadena interior <code>.0</code>. Si este c√≥digo se usara como librer√≠a en otros programas, esta cadena interior no estar√≠a accesible, salvo en el caso de que se marcara como <code>pub</code>. Por eso, en esta clase de tipos es habitual el uso del rasgo <code>Deref</code>. Ambos conceptos, <code>pub</code> y <code>Deref</code>, se ver√°n m√°s adelante.</p>
<h2 id="importar-y-redenominar-dentro-de-una-funci√≥n"><a class="header" href="#importar-y-redenominar-dentro-de-una-funci√≥n">Importar y redenominar dentro de una funci√≥n</a></h2>
<p>Normalmente, se escribe <code>use</code> al inicio del programa, de esta forma:</p>
<pre><pre class="playground"><code class="language-rust">use std::cell::{Cell, RefCell};

fn main() {}
</code></pre></pre>
<p>Pero es posible, como se ha visto, usarlo en cualquier parte del c√≥digo. Especialmente en funciones con enumerados que tienen nombres largos. Por ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">enum MapDirection {
    North,
    NorthEast,
    East,
    SouthEast,
    South,
    SouthWest,
    West,
    NorthWest,
}

fn main() {}

fn give_direction(direction: &amp;MapDirection) {
    match direction {
        MapDirection::North =&gt; println!(&quot;You are heading north.&quot;),
        MapDirection::NorthEast =&gt; println!(&quot;You are heading northeast.&quot;),
        // Hay que teclear mucho... Y seguir tecleando el resto de opciones
    }
}
</code></pre></pre>
<p>Sin embargo, es posible simplificar escribiendo un <code>use</code> dentro de la propia funci√≥n.</p>
<pre><pre class="playground"><code class="language-rust">enum MapDirection {
    North,
    NorthEast,
    East,
    SouthEast,
    South,
    SouthWest,
    West,
    NorthWest,
}

fn main() {}

fn give_direction(direction: &amp;MapDirection) {
    use MapDirection::*; // Se importa todo en MapDirection
    let m = &quot;You are heading&quot;;

    match direction {
        North =&gt; println!(&quot;{} north.&quot;, m),
        NorthEast =&gt; println!(&quot;{} northeast.&quot;, m),
        // Es un poco menos a escribir
        // ‚ö†Ô∏è
    }
}
</code></pre></pre>
<p>Se ha visto ya que <code>::*</code> significa que &quot;se importa todo lo que venga despu√©s de ::&quot;. En este caso, significa que se importa <code>North</code>, <code>NorthEast</code>, ... y as√≠ hasta <code>NorthWest</code>. Tambi√©n se puede hacer la importar c√≥digo de terceros. Esto puede dar lugar a problemas cuando parte de nuestro c√≥digo tiene nomenclatura id√©ntica a la de otras librer√≠as. Por eso, no es recomendable usar <code>::*</code> a menos que se est√© seguro de ello.</p>
<p>Algunas veces se observar√° que existe una secci√≥n denominada <code>prelude</code> en el c√≥digo de otras librer√≠as. Por convenio, esta es la forma de agrupar los elementos que se necesitar√°n de forma habitual. En este caso, la forma de importarlo recomendada, s√≠ suele ser con <code>*</code>, as√≠: <code>name::prelude::*</code>. Se hablar√° m√°s de ello en las secciones dedicadas a <code>modules</code> y <code>crates</code>.</p>
<p>Tambi√©n se puede usar <code>as</code> para cambiar los nombres. Por ejemplo, se puede dar el caso de estar utilizando el c√≥digo de otro desarrollador y no se pueden cambiar los nombres en un <code>enum</code>:</p>
<pre><pre class="playground"><code class="language-rust">enum FileState {
    CannotAccessFile,
    FileOpenedAndReady,
    NoSuchFileExists,
    SimilarFileNameInNextDirectory,
}

fn main() {}
</code></pre></pre>
<p>As√≠ que se puede importar todo y luego cambiarle los nombres.</p>
<pre><pre class="playground"><code class="language-rust">enum FileState {
    CannotAccessFile,
    FileOpenedAndReady,
    NoSuchFileExists,
    SimilarFileNameInNextDirectory,
}

fn give_filestate(input: &amp;FileState) {
    use FileState::{
        CannotAccessFile as NoAccess,
        FileOpenedAndReady as Good,
        NoSuchFileExists as NoFile,
        SimilarFileNameInNextDirectory as OtherDirectory
    };
    match input {
        NoAccess =&gt; println!(&quot;Can't access file.&quot;),
        Good =&gt; println!(&quot;Here is your file&quot;),
        NoFile =&gt; println!(&quot;Sorry, there is no file by that name.&quot;),
        OtherDirectory =&gt; println!(&quot;Please check the other directory.&quot;),
    }
}

fn main() {}
</code></pre></pre>
<p>Por lo que ahora se puede escribir <code>OtherDirectory</code> en lugar de <code>FileState::SimilarFileNameInNextDirectory</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="la-macro-todo"><a class="header" href="#la-macro-todo">La macro <code>todo!</code></a></h1>
<p>En ocasiones, se necesita escribir c√≥digo para ayudar a imaginar el proyecto que se est√° desarrollando. Por ejemplo, se puede imaginar un proyecto para hacer algo con libros. Esto es lo que se puede ir pensando mientras se va escribiendo:</p>
<pre><pre class="playground"><code class="language-rust">struct Libro {} // Primero necesitar√© una estructura para los libros.
               // Nada aqu√≠ a√∫n - se a√±adir√° m√°s tarde

enum TipoLibro { // Un Libro puede ser de TapaDura o de TapaBlanda: necesito un enumerado
    TapaDura,
    TapaBlanda,
}

fn get_libro(libro: &amp;Libro) -&gt; Option&lt;String&gt; {} // ‚ö†Ô∏è get_libro deber√≠a recibir un &amp;Libro y devolver un Option&lt;String&gt;

fn delete_libro(libro: Libro) -&gt; Result&lt;(), String&gt; {} // delete_libro deber√≠a recibir un Libro y devolver un Result...
                        // TODO: bloque impl con el cntenido de estas funciones...
fn check_tipo_libro(tipo_libro: &amp;TipoLibro) { // Me aseguro de que este match funciona
    match tipo_libro {
        TipoLibro::TapaDura =&gt; println!(&quot;Es TapaDura&quot;),
        TipoLibro::TapaBlanda =&gt; println!(&quot;Es TapaBlanda&quot;),
    }
}

fn main() {
    let tipo_libro = TipoLibro::TapaDura;
    check_tipo_libro(&amp;tipo_libro); // Vamos a probarlo
}
</code></pre></pre>
<p>Rust no puede compilar el c√≥digo anterior debido a <code>get_libro</code> y <code>delete_libro</code>. Dice:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:9:32
  |
9 | fn get_libro(libro: &amp;Libro) -&gt; Option&lt;String&gt; {} // ‚ö†Ô∏è get_libro deber√≠a recibir un &amp;Libro y devolver un Option&lt;String&gt;
  |    ---------                   ^^^^^^^^^^^^^^ expected enum `Option`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
  |
  = note:   expected enum `Option&lt;String&gt;`
          found unit type `()`

error[E0308]: mismatched types
  --&gt; src/main.rs:11:34
   |
11 | fn delete_libro(libro: Libro) -&gt; Result&lt;(), String&gt; {} // delete_libro deber√≠a recibir un Libro y devolver un Result...
   |    ------------                  ^^^^^^^^^^^^^^^^^^ expected enum `Result`, found `()`
   |    |
   |    implicitly returns `()` as its body has no tail or `return` expression
   |
   = note:   expected enum `Result&lt;(), String&gt;`
           found unit type `()`
</code></pre>
<p>En este momento no es posible completar el c√≥digo de <code>get_libro</code>, ni de <code>delete_libro</code>. Para esto se puede usar <code>todo!()</code>. Si se a√±ade a la funci√≥n, se evitan los fallos que encuentra Rust.</p>
<pre><pre class="playground"><code class="language-rust">struct Libro {}

fn get_libro(libro: &amp;Libro) -&gt; Option&lt;String&gt; {
    todo!() // todo! significa &quot;Lo a√±adir√© despu√©s. Por favor, dalo por bueno mientras tanto.&quot;
}

fn delete_libro(libro: Libro) -&gt; Result&lt;(), String&gt; {
    todo!()
}

fn main() {}
</code></pre></pre>
<p>Ahora el c√≥digo compila y se puede ver el resultado de <code>check_tipo_libro</code>: <code>Es TapaDura</code>.</p>
<p>Es necesario tener cuidado, ya que aunque compile no se pueden usar las funciones que contienen <code>todo</code>. Si se llamaa una de estas funciones, el programa entrar√° <em>en p√°nico</em>.</p>
<p>Adicionalmente, las funciones que contienen <code>todo!</code> siguen necesitando tipos de entrada y salida existentes. Si se escribe un tipo inexistente, el programa no compilar√°. Por ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">struct Libro {}

fn get_libro(libro: &amp;Libro) -&gt; WorldsBestType { // ‚ö†Ô∏è
    todo!()
}

fn main() {}
</code></pre></pre>
<p>Dir√° al compilar:</p>
<pre><code class="language-text">error[E0412]: cannot find type `WorldsBestType` in this scope
 --&gt; src/main.rs:3:32
  |
3 | fn get_libro(libro: &amp;Libro) -&gt; WorldsBestType { // ‚ö†Ô∏è
  |                                ^^^^^^^^^^^^^^ not found in this scope
</code></pre>
<p>La macro <code>todo!</code> funciona de forma igual a <code>unimplemented!()</code>. Simplemente <code>unimplemented!()</code> es demasiado largo de escribir, por lo que se cre√≥ <code>todo!()</code> que es m√°s corto.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rc"><a class="header" href="#rc">Rc</a></h1>
<p><code>Rc</code> significa &quot;contador de referencias&quot;. Ya se ha visto que en Rust cada valor solo puede ter un due√±o. Por eso, el siguiente c√≥digo no funciona:</p>
<pre><pre class="playground"><code class="language-rust">fn takes_a_string(input: String) {
    println!(&quot;It is: {}&quot;, input)
}

fn also_takes_a_string(input: String) {
    println!(&quot;It is: {}&quot;, input)
}

fn main() {
    let user_name = String::from(&quot;User MacUserson&quot;);

    takes_a_string(user_name);
    also_takes_a_string(user_name); // ‚ö†Ô∏è
}
</code></pre></pre>
<p>Despu√©s de que <code>takes_a_string</code> reciba <code>user_name</code>, no se puede volver a usar. En este caso, se podr√≠a solventar utilizando <code>user_name.clone()</code>. Pero en ocasiones, un valor forma parte de un struct y puede que no se pueda clonar ese struct. O puede que sea un valor de gran tama√±o que no sea eficiente clonar. Por estas razones existe <code>Rc</code>, que sirve para permitir que un valor tenga m√°s de un due√±o de forma simult√°nea. <code>Rc</code> anota quienes tienen la propiedad y cu√°ntos. Posteriormente, cuando el n√∫mero de due√±os baja a cero, el valor asociado se liberar√°.</p>
<p>En el siguiente ejemplo se usa <code>Rc</code>. Se crean dos <code>struct</code>: uno denominado <code>City</code> y otro <code>CityData</code>. <code>City</code> contiene la informaci√≥n de una ciudad y <code>CityData</code> re√∫ne todas las ciudades usando <code>Vec</code>.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct City {
    name: String,
    population: u32,
    city_history: String,
}

#[derive(Debug)]
struct CityData {
    names: Vec&lt;String&gt;,
    histories: Vec&lt;String&gt;,
}

fn main() {
    let calgary = City {
        name: &quot;Calgary&quot;.to_string(),
        population: 1_200_000,
           // Pretend that this string is very very long
        city_history: &quot;Calgary began as a fort called Fort Calgary that...&quot;.to_string(),
    };

    let canada_cities = CityData {
        names: vec![calgary.name], // This is using calgary.name, which is short
        histories: vec![calgary.city_history], // But this String is very long
    };

    println!(&quot;Calgary's history is: {}&quot;, calgary.city_history);  // ‚ö†Ô∏è
}
</code></pre></pre>
<p>Esto no funciona debido a que <code>canada_cities</code> es el due√±o de los datos al final y <code>calgary</code> ya no lo es. Por lo que el error es el siguiente:</p>
<pre><code class="language-text">error[E0382]: borrow of moved value: `calgary.city_history`
  --&gt; src/main.rs:27:42
   |
24 |         histories: vec![calgary.city_history], // But this String is very long
   |                         -------------------- value moved here
...
27 |     println!(&quot;Calgary's history is: {}&quot;, calgary.city_history);  // ‚ö†Ô∏è
   |                                          ^^^^^^^^^^^^^^^^^^^^ value borrowed here after move
   |
   = note: move occurs because `calgary.city_history` has type `String`, which does not implement the `Copy` trait
</code></pre>
<p>Se podr√≠a clonar el nombre con <code>names: vec![calgary.name.clone()]</code>, pero no se desea con <code>city_history</code> debido a que puede ser un texto muy largo. Por ello, se usa <code>Rc</code>. Para ello, se debe declarar su uso previamente:</p>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;

fn main() {}
</code></pre></pre>
<p>Y despu√©s, usar <code>Rc</code> como tipo de la variable que se quiera usar:</p>
<p>¬¥¬¥¬¥rust
use std::rc::Rc;</p>
<p>#[derive(Debug)]
struct City {
name: String,
population: u32,
city_history: Rc<String>,
}</p>
<p>#[derive(Debug)]
struct CityData {
names: Vec<String>,
histories: Vec&lt;Rc<String>&gt;,
}</p>
<p>fn main() {}
¬¥¬¥¬¥</p>
<p>Para a√±adir una nueva referencia, se debe usar <code>clone</code> sobre el elemento <code>Rc</code>. En los <code>Rc</code>, esta funci√≥n solo clona el puntero y no duplica la variable contenida. Por ello, su coste es m√≠nimo.</p>
<p>En el ejemplo anterior, al clonar la historia de una ciudad, esta tendr√° dos due√±os. Se puede comprobar el n√∫mero de due√±os en un momento dado mediante <code>Rc::strong_count(&amp;item)</code>. El c√≥digo quedar√° as√≠:</p>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;

#[derive(Debug)]
struct City {
    name: String,
    population: u32,
    city_history: Rc&lt;String&gt;, // String dentro de un Rc
}

#[derive(Debug)]
struct CityData {
    names: Vec&lt;String&gt;,
    histories: Vec&lt;Rc&lt;String&gt;&gt;, // Un Vec de Strings dentro de Rcs
}

fn main() {
    let calgary = City {
        name: &quot;Calgary&quot;.to_string(),
        population: 1_200_000,
        city_history: Rc::new(&quot;Calgary began as a fort called Fort Calgary that...&quot;.to_string()), // Rc::new() para crear el Rc
    };

    let canada_cities = CityData {
        names: vec![calgary.name],
        histories: vec![calgary.city_history.clone()], // .clone() para incrementar la cuenta
    };

    println!(&quot;Calgary's history is: {}&quot;, calgary.city_history);
    println!(&quot;{}&quot;, Rc::strong_count(&amp;calgary.city_history));
    let new_owner = calgary.city_history.clone();
}
</code></pre></pre>
<p>Este c√≥digo imprime <code>2</code> como el n√∫mero de due√±os de la historia de Calgary. Como la √∫ltima l√≠nea de c√≥digo a√±ade otro due√±o, <code>new_owner</code>, si se imprimiera despu√©s la cuenta de due√±os, se mostrar√≠a ya <code>3</code>.</p>
<p>Se observa que esta funci√≥n habla de <em>strong pointers (punteros fuertes)</em>. ¬øExisten los <em>punteros d√©biles</em>? S√≠, existen. Se utilizan cuando se quiere evitar referencias circulares entre elementos. Por ejemplo, si dos <code>Rc</code> se apuntan entre s√≠, si ambos punteros son fuertes, nunca alcanzar√°n la cuenta de cero due√±os, ya que cada uno es due√±o del otro, y no se podr√°n liberar. <code>Rc</code> mantiene la cuenta de los <em>punteros d√©biles</em>, pero no la tiene en cuenta para liberar la memoria. Es decir, cuando un elemento <code>Rc</code> no tiene <em>punteros fuertes</em>, se libera su espacio aunque la cuenta de <em>punteros d√©biles</em> no sea cero.</p>
<p>Se puede utilizar <code>Rc::downgrade(&amp;item)</code> en lugar de <code>Rc::clone(&amp;item)</code> para construir una referencia d√©bil. Para ver la cuenta de referencias d√©biles se usa <code>Rc::weak_count(&amp;item)</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="m√∫ltiples-hilos"><a class="header" href="#m√∫ltiples-hilos">M√∫ltiples hilos</a></h1>
<p>Para ejecutar diferentes tareas al mismo tiempo, se usan los <em>hilos (threads)</em>. Los ordenadores modernos suelen tener m√°s de un n√∫cleo de proceso por lo que pueden ejecutar m√°s de una cosa a la vez. Rust permite aprovechar esto. Para ello, Rust utiliza hilos, llamados <em>hilos de sistema operativo</em>. Esto significa que el sistema operativo crea este hilo y lo asigna a un n√∫cleo de proceso. Otros lenguajes de programaci√≥n utilizan <em>hilos verdes (green threads)</em> que son menos potentes.</p>
<p>Se pueden crear hilos con <code>std::thread::spawn</code> al que se le pasa un cierre para indicarle qu√© tiene que hacer. Los hilos son interesantes porque se ejecutan a la vez. Se puede comprobar con el siguiente ejemplo.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    std::thread::spawn(|| {
        println!(&quot;I am printing something&quot;);
    });
}
</code></pre></pre>
<p>Si se ejecuta este c√≥digo, en ocasiones se imprimir√° algo y otras veces no. Depender√° tambi√©n de la velocidad del ordenador en que se ejecute. Esto sucede porque <code>main()</code> se ejecuta en el hilo principal del programa y el cierre en un hilo secundario. Cuando el hilo principal, <code>main()</code>, finaliza, el programa se para.</p>
<p>Para verlo mejor, un bucle for resulta m√°s pr√°ctico:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for _ in 0..10 { // lanzar√° 10 hilos
        std::thread::spawn(|| {
            println!(&quot;I am printing something&quot;);
        });
    }   // Se inicia un hilo.
}       // ¬øCu√°ntos hilos pueden terminar antes de que main() finalice aqu√≠?
</code></pre></pre>
<p>Variar√° en cada caso, unas veces 1, otras 4, otras 5. Si el ordenador es muy r√°pido, podr√≠a no llegarse a imprimir nada. A veces, pdor√≠a darse este error:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>thread 'thread 'I am printing something
thread '&lt;unnamed&gt;&lt;unnamed&gt;thread '' panicked at '&lt;unnamed&gt;I am printing something
' panicked at 'thread '&lt;unnamed&gt;cannot access stdout during shutdown' panicked at '&lt;unnamed&gt;thread 'cannot access stdout during
shutdown
<span class="boring">}
</span></code></pre></pre>
<p>Que sucede cuando el hilo intenta ejecutar algo mientras el programa est√° finalizando.</p>
<p>Se le puede pedir al hilo principal (el que est√° ejecutando la funci√≥n <code>main()</code>) que ejecute algo que <em>lo entretenga</em> mientras se ejecutan los hilos:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for _ in 0..10 {
        std::thread::spawn(|| {
            println!(&quot;I am printing something&quot;);
        });
    }
    for _ in 0..1_000_000 { // declarar &quot;let x = 9&quot; un mill√≥n de veces
                            // Tiene que hacerlo antes de poder acabar la funci√≥n main()
        let _x = 9;
    }
}
</code></pre></pre>
<p>Pero este c√≥digo anterior es una mala pr√°ctica. Para dar tiempo a acabar a los hilos, lo que se debe hacer es conservarlas en una variable. Si se a√±ade <code>let</code> se asigna un valor de tipo <code>JoinHandle</code>. Esto se ve claramente en la definici√≥n de la funci√≥n <code>spawn</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
where
    F: FnOnce() -&gt; T,
    F: Send + 'static,
    T: Send + 'static,
<span class="boring">}
</span></code></pre></pre>
<p><code>f</code> es el cierre que se ejecuta por este hilo. <code>JoinHandle</code> es el tipo de retorno.</p>
<p>Ahora se puede escribir:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for i in 0..10 {
        let handle = std::thread::spawn(|| {
            println!(&quot;Hilo, imprimo algo&quot;);
        });
        println!(&quot;Hilo {} creado.&quot;, i);
    }
}
</code></pre></pre>
<p><code>handle</code> es de tipo <code>JoinHandle</code>. ¬øQu√© se hace con √©l? Se puede usar el m√©todo <code>.join()</code> que hace que el hilo en el que se ejecute (el principal), se pare para esperar a que este hilo haya terminado. As√≠:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for i in 0..10 {
        let handle = std::thread::spawn(|| {
            println!(&quot;Hilo, imprimo algo&quot;);
        });
        println!(&quot;Hilo {} creado.&quot;, i);
        handle.join(); // Espera a que acabe este hilo 
    }
}
</code></pre></pre>
<p>El c√≥digo anterior no es muy correcto ya que su orden de ejecuci√≥n es: crea un hilo, espera a que termine, luego crea otro, etc. El resultado siempre es:</p>
<pre><code class="language-text">Hilo 0 creado.
Hilo, imprimo algo
Hilo 1 creado.
Hilo, imprimo algo
Hilo 2 creado.
Hilo, imprimo algo
Hilo 3 creado.
Hilo, imprimo algo
Hilo 4 creado.
Hilo, imprimo algo
Hilo 5 creado.
Hilo, imprimo algo
Hilo 6 creado.
Hilo, imprimo algo
Hilo 7 creado.
Hilo, imprimo algo
Hilo 8 creado.
Hilo, imprimo algo
Hilo 9 creado.
Hilo, imprimo algo
</code></pre>
<p>Con lo que no se aprovecha para paralelizar todo lo que sea posible por los nucleos de proceso que tenga el ordenador. Lo correcto ser√≠a lanzar todos los hilos y luego esperar a que acaben todos, as√≠:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut handles = Vec::new();

    for i in 0..10 {
        handles.push(std::thread::spawn(|| {
            println!(&quot;Hilo, imprimo algo&quot;);
        }));
        println!(&quot;Hilo {} creado.&quot;, i);
    }

    for handle in handles {
        handle.join();
    }
}
</code></pre></pre>
<p>De esta forma, se crean los hilos y la ejecuci√≥n puede producirse en diversos ordenes. Pero de forma simult√°nea puede haber hasta un m√°ximo de 10 hilos.</p>
<p>A continuaci√≥n se explican los tres tipos de cierres que existen:</p>
<ul>
<li><em>FnOnce</em>: que toma el cierre completo.</li>
<li><em>FnMut</em>: que toma una referencia modificable.</li>
<li><em>Fn</em>: que toma una referencia.</li>
</ul>
<p>Un cierre intentar√° usar <code>Fn</code>, si es posible. Pero si necesita modificar alg√∫n valor utilizar√° <code>FnMut</code>. Y si necesita apropiarse del valor, usar√° <code>FnOnce</code>. Este √∫ltimo es un buen nombre, porque explica lo que hace: tomar el valor una vez y luego ya no puede volver a usarlo.</p>
<p>A continuaci√≥n se observa un ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_string = String::from(&quot;I will go into the closure&quot;);
    let my_closure = || println!(&quot;{}&quot;, my_string);
    my_closure();
    my_closure();
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">I will go into the closure
I will go into the closure
</code></pre>
<p><code>String</code> no es de tipo <code>Copy</code>, por lo que el cierre es <code>Fn</code> y Rust crea una referencia al valor.</p>
<p>Si se modificara el valor de la variable, el cierre pasar√≠a a ser de tipo <code>FnMut</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_string = String::from(&quot;I will go into the closure&quot;);
    let mut my_closure = || {
        my_string.push_str(&quot; now&quot;);
        println!(&quot;{}&quot;, my_string);
    };
    my_closure();
    my_closure();
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">I will go into the closure now
I will go into the closure now now
</code></pre>
<p>Si la variable se pasa por valor, entonces el cierre ser√° <code>FnOnce</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec: Vec&lt;i32&gt; = vec![8, 9, 10];
    let my_closure = || {
        my_vec
            .into_iter() // into_iter toma la propiedad
            .map(|x| x as u8) // lo convierte en u8
            .map(|x| x * 2) // lo multiplica por 2
            .collect::&lt;Vec&lt;u8&gt;&gt;() // y lo guarda en un Vec
    };
    let new_vec = my_closure();
    println!(&quot;{:?}&quot;, new_vec);
}
</code></pre></pre>
<p>En este √∫ltimo caso, solo se puede ejecutar una vez este cierre ya que <code>my_vec</code> se pasa por valor.</p>
<p>De vuelta a los hilos. Si se intenta usar un valor as√≠:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_string = String::from(&quot;¬øPuede pasarlo a un hilo?&quot;);

    let handle = std::thread::spawn(|| {
        println!(&quot;{}&quot;, my_string); // ‚ö†Ô∏è
    });

    handle.join();
}
</code></pre></pre>
<p>El compilador dice que esto no es posible:</p>
<pre><code class="language-text">error[E0373]: closure may outlive the current function, but it borrows `my_string`, which is owned by the current function
 --&gt; src/main.rs:4:37
  |
4 |     let handle = std::thread::spawn(|| {
  |                                     ^^ may outlive borrowed value `my_string`
5 |         println!(&quot;{}&quot;, my_string); // ‚ö†Ô∏è
  |                        --------- `my_string` is borrowed here
  |
note: function requires argument type to outlive `'static`
 --&gt; src/main.rs:4:18
  |
4 |       let handle = std::thread::spawn(|| {
  |  __________________^
5 | |         println!(&quot;{}&quot;, my_string); // ‚ö†Ô∏è
6 | |     });
  | |______^
help: to force the closure to take ownership of `my_string` (and any other referenced variables), use the `move` keyword
  |
4 |     let handle = std::thread::spawn(move || {
  |                                     ++++
</code></pre>
<p>Es un mensaje muy largo, pero explicativo: dice que es necesario usar la palabra <code>move</code>. El problema es que en el hilo principal la variable es <code>mut</code> y, por lo tanto, se puede modificar mientras los dem√°s hilos tienen acceso a ella. Esto no es seguro.</p>
<p>Se puede intentar algo m√°s que tampoco funciona:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_string = String::from(&quot;Can I go inside the thread?&quot;);

    let handle = std::thread::spawn(|| {
        println!(&quot;{}&quot;, my_string); // now my_string is being used as a reference
    });

    std::mem::drop(my_string);  // ‚ö†Ô∏è We try to drop it here. But the thread still needs it.

    handle.join();
}
</code></pre></pre>
<p>Lo correcto, para poder usarlo, es pasar la variable con <code>move</code> para hacer al cierreo propietario de tipo <code>FnOnce</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_string = String::from(&quot;Can I go inside the thread?&quot;);

    let handle = std::thread::spawn(move|| {
        println!(&quot;{}&quot;, my_string);
    });

    std::mem::drop(my_string);  // ‚ö†Ô∏è No se puede hacer drop, ya que se ha transferido al hilo anterior.

    handle.join();
}
</code></pre></pre>
<p>Si se quita el <code>std::mem::drop</code> funciona correctamente ya que el c√≥digo es seguro:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_string = String::from(&quot;Can I go inside the thread?&quot;);

    let handle = std::thread::spawn(move|| {
        println!(&quot;{}&quot;, my_string);
    });

    handle.join().unwrap();
}
</code></pre></pre>
<p>Es necesario recordar: si se necesita pasar por valor un elemento, es necesario usar <code>move</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cierres-en-funciones"><a class="header" href="#cierres-en-funciones">Cierres en funciones</a></h1>
<p>Los cierres (closures) son muy √∫tiles. ¬øC√≥mo los pasamos como par√°metro a nuestras propias funciones?</p>
<p>Es posible hacerlo, pero dentro de ellas es necesario definir el tipo de cierre (de los tres tipos posibles vistos en el apartardo anterior). Fuera de una funci√≥n, Rust decide por s√≠ mismo qu√© tipo de cierre debe usar: <code>Fn</code>, <code>FnMut</code> o <code>FnOnce</code>. Sin embargo, dentro de la funci√≥n resulta necesario seleccionar qu√© tipo se admite. Loa mejor forma de comprenderlo es revisar varias definiciones de funi√≥n. Por ejemplo, la siguiente de <code>.all()</code>. Si se recuerda, esta funci√≥n comprueba si un iterador cumple una condici√≥n en todos sus elementos. Parte de la definici√≥n dice:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn all&lt;F&gt;(&amp;mut self, f: F) -&gt; bool    // üöß
    where
        F: FnMut(Self::Item) -&gt; bool,
<span class="boring">}
</span></code></pre></pre>
<ol>
<li><code>fn all&lt;F&gt;</code> indica que existe un tipo gen√©rico <code>F</code>. Un cierre siempre es un tipo gen√©rico ya que cada funci√≥n es en s√≠ misma un tipo diferente (con un solo valor).</li>
<li><code>(&amp;mut self, f: F)</code>: <code>&amp;mut self</code> revela que esta funci√≥n es un m√©todo. <code>f: F</code> es lo que por convenio se suele escribir para representar un par√°metro que debe recibir un cierre: este es el nombre de la variable y el tipo gen√©rico. No es obligatorio, l√≥gicamente, usar estas letras <code>f</code> y <code>F</code>.</li>
<li>La siguiente parte es la que define que el gen√©rico tiene que ser uno de los tres tipos de cierre: <code>where F: FnMut(Self::Item) -&gt; bool</code>. Se requiere, en este caso, que el cierre sea modificable para que se puedan modificar sus par√°metros. En este caso, necesita cambiar el iterador (<code>Self::Item</code>). Se devuelve un booleano: <code>true</code> o <code>false</code>.</li>
</ol>
<p>A continuaci√≥n se muestar una definici√≥n m√°s simple con un cierre:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_something&lt;F&gt;(f: F)    // üöß
where
    F: FnOnce(),
{
    f();
}
<span class="boring">}
</span></code></pre></pre>
<p>En este caso, se toma un cierre como par√°metro (se hace propietario de √©l ya que es de tipo <code>FnOnce</code>) y no devuelve ning√∫n valor. El cierre, seg√∫n se define en la cl√°usula <code>where</code>, no tiene par√°metros y no devuelve ning√∫n valor.</p>
<p>Ampliando el ejemplo anterior, se crea un <code>Vec</code> y se itera a trav√©s de √©l para mostrar lo que se puede hacer:</p>
<pre><pre class="playground"><code class="language-rust">fn do_something&lt;F&gt;(f: F)
where
    F: FnOnce(),
{
    f();
}

fn main() {
    let some_vec = vec![9, 8, 10];
    do_something(|| {
        some_vec
            .into_iter()
            .for_each(|x| println!(&quot;The number is: {}&quot;, x));
    })
}
</code></pre></pre>
<p>Para ver un ejemplo m√°s realista, se crea a continuaci√≥n un <code>struct City</code>. Esta vez tendr√° m√°s datos sobre a√±os y poblaci√≥n. Dispone de un <code>Vec&lt;u32&gt;</code> para contener todos los a√±os y otro <code>Vec&lt;u32&gt;</code>igual para el n√∫mero de habitantes.</p>
<p><code>City</code> tiene dos funciones: <code>new()</code> para crear una nueva ciudad y <code>.city_data()</code> que recibe un cierre. Cuando se usa <code>.city_data()</code> devuelve los a√±os, los habitantes y un cierre, para que se pueda realizar la operaci√≥n que se solicite con los datos. El tipo del cierre es <code>FnMut</code> para poder modificar los valores. El ejemplo es as√≠:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct City {
    name: String,
    years: Vec&lt;u32&gt;,
    populations: Vec&lt;u32&gt;,
}

impl City {
    fn new(name: &amp;str, years: Vec&lt;u32&gt;, populations: Vec&lt;u32&gt;) -&gt; Self {

        Self {
            name: name.to_string(),
            years,
            populations,
        }
    }

    fn city_data&lt;F&gt;(&amp;mut self, mut f: F) // self. Solo f es gen√©rico de tipo F. f es el cierre

    where
        F: FnMut(&amp;mut Vec&lt;u32&gt;, &amp;mut Vec&lt;u32&gt;), // El cierre toma como par√°metrso dos vectors de u32
                                // que representan el a√±o y la poblicaci√≥n.
                                // no devuelve ning√∫n valor
    {
        f(&amp;mut self.years, &amp;mut self.populations) // Finalmente este es el c√≥digo de la funci√≥n
            // simplemente usa el cierre en los dos par√°metros year y habitantes&quot;
            // se puede hacer lo que se quiera dentro del cierre. No devuelve ning√∫n valor
    }
}

fn main() {
    let years = vec![
        1372, 1834, 1851, 1881, 1897, 1925, 1959, 1989, 2000, 2005, 2010, 2020,
    ];
    let populations = vec![
        3_250, 15_300, 24_000, 45_900, 58_800, 119_800, 283_071, 478_974, 400_378, 401_694,
        406_703, 437_619,
    ];
    // Se crea la ciudad
    let mut tallinn = City::new(&quot;Tallinn&quot;, years, populations);

    // Ahora se tiene el m√©todo .city_data() que utiliza un cierre.
    // Se puede hacer lo que se quiera.

    // En primer lugar se unen los 5  primeros a√±os y los habitantes para imprimirlos.
    tallinn.city_data(|city_years, city_populations| { // Los par√°metros se pueden llamar como se quiera
        let new_vec = city_years
            .into_iter()
            .zip(city_populations.into_iter()) // Zip los dos valores juntos
            .take(5)                           // pero se queda con los 5 primeros
            .collect::&lt;Vec&lt;(_, _)&gt;&gt;(); // Deja a Rust decidir el tipo de la tupla
        println!(&quot;{:?}&quot;, new_vec);
    });

    // Ahora se va a a√±adir alg√∫n dato para el a√±o 2030
    tallinn.city_data(|x, y| { // Esta vez se les llama a los par√°metros: x, y.
        x.push(2030);
        y.push(500_000);
    });

    // Ahora no se quieren los datos de 1834
    tallinn.city_data(|x, y| {
        let position_option = x.iter().position(|x| *x == 1834);
        if let Some(position) = position_option {
            println!(
                &quot;Going to delete {} at position {:?} now.&quot;,
                x[position], position
            ); // Confirma que se est√° borrando el elemento apropiado
            x.remove(position);
            y.remove(position);
        }
    });

    println!(
        &quot;Years left are {:?}\nPopulations left are {:?}&quot;,
        tallinn.years, tallinn.populations
    );
}
</code></pre></pre>
<p>Esto imprimir√° el valor de todas las veces que se ha llamado a <code>.city_data()</code>::</p>
<pre><code class="language-text">[(1372, 3250), (1834, 15300), (1851, 24000), (1881, 45900), (1897, 58800)]
Going to delete 1834 at position 1 now.
Years left are [1372, 1851, 1881, 1897, 1925, 1959, 1989, 2000, 2005, 2010, 2020, 2030]
Populations left are [3250, 24000, 45900, 58800, 119800, 283071, 478974, 400378, 401694, 406703, 437619, 500000]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="impl-trait"><a class="header" href="#impl-trait"><code>impl Trait</code></a></h1>
<p><code>imple Trait</code> es similar a los gen√©ricos. Los gen√©ricos usan un tipo, representado (por convenio) por <code>T</code> o similar, que se decide en tiempo de compilaci√≥n.</p>
<p>En primer lugar, se presenta un ejemplo con un tipo concreto:</p>
<pre><pre class="playground"><code class="language-rust">fn gives_higher_i32(one: i32, two: i32) {
    let higher = if one &gt; two { one } else { two };
    println!(&quot;{} is higher.&quot;, higher);
}

fn main() {
    gives_higher_i32(8, 10);
}
</code></pre></pre>
<p>Que imprime: <code>10 is higher.</code>.</p>
<p>En este caso, la funci√≥n solo recibe el tipo <code>i32</code>. A continuaci√≥n, se modifica el c√≥digo para hacerlo gen√©rico. El c√≥digo de la funci√≥n necesita comparar y necesita imprimir con <code>{}</code>, por lo que el tipo <code>T</code> necesita implementar los rasgos <code>PartialOrd</code> y <code>Display</code>. Se debe recordar que esto significa que solo es posible implementar esta funci√≥n para aquellos tipos que tengan estos rasgos.</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

fn gives_higher_i32&lt;T: PartialOrd + Display&gt;(one: T, two: T) {
    let higher = if one &gt; two { one } else { two };
    println!(&quot;{} is higher.&quot;, higher);
}

fn main() {
    gives_higher_i32(8, 10);
}
</code></pre></pre>
<p>El caso de <code>impl Trait</code> es similar, pero decide en tiempo de ejecuci√≥n. Permite pasar variables de los tipos que implementen el rasgo, pero el c√≥digo de la funci√≥n es uno solo (no se desarrolla uno para cada tipo en tiempo de ejecuci√≥n). El c√≥digo es un poco menos eficiente, ya que necesita determinar en tiempo de ejecuci√≥n si el tipo que se pasa implementa o no los rasgos necesarios.</p>
<pre><pre class="playground"><code class="language-rust">fn prints_it(input: impl Into&lt;String&gt; + std::fmt::Display) { // Takes anything that can turn into a String and has Display
    println!(&quot;You can print many things, including {}&quot;, input);
}

fn main() {
    let name = &quot;Tuon&quot;;
    let string_name = String::from(&quot;Tuon&quot;);
    prints_it(name);
    prints_it(string_name);
}
</code></pre></pre>
<p>Sin embargo, lo m√°s interesante de esto es que se puede devolver tambi√©n <code>impl Trait</code> y que esto permite devolver cierres (hay que recordar que hay tres tipos de cierres, pero cada implementaci√≥n concreta tiene un tipo concreto √∫nico que es de uno de los tres generales). La definici√≥n de cada cierre es un rasgo en s√≠ (trait).</p>
<p>Para entenderlo mejor, se puede observar alg√∫n m√©todo que funciona as√≠ en la librer√≠a est√°ndar. Por ejemplo, esta es la definici√≥n de <code>.map()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt;     // üöß
    where
        Self: Sized,
        F: FnMut(Self::Item) -&gt; B,
    {
        Map::new(self, f)
    }
<span class="boring">}
</span></code></pre></pre>
<p><code>fn map&lt;B, F&gt;(self, f: F)</code> significa que esta funci√≥n necesita dos tipos gen√©ricos. <code>F</code> es una funci√≥n que recibe como par√°metro un elemento del contenedor que implementa <code>.map()</code> y <code>B</code> es el valor de retorno de esta funci√≥n. En el <code>where</code> se observan los ragos que deben tener las diferentes variables y tipos. <code>Self</code> tiene que ser un tipo <code>Sized</code> y <code>F</code> tiene que ser una funci√≥n/cierre <code>FnMut</code>.</p>
<p>As√≠, se puede hacer lo mismo para devolver un cierre. Se usa <code>impl</code> y la definici√≥n del cierre. Una vez devuelto, se puede usar como cualquier otra funci√≥n. A continuaci√≥n se presenta un ejemplo de una funci√≥n que devuelve diferentes cierres en funci√≥n del texto que reciba. Si se pasa &quot;double&quot; o &quot;triple&quot; devuelve un cierre que multiplica por dos o por tres. En todos los dem√°s casos, usa un cierre que devuelve el mismo valor:</p>
<pre><pre class="playground"><code class="language-rust">fn returns_a_closure(input: &amp;str) -&gt; impl FnMut(i32) -&gt; i32 {
    match input {
        &quot;double&quot; =&gt; |mut number| {
            number *= 2;
            println!(&quot;Doubling number. Now it is {}&quot;, number);
            number
        },
        &quot;triple&quot; =&gt; |mut number| {
            number *= 40;
            println!(&quot;Tripling number. Now it is {}&quot;, number);
            number
        },
        _ =&gt; |number| {
            println!(&quot;Sorry, it's the same: {}.&quot;, number);
            number
        },
    }
}

fn main() {
    let my_number = 10;

    // Make three closures
    let mut doubles = returns_a_closure(&quot;double&quot;);
    let mut triples = returns_a_closure(&quot;triple&quot;);
    let mut quadruples = returns_a_closure(&quot;quadruple&quot;);

    doubles(my_number);
    triples(my_number);
    quadruples(my_number);
}
</code></pre></pre>
<p>Por √∫ltimo, se presenta un ejemplo m√°s largo. Se imagina un juego en el que el personaje se enfrenta a monstruos que son m√°s fuertes por la noche. Se puede crear un enumerado denominado <code>TimeOfday</code> para conocer el momento del d√≠a. El personaje se llama Sim√≥n y tiene un n√∫mero que se denomina <code>character_fear</code>, que es un <code>f64</code>. El n√∫mero sube por la noche (tiene m√°s miedo por la noche) y baja durante el d√≠a. Se construye una funci√≥n <code>change_fear</code> que cambia el el miedo en funci√≥n del momento del d√≠a y hace otras cosas como imprimir mensajes:</p>
<pre><pre class="playground"><code class="language-rust">enum TimeOfDay { // enum
    Dawn,
    Day,
    Sunset,
    Night,
}

fn change_fear(input: TimeOfDay) -&gt; impl FnMut(f64) -&gt; f64 { // la funci√≥n recibe TimeOfDay. Devuelve un closure.
                // Se usa impl FnMut(64) -&gt; f64 para indicar la funci√≥n que
                // cambiar√° el valor
    use TimeOfDay::*; // Para que sea m√°s corto de escribir Dawn, Day, Sunset, Night
                      // En lugar de TimeOfDay::Dawn, TimeOfDay::Day, etc.
    match input {
        Dawn =&gt; |x| { // x representa a la variable character_fear que se pasar√° despu√©s
            println!(&quot;The morning sun has vanquished the horrible night. You no longer feel afraid.&quot;);
            println!(&quot;Your fear is now {}&quot;, x * 0.5);
            x * 0.5
        },
        Day =&gt; |x| {
            println!(&quot;What a nice day. Maybe put your feet up and rest a bit.&quot;);
            println!(&quot;Your fear is now {}&quot;, x * 0.2);
            x * 0.2
        },
        Sunset =&gt; |x| {
            println!(&quot;The sun is almost down! This is no good.&quot;);
            println!(&quot;Your fear is now {}&quot;, x * 1.4);
            x * 1.4
        },
        Night =&gt; |x| {
            println!(&quot;What a horrible night to have a curse.&quot;);
            println!(&quot;Your fear is now {}&quot;, x * 5.0);
            x * 5.0
        },
    }
}

fn main() {
    use TimeOfDay::*;
    let mut character_fear = 10.0; // Comienza Simon a 10

    let mut daytime = change_fear(Day); // Crea cuatro cierres que cambian el nivel de miedo de Simon.
    let mut sunset = change_fear(Sunset);
    let mut night = change_fear(Night);
    let mut morning = change_fear(Dawn);

    character_fear = daytime(character_fear); // Llama a los cierres. Cambian el miedo y escriben un mensaje
    character_fear = sunset(character_fear);
    character_fear = night(character_fear);
    character_fear = morning(character_fear);
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">What a nice day. Maybe put your feet up and rest a bit.
Your fear is now 2
The sun is almost down! This is no good.
Your fear is now 2.8
What a horrible night to have a curse.
Your fear is now 14
The morning sun has vanquished the horrible night. You no longer feel afraid.
Your fear is now 7
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arc"><a class="header" href="#arc">Arc</a></h1>
<p>Seg√∫n se ha visto, para permitir que una variable tuviera m√°s de un due√±o de forma segura, se utiliza <code>Rc</code>. Si se quiere hacer lo mismo <em>compartiendo la propiedad</em> de una variable entre diferentes hilos, se debe usar <code>Arc</code>. <code>Arc</code> significa: contador de referencias at√≥mico. En este contexto, at√≥mico se refiere a que solo un proceso de los existentes puede escribir en √©l cada vez. Esto es importante ya que si dos hilos escribieran a la vez, podr√≠an darse resultados err√≥neos. Por ejemplo, si se pudiera hacer esto en Rust:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
let mut x = 10;

for i in 0..10 { // Hilo 1
    x += 1
}
for i in 0..10 { // Hilo 2
    x += 1
}
<span class="boring">}
</span></code></pre></pre>
<p>Si el hilo 1 y el hilo 2 comienzan a la vez y se permitiera escribir simult√°neamente, podr√≠a darse lo siguiente:</p>
<ul>
<li>El hilo 1 lee 10 y escribe 11. Posteriormente, el hilo 2 lee 11 y escribe 12. Esto no causa problema.</li>
<li>El hilo 1 lee 12 y a la vez el hilo 2 lee 12. El hilo 1 escribe 13 y el hilo 2 escribe 13. Se ha perdido un incremento, lo que es un problema grave.</li>
</ul>
<p>El tipo <code>Arc</code> se asegura de que esto no suceda y es lo que se debe usar para compartir valores entre hilos. Si no hay hilos, es suficiente con usar <code>Rc</code> que, adem√°s, es ligeramente m√°s r√°pido.</p>
<p>Para poder modificar los valores de un <code>Arc</code> no es suficiente con √©l. Se necesita envolver los datos en un <code>Mutex</code> que es lo que se compartir√° entre hilos con <code>Arc</code>.</p>
<p>En el siguiente ejemplo, se va a usar un <code>Mutex</code> dentro de un <code>Arc</code> para modificar un valor de un n√∫mero entre hilos. En primer lugar, se muestra el primer hilo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

    let handle = std::thread::spawn(|| {
        println!(&quot;The thread is working!&quot;) // Just testing the thread
    });

    handle.join().unwrap(); // Make the thread wait here until it is done
    println!(&quot;Exiting the program&quot;);
}
</code></pre></pre>
<p>Por ahora, solo imprime:</p>
<pre><code class="language-text">The thread is working!
Exiting the program
</code></pre>
<p>Bien, a continuaci√≥n se incluye un bucle en el hilo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

    let handle = std::thread::spawn(|| {
        for _ in 0..5 {
            println!(&quot;The thread is working!&quot;)
        }
    });

    handle.join().unwrap();
    println!(&quot;Exiting the program&quot;);
}
</code></pre></pre>
<p>Tambi√©n funciona, su ejecuci√≥n resulta en:</p>
<pre><code class="language-text">The thread is working!
The thread is working!
The thread is working!
The thread is working!
The thread is working!
Exiting the program
</code></pre>
<p>Ahora se crea otro hilo que har√° lo mismo. La forma en que se ordena la impresi√≥n puede ser diferente cada vez, seg√∫n sea la ejecuci√≥n paralela de ambos hilos. Se ejecutan de forma <em>concurrente</em>, que significa que se ejecutan a la vez.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

    let thread1 = std::thread::spawn(|| {
        for _ in 0..5 {
            println!(&quot;Thread 1 is working!&quot;)
        }
    });

    let thread2 = std::thread::spawn(|| {
        for _ in 0..5 {
            println!(&quot;Thread 2 is working!&quot;)
        }
    });

    thread2.join().unwrap();
    thread1.join().unwrap();
    println!(&quot;Exiting the program&quot;);
}
</code></pre></pre>
<p>Que podr√≠a imprimir diferentes resultados cada vez (dependiendo de la velocidad de ejecuci√≥n de cada hilo), como por ejemplo:</p>
<pre><code class="language-text">Thread 1 is working!
Thread 1 is working!
Thread 1 is working!
Thread 1 is working!
Thread 1 is working!
Thread 2 is working!
Thread 2 is working!
Thread 2 is working!
Thread 2 is working!
Thread 2 is working!
Exiting the program
</code></pre>
<p>Ahora se trata de que cada hilo cambie el valor de <code>my_number</code> que puede ser un <code>i32</code>. Para que se pueda compartir entre hilos, se debe definir as√≠:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
let my_number = Arc::new(Mutex::new(0));
<span class="boring">}
</span></code></pre></pre>
<p>Despu√©s, se deben clonar (que realmente solo clona el puntero), para pasar cada clon a cada hilo.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
let my_number = Arc::new(Mutex::new(0));

let my_number1 = Arc::clone(&amp;my_number); // Este clon va al hilo 1
let my_number2 = Arc::clone(&amp;my_number); // Este clon va al hilo 2
<span class="boring">}
</span></code></pre></pre>
<p>Ahora se pueden mover (<code>move</code>) a cada hilo:</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};

fn main() {
    let my_number = Arc::new(Mutex::new(0));

    let my_number1 = Arc::clone(&amp;my_number);
    let my_number2 = Arc::clone(&amp;my_number);

    let thread1 = std::thread::spawn(move || { // El clon va al hilo 1
        for _ in 0..10 {
            *my_number1.lock().unwrap() +=1; // Bloquea el Mutex y cambia el valor
        }
    });

    let thread2 = std::thread::spawn(move || { // El clon va al hilo 2
        for _ in 0..10 {
            *my_number2.lock().unwrap() += 1;
        }
    });

    thread1.join().unwrap();
    thread2.join().unwrap();
    println!(&quot;Value is: {:?}&quot;, my_number);
    println!(&quot;Exiting the program&quot;);
}
</code></pre></pre>
<p>El programa da como resultado:</p>
<pre><code class="language-text">Value is: Mutex { data: 20 }
Exiting the program
</code></pre>
<p>Para simplificar el c√≥digo, se puede unificar el c√≥digo de cada hilo (ya que es id√©ntico):</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};

fn main() {
    let my_number = Arc::new(Mutex::new(0));
    let mut handle_vec = vec![]; // los JoinHandles ir√°n aqu√≠

    for _ in 0..2 { // se hace dos veces
        let my_number_clone = Arc::clone(&amp;my_number); // se clona antes de iniciar el hilo
        let handle = std::thread::spawn(move || { // se mueve el clon
            for _ in 0..10 {
                *my_number_clone.lock().unwrap() += 1;
            }
        });
        handle_vec.push(handle); // se guarda el manejador para poder hacer join cuando est√©n lanzados los dos hilos.
            //si no lo hici√©ramos, este manejador se perder√≠a
    }

    handle_vec.into_iter().for_each(|handle| handle.join().unwrap()); // se llama al join de todos los hilos lanzados (dos, en este caso)
    println!(&quot;{:?}&quot;, my_number);
}
</code></pre></pre>
<p>Esto imprime: <code>{ data: 20 }</code>.</p>
<p>Aunque parece complejo <code>Arc&lt;Mutex&lt;AlgunTipo&gt;&gt;</code> es algo que se usa mucho en Rust y se vuelve natural. Siempre se puede escribir el c√≥digo para que quede m√°s claro. A continuaci√≥n, se muestra el mismo c√≥digo, pero a√±adiendo un <code>use</code> y dos funciones. As√≠ el c√≥digo de <code>main()</code> queda conciso y claro:</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread::spawn; // As√≠ solo hace falta escribir spawn

fn make_arc(number: i32) -&gt; Arc&lt;Mutex&lt;i32&gt;&gt; { // una funci√≥n para crear un Mutex en un Arc
    Arc::new(Mutex::new(number))
}

fn new_clone(input: &amp;Arc&lt;Mutex&lt;i32&gt;&gt;) -&gt; Arc&lt;Mutex&lt;i32&gt;&gt; { // para crear clones
    Arc::clone(&amp;input)
}

// Ahora main() se lee m√°s f√°cil
fn main() {
    let mut handle_vec = vec![]; // los manejadores de hilos se guardan aqu√≠
    let my_number = make_arc(0);

    for _ in 0..2 {
        let my_number_clone = new_clone(&amp;my_number);
        let handle = spawn(move || {
            for _ in 0..10 {
                let mut value_inside = my_number_clone.lock().unwrap();
                *value_inside += 1;
            }
        });
        handle_vec.push(handle);    // se guarda el manejador
    }

    handle_vec.into_iter().for_each(|handle| handle.join().unwrap()); // se espera a la finalizaci√≥n de los hilos

    println!(&quot;{:?}&quot;, my_number);
}
</code></pre></pre>
<p>En todo caso, siempre se puede reescribir el c√≥digo que parezca dif√≠cl de leer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="canales"><a class="header" href="#canales">Canales</a></h1>
<p>Un canal es una forma f√°cil de utilizar muchos hilos que env√≠an informaci√≥n a un √∫nico punto. Son muy populares porque son simples de usar. En Rust, se puede crear un canal mediante <code>std::sync::mpsc</code>. <code>mpsc</code> significa &quot;m√∫ltiple productor, solo un consumidor&quot;. Es decir, &quot;muchos hilos enviando a un √∫nico lugar&quot;. Para iniciar un canal se utiliza <code>channel()</code>, que sirve para rear un <code>Sender</code> (un proceso que env√≠a) y un <code>Receiver</code> (un proceso que recibe) que est√°n unidos. Se puede observar en la declaraci√≥n de la funci√≥n:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
pub fn channel&lt;T&gt;() -&gt; (Sender&lt;T&gt;, Receiver&lt;T&gt;)
<span class="boring">}
</span></code></pre></pre>
<p>Normalmente, se asignan a unas variables cada elemento de la tupla con nombres como <code>sender</code> y <code>receiver</code>. O, en espa√±ol, <code>emisor</code> y <code>receptor</code>. Como se trata de una funci√≥n gen√©rica, si se escribe solo lo siguiente:</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc::channel;

fn main() {
    let (sender, receiver) = channel(); // ‚ö†Ô∏è
}
</code></pre></pre>
<p>Rust no conocer√° el tipo que se env√≠a y recibe. As√≠ que el compilador indica:</p>
<pre><code class="language-text">error[E0282]: type annotations needed for `(std::sync::mpsc::Sender&lt;T&gt;, std::sync::mpsc::Receiver&lt;T&gt;)`
  --&gt; src\main.rs:30:30
   |
30 |     let (sender, receiver) = channel();
   |         ------------------   ^^^^^^^ cannot infer type for type parameter `T` declared on the function `channel`
   |         |
   |         consider giving this pattern the explicit type `(std::sync::mpsc::Sender&lt;T&gt;, std::sync::mpsc::Receiver&lt;T&gt;)`, where
the type parameter `T` is specified
</code></pre>
<p>Que indica que es necesario a√±adir un tipo para el <code>Sender</code> y el <code>Receiver</code>. Se puede hacer de la siguiente forma:</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc::{channel, Sender, Receiver};

fn main() {
    let (sender, receiver): (Sender&lt;i32&gt;, Receiver&lt;i32&gt;) = channel();
}
</code></pre></pre>
<p>o</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc::{channel, Sender, Receiver};

fn main() {
    let (sender, receiver) = channel::&lt;i32&gt;();
}
</code></pre></pre>
<p>o simplemente, se env√≠a algo a trav√©s del <code>Sender</code> en el c√≥digo, para que Rust pueda inferir su tipo:</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc::{channel, Sender, Receiver};

fn main() {
    let (sender, receiver) = channel();
    sender.send(5);
    receiver.recv(); //recv es la funci√≥n que sirve para recibir el valor. En este caso, no se usa.
}
</code></pre></pre>
<p>As√≠, el compilador conoce el tipo. <code>sender</code> es de tipo <code>Result&lt;(), SendError&lt;i32&gt;&gt;</code> y <code>receiver</code> es de tipo <code>Result&lt;(), RecvError&gt;</code>. Se puede usar <code>unwrap()</code> para ver si el env√≠o ha funcionado. Por ejemplo, se el siguiente c√≥digo comprueba si ha funcionado el env√≠o:</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc::channel;

fn main() {
    let (sender, receiver) = channel();

    sender.send(5).unwrap();
    println!(&quot;{}&quot;, receiver.recv().unwrap());
}
</code></pre></pre>
<p>Que imprime <code>5</code>.</p>
<p>Un canal es como un <code>Arc</code> ya que se puede clonar y enviar los clones a otros hilos. En el siguiente ejemplo se crean dos hilos que env√≠an valores a un <code>receiver</code>. Este c√≥digo funcionar√°, aunque no exactamente como se pretende:</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc::channel;

fn main() {
    let (sender, receiver) = channel();
    let sender_clone = sender.clone();

    std::thread::spawn(move|| { // mueve un sender 
        sender.send(&quot;Env√≠a un &amp;str esta vez&quot;).unwrap();
    });

    std::thread::spawn(move|| { // mueve un sender_clone
        sender_clone.send(&quot;Y aqu√≠ otro &amp;str&quot;).unwrap();
    });

    println!(&quot;{}&quot;, receiver.recv().unwrap());   
}
</code></pre></pre>
<p>Los dos hilos comienzan a enviar (en cualquier orden) y despu√©s se imprime lo primero que se recibe. Por lo tanto, el resultado de la impresi√≥n puede variar cada vez, dependiendo del hilo que env√≠e primero.</p>
<p>Para ver el resultado completo de cada hilo, resulta conveniente guardar los manejadores de ejecutar tantas recepciones como sean necesarias.</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc::channel;

fn main() {
    let (sender, receiver) = channel();
    let sender_clone = sender.clone();
    let mut handle_vec = vec![]; // Se guardan los manejadores

    handle_vec.push(std::thread::spawn(move|| {  // push del primero
        sender.send(&quot;Env√≠a un &amp;str esta vez&quot;).unwrap();
    }));

    handle_vec.push(std::thread::spawn(move|| {  // y push del segundo
        sender_clone.send(&quot;Y aqu√≠ otro &amp;str&quot;).unwrap();
    }));

    for _ in handle_vec { // ahora handle_vec tiene 2 elementos. Como cada uno env√≠a un dato, se hacen tantos print como manejadores
        println!(&quot;{:?}&quot;, receiver.recv().unwrap());
    }
}
</code></pre></pre>
<p>El orden de los str puede variar en funci√≥n del orden en que se ejecutan los env√≠os.</p>
<p>En el siguiente ejemplo, se crea un vector con los resultados, en lugar de imprimirlos directamente:</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc::channel;

fn main() {
    let (sender, receiver) = channel();
    let sender_clone = sender.clone();
    let mut handle_vec = vec![]; // Se guardan los manejadores
    let mut results_vec = vec![];

    handle_vec.push(std::thread::spawn(move|| {  // push del primero
        sender.send(&quot;Env√≠a un &amp;str esta vez&quot;).unwrap();
    }));

    handle_vec.push(std::thread::spawn(move|| {  // y push del segundo
        sender_clone.send(&quot;Y aqu√≠ otro &amp;str&quot;).unwrap();
    }));

    for _ in handle_vec { // ahora handle_vec tiene 2 elementos. Como cada uno env√≠a un dato, alamcenan tantos como manejadores
        results_vec.push(receiver.recv().unwrap());
    }

    println!(&quot;{:?}&quot;, results_vec);
}
</code></pre></pre>
<p>El resultado del vector es <code>[&quot;Env√≠a un &amp;str esta vez&quot;, &quot;Y aqu√≠ otro &amp;str&quot;]</code>.</p>
<p>El siguiente ejemplo utiliza diez hilos para modificar un vector de un mill√≥n de elementos. Al comienzo, todos los elementos del vector valen cero. Se modifican todos los valores a 1. Cada hilo har√° la d√©cima parte del trabjo. Se crear√° un nuevo vector y se usar√° <code>.extend()</code> para guardar el resultado de cada hilo.</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc::channel;
use std::thread::spawn;

fn main() {
    let (sender, receiver) = channel();
    let hugevec = vec![0; 1_000_000];
    let mut newvec = vec![];
    let mut handle_vec = vec![];

    for i in 0..10 {
        let sender_clone = sender.clone();
        let mut work: Vec&lt;u8&gt; = Vec::with_capacity(hugevec.len() / 10); // el nuevo vec en el que guardar el resultado de la d√©cima parte del trabajo
        work.extend(&amp;hugevec[i*100_000..(i+1)*100_000]); // el primero trabaja de 0..100_000, el siguiente de 100_000..200_000, etc.
        let handle =spawn(move || { // crea un manejador

            for number in work.iter_mut() { // efect√∫a el trabajo
                *number += 1;
            };
            sender_clone.send(work).unwrap(); // utiliza el sender_clone para enviar el trabajo al receptor
        });
        handle_vec.push(handle);
    }
    
    for handle in handle_vec { // espera a que todos los hilos terminen
        handle.join().unwrap();
    }
    
    while let Ok(results) = receiver.try_recv() {
        newvec.push(results); // guarda los resultados en receiver.recv() en el vector final
    }

    // Ahora se tiene un Vec&lt;Vec&lt;u8&gt;&gt;. se debe aplanar con .flatten()
    let newvec = newvec.into_iter().flatten().collect::&lt;Vec&lt;u8&gt;&gt;(); // Ahora es un vector de 1_000_000 u8 n√∫meros. El orden de cada d√©cima parte puede no coincidir aunque en este caso no se nota debido a que todos valen cero inicialmente
    
    println!(&quot;{:?}, {:?}, longitud total: {}&quot;, // se imprimen algunos para comprobar que contienen un 1
        &amp;newvec[0..10], &amp;newvec[newvec.len()-10..newvec.len()], newvec.len() // y se muestra que la longitud es de  1_000_000 de elementos
    );
    
    for number in newvec { // Si alg√∫nvalor no fuese 1 se entra en p√°nico
        if number != 1 {
            panic!();
        }
    }
}
</code></pre></pre>
<p>Para que este ejemplo mantuviese el orden de los elementos originales (en caso de no fuesen todos con el mismo valor), ser√≠a necesario que tambi√©n se trabajara con un √≠ndice de cada secci√≥n para reordenar en el resultado antes de aplanar el vector final.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entender-la-documentaci√≥n-de-rust"><a class="header" href="#entender-la-documentaci√≥n-de-rust">Entender la documentaci√≥n de Rust</a></h1>
<p>Es importante conocer c√≥mo leer la documentaci√≥n de Rust para poder comprender lo que otras personas han escrito. A continuaci√≥n, se observan algunas cosas que es es conveniente conocer de la documentaci√≥n de Rust:</p>
<h2 id="assert_eq"><a class="header" href="#assert_eq">assert_eq!</a></h2>
<p>Como se ha visto, <code>assert_eq!</code> se utiliza durante las pruebas. Se pasan dos elementos y la aplicaci√≥n entra en p√°nico si no son iguales entre s√≠. A continuaci√≥n, se muestra un ejemplo simple en el que se necesita un n√∫mero par.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    prints_number(56);
}

fn prints_number(input: i32) {
    assert_eq!(input % 2, 0); // el resto debe ser cero para que sea par.
                              // Si el resultado de number % 2 si no es 0, entra en p√°nico
    println!(&quot;El n√∫mero no es impar. Es {}&quot;, input);
}
</code></pre></pre>
<p>Puede que no se quiera usar <code>assert_eq!</code> en el c√≥digo que se escriba, pero est√° en todas partes de la documentaci√≥n de Rust. Esto es debido a que en un documento se requiera mucho espacio para usar <code>println!</code> para todo. Adem√°s, se necesitar√≠a que los elementos dispusieran del rasgo <code>Display</code> o <code>Debug</code> para todo lo que se quiera imprimir. Por eso la documentaci√≥n utiliza <code>assert_eq!</code>. El siguiente es un ejmpleo de <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">https://doc.rust-lang.org/std/vec/struct.Vec.html</a> que muestra c√≥mo utilizar <code>Vec</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut vec = Vec::new();
    vec.push(1);
    vec.push(2);

    assert_eq!(vec.len(), 2);
    assert_eq!(vec[0], 1);

    assert_eq!(vec.pop(), Some(2));
    assert_eq!(vec.len(), 1);

    vec[0] = 7;
    assert_eq!(vec[0], 7);

    vec.extend([1, 2, 3].iter().copied());

    for x in &amp;vec {
        println!(&quot;{}&quot;, x);
    }
    assert_eq!(vec, [7, 1, 2, 3]);
}
</code></pre></pre>
<p>En estos ejemplos basta con leer <code>assert_eq(a, b)</code> como que &quot;a es b&quot;. A continuaci√≥n, se muestra el mismo ejemplo con comentarios que indican lo que significa cada fila.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut vec = Vec::new();
    vec.push(1);
    vec.push(2);

    assert_eq!(vec.len(), 2); // &quot;La longitud del vec es 2&quot;
    assert_eq!(vec[0], 1); // &quot;vec[0] es 1&quot;

    assert_eq!(vec.pop(), Some(2)); // &quot;Cuando se usa .pop(), se obtiene un Some()&quot;
    assert_eq!(vec.len(), 1); // &quot;La longitud del vec ahora es 1&quot;

    vec[0] = 7;
    assert_eq!(vec[0], 7); // &quot;Vec[0] es 7&quot;

    vec.extend([1, 2, 3].iter().copied());

    for x in &amp;vec {
        println!(&quot;{}&quot;, x);
    }
    assert_eq!(vec, [7, 1, 2, 3]); // &quot;El vec contiene ahora [7, 1, 2, 3]&quot;
}
</code></pre></pre>
<h2 id="b√∫squedas"><a class="header" href="#b√∫squedas">B√∫squedas</a></h2>
<p>La barra superior en la documentaci√≥n de Rust es la barra de b√∫squeda. Muestra los resultados seg√∫n se teclea. Cuando se avanza en una p√°gina, la barra de b√∫squeda desaparece, pero si se pulsa la tecla <strong>s</strong> en el teclado vuelve a aparecer. Esto permite buscar algo de forma r√°pida.</p>
<h2 id="el-enlace-source"><a class="header" href="#el-enlace-source">El enlace [source]</a></h2>
<p>Normalmente, el c√≥digo de un m√©todo, struct, etc. No estar√° completo. Esto se debe a que normalmente no se necesita ver todo el c√≥digo para conocer como funciona. De hecho, el c√≥digo completo puede hacer m√°s dif√≠cil entender el objetivo de una explicaci√≥n. Pero si se quiere ver, se puede pulsar en [source] y se mostrar√° todo el c√≥digo. Por ejemplo, en la p√°gina dedicada a <code>String</code> se ver la declaraci√≥n de <code>.with_capacity()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
pub fn with_capacity(capacity: usize) -&gt; String
<span class="boring">}
</span></code></pre></pre>
<p>Este m√©todo recibe un n√∫mero y obtiene una <code>String</code>. Si se quiere conocer m√°s, se puede pulsar en el enlace [source] que muestra:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
pub fn with_capacity(capacity: usize) -&gt; String {
    String { vec: Vec::with_capacity(capacity) }
}
<span class="boring">}
</span></code></pre></pre>
<p>Ahora se puede observar que una <code>String</code> es un tipo de <code>Vec</code>. Realmente, un <code>String</code> es un vector de <code>u8</code> bytes, lo que resulta interesante conocer. Para utilizar el m√©todo <code>with_capacity</code> no es necesario conocer este detalle, por eso solo se ve si se pulsa [source]. As√≠ que es una buena idea pulsarlo cuando se quiere conocer los detalles de algo en la documentaci√≥n.</p>
<h2 id="informaci√≥n-sobre-rasgos"><a class="header" href="#informaci√≥n-sobre-rasgos">Informaci√≥n sobre rasgos</a></h2>
<p>La parte importante de la documentaci√≥n de los rasgos es la de los &quot;M√©todos necesitados&quot; (Required Methods) a la izquierda. Cuando en un rasgo existe un apartado a la izquierda con m√©todos necesitados, es probable que signifique que es necesario escribirlos. Por ejemplo, para <code>Iterator</code> se necesita escribir el m√©todo <code>.next()</code>. Y para el rasgo <code>From</code> se necesita escribir el m√©todo <code>.from()</code>. Algunos rasgos se pueden implementar con solo utilizar un  <strong>atributo</strong>, como sucede con el rasgo <code>Debug</code> que basta con usar <code>#[derive(Debug)]</code>. <code>Debug</code> necesita el m√©todo <code>.fmt()</code>, pero normalmente no es necesario escribirlo ya que el atributo <code>#[derive(Debug)]</code> resulta suficiente para ello. Por eso, la p√°gina de <code>std::fmt::Debug</code> dice que &quot;en general,  deber√≠a ser suficiente con derivar la implementaci√≥n de Debug&quot;.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atributos"><a class="header" href="#atributos">Atributos</a></h1>
<p>Ya se ha visto anteriormente c√≥digo como este <code>#[derive(Debug)]</code>. Este tipo de c√≥digo es un <em>atributo</em>. Los atributos son peque√±as piezas de c√≥digo que dan informaci√≥n al compilador. No son f√°ciles de crear, pero son muy f√°ciles de usar. Un atributo puede comenzar con solo <code>#</code>, lo que significa que solo afecta al c√≥digo de la siguiente l√≠nea. Sin embargo, si comienza con <code>#!</code> afectar√° a todo lo que est√© en su espacio.</p>
<p>Hay atributos que aparecen mucho:</p>
<p><code>#[allow(dead_code)]</code> y <code>#[allow(unused_variables)]</code>. Si el fichero contiene c√≥digo que no se utiliza, Rust compilar√°, pero avisar√°. Por ejemplo, el siguiente c√≥digo contiene un <code>struct</code> vac√≠o y una variable. Ninguno se usa en el c√≥digo:</p>
<pre><pre class="playground"><code class="language-rust">struct JustAStruct {}

fn main() {
    let some_char = '„Çì';
}
</code></pre></pre>
<p>Rust se queja e indica que no se usan:</p>
<pre><code class="language-text">warning: unused variable: `some_char`
 --&gt; src\main.rs:4:9
  |
4 |     let some_char = '„Çì';
  |         ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_some_char`
  |
  = note: `#[warn(unused_variables)]` on by default

warning: struct is never constructed: `JustAStruct`
 --&gt; src\main.rs:1:8
  |
1 | struct JustAStruct {}
  |        ^^^^^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default
</code></pre>
<p>Se ha visto que se puede utilizar un gui√≥n bajo para indicar que no se usa <code>_</code>:</p>
<pre><pre class="playground"><code class="language-rust">struct _JustAStruct {}

fn main() {
    let _some_char = '„Çì';
}
</code></pre></pre>
<p>Pero tambi√©n se puede utilizar un atributo. El propio mensaje de Rust indica que tiene activo los atributos <code>#[warn(unused_variables)]</code> y <code>#[warn(dead_code)]</code>. En el c√≥digo anterior, <code>JustAStruct</code> es c√≥digo muerto y <code>some_char</code> es una variable sin usar. El atributo opuesto a <code>warn</code> es <code>allow</code>, por lo que se puede escribire en el c√≥digo y Rust dejar√° de avisar para estos casos:</p>
<pre><pre class="playground"><code class="language-rust">#![allow(dead_code)]
#![allow(unused_variables)]

struct Struct1 {} // Crea cinco structs
struct Struct2 {}
struct Struct3 {}
struct Struct4 {}
struct Struct5 {}

fn main() {
    let char1 = '„Çì'; // y cuatro variables. No se usa ninguno de ellos, pero el compilador ya no da ning√∫n mensaje
    let char2 = ';';
    let some_str = &quot;I'm just a regular &amp;str&quot;;
    let some_vec = vec![&quot;I&quot;, &quot;am&quot;, &quot;just&quot;, &quot;a&quot;, &quot;vec&quot;];
}
</code></pre></pre>
<p>Es importante tener en cuenta el c√≥digo muerto y las variables sin uso, pero en ocasiones puede ser necesario que el compilador deje de avisar durante un tiempo. Se puede necesitar desarrollar el c√≥digo o ense√±ar a alguien y no se quiere confundir con excesivos mensajes.</p>
<p>El atributo <code>#[derive(NombreDeRasfgo)]</code> permite derivar algunos rasgos para los struct y enum que se creen. Diversos rasgos de uso com√∫n, como <code>Debug</code>, pueden derivarse de esta forma. Otros, como <code>Display</code>, no se pueden derivar. En el caso de <code>Display</code> es necesari que se dedica por parte del desarrollador c√≥mo se quiere mostrar el elemento.</p>
<pre><pre class="playground"><code class="language-rust">// ‚ö†Ô∏è
#[derive(Display)]
struct HoldsAString {
    the_string: String,
}

fn main() {
    let my_string = HoldsAString {
        the_string: &quot;¬°Aqu√≠ estoy!&quot;.to_string(),
    };
}
</code></pre></pre>
<p>El mensaje de error lo indica bien claro:</p>
<pre><code class="language-text">error: cannot find derive macro `Display` in this scope
 --&gt; src/main.rs:2:10
  |
2 | #[derive(Display)]
  |          ^^^^^^^
</code></pre>
<p>Pero en los casos de rasgos que se pueden derivar, se pueden indicar tantos como se necesite. En el siguiente ejemplo se le dan siete rasgos diferentes a un <code>struct</code>, solo por gusto, aunque solo se necesite uno en este caso.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug, PartialEq, Eq, Ord, PartialOrd, Hash, Clone)]
struct HoldsAString {
    the_string: String,
}

fn main() {
    let my_string = HoldsAString {
        the_string: &quot;¬°Aqu√≠ estoy!&quot;.to_string(),
    };
    println!(&quot;{:?}&quot;, my_string);
}
</code></pre></pre>
<p>Se puede derivar <code>Copy</code>, pero solo en los casos que un elemento solo contiene elementos que tambi√©n tienen el rasgo <code>Copy</code>. En el ejemplo anterior no es posible puesto que <code>String</code> no tiene dicho rasgo y el <code>struct HodsAString</code> contiene una variable de dicho tipo. Sin embargo en el siguiente ejemplo s√≠ se puede derivar <code>Copy</code> al contener tipos que disponen de dicho rasgo:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone, Copy)] // Se necesita Clone para usar Copy
struct NumberAndBool {
    number: i32, // i32 es Copy
    true_or_false: bool // bool es tambi√©n Copy. Por lo que no es problema
}

fn does_nothing(input: NumberAndBool) {

}

fn main() {
    let number_and_bool = NumberAndBool {
        number: 8,
        true_or_false: true
    };

    does_nothing(number_and_bool);
    does_nothing(number_and_bool); // Sin Copy, esta fila dar√≠a error
}
</code></pre></pre>
<p>El atributo <code>#[cfg()]</code> significa configuraci√≥n e indica al compilador si ejecutar c√≥digo o no. Normalmente, se encuentra de la siguiente forma <code>#[cfg(test)]</code>. Se usa cuando se escriben funciones de prueba para que el compilador solo las ejecute cuando se est√° probando. As√≠, el c√≥digo de prueba puede estar junto al c√≥digo del programa sin que el compilador lo ejecute, salvo cuando se le indica.</p>
<p>Otro ejemplo del uso de <code>cfg</code> es <code>#[cfg(target_os = &quot;windows&quot;)]</code>. Que indica que solo se ejecute el c√≥digo en windows (o linux u otro sistema).</p>
<p>El atributo <code>#![no_std]</code> indica a Rust que no incorpore la librer√≠a est√°ndar. Esto implica que no se dispone de <code>Vec</code>, <code>String</code> y todo lo que aporta esta librer√≠a. Es √∫til cuando no es necesaria y el c√≥digo tiene que ejecutarse en peque√±os dispositivos con poca memoria.</p>
<p>Los diferentes atributos disponibles se pueden consultar <a href="https://doc.rust-lang.org/reference/attributes.html">aqu√≠</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="box"><a class="header" href="#box">Box</a></h1>
<p><code>Box</code> se trata de un tipo muy util en Rust. Permite almacenar en el <code>heap</code> (el mont√≥n) un valor, en lugar de almacenarlo en la pila. Para crear un elemento de este tipo se usa <code>Box::new()</code> con el elemento como par√°metro.</p>
<pre><pre class="playground"><code class="language-rust">fn just_takes_a_variable&lt;T&gt;(item: T) {} // Toma cualquier variable y la olvida.

fn main() {
    let my_number = 1; // Este es de tipo i32
    just_takes_a_variable(my_number);
    just_takes_a_variable(my_number); // no hay problema en usarla dos veces porque el tipo permite Copy

    let my_box = Box::new(1); // Este es de tipo Box&lt;i32&gt;
    just_takes_a_variable(my_box.clone()); // Sin .clone() la segunda funci√≥n dar√≠a error
    just_takes_a_variable(my_box); // debido a que Box no dispone de Copy
}
</code></pre></pre>
<p>Al principio, resulta dif√≠cil pensar en la utilidad de este tipo, pero se usa mucho en Rust. Si se recuerda, <code>&amp;</code> se usa para los <code>str</code> debido a que el compilador no conoce su tama√±o: <code>str</code> puede ser de cualquier longitud. Y la referencia <code>&amp;</code> s√≠ que tiene un tama√±o conocido, siempre igual. <code>Box</code> se comporta de forma similar. Adem√°s, <code>*</code> sirve para extraer el valor de un <code>Box</code>. Igual que sucede con <code>&amp;</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_box = Box::new(1); // Este es Box&lt;i32&gt;
    let an_integer = *my_box; // Este es i32
    println!(&quot;{:?}&quot;, my_box);
    println!(&quot;{:?}&quot;, an_integer);
}
</code></pre></pre>
<p>Por este motivo se denomina &quot;puntero inteligente&quot; a <code>Box</code>, porque es como una referencia (un tipo de puntero), pero facilita otro conjunto de cosas.</p>
<p>Se puede usar <code>Box</code> para crear un <code>struct</code> con la misma estructura en su interior. A esto se le denomina <em>estructura recursiva</em>. Es decir, que dentro de un <code>Struc A</code> puede haber otro <code>Struct A</code>. En ocasiones, se puede necesitar <code>Box</code> para crear listas enlazadas, aunque este tipo de listas no son muy populares en Rust. A continuaci√≥n se muestra un ejemplo que muestra lo que sucede si se intenta crear una estructura recursiva sin <code>Box</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct List {
    item: Option&lt;List&gt;, // ‚ö†Ô∏è
}
<span class="boring">}
</span></code></pre></pre>
<p>Este struct simple contiene un √∫nico elemento que puede ser <code>Some&lt;List&gt;</code> o <code>None</code>. Debido a que se puede incorporar este √∫ltimo, el struct no es recursivo hasta el infinito. Pero el compilador no puede conocer su tama√±o para poder depositar sus elementos en la pila:</p>
<pre><code class="language-text">error[E0072]: recursive type `List` has infinite size
 --&gt; src/main.rs:3:1
  |
3 | struct List {
  | ^^^^^^^^^^^ recursive type has infinite size
4 |     item: Option&lt;List&gt;, // ‚ö†Ô∏è
  |           ------------ recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to make `List` representable
</code></pre>
<p>Se observa que el propio compilador sugiere que se use <code>Box</code>. Si se aplica este cambio:</p>
<pre><pre class="playground"><code class="language-rust">struct List {
    item: Option&lt;Box&lt;List&gt;&gt;,
}
fn main() {}
</code></pre></pre>
<p>Ahora el compilador acepta el <code>struct List</code>, debido a que la recursividad se encuentra detr√°s de un <code>Box</code> y el tama√±o de este es conocido.</p>
<p>Un lista simple podr√≠a definirse as√≠:</p>
<pre><pre class="playground"><code class="language-rust">struct List {
    item: Option&lt;Box&lt;List&gt;&gt;,
}

impl List {
    fn new() -&gt; List {
        List {
            item: Some(Box::new(List { item: None })),
        }
    }
}

fn main() {
    let mut my_list = List::new();
}
</code></pre></pre>
<p>Incluso sin datos es un poco complejo. Rust no usa este tipo de patr√≥n muy a menudo. Esto se debe a las estrictas reglas de propiedad y pr√©stamo que tiene Rust. En todo caso, si se necesita un tipo cualquiera de lista enlazada, <code>Box</code> puede ayudar.</p>
<p><code>Box</code> permite el uso de <code>std::mem::drop</code> sobre un elemento de este tipo ya que el elemento se encuentra en el <code>heap</code> (mont√≥n). Esto puede ser √∫til en ocasiones.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="box-y-los-rasgos"><a class="header" href="#box-y-los-rasgos">Box y los rasgos</a></h1>
<p><code>Box</code> es muy √∫til para devolver rasgos. Como ya se conoce, se pueden escribir rasgos en funciones gen√©ricas como la del siguiente ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

struct DoesntImplementDisplay {}

fn displays_it&lt;T: Display&gt;(input: T) {
    println!(&quot;{}&quot;, input);
}

fn main() {}
</code></pre></pre>
<p>Como la funci√≥n <code>displays_it</code> solo recibe un elemento que implemente <code>Display</code>, no puede aceptar elementos del tipo <code>struct DoesntImplementDisplay</code>. Sin embargo, puede recibir como par√°metro otros elementos como <code>String</code>.</p>
<p>Tambi√©n se ha visto que se puede usar <code>impl Trait</code> para devolver otros rasgos o cierres. <code>Box</code> se puede usar de una forma similar ya que permite que el compilador conozca el tama√±o del elemento a devolver. El siguiente ejemplo muestra que un rasgo puede usarse en un elemento de cualquier tama√±o:</p>
<pre><pre class="playground"><code class="language-rust">#![allow(dead_code)] // Le dice al compilador que no se queje con c√≥digo muerto
use std::mem::size_of; // Es funci√≥n devuelve el tama√±o de un tipo determinado

trait JustATrait {} // Se implementar√° este rasgo en todos los tipos

enum EnumOfNumbers {
    I8(i8),
    AnotherI8(i8),
    OneMoreI8(i8),
}
impl JustATrait for EnumOfNumbers {}

struct StructOfNumbers {
    an_i8: i8,
    another_i8: i8,
    one_more_i8: i8,
}
impl JustATrait for StructOfNumbers {}

enum EnumOfOtherTypes {
    I8(i8),
    AnotherI8(i8),
    Collection(Vec&lt;String&gt;),
}
impl JustATrait for EnumOfOtherTypes {}

struct StructOfOtherTypes {
    an_i8: i8,
    another_i8: i8,
    a_collection: Vec&lt;String&gt;,
}
impl JustATrait for StructOfOtherTypes {}

struct ArrayAndI8 {
    array: [i8; 1000], // Este va a ser muy largo
    an_i8: i8,
    in_u8: u8,
}
impl JustATrait for ArrayAndI8 {}

fn main() {
    println!(
        &quot;{}, {}, {}, {}, {}&quot;,
        size_of::&lt;EnumOfNumbers&gt;(),
        size_of::&lt;StructOfNumbers&gt;(),
        size_of::&lt;EnumOfOtherTypes&gt;(),
        size_of::&lt;StructOfOtherTypes&gt;(),
        size_of::&lt;ArrayAndI8&gt;(),
    );
}
</code></pre></pre>
<p>Cuando se imprime el resultado del tama√±o de estos objetos se obtiene <code>2, 3, 32, 1002</code>. Por ello, si se devolviera lo siguiente, dar√≠a error:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚ö†Ô∏è
fn returns_just_a_trait() -&gt; JustATrait {
    let some_enum = EnumOfNumbers::I8(8);
    some_enum
}
<span class="boring">}
</span></code></pre></pre>
<p>El compilador dice:</p>
<pre><code class="language-text">error[E0746]: return type cannot have an unboxed trait object
  --&gt; src\main.rs:53:30
   |
53 | fn returns_just_a_trait() -&gt; JustATrait {
   |                              ^^^^^^^^^^ doesn't have a size known at compile-time
</code></pre>
<p>Debido a que el rasgo puede implementarse por objetos de diverso tama√±o, el compilador se queja. Para que funcione, es necesario guardar el objeto en un <code>Box</code>. Adem√°s, hace falta indicar <code>dyn</code>, que sirve para indicar que se est√° devolviendo en tiempo de ejecuci√≥n un elemento de diverso tipo, que est√° representado por un rasgo que s√≠ que tienen que tener los valores a devolver (N.T.: Es una forma de polimorfismo).</p>
<p>La nueva funci√≥n queda as√≠:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
fn returns_just_a_trait() -&gt; Box&lt;dyn JustATrait&gt; {
    let some_enum = EnumOfNumbers::I8(8);
    Box::new(some_enum)
}
<span class="boring">}
</span></code></pre></pre>
<p>Ahora funciona. En la pila se puede incorporar el elemento <code>Box</code> de tama√±o fijo.</p>
<p>Esta forma de c√≥digo se encuentra mucho en la forma de <code>Box&lt;dyn Error&gt;</code>, debido a que en ocasiones puede haber diversos tipos de error.</p>
<p>El siguiente ejemplo muestra dos tipos de error. Para crear un elemento de tipo <code>Error</code> que sea oficial, se debe implementar el rasgo <code>std::error::Error</code>. Esto es f√°cil, simplemente se escribe <code>impl std::error::Error {}</code>. Los tipos de error tambi√©n tienen que implementar <code>Debug</code> y <code>Display</code> para que puedan mostrar informaci√≥n sobre el problema. <code>Debug</code> es f√°cil de implementar, basta con <code>#[derive(Debug)]</code>, pero <code>Display</code> necesita el m√©todo <code>.fmt()</code>. Esto ya se ha codificado antes:</p>
<pre><pre class="playground"><code class="language-rust">use std::error::Error;
use std::fmt;

#[derive(Debug)]
struct ErrorOne;

impl Error for ErrorOne {} // Ahora ya es un tipo de eroro con Debug. Falta Display:

impl fmt::Display for ErrorOne {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;¬°Se ha producido el primer error!&quot;) // Todo lo que hace es escribir este mensaje
    }
}


#[derive(Debug)] // Se hace lo mismo con ErrorTwo
struct ErrorTwo;

impl Error for ErrorTwo {}

impl fmt::Display for ErrorTwo {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;¬°Se ha producido el segundo error!&quot;)
    }
}

// Se crea una funci√≥n que devuelve un String o Errores
fn returns_errors(input: u8) -&gt; Result&lt;String, Box&lt;dyn Error&gt;&gt; { // Con Box&lt;dyn Error&gt; se puede devolver cualquier elemento que implemente el rasgo Error

    match input {
        0 =&gt; Err(Box::new(ErrorOne)), // no se puede olvidar que debe estar en una Box
        1 =&gt; Err(Box::new(ErrorTwo)),
        _ =&gt; Ok(&quot;Parece correcto&quot;.to_string()), // Este es el tipo de retorno correcto
    }

}

fn main() {

    let vec_of_u8s = vec![0_u8, 1, 80]; // Tres n√∫meros de prueba

    for number in vec_of_u8s {
        match returns_errors(number) {
            Ok(input) =&gt; println!(&quot;{}&quot;, input),
            Err(message) =&gt; println!(&quot;{}&quot;, message),
        }
    }
}
</code></pre></pre>
<p>Este c√≥digo imprime:</p>
<pre><code class="language-text">¬°Se ha producido el primer error!
¬°Se ha producido el segundo error!
Parece correcto
</code></pre>
<p>Si no se devolviera <code>Box&lt;dyn Error&gt;</code> se producir√≠a un error al compilar:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚ö†Ô∏è
fn returns_errors(input: u8) -&gt; Result&lt;String, Error&gt; {
    match input {
        0 =&gt; Err(ErrorOne),
        1 =&gt; Err(ErrorTwo),
        _ =&gt; Ok(&quot;Parece correcto&quot;.to_string()),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Producir√° el siguiente error durante la compilaci√≥n:</p>
<pre><code class="language-text">21  | fn returns_errors(input: u8) -&gt; Result&lt;String, Error&gt; {
    |                                 ^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
</code></pre>
<p>Lo que no es sorprendente ya que los rasgos se pueden implementar por muchos tipos diferentes que pueden tener diferente tama√±o.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="default-y-el-patr√≥n-constructor-builder"><a class="header" href="#default-y-el-patr√≥n-constructor-builder">Default y el patr√≥n constructor (builder)</a></h1>
<p>Se puede implementar el rasgo <code>Default</code> para inicializar un <code>struct</code> o <code>enum</code> a los valores que se consideren m√°s habituales. El patr√≥n constructor (builder) se usa de forma combinada con esto para facilitar a los usuarios realizar aquellos cambios que quieran. En primer lugar se va a ver <code>Default</code>. Los tipos generales de Rust ya implementan <code>Default</code>. Son valores bastante habituales: <code>0</code>, <code>&quot;&quot;</code> (cadenas de caracteres vac√≠a), <code>false</code>, etc.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let default_i8: i8 = Default::default();
    let default_str: String = Default::default();
    let default_bool: bool = Default::default();

    println!(&quot;'{}', '{}', '{}'&quot;, default_i8, default_str, default_bool);
}
</code></pre></pre>
<p>Lo anterior imprime '0', ''. 'false'.</p>
<p>As√≠, <code>Default</code> es como la funci√≥n <code>new</code>, salvo que no hay que darle nig√∫n valor. En primer lugar, se va a mostrar un <code>struct</code> uqe no implemente <code>Default</code>. Tendr√° una funci√≥n <code>new</code> que se usa para crear un personaje denominado Billy con algunas caracter√≠sticas.</p>
<pre><pre class="playground"><code class="language-rust">struct Personaje {
    nombre: String,
    edad: u8,
    estatura: u32,
    peso: u32,
    estadovital: EstadoVital,
}

enum EstadoVital {
    Vivo,
    Muerto,
    NuncaVivo,
    Desconocido
}

impl Personaje {
    fn new(nombre: String, edad: u8, estatura: u32, peso: u32, vivo: bool) -&gt; Self {
        Self {
            nombre,
            edad,
            estatura,
            peso,
            estadovital: if vivo { EstadoVital::Vivo } else { EstadoVital::Muerto },
        }
    }
}

fn main() {
    let personaje_1 = Personaje::new(&quot;Billy&quot;.to_string(), 15, 170, 70, true);
}
</code></pre></pre>
<p>Puede que en este mundo, la mayor√≠a de los personajes se llamen Billy, tengan edad de 15 a√±os, estatura de 170, peso de 70 y est√©n vivos. Para ello, se puede implementar <code>Default</code> de forma que se pueda crear un personaje est√°ndar con solo <code>Personaje::default()</code>. Se har√≠a de la siguiente forma:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Personaje {
    nombre: String,
    edad: u8,
    estatura: u32,
    peso: u32,
    estadovital: EstadoVital,
}

#[derive(Debug)]
enum EstadoVital {
    Vivo,
    Muerto,
    NuncaVivo,
    Desconocido
}

impl Personaje {
    fn new(nombre: String, edad: u8, estatura: u32, peso: u32, vivo: bool) -&gt; Self {
        Self {
            nombre,
            edad,
            estatura,
            peso,
            estadovital: if vivo { EstadoVital::Vivo } else { EstadoVital::Muerto },
        }
    }
}

impl Default for Personaje {
    fn default() -&gt; Self {
        Self {
            nombre: &quot;Billy&quot;.to_string(),
            edad: 15,
            estatura: 170,
            peso: 70,
            estadovital: EstadoVital::Vivo,
        }
    }
}

fn main() {
    let personaje_1 = Personaje::default();

    println!(
        &quot;El personaje {:?} tiene {:?} a√±os.&quot;,
        personaje_1.nombre, personaje_1.edad
    );
}
</code></pre></pre>
<p>El c√≥digo anterior imprime <code>El personaje &quot;Billy&quot; tiene 15 a√±os.</code>.</p>
<h2 id="el-patr√≥n-constructor-builder"><a class="header" href="#el-patr√≥n-constructor-builder">El patr√≥n constructor (builder)</a></h2>
<p>A continuaci√≥n se mostrar√° c√≥mo utilizar el patr√≥n constructor. Se mantiene el valor por defecto usando el rasgo <code>Default</code>. A veces, algunos personajes solo ser√°n ligeramente diferentes a &quot;Billy&quot;. El patr√≥n constructor establece una cadena de m√©todos para cambiar un valor cada vez. A continuaci√≥n se muestra uno de estos m√©todos para el <code>Personaje</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn estatura(mut self, estatura: u32) -&gt; Self {    // üöß
    self.estatura = estatura;
    self
}
<span class="boring">}
</span></code></pre></pre>
<p>Se debe prestar atenci√≥n a que toma como par√°metro un <code>mut self</code>. Esto ya se vio anteriormente. No es una referencia <code>&amp;mut self</code>). Toma propiedad de <code>Self</code> y con <code>mut</code> es modificable, aunque no lo fuese antes. Esto es debido a que <code>.estatura()</code> obtiene la completa propiedad y nadie lo puede tocar, por lo que es seguro usar <code>mut</code> y el compilador no se queja. Luego solo le cambia el valor <code>self.estatura</code> y devuelve <code>Self</code> (que es de tipo <code>Personaje</code>).</p>
<p>En el ejemplo, se crean tres m√©todos constructores. Son muy parecidos:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn estatura(mut self, estatura: u32) -&gt; Self {     // üöß
    self.estatura = estatura;
    self
}

fn peso(mut self, peso: u32) -&gt; Self {
    self.peso = peso;
    self
}

fn nombre(mut self, nombre: &amp;str) -&gt; Self {
    self.nombre = nombre.to_string();
    self
}
<span class="boring">}
</span></code></pre></pre>
<p>Cada uno de estos m√©todos modifica una variable y devuelve <code>Self</code>: esto es lo que define a un patr√≥n constructor. As√≠, se puede escribir lo siguiente para construir un personaje: <code>let personaje_1 = Personaje::default().estatura(180).peso(60).nombre(&quot;Bobby&quot;);</code>- Si se est√° construyendo una librer√≠a, esto hace que sea m√°s f√°cil el crear nuevos elementos ya que queda legible lo que se est√° haciendo. Con estos cambios, el c√≥digo queda as√≠:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Personaje {
    nombre: String,
    edad: u8,
    estatura: u32,
    peso: u32,
    estadovital: EstadoVital,
}

#[derive(Debug)]
enum EstadoVital {
    Vivo,
    Muerto,
    NuncaVivo,
    Desconocido
}

impl Personaje {
    fn new(nombre: String, edad: u8, estatura: u32, peso: u32, vivo: bool) -&gt; Self {
        Self {
            nombre,
            edad,
            estatura,
            peso,
            estadovital: if vivo { EstadoVital::Vivo } else { EstadoVital::Muerto },
        }
    }
    fn estatura(mut self, estatura: u32) -&gt; Self {     
        self.estatura = estatura;
        self
    }

    fn peso(mut self, peso: u32) -&gt; Self {
        self.peso = peso;
        self
    }

    fn nombre(mut self, nombre: &amp;str) -&gt; Self {
        self.nombre = nombre.to_string();
        self
    }
}

impl Default for Personaje {
    fn default() -&gt; Self {
        Self {
            nombre: &quot;Billy&quot;.to_string(),
            edad: 15,
            estatura: 170,
            peso: 70,
            estadovital: EstadoVital::Vivo,
        }
    }
}

fn main() {
    let personaje_1 = Personaje::default().estatura(180).peso(60).nombre(&quot;Bobby&quot;);;

    println!(&quot;{:?}&quot;, personaje_1);
}
</code></pre></pre>
<p>Un √∫ltimo m√©todo que se suele a√±adir es <code>.build()</code>. Este m√©todo es una especie de validaci√≥n final. Por ejemplo, para comprobar que la estatura no contenga un valor de 5000. Con este m√©todo <code>build()</code> que deber√≠a devolver un <code>Result</code>,  se pueden establecer validaciones para comprobar si es correcto el elemento que se est√° construyendo. Si lo es, se puede devolver <code>Ok(Self)</code>.</p>
<p>En primer lugar, se modifica el m√©todo <code>new()</code> para que no reciba par√°metros. Se evita que los usuarios sean libres de crear cualquier persona con cualquier valor. Los valores que utiliza la implementaci√≥n de <code>Default</code> se pasan a <code>.new()</code>, que queda as√≠:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn new() -&gt; Self {    // üöß
        Self {
            nombre: &quot;Billy&quot;.to_string(),
            edad: 15,
            estatura: 170,
            peso: 70,
            estadovital: EstadoVital::Vivo,
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>As√≠, deja de ser necesaria la implementaci√≥n del rasgo <code>Default</code>. Por tanto, se puede eliminar del c√≥digo, que queda as√≠:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Personaje {
    nombre: String,
    edad: u8,
    estatura: u32,
    peso: u32,
    estadovital: EstadoVital,
}

#[derive(Debug)]
enum EstadoVital {
    Vivo,
    Muerto,
    NuncaVivo,
    Desconocido
}

impl Personaje {
    fn new() -&gt; Self {    
        Self {
            nombre: &quot;Billy&quot;.to_string(),
            edad: 15,
            estatura: 170,
            peso: 70,
            estadovital: EstadoVital::Vivo,
        }
    }

    fn estatura(mut self, estatura: u32) -&gt; Self {     
        self.estatura = estatura;
        self
    }

    fn peso(mut self, peso: u32) -&gt; Self {
        self.peso = peso;
        self
    }

    fn nombre(mut self, nombre: &amp;str) -&gt; Self {
        self.nombre = nombre.to_string();
        self
    }
}

fn main() {
    let personaje_1 = Personaje::new().estatura(180).peso(60).nombre(&quot;Bobby&quot;);;

    println!(&quot;{:?}&quot;, personaje_1);
}
</code></pre></pre>
<p>Lo anterior, imprime lo mismo que antes: <code>Personaje { nombre: &quot;Bobby&quot;, edad: 15, estatura: 180, peso: 60, estadovital: Vivo }</code>.</p>
<p>Con el c√≥digo anterior, casi se puede implementar el m√©todo <code>build()</code>, pero hay un problema: ¬øc√≥mo se fuerza al usuario a que lo utilice despu√©s de poner todos los valores de los diferentes atributos? En este momento, el usuario puede escribir solo <code>let x = Personaje::new().estatura(76767);</code> y obtener un <code>Personaje</code> con una estatura imposible. Hay diversas formas de hacerlo. Una de ellas consiste en a√±adir a <code>Personaje</code> un atributo <code>se_puede_usar: bool</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn new() -&gt; Self {    // üöß
        Self {
            nombre: &quot;Billy&quot;.to_string(),
            edad: 15,
            estatura: 170,
            peso: 70,
            estadovital: EstadoVital::Vivo,
            se_puede_usar: true, // .new() devuelve un elemento v√°lido, se puede usar.
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>Los dem√°s m√©todos constructores como <code>.estatura()</code>, establecer√°n <code>se_puede_usar</code> a <code>false</code>. Solo <code>.build()</code> lo volver√° a establecer a <code>true</code>. As√≠, el usuario se ver√° obligado a llamar a este m√©todo de comprobaci√≥n. Se validar√° que la estatura no es superior a 250 y el peso no es superior a 300. Tambi√©n se comprobar√° que los personajes no puedan llamarse <code>smurf</code>.</p>
<p>El m√©todo <code>.build()</code> queda como sigue:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn build(mut self) -&gt; Result&lt;Personaje, String&gt; {      // üöß
    if self.estatura &lt; 250 &amp;&amp; self.peso &lt; 300 &amp;&amp; !self.nombre.to_lowercase().contains(&quot;smurf&quot;) {
        self.se_puede_usar = true;
        Ok(self)
    } else {
        Err(&quot;No se puede crear el Personaje. Los Personajes deben tener:
1) estatura menor a 250
2) peso menor a 300
3) nombre diferente a Smurf (es una palabra fea)&quot;
            .to_string())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>!self.nombre.to_lowercase().contains(&quot;smurf&quot;)</code> sirve para asegurar que el usuario no escribe variaciones de esta palabra como &quot;SMURF&quot; o &quot;SoySmurf&quot;. Pasa la cadena de caracteres a min√∫scula y comprueba que no contenga el texto. La <code>!</code> significa <code>no</code>.</p>
<p>Si el personaje es correcto, se activa <code>se_puede_usar</code> a <code>true</code> y se devuelve el personaje dentro del elemento <code>Ok</code>.</p>
<p>As√≠ queda el c√≥digo completo. Se muestra creando tres personajes que no cumplen los requisitos y un personaje que s√≠.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Personaje {
    nombre: String,
    edad: u8,
    estatura: u32,
    peso: u32,
    estadovital: EstadoVital,
    se_puede_usar: bool,
}

#[derive(Debug)]
enum EstadoVital {
    Vivo,
    Muerto,
    NuncaVivo,
    Desconocido
}

impl Personaje {
    fn new() -&gt; Self {    
        Self {
            nombre: &quot;Billy&quot;.to_string(),
            edad: 15,
            estatura: 170,
            peso: 70,
            estadovital: EstadoVital::Vivo,
            se_puede_usar: true,
        }
    }

    fn estatura(mut self, estatura: u32) -&gt; Self {     
        self.estatura = estatura;
        self.se_puede_usar = false;
        self
    }

    fn peso(mut self, peso: u32) -&gt; Self {
        self.peso = peso;
        self.se_puede_usar = false;
        self
    }

    fn nombre(mut self, nombre: &amp;str) -&gt; Self {
        self.nombre = nombre.to_string();
        self.se_puede_usar = false;
        self
    }

    fn build(mut self) -&gt; Result&lt;Personaje, String&gt; { 
        if self.estatura &lt; 250 &amp;&amp; self.peso &lt; 300 &amp;&amp; !self.nombre.to_lowercase().contains(&quot;smurf&quot;) {
            self.se_puede_usar = true;
            Ok(self)
        } else {
            Err(&quot;No se puede crear el Personaje. Los Personajes deben tener:
1) estatura menor a 250
2) peso menor a 300
3) nombre diferente a Smurf (es una palabra fea)&quot;
                .to_string())
        }
    }
}

fn main() {
 let personaje_con_smurf = Personaje::new().nombre(&quot;jeje, soy Smurf!!&quot;).build(); // Este contiene &quot;smurf&quot; - no es correcto
    let personaje_demasiado_alto = Personaje::new().estatura(400).build(); // Demasiado alto - no es correcto
    let personaje_demasiado_pesado = Personaje::new().peso(500).build(); // Demasiado pesado - no es correcto
    let personaje_correcto = Personaje::new()
        .nombre(&quot;Billybrobby&quot;)
        .estatura(180)
        .peso(100)
        .build();   // Este es correcto, peso, estatura y nombre

    // Las cuatro variables no son Personaje, son Result&lt;Personaje, String&gt;. Se meten en un vector y se ve el resultado:
    let personaje_vec = vec![personaje_con_smurf, personaje_demasiado_alto, personaje_demasiado_pesado, personaje_correcto];

    for Personaje in personaje_vec { // Se imprimir√° para ver si hay un error o no
        match Personaje {
            Ok(personaje_info) =&gt; println!(&quot;{:?}&quot;, personaje_info),
            Err(err_info) =&gt; println!(&quot;{}&quot;, err_info),
        }
        println!(); // A√±ade una l√≠nea separadora
    }
}
</code></pre></pre>
<p>El c√≥digo anterior da como resultado:</p>
<pre><code class="language-text">No se puede crear el Personaje. Los Personajes deben tener:
1) estatura menor a 250
2) peso menor a 300
3) nombre diferente a Smurf (es una palabra fea)

No se puede crear el Personaje. Los Personajes deben tener:
1) estatura menor a 250
2) peso menor a 300
3) nombre diferente a Smurf (es una palabra fea)

No se puede crear el Personaje. Los Personajes deben tener:
1) estatura menor a 250
2) peso menor a 300
3) nombre diferente a Smurf (es una palabra fea)

Personaje { nombre: &quot;Billybrobby&quot;, edad: 15, estatura: 180, peso: 100, estadovital: Vivo, se_puede_usar: true }
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
