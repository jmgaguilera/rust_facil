<!DOCTYPE HTML>
<html lang="es" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust en espa√±ol f√°cil</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="actualizaciones.html">Actualizaciones</a></li><li class="chapter-item expanded affix "><a href="introduccion.html">Introducci√≥n</a></li><li class="chapter-item expanded affix "><a href="quiensoy.html">¬øQui√©n soy?</a></li><li class="chapter-item expanded affix "><a href="escritura.html">La escritura de Rust en ingl√©s f√°cil</a></li><li class="chapter-item expanded affix "><li class="part-title">Parte 1 - Rust en tu navegador</li><li class="chapter-item expanded "><a href="01.html"><strong aria-hidden="true">1.</strong> El entorno de pruebas de Rust</a></li><li class="chapter-item expanded "><a href="02.html"><strong aria-hidden="true">2.</strong> üöß y ‚ö†Ô∏è</a></li><li class="chapter-item expanded "><a href="03.html"><strong aria-hidden="true">3.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="04.html"><strong aria-hidden="true">4.</strong> Tipos de dato</a></li><li class="chapter-item expanded "><a href="05.html"><strong aria-hidden="true">5.</strong> Inferencia de tipos de dato</a></li><li class="chapter-item expanded "><a href="06.html"><strong aria-hidden="true">6.</strong> Imprimiendo '¬°Hola, mundo!'</a></li><li class="chapter-item expanded "><a href="07.html"><strong aria-hidden="true">7.</strong> La visualizaci√≥n y depuraci√≥n</a></li><li class="chapter-item expanded "><a href="08.html"><strong aria-hidden="true">8.</strong> Mutabilidad (cambio)</a></li><li class="chapter-item expanded "><a href="09.html"><strong aria-hidden="true">9.</strong> La pila, la memoria din√°mica y los punteros</a></li><li class="chapter-item expanded "><a href="10.html"><strong aria-hidden="true">10.</strong> M√°s sobre impresi√≥n</a></li><li class="chapter-item expanded "><a href="11.html"><strong aria-hidden="true">11.</strong> Cadenas de caracteres</a></li><li class="chapter-item expanded "><a href="12.html"><strong aria-hidden="true">12.</strong> const y static</a></li><li class="chapter-item expanded "><a href="13.html"><strong aria-hidden="true">13.</strong> Algo m√°s sobre referencias</a></li><li class="chapter-item expanded "><a href="14.html"><strong aria-hidden="true">14.</strong> Referencias modificables (mutables)</a></li><li class="chapter-item expanded "><a href="15.html"><strong aria-hidden="true">15.</strong> Paso de referencias a funciones</a></li><li class="chapter-item expanded "><a href="16.html"><strong aria-hidden="true">16.</strong> Copia</a></li><li class="chapter-item expanded "><a href="17.html"><strong aria-hidden="true">17.</strong> Tipos colecci√≥n</a></li><li class="chapter-item expanded "><a href="18.html"><strong aria-hidden="true">18.</strong> Vectores</a></li><li class="chapter-item expanded "><a href="19.html"><strong aria-hidden="true">19.</strong> Tuplas</a></li><li class="chapter-item expanded "><a href="20.html"><strong aria-hidden="true">20.</strong> Estructuras de control</a></li><li class="chapter-item expanded "><a href="21.html"><strong aria-hidden="true">21.</strong> Estructuras - struct</a></li><li class="chapter-item expanded "><a href="22.html"><strong aria-hidden="true">22.</strong> Enumerados - enum</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust en espa√±ol f√°cil</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="actualizaciones"><a class="header" href="#actualizaciones">Actualizaciones</a></h1>
<p><img src="https://github.com/Dhghomon/easy_rust/workflows/github%20pages/badge.svg" alt="example workflow name" /></p>
<p>23 de mayo de 2021: <a href="https://github.com/ariandy/easy-rust-indonesia">Ahora disponible en indonesio</a> gracias <a href="https://github.com/ariandy">Ariandy</a>/<a href="https://1kilobyte.github.io/">1kb</a>.</p>
<p>2 de abril de 2021: <a href="https://www.buymeacoffee.com/mithridates">A√±adido enlace a BuyMeACoffee</a> para aquellos a los que les gustar√≠a invitarme a un caf√©.</p>
<p>1 de febrero de 2021: <a href="https://www.youtube.com/playlist?list=PLfllocyHVgsRwLkTAhG0E-2QxCf-ozBkk">¬°Ahora disponible en youtube! (en ingl√©s)</a> Dos meses despu√©s: completo el 1 de abril de 2021, 186 v√≠deos en total (un poco m√°s de 23 horas).</p>
<p>22 de diciembre 2020: el libro en mdBook se puede encontrar <a href="https://dhghomon.github.io/easy_rust">aqu√≠</a>.</p>
<p>28 de noviembre de 2020: <a href="https://github.com/kumakichi/easy_rust_chs">Ahora tambi√©n disponible en chino simplificado</a> ¬°Gracias a <a href="https://github.com/kumakichi">kumakichi</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introducci√≥n"><a class="header" href="#introducci√≥n">Introducci√≥n</a></h1>
<p>Rust es un nuevo lenguaje de programaci√≥n que ya tiene buenos libros de texto, pero a veces son dif√≠ciles ya que son para personas cuyo ingl√©s es nativo. Muchas empresas y personas est√°n aprendiendo Rust en estos d√≠as y pueden aprenderlo m√°s r√°pido con un libro que use un ingl√©s f√°cil<sup class="footnote-reference"><a href="#1">1</a></sup>. Este libro es para que estas empresas y personas puedan aprender Rust con un espa√±ol simple.</p>
<p>Rust es un lenguaje que bastante nuevo, pero ya es muy popular. Es popular porque te da la velocidad y control de C o C++, pero tambi√©n ofrece protecci√≥n del acceso a la memoria como otros lenguajes como Python. Esto lo hace usando nuevas ideas que son en parte diferentes a otros lenguajes. Lo que significa que hay que aprender cosas nuevas y no puedes simplemente &quot;descubrirlo seg√∫n vas avanzando&quot;. Rust es un lenguaje en el que tienes que pensar las cosas durante un tiempo para comprenderlo, pero que a√∫n suena a familiar si conoces otros lenguajes y est√° dise√±ado para ayudarte a escribir c√≥digo de calidad.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>N.T.: esta traducci√≥n al espa√±ol trata de seguir el mismo principio utilizando un espa√±ol f√°cil.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="qui√©n-soy"><a class="header" href="#qui√©n-soy">¬øQui√©n soy?</a></h1>
<p>Soy un canadiense que vive en Korea y escrib√≠ Rust F√°cil pensando en c√≥mo hacer m√°s f√°cil su uso para las empresas de aqu√≠<sup class="footnote-reference"><a href="#1">1</a></sup>. Espero que otras empresas que no usan el ingl√©s como primer idioma puedan utilizarlo tambi√©n.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>N.T.: Soy un espa√±ol que vive en Madrid, espero que esta traducci√≥n tambi√©n facilite la comprensi√≥n de este lenguaje que tiene aspectos novedosos incluso para los que conocen C, C++, Java, Python, Ruby, Javascript o Typescript...</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="la-escritura-de-rust-en-ingl√©s-f√°cil"><a class="header" href="#la-escritura-de-rust-en-ingl√©s-f√°cil">La escritura de Rust en ingl√©s f√°cil</a></h1>
<p><em>Rust en ingl√©s f√°cil</em> se escribi√≥ de julio a agosto de 2020 y ocupa unas 400 p√°ginas. Puedes contactarme aqu√≠ o <a href="https://www.linkedin.com/in/davemacleod">en LinkedIn</a> o <a href="https://twitter.com/mithridates">en Twitter</a> si tienes cualquier pregunta. Si ves algo err√≥neo o tienes una petici√≥n de inserci√≥n (pull request) que hacer, adelante. M√°s de 20 personas ya han ayudado a corregir erratas y problemas en el c√≥digo, por lo que t√∫ tambi√©n puedes[1^]. no soy el mejor experto de Rust del mundo, as√≠ que me gusta escuchar nuevas ideas o ver en qu√© puedo hacer el libro mejor.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>N.T.: Esta traducci√≥n, <em>Rust en espa√±ol f√°cil</em>, se inici√≥ en julio de 2021. Para cualquier asunto relacionado con ella, puedes contactarme en <a href="https://github.com/jmgaguilera">github</a> o en <a href="https://es.linkedin.com/in/jmgaguilera">LinkedIn</a>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parte-1---rust-en-tu-navegador"><a class="header" href="#parte-1---rust-en-tu-navegador">Parte 1 - Rust en tu navegador</a></h1>
<p>Este libro tiene dos partes. En la primera, aprender√°s todo solo utilizando tu navegador. Puedes aprender casi todo lo que debes saber sin instalar Rust. Por eso esta primera parte es muy larga. En la segunda parte, mucho m√°s corta, se habla de Rust en tu ordenador. Ah√≠ aprender√°s todo lo que necesitas conocer y que solo se puede hacer fuera del navegador. Algunos ejemplos son: trabajar con ficheros, obtener datos del usuario, gr√°ficos y configuraciones personales. Espero que al finalizar la primera parte te guste Rust lo suficiente para que lo instales en tu equipo. Y si no, no hay problema, esta primera parte de ense√±a tanto que no te importar√°.</p>
<h1 id="el-entorno-de-pruebas-playground-de-rust"><a class="header" href="#el-entorno-de-pruebas-playground-de-rust">El entorno de pruebas (Playground) de Rust</a></h1>
<p><strong><a href="https://youtu.be/-lYeJeQ11OI">Puedes ver este cap√≠tulo en ingl√©s en YouTube</a></strong></p>
<p>Puede que no quieras instalarte a√∫n Rust. No pasa nada. Puedes ir a <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> y comenzar a escribir Rust sin salir del navegador. Puedes escribir ah√≠ el c√≥digo y pulsar <strong>Run</strong> para ver los resultados. Puedes ejecutar la mayor√≠a de los ejemplos de este libro en este entorno. Solamente al final del libro ver√°s ejemplos que van m√°s all√° de lo que se puede hacer aqu√≠ (como abrir ficheros.)</p>
<p>Algunas recomendaciones de uso de este entorno de pruebas (Playground):</p>
<ul>
<li>Ejecuta el c√≥digo con <strong>Run</strong></li>
<li>Cambia de <strong>Debug</strong> a <strong>Release</strong> si quieres que el c√≥digo sea m√°s r√°pdio. <strong>Debug</strong> (Depuraci√≥n) hace que compile m√°s r√°pido, se ejecute m√°s lento y contenga informaci√≥n para la depuraci√≥n de errores. <strong>Release</strong> (Producci√≥n) hace que compile m√°s lento, se ejecute m√°s r√°pido y se suprima la informaci√≥n para la depuraci√≥n de errores.</li>
<li>Pulsa en <strong>Share</strong> (Compartir) para obtener un hiperenlace. Puedes usarlo para compartir tu c√≥digo si necesitas ayuda. Despu√©s de pulsar compartir, puedes pulsar en <code>Open a new thread in de Rust user forum</code>(Abre un nuevo hilo en el foro de usuarios de Rust) para pedir ayuda.</li>
<li><strong>Tools</strong> (Herramientas): <strong>Rustfmt</strong> formatea el c√≥digo correctamente.</li>
<li><strong>Tools</strong> (Herramientas): <strong>Clippy</strong> da informaci√≥n extra sobre c√≥mo hacer mejor el c√≥digo.</li>
<li><strong>Config</strong> (Configuraci√≥n): puedes cambiar aqu√≠ el tema a modo oscuro para que puedas trabajar mejor de noche y otras muchas opciones.</li>
</ul>
<p>Si quieres instalar Rust, ve a <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a> y sigue las instrucciones. Normalmente, usar√°s <code>rustup</code> para instalar y actualizar Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-y-"><a class="header" href="#-y-">üöß y ‚ö†Ô∏è</a></h1>
<p>En ocasiones, el c√≥digo de los ejemplos del libro no funciona. Si un ejemplo no funciona, veras un üöß o un ‚ö†Ô∏è junto a √©l. üöß significa &quot;en construcci√≥n&quot;, es decir, que el c√≥digo no est√° completo. Rust necesita una <code>fn main()</code> (funci√≥n principal) para ejecutarse, pero algunas veces solo queremos observar una parte del c√≥digo por lo que no aparecer√° el c√≥digo <code>fn main ()</code>. Estos ejemplos son correctos, pero necesitan de una funci√≥n <code>fn main()</code> para ejecutarse. En algunos ejemplos el c√≥digo mostrar√° un problema que tendr√°s que resolver. Estos ejemplos podr√≠an tener una funci√≥n <code>fn main()</code> pero generar√°n un error y por eso se acompa√±an de un s√≠mbolo ‚ö†Ô∏è.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comentarios"><a class="header" href="#comentarios">Comentarios</a></h1>
<p><strong><a href="https://youtu.be/fJ7jBZG_Rpo">Puedes ver este cap√≠tulo en ingl√©s en YouTube</a></strong></p>
<p>Los comentarios son para que los lean los programadores, no el ordenador. es bueno escribir comentarios para ayudar a otras personas a entender tu c√≥digo. Es bueno, tambi√©n, para ayudarte a entender tu propio c√≥digo pasado un tiempo (Muchas personas escriben buen c√≥digo, pero olvidan porqu√© lo escribieron). Para escribir comentarios en el c√≥digo, en Rust se suele usar <code>//</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Los programas Rust comienzan en fn main()
    // Pones el c√≥digo en un bloque que comienza con { y termina con }
    let algun_numero = 100; // Aqu√≠ podemos esribir todo lo que queramos ya que el compilador no lo va mirar
}
</code></pre></pre>
<p>Cuando lo haces as√≠, el compilador no mirar√° nada que haya a la derecha de <code>//</code>.</p>
<p>Existe otra clase de comentario que se escribe con <code>/*</code> para iniciarlo y se termina con `*/. Este tipo de comentario es √∫til para escribirlo entre el c√≥digo.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let algun_numero/*: i16*/ = 100;
}
</code></pre></pre>
<p>Para el compilador <code>let algun_numero/*: i16*/ = 100;</code> es igual que <code>let algun_numero = 100;</code>.</p>
<p>Esta forma <code>/* */</code> tambi√©n es √∫til para los comentarios de gran longitud que necesiten m√°s de una l√≠nea. En este ejemplo se puede ver que necesitas escribir <code>//</code> en cada l√≠nea, pero si utilizas <code>/*</code>, el comentario dura hasta que lo finalices con <code>*/</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let algun_numero = 100; /* D√©jame contarte
    un poco sobre este n√∫mero.
    Es el 100, que es mi n√∫mero favorito.
    Se llama algun_numero pero realmente creo que...*/

    let algun_numero = 100; // D√©jame contarte
    // un poco sobre este n√∫mero.
    // Es el 100, que es mi n√∫mero favorito.
    // Se llama algun_numero pero realmente creo que...
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tipos-de-dato"><a class="header" href="#tipos-de-dato">Tipos de dato</a></h1>
<p>Rust tiene muchos tipos de dato que permiten trabajar con n√∫meros, caracteres y otros. Algunos son simples, otros son m√°s complicados e, incluso, puedes crear tus propios tipos de dato.</p>
<h2 id="tipos-de-dato-primitivos"><a class="header" href="#tipos-de-dato-primitivos">Tipos de dato primitivos</a></h2>
<p><strong><a href="https://youtu.be/OxTPU5UGMhs">Puedes ver este cap√≠tulo en YouTube en ingl√©s</a></strong></p>
<p>Rust tiene tipos simples que llaman <strong>tipos primitivos</strong> (primitivo = muy b√°sico). Comenzaremos con los n√∫meros enteros y los <code>char</code> (caracteres). Los enteros son n√∫meros sin coma decimal. Existen dos tipos de enteros:</p>
<ul>
<li>Enteros con signo.</li>
<li>Enteros sin signo.</li>
</ul>
<p>&quot;Con signo&quot; significa que disponen de <code>+</code> (signo m√°s) y <code>-</code> (signo menos), por lo que los enteros con signo pueden ser positivos o negativos (por ejemplo, +8, -8). Por el contratio, los enteros sin signo solo pueden ser positivos ya que no tienen signo.</p>
<p>Los enteros con signo son: <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, e <code>isize</code>.</p>
<p>Los enteros sin signo son: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, e <code>usize</code>.</p>
<p>El n√∫mero tras la <strong>i</strong> o la <strong>u</strong> indica el n√∫mero de bits que se usan para el entero. As√≠, los n√∫meros con m√°s bits pueden ser mayores. 8 bits = un byte por lo que <code>i8</code> ocupa un byte, y puede contener valores entre el -128 y el 127. Por lo tanto <code>i64</code> ocupa 64 bits o, lo que es lo mismo, 8 bytes y puede representar n√∫meros entre el -9223372036854775808 y el 9223372036854775807.</p>
<p>Los tipos num√©ricos con mayor tama√±o pueden representar valores mayores. Por ejemplo, el tipo <code>u8</code>puede representar del 0 al 255, el tipo <code>u16</code> puede representar del 0 al 65635, y el tipo <code>u128</code> puede representar a un n√∫mero entre el 0 y el 340282366920938463463374607431768211455.</p>
<p>¬øY qu√© representan <code>isize</code> y <code>usize</code>? El n√∫mero de bits del tipo nativo del procesador de tu ordenador (El n√∫mero de bits nativo de tu procesador se denomina la <strong>arquitectura</strong> de tu procesador). As√≠ que <code>isize</code> y <code>usize</code> en un ordenador de 32-bits son equivalentes a <code>i32</code> y <code>u32</code>. En un ordenador de 64-bits son equivalentes a <code>i64</code> y <code>u64</code>.</p>
<p>Hay muchas razones para disponer de todos estos tipos de n√∫meros enteros. Una raz√≥n es el rendimiento del ordenador: es m√°s r√°pido procesar un n√∫mero menor de bytes. Por ejemplo, el n√∫mero -10 representado como un <code>i8</code> es <code>11110110</code>, pero como un <code>i128</code> es <code>11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110110</code>. </p>
<p>veamos otros usos:</p>
<p>Los caracters en Rust se denominan <code>char</code>. Todo <code>char</code> se representa por un n√∫mero: la letra <code>A</code> es lel n√∫mero 65, mientras que el car√°cter <code>Âèã</code> (&quot;amigo&quot; en chino) es el n√∫mero 21451. La lista de estos n√∫meros que representan a carateres se denomina &quot;Unicode&quot;. Unicode usa n√∫meros m√°s peque√±os para los caracteres que se usan m√°s, como los de la A a la Z, los d√≠gitos de 0 a 9 o el espacio.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let primera_letra = 'A';
    let espacio = ' '; // Un espacio entre ' ' tambi√©n es un char
    let char_en_otro_idioma = '·èÑ'; // Gracias a Unicode, otros lenguajes, como el Cherokee, tambi√©n se visualizan bien
    let cara_gato = 'üò∫'; // Emojis tambi√©n son char
}
</code></pre></pre>
<p>Los caracters que se utilizan m√°s se representan or n√∫meros menores al 256 y as√≠ pueden caber en un <code>u8</code>. Recuerda que un <code>u8</code> permite n√∫meros entre el 0 y el 255, lo que facilita la representaci√≥n de 256 caracteres en total. Esto significa que Rust puede convertir de forma segura del tipo de datos <code>u8</code> al <code>char</code>, utilizando la palabra reservada del lenguaje <code>as</code> (Considera el dato de este tipo <code>u8</code> como si fuese <code>char</code>).</p>
<p>La conversi√≥n de tipos de datos utilizando <code>as</code> es muy √∫til ya que Rust es muy estrict. Siempre necesita conocer el tipo de dato y, adem√°s, no deja utilizar de forma conjunta dos tipos de datos diferentes incluso aunque sean de la misma familia (como los enteros). Por ejemplo, este c√≥digo no funcionar√°:</p>
<pre><pre class="playground"><code class="language-rust">fn main() { // main() es la funci√≥n a partir de la que se 
            // inician los programas Rust. El c√≥digo entre las llaves {}

    let mi_numero = 100; // No hemos indicado el tipo de datos entero
                         // que Rust debe utilizar,
                         // as√≠ que Rust elige i32. Rust siempre
                         // elige i32 para los enteros si no se le indica
                         // que utilice otro tipo de datos diferente

    println!(&quot;{}&quot;, mi_numero as char); // ‚ö†Ô∏è
}
</code></pre></pre>
<p>Esta es la raz√≥n:</p>
<pre><code class="language-text">error[E0604]: only `u8` can be cast as `char`, not `i32`
 --&gt; src\main.rs:10:20
  |
3 |     println!(&quot;{}&quot;, mi_numero as char);
  |                    ^^^^^^^^^^^^^^^^^ invalid cast
</code></pre>
<p>Afortunadamente, podemos corregir esto f√°cilmente con <code>as</code>. No podemos convertir un <code>i32</code> a <code>char</code>, pero podemos convertir un <code>i32</code> a <code>u8</code>. Y despu√©s, podemos realizar la conversi√≥n de <code>u8</code> a <code>char</code>. Po tanto, en una l√≠nea usamos <code>as</code> para convertir mi_numero a <code>u8</code> y despu√©s lo convertimos a <code>char</code>. Ahora s√≠ compilar√°:</p>
<pre><pre class="playground"><code class="language-rust">fn main() { 
    let mi_numero = 100; 
    println!(&quot;{}&quot;, mi_numero as u8 as char);
}
</code></pre></pre>
<p>Se imprime <code>d</code> porque es el <code>char</code> que est√° representado en Unicode con este n√∫mero.</p>
<p>Existe una forma m√°s f√°cil, sin embargo, de conseguir este resultado: indicarle a Rust que <code>mi_numero</code> es de tipo <code>u8</code>. As√≠:</p>
<pre><pre class="playground"><code class="language-rust">fn main() { 
    let mi_numero: u8 = 100; // se indica de forma expresa que
                             // el tipo de la variable mi_numero es u8
    println!(&quot;{}&quot;, mi_numero as char);
}
</code></pre></pre>
<p>Las anteriores, son dos de las razones para la existencia de todos estos tipos de datos num√©ricos en Rust. Hay otra raz√≥n m√°s: <code>usize</code> es el tama√±o que Rust utiliza para <em>indexar</em> (Indexar significa &quot;conocer cual elemento va primero&quot;, &quot;cual va segundo&quot;, etc.). <code>usize</code> es el mejor tama√±o para el indexado porque:</p>
<ul>
<li>Un √≠ndice no puede ser negativo, por lo que tiene que ser uno de los tipos de dato con una <strong>u</strong>.</li>
<li>Debe ser grande porque en muchas ocasiones necesitas indexar muchas cosas, pero</li>
<li>No puede ser un u64 porque los ordenadores de 32-bits no lo pueden manejar.</li>
</ul>
<p>Por eso Rust usa <code>usize</code> para indexar y facilitar que tu ordenador pueda utilizar el tipo de datos mayor de que disponga.</p>
<p>Vamos a aprender algo m√°s sobre <code>char</code>. Ya vimos que <code>char</code>siempre es un car√°cter y utiliza <code>''</code> en lugar de <code>&quot;&quot;</code>.</p>
<p>Todos los <code>char</code> usan 4 bytes de memoria, puesto que son necesarios 4 bytes para contener cualquier clase de car√°cter:</p>
<ul>
<li>Las letras y s√≠mbolos b√°sicos suelen necesitar solo 1 de los 4 bytes: <code>a b 1 2 + - = $ @</code></li>
<li>Otras letras como las di√©resis y tildes necesitan 2 de los 4 bytes: <code>√§ √∂ √º √ü √® √© √† √±</code></li>
<li>Los caracteres coreanos, japoneses o chinos necesitan 3 de los cuatro bytes: <code>ÂõΩ Ïïà ÎÖï</code></li>
</ul>
<p>Cuando los caracteres se usan como parte de una cadena, esta se codifica para usar la menor cantidad de memoria necesaria para cada car√°cter<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<p><sup class="footnote-reference"><a href="#1">1</a></sup> N.T.: Rust codifica las cadenas en UTF-8.</p>
<p>Para observar esto podemos usar <code>.len()</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Tama√±o de un char: {}&quot;, std::mem::size_of::&lt;char&gt;()); // 4 bytes
    // .len() devuelve el tama√±o de una cadena de texto en bytes
    println!(&quot;Tama√±o de una cadena que contiene la 'a': {}&quot;, &quot;a&quot;.len());
    println!(&quot;Tama√±o de una cadena que contiene la '√ü': {}&quot;, &quot;√ü&quot;.len());
    println!(&quot;Tama√±o de una cadena que contiene la 'ÂõΩ': {}&quot;, &quot;ÂõΩ&quot;.len());
    println!(&quot;Tama√±o de una cadena que contiene la 'ìÖ±': {}&quot;, &quot;ìÖ±&quot;.len());
}
</code></pre></pre>
<p>Lo que imprime:</p>
<pre><code class="language-text">Tama√±o de un char: 4
Tama√±o de una cadena que contiene la 'a': 1
Tama√±o de una cadena que contiene la '√ü': 2
Tama√±o de una cadena que contiene la 'ÂõΩ': 3
Tama√±o de una cadena que contiene la 'ìÖ±': 4
</code></pre>
<p>Puedes ver que la <code>a</code> ocupa un byte, la '√ü' alemana ocupa dos, la japonesa <code>ÂõΩ</code> ocupa tres, y el car√°cter del antiguo egipto <code>ìÖ±</code> ocupa cuatro bytes.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let fragmento = &quot;¬°Hola!&quot;;
    println!(&quot;El fragmento ocupa {} bytes.&quot;, fragmento.len());
    let fragmento2 = &quot;ÏïàÎÖï!&quot;; // Coreano de &quot;hola&quot;
    println!(&quot;El fragmento2 ocupa {} bytes.&quot;, fragmento2.len());
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">El fragmento ocupa 7 bytes.
El fragmento2 ocupa 7 bytes.
</code></pre>
<p>El primer fragmento consta de seis caracteres y ocupa 7 bytes (la apertura de exclamaci√≥n ocupa dos bytes). El segundo fragmento consta de tres caracteres y ocupa 7 bytes (los dos primeros caracteres ocupan tres bytes cada uno).</p>
<p>Si <code>.len()</code> devuelve el tama√±o en bytes, ¬øc√≥mo se puede conocer el tama√±o de una cadena de texto en caracteres? Aprenderemos esto m√°s tarde, en este momento basta con recordar que se hace con <code>.chars().count()</code>. La primera funci√≥n <code>.chars()</code> devuelve los caracteres separados y luego cuenta cu√°ntos son.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let fragmento = &quot;¬°Hola!&quot;;
    println!(&quot;El fragmento ocupa {} bytes y son {} caracteres.&quot;,
        fragmento.len(), fragmento.chars().count());
    let fragmento2 = &quot;ÏïàÎÖï!&quot;;
    println!(&quot;El fragmento2 ocupa {} bytes y son {} caracteres.&quot;,
        fragmento2.len(), fragmento2.chars().count());
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">El fragmento ocupa 7 bytes y son 6 caracteres.
El fragmento2 ocupa 7 bytes y son 3 caracteres.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inferencia-de-tipos-de-dato"><a class="header" href="#inferencia-de-tipos-de-dato">Inferencia de tipos de dato</a></h1>
<p><strong><a href="https://youtu.be/q1D2vpy3kEI">Puedes ver este cap√≠tulo en YouTube en ingl√©s</a></strong></p>
<p>La inferencia de tipos de datos consiste en que si no se le indica el tipo de datos al compilador, pero lo puede determinar por s√≠ mismo, √©l decide que tipo utilizar. El compilador siempre necesita conocer el tipo de las variables, pero no siempre es necesario dec√≠rselo expresamente. En realidad, normalmente no necesitas indic√°rselo. Por ejemplo, en la sentencia <code>let mi_numero = 8</code>, <code>mi_numero</code> ser√° de tipo <code>i32</code>. Esto se debe a que el compilador elige siempre el tipo <code>i32</code> para los n√∫meros enteros si no se le indica uno. Sin embargo, en la siguiente sentencia <code>let mi_numero: u8 = 8</code>, la variable <code>mi_numero</code> es de tipo <code>u8</code> ya que as√≠ se le ha indicado.</p>
<p>As√≠ que normalmente el compilador puede deducir el tipo de datos, pero en ocasiones ser√° necesario indic√°rselo por una de las siguientes dos razones:</p>
<ol>
<li>Est√°s programando algo muy complejo y el compilador no puede deducir el tipo de datos que es necesario.</li>
<li>Quieres usar un tipo de datos diferente (por ejemplo, quieres un <code>i128</code>, no el <code>i32</code> que se usa por defecto).</li>
</ol>
<p>Para especificar un tipo, se a√±aden dos puntos despu√©s del nombre de la variable seguido del tipo.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numerito: u8 = 10;
}
</code></pre></pre>
<p>Para los n√∫meros, se puede especificar el tipo despu√©s del n√∫mero, no se necesita un espacio - solo teclearlo justo despu√©s del n√∫mero.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numerito = 10u8; // 10u8 = 10 de tipo u8
}
</code></pre></pre>
<p>Tambi√©n se puede a√±adir <code>_</code> para a√±adir claridad a la lectura.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numerito = 10_u8; // Esto es m√°s f√°cil de leer
    let numerazo = 100_000_000_i32; // 100 millones es de f√°cil lectura con _
}
</code></pre></pre>
<p>El <code>_</code> no modifica el n√∫mero. Solo lo hace m√°s f√°cil de leer. Y no importa el cuantos <code>_</code> se utilizan.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numero = 0________u8;
    let numero2 = 1___6______2____4______i32;
    println!(&quot;{}, {}&quot;, numero, numero2);
}
</code></pre></pre>
<p>Lo anterior imprime <code>0, 1624</code>.</p>
<h2 id="n√∫meros-decimales"><a class="header" href="#n√∫meros-decimales">N√∫meros decimales</a></h2>
<p>Los n√∫meros decimales son aquellos que tienen coma decimal<sup class="footnote-reference"><a href="#1">1</a></sup>. <code>5.5</code> es un n√∫mero decimal y <code>6</code> es un n√∫mero entero. <code>5.0</code> tambi√©n es un n√∫mero decimal e incluso <code>5.</code> lo es.</p>
<p><sup class="footnote-reference"><a href="#1">1</a></sup> N.T.: en espa√±ol se usa una coma como car√°cter para separar la parte entera de un n√∫mero de su parte decimal. En Rust, la coma decimal espa√±ola se sustituye por el punto decimal que es el que se usa habitualmente en los lenguajes de programaci√≥n.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_decimal = 5.; // Rust ve un . y sabe que es un decimal (float, en ingl√©s)
}
</code></pre></pre>
<p>Rust utiliza diversos tipos de dato para almacenar n√∫meros decimales, son el <code>f32</code> y el <code>f64</code>. Al igual que en los n√∫meros enteros, el n√∫mero tras <code>f</code> muestra el n√∫mero de bits utilizados en cada caso para almacenar el dato. Si no se indica el tipo, Rust elige <code>f64</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_decimal: f64 = 5.0; // Esta variable es de tipo f64
    let mi_otro_decimal: f32 = 8.5; // Esta es de tipo f32
    let tercer_decimal = mi_decimal + mi_otro_decimal; // ‚ö†Ô∏è
}
</code></pre></pre>
<p>Cuanto se intenta ejecutar el c√≥digo anterior, Rust se queja diciendo:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:4:39
  |
5 |     let tercer_decimal = mi_decimal + mi_otro_decimal; // ‚ö†Ô∏è
  |                                       ^^^^^^^^^^^^^^^ expected `f64`, found `f32`
</code></pre>
<p>El compilador indica &quot;expected (tipo), found (type)&quot; cuando se usa el tipo err√≥neo. Rust lee el c√≥digo de esta forma:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_decimal: f64 = 5.0; // El compilador ve un f64
    let mi_otro_decimal: f32 = 8.5; // El compilador ve un f64. Es un tipo diferente.
    let tercer_decimal = mi_decimal + // Se quiere sumar mi_decimal, que es f64 a alg√∫n
                                      // otro n√∫mero. Ahora espera otro f64...  
        mi_otro_decimal; // ‚ö†Ô∏è pero se encuentra un f32, no se pueden sumar.
}
</code></pre></pre>
<p>As√≠ que cuando veas que el compilador indica &quot;expected (tipo), found (type)&quot;, debes buscar la causa por la que el compilador esperaba un tipo de datos diferente.</p>
<p>Con los n√∫meros simples es f√°cil arreglarlo. Puedes convertir el <code>f32</code> a <code>f64</code> con un <code>as</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_decimal: f64 = 5.0;
    let mi_otro_decimal: f32 = 8.5;
    // En la siguiente l√≠nea, se utiliza mi_otro decimal como un f64
    let tercer_decimal = mi_decimal + mi_otro_decimal as f64;
}
</code></pre></pre>
<p>O simplemente, se pueden eliminar las declaraciones de tipo, Rust elegir√° tipos que se puedan sumar entre s√≠.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_decimal = 5.0; // Rust elige f64
    let mi_otro_decimal = 8.5; // Rust elige de nuevo f64
    let tercer_decimal = mi_decimal + mi_otro_decimal;
}
</code></pre></pre>
<p>El compilador de Rust es inteligente y no elegir√° f64 si necesitas f32:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_decimal: f32 = 5.0; // Rust elige f64
    let mi_otro_decimal = 8.5; // Normalmente Rust elegir√≠a f64
    // pero al conocer que lo vamos a sumar a un f32, elige un f32 para mi_otro_decimal
    let tercer_decimal = mi_decimal + mi_otro_decimal;
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="imprimiendo-hola-mundo"><a class="header" href="#imprimiendo-hola-mundo">Imprimiendo '¬°Hola, mundo!'</a></h1>
<p><strong>Puedes ver este cap√≠tulo en YouTube en ingl√©s: <a href="https://youtu.be/yYlPHRl2geQ">Video 1</a>, <a href="https://youtu.be/DTCSfBJJZb8">Video 2</a></strong></p>
<p>Cuando creas un nuevo programa Rust, siempre contiene este c√≥digo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<ul>
<li><code>fn</code> significa funci√≥n.</li>
<li><code>main</code> es el nombre de la funci√≥n que inicia el programa.</li>
<li><code>()</code> significa que en este caso no se le pasan variables a esta funci√≥n.</li>
<li><code>{}</code> es un <strong>bloque de c√≥digo</strong>. Es donde se encuentra el c√≥digo.</li>
<li><code>println!</code> es una <strong>macro</strong>, que es como una funci√≥n que sirve para escribir c√≥digo por ti. Las macros siempre tienen un <code>!</code> al final de su nombre. Por ahora, recuerda que <code>!</code> significa que es una macro.</li>
</ul>
<p>Para aprender lo que hace <code>;</code>, crearemos otra funci√≥n. Primero, en <code>main</code> imprimiremos el n√∫mero 8<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<p><sup class="footnote-reference"><a href="#1">1</a></sup> N.T.: aprovechamos para cambiar el saludo a espa√±ol. En Rust, cuando se utiliza la aplicaci√≥n <code>cargo</code> para crear un programa, siempre se incorpora el c√≥digo de <code>main</code> con &quot;Hello, world!&quot; de forma autom√°tica. </p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;¬°Hola, mundo n√∫mero {}!&quot;, 8);
}
</code></pre></pre>
<p>Las <code>{}</code> dentro de <code>println!</code> indican a Rust que &quot;ponga la variable en este lugar&quot;. Este c√≥digo imprime <code>¬°Hola, mundo n√∫mero 8!</code>.</p>
<p>Podemos poner m√°s cosas ampliando lo anterior.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;¬°Hola, mundos n√∫mero {} y {}!&quot;, 8, 9);
}
</code></pre></pre>
<p>El codigo anterior imprime <code>¬°Hola, mundos n√∫mero 8 y 9!</code>.</p>
<p>Ahora vamos a crear una funci√≥n.</p>
<pre><pre class="playground"><code class="language-rust">fn numero() -&gt; i32 {
    8
}

fn main() {
    println!(&quot;¬°Hola, mundo n√∫mero {}!&quot;, numero());
}
</code></pre></pre>
<p>El c√≥digo anterior tambi√©n imprime <code>¬°Hola, mundo n√∫mero 8!</code>. Cuando Rust encuentra <code>numero()</code> entiende que es una funci√≥n. Esta funci√≥n:</p>
<ul>
<li>No toma ning√∫n par√°metro (porque tiene una llamada con <code>()</code>).</li>
<li>Devuelve un <code>i32</code>. El s√≠mbolo de flecha <code>-&gt;</code> muestra el tipo que devuelve la funci√≥n.</li>
<li>La funci√≥n en s√≠ misma solo contiene un <code>8</code>. Al no terminar en <code>;</code> este valor es el que devuelve al terminar de ejecutarse. Si tuviera un <code>;</code> detr√°s, la funci√≥n no devolver√≠a nada (devolver√≠a un <code>()</code>). Rust no compilar√≠a si contuviera un <code>;</code> al final ya que se ha indicado que (tras la flecha) debe devolver un valor de tipo <code>i32</code> y con el <code>;</code> se devuelve <code>()</code> que no es de tipo <code>i32</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn numero() -&gt; i32 {
    8;
}

fn main() {
    println!(&quot;¬°Hola, mundo n√∫mero {}!&quot;, numero());
}
</code></pre></pre>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:1:16
  |
1 | fn numero() -&gt; i32 {
  |    ------      ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
2 |     8;
  |      - help: consider removing this semicolon
</code></pre>
<p>Esto significa que &quot;me dijiste que <code>numero()</code> devuelve un <code>i32</code>, pero a√±adiste un <code>;</code> por lo que esta funci√≥n no devuelve nada&quot;. As√≠ que el compilador sugiere que se elimine el punto y coma.</p>
<p>Tambi√©n se puede escribir lo siguiente <code>return 8;</code>, pero en Rust lo normal es simplemente eliminar el <code>;</code> para ejecutar el <code>return</code>.</p>
<p>Cuando se quiere pasar variables a una funci√≥n, se deben poner dentro de <code>()</code>. Hay que darles un nombre e indicar su tipo.</p>
<pre><pre class="playground"><code class="language-rust">// Entran a la funci√≥n dos i32s. Se llaman num_uno y num_dos
fn multiplicar(num_uno: i32, num_dos: i32) {
    let resultado = num_uno * num_dos;
    println!(&quot;{} por {} es {}&quot;, num_uno, num_dos, resultado);
}

fn main() {
    multiplicar(8, 9); // Pasamos unos n√∫meros directamente
    let algun_numero = 10; // o podemos declarar dos variables
    let algun_otro_numero = 2;
    multiplicar(algun_numero, algun_otro_numero); // y pasarlos a la funci√≥n
}
</code></pre></pre>
<p>Tambi√©n se puede devolver un <code>i32</code>. Basta con poner la variable <code>resultado</code> como la √∫ltima de la funci√≥n sin <code>;</code> al final.</p>
<pre><pre class="playground"><code class="language-rust">fn multiplicar(num_uno: i32, num_dos: i32) -&gt; i32 {
    let resultado = num_uno * num_dos;
    println!(&quot;{} por {} es {}&quot;, num_uno, num_dos, resultado);
    resultado // este es el valor i32 que se retorna
}

fn main() {
    // multiplicar() imprime el resultado y lo devuelve,
    // lo que permite asignarlo a resultado_mult
    let resultado_mult = multiplicar(8, 9);
}
</code></pre></pre>
<h2 id="la-declaraci√≥n-de-variables-y-los-bloques-de-c√≥digo"><a class="header" href="#la-declaraci√≥n-de-variables-y-los-bloques-de-c√≥digo">La declaraci√≥n de variables y los bloques de c√≥digo</a></h2>
<p>Se usa <code>let</code>para declarar una variable (para decirle a Rust que construya una variable).</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_numero = 8;
    println!(&quot;¬°Hola, mundo n√∫mero {}!&quot;, mi_numero);
}
</code></pre></pre>
<p>Las variables existen dentro de un bloque de c√≥digo <code>{}</code>. En el siguiente ejemplo <code>mi_numero</code> desaparece antes de llamar a <code>println!</code> porque se encuentra dentro de su propio c√≥digo.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    {
        let mi_numero = 8; // mi_numero se crea aqu√≠
                           // mi_numero se extingue aqu√≠
    }
    println!(&quot;¬°Hola, mundo n√∫mero {}!&quot;, mi_numero);// ‚ö†Ô∏è  mi_numero no existe y
                                                   // println!() no lo puede encontrar
}
</code></pre></pre>
<p>Se puede usar un bloque de c√≥digo para devolver un valor, como en el siguiente c√≥digo.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_numero = {
        let segundo_num = 8;
        segundo_num + 9 // sin punto y coma, por lo que el
                        // bloque de c√≥digo devuelve 8 + 9 = 17
    }; 
    println!(&quot;¬°Hola, mundo n√∫mero {}!&quot;, mi_numero);
}
</code></pre></pre>
<p>Si se a√±adiera un punto y coma en la sentencia final del bloque, devolver√≠a <code>()</code> (nada).</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_numero = {
        let segundo_num = 8; // declara el segundo n√∫mero
        segundo_num + 9;     // suma 9 con el segundo n√∫mero
                             // pero no se devuelve
                             // segundo_num desaparece aqu√≠
    }; 
    println!(&quot;¬°Hola, mundo n√∫mero {:?}!&quot;, mi_numero); // mi_numero es ()
}
</code></pre></pre>
<p>Si has observado bien, hemos cambiado <code>{}</code> por <code>{:?}</code>. El motivo se ver√° en el siguiente cap√≠tulo.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="la-visualizaci√≥n-y-depuraci√≥n"><a class="header" href="#la-visualizaci√≥n-y-depuraci√≥n">La visualizaci√≥n y depuraci√≥n</a></h1>
<p><strong><a href="https://youtu.be/jd3pC248c0o">Puedes ver este cap√≠tulo en YouTube en ingl√©s</a></strong></p>
<p>En Rust, las variables simples se pueden imprimir usyo <code>{}</code> en <code>println!</code>.  Pero hay variables que no pueden imprimirse y es necesario usar <strong>la impresi√≥n de depuraci√≥n</strong>. La impresi√≥n de depuraci√≥n es para los programadores, porque habitualmente muestra m√°s informaci√≥n. En ocasiones, esta impresi√≥n no es &quot;bonita&quot;, no queda bien, porque muestra informaci√≥n extra para ayudarte.</p>
<p>¬øC√≥mo puedes conocer si necesitas usar <code>{:?}</code> y no <code>{}</code>? El compilador te avesar√°. Por ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let no_imprime = ();
    println!(&quot;Esto no se imprimir√°: {}&quot;, no_imprime); // ‚ö†Ô∏è
}
</code></pre></pre>
<p>Cuyo se compila el c√≥digo anterior, el compilador se queja as√≠:</p>
<pre><code class="language-text">error[E0277]: `()` doesn't implement `std::fmt::Desplay`
 --&gt; src/main.rs:3:42
  |
3 |     println!(&quot;Esto no se imprimir√°: {}&quot;, no_imprime); // ‚ö†Ô∏è
  |                                          ^^^^^^^^^^ `()` cannot be formatted with el default formatter
  |
  = help: el trait `std::fmt::Desplay` es not implemented for `()`
  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
  = note: required by `std::fmt::Desplay::fmt`
  = note: thes error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)
</code></pre>
<p>Esto es mucha informaci√≥n, pero la parte importante es <code>you may be able to use {:?} (or {:#?} for pretty-print) instead</code>. Esto significa que puedes intentar usar <code>{:?}</code> o tambi√©n <code>{:#?}</code>. La segunda opci√≥n, <code>{:#?}</code> se llama &quot;impresi√≥n atractiva&quot;. Es igual que <code>{:?}</code> pero usyo un formateo diferente en m√°s l√≠neas.</p>
<p>En resumen, <code>Desplay</code> (vesualizaci√≥n) supone la impresi√≥n con <code>{}</code>, y <code>Debug</code> (depuraci√≥n) supone la impresi√≥n con <code>{:?}</code>.</p>
<p>Una √∫ltima cosa, puedes usar <code>print!</code> sin <code>ln</code> si no quieres que haya un salto de l√≠nea al final de la impresi√≥n.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    print!(&quot;Esto no imprimir√° un salto de l√≠nea&quot;);
    println!(&quot; as√≠ que esto estar√° en la mesma l√≠nea&quot;);
}
</code></pre></pre>
<p>Que imprimir√° <code>Esto no imprimir√° un salto de l√≠nea as√≠ que esto estar√° en la mesma l√≠nea</code>.</p>
<h2 id="el-n√∫mero-menor-y-el-n√∫mero-mayor"><a class="header" href="#el-n√∫mero-menor-y-el-n√∫mero-mayor">El n√∫mero menor y el n√∫mero mayor</a></h2>
<p>Si se quiere ver el menor y mayor n√∫mero que se puede representar, se puede usar MIN y MAX. <code>std</code> es la &quot;librer√≠a est√°ndar del lenguaje&quot; y contiene las funciones y otros elementos importantes del lenguaje Rust. M√°s adelante se explicar√°n elementos de la librer√≠a estyar. Mientras tanto, puedes recordar que esta es la forma de obtener los numeros menor y mayor de un tipo de datos.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // pista: std::i8::MIN significa
    // &quot;el valor de MIN de la secci√≥n i8 de la librer√≠a estandar&quot;
    println!(&quot;El menor i8 es {} y el mayor i8 es {}.&quot;, std::i8::MIN, std::i8::MAX); 
    println!(&quot;El menor u8 es {} y el mayor u8 es {}.&quot;, std::u8::MIN, std::u8::MAX);
    println!(&quot;El menor i16 es {} y el mayor i16 es {}.&quot;, std::i16::MIN, std::i16::MAX);
    println!(&quot;El menor u16 es {} y el mayor u16 es {}.&quot;, std::u16::MIN, std::u16::MAX);
    println!(&quot;El menor i32 es {} y el mayor i32 es {}.&quot;, std::i32::MIN, std::i32::MAX);
    println!(&quot;El menor u32 es {} y el mayor u32 es {}.&quot;, std::u32::MIN, std::u32::MAX);
    println!(&quot;El menor i64 es {} y el mayor i64 es {}.&quot;, std::i64::MIN, std::i64::MAX);
    println!(&quot;El menor u64 es {} y el mayor u64 es {}.&quot;, std::u64::MIN, std::u64::MAX);
    println!(&quot;El menor i128 es {} y el mayor i128 es {}.&quot;, std::i128::MIN, std::i128::MAX);
    println!(&quot;El menor u128 es {} y el mayor u128 es {}.&quot;, std::u128::MIN, std::u128::MAX);
}
</code></pre></pre>
<p>Que imprimir√°:</p>
<pre><code class="language-text">El menor i8 es -128 y el mayor i8 es 127.
El menor u8 es 0 y el mayor u8 es 255.
El menor i16 es -32768 y el mayor i16 es 32767.
El menor u16 es 0 y el mayor u16 es 65535.
El menor i32 es -2147483648 y el mayor i32 es 2147483647.
El menor u32 es 0 y el mayor u32 es 4294967295.
El menor i64 es -9223372036854775808 y el mayor i64 es 9223372036854775807.
El menor u64 es 0 y el mayor u64 es 18446744073709551615.
El menor i128 es -170141183460469231731687303715884105728 y el mayor i128 es 170141183460469231731687303715884105727.
El menor u128 es 0 y el mayor u128 es 340282366920938463463374607431768211455.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutabilidad-cambio"><a class="header" href="#mutabilidad-cambio">Mutabilidad (cambio)</a></h1>
<p><strong><a href="https://youtu.be/Nyyd6qn7dZY">Puedes ver este cap√≠tulo en YouTube en ingl√©s</a></strong></p>
<p>Cuando se declara una variable con `let, es inmutable (no se puede cambiar su valor).</p>
<p>El c√≥digo siguiente no funciona.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_numero = 8;
    mi_numero = 10; // ‚ö†Ô∏è
}
</code></pre></pre>
<p>El compilador indica <code>error[E0384]: cannot assign twice to immutable variable mi_numero</code>.</p>
<pre><code class="language-text">error[E0384]: cannot assign twice to immutable variable `mi_numero`
 --&gt; src/main.rs:3:5
  |
2 |     let mi_numero = 8;
  |         ---------
  |         |
  |         first assignment to `mi_numero`
  |         help: consider making this binding mutable: `mut mi_numero`
3 |     mi_numero = 10; // ‚ö†Ô∏è
  |     ^^^^^^^^^^^^^^ cannot assign twice to immutable variable
</code></pre>
<p>Esto es porque las variables son inmutables si solo se escribe <code>let</code>.</p>
<p>Muchas veces, ser√° necesario modificar la variable. Para ello, se debe a√±adir <code>mut</code> despu√©s de <code>let</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut mi_numero = 8;
    mi_numero = 10;
}
</code></pre></pre>
<p>El c√≥digo anterior funciona sin problema alguno.</p>
<p>Sin embargo, no se le puede cambiar el tipo. Esto no funciona:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut mi_numero = 8; // La variable es i32. 
                           // El tipo no se puede cambiar.
    mi_numero = &quot;¬°Hola, mundo!&quot;; // ‚ö†Ô∏è
}
</code></pre></pre>
<p>Si se intenta compilar el programa anterior, se obtendr√° el mismo mensaje &quot;expected&quot; por parte del compilador: <code>expected integer, found &amp;str</code>. <code>&amp;str</code>es un tipo de cadena que aprenderemos pronto.</p>
<h3 id="ocultaci√≥n-shadowing"><a class="header" href="#ocultaci√≥n-shadowing">Ocultaci√≥n (Shadowing)</a></h3>
<p>La ocultaci√≥n de una variable sucede cuando se usa <code>let</code> para declarar una nueva variable con el mismo nombre que otra. A primera vista se parece a la mutabilidad, pero es totalmente diferente. En el siguiente ejemplo, se oculta una variable:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_numero = 8; // Esta variable es i32
    println!(&quot;{}&quot;, mi_numero); // imprime 8
    let mi_numero = 9.2; // Esta variable es f64 y tiene el mismo nombre
    // pero es una variable nueva, completamente diferente.
    println!(&quot;{}&quot;, mi_numero) // imprime 9.2
}
</code></pre></pre>
<p>Se dice que hemos &quot;ocultado&quot; <code>mi_numero</code>con un nuevo &quot;enlace&quot;.</p>
<p>¬øSe ha destruido la anterior variable <code>mi_numero</code>? No, pero cuando se llama a <code>mi_numero</code> ahora se accede a la segunda variable de tipo <code>f64</code>. Y como ambas declaraciones se encuentran en el mismo bloque de c√≥digo (mismo √°mbito, mismo <code>{}</code>), se deja de tener acceso al <code>mi_numero</code> de tipo <code>i32</code>.</p>
<p>Si estuvieran en diferentes bloques de c√≥digo, podr√≠amos volver a acceder a la primera variable <code>mi_numero</code>. Por ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_numero = 8; // Esta variable es i32
    println!(&quot;{}&quot;, mi_numero); // imprime 8
    {
        let mi_numero = 9.2; // Esta variable es f64 y tiene el mismo nombre
        // pero es una variable nueva, completamente diferente.
        println!(&quot;{}&quot;, mi_numero) // imprime 9.2
                                  // pero la nueva variable mi_numero
                                  // solo existe hasta aqu√≠
                                  // la anterior ¬°sigue viva!
    }
    println!(&quot;{}&quot;, mi_numero); // imprime 8
}
</code></pre></pre>
<p>En resumen, cuando ocultas una variable, no la destruyes. La <strong>bloqueas</strong>.</p>
<p>Qu√© ventajas tiene el ocultar variables. Es una buena pr√°ctica cuando necesitas modificar una variable en muchas ocasiones. Imagina que quieres hacer un conjunto de c√°lculos matem√°ticos simples con una variable:</p>
<pre><pre class="playground"><code class="language-rust">fn dos_veces(numero: i32) -&gt; i32 {
    numero * 2
}

fn main() {
    let numero_final = {
        let y = 10;
        let x = 9; // x comienza con 9
        let x = dos_veces(x); // se oculta con el nuevo x: 18
        let x = x + y; // se oculta con el nuevo x: 28
        x // devuelve x: a numero_final se asigna este valor de x
    };
    println!(&quot;El n√∫mero ahora es: {}&quot;, numero_final)
}
</code></pre></pre>
<p>Sin ocultar las variables anteriores, habr√≠a sido necesario pensar diferentes nombres, incluso aunque no nos importen estos valores intermedios:</p>
<pre><pre class="playground"><code class="language-rust">fn dos_veces(numero: i32) -&gt; i32 {
    numero * 2
}

fn main() {
    // Ejemplo sin usar las capacidades de ocultar variables
    let numero_final = {
        let y = 10;
        let x = 9; // x comienza con 9
        let x2 = dos_veces(x); // segundo nombre para x
        let x2_y = x2 + y; // ¬°tercer nombre para x!
        x2_y // qu√© pena no tener disponible la ocultaci√≥n
             // habr√≠amos podido usar solo una variable x
    };
    println!(&quot;El n√∫mero ahora es: {}&quot;, numero_final)
}
</code></pre></pre>
<p>En general, se usa la ocultaci√≥n de variables en estos casos. Cuando se quiere usar una variable para un c√°lculo y luego otro m√°s, sin tener mucho inter√©s por los valores intermedios.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="la-pila-la-memoria-din√°mica-y-los-punteros"><a class="header" href="#la-pila-la-memoria-din√°mica-y-los-punteros">La pila, la memoria din√°mica y los punteros</a></h1>
<p>La pila (&quot;stack&quot; en ingl√©s), la memoria din√°mica (&quot;heap&quot; en ingl√©s) y los punteros son elementos muy importantes en Rust.</p>
<p>La pila y la memoria din√°mica son dos tipos de almacenamiento de los datos de un programa durante su ejecuci√≥n. Sus diferencias m√°s importantes son:</p>
<ul>
<li>La pila es muy r√°pida, la memoria din√°mica no lo es tanto. Tampoco es lenta, pero siempre es m√°s r√°pido acceder a la pila. Aunque no es posible utilizar la pila siempre porque:</li>
<li>Rust necesita conocer el tama√±o de una variable en durante su compilaci√≥n para poder guardarla en la pila. As√≠, las variables simples como <code>i32</code> van a la pila ya que se conoce su tama√±o exacto. Se sabe que va a ocupar 4 bytes, 32 bits = 4 bytes. Por lo tanto, los datos de tipo <code>i32</code> pueden ir siempre a la pila.</li>
<li>Algunos tipos no tienen un tama√±o conocido en tiempo de compilaci√≥n. No pueden guardarse en la pila. ¬øQu√© se puede hacer? En primer lugar, se pone la informaci√≥n en la memoria din√°mica ya que esta puede contener datos de cualquier tama√±o. En segundo lugar, se guarda un puntero en la pila. El tama√±o de los punteros es conocid. As√≠, para recuperar un valor de una variable que est√° en la memoria din√°mica, el ordenador va primero a la pila, obtiene el puntero y lo sigue hasta la memoria din√°mica para localizr el dato que se busca.</li>
</ul>
<p>Los punteros parecen complicados, pero no lo son. Son como una tabla de contenidos de un libro. Imagina este libro:</p>
<pre><code class="language-text">MI LIBRO

TABLA DE CONTENIDO

Cap√≠tulo                        P√°gina
Cap√≠tulo 1: mi vida              1
Cap√≠tulo 2: mi gato              15
Cap√≠tulo 3: mi trabajo           23
Cap√≠tulo 4: mi familia           30
Cap√≠tulo 5: mis planes futuros   43
</code></pre>
<p>La tabla de contenido es como una &quot;pila&quot; que, en este caso, contiene cinco punteros. Puedes leerlos y encontrar la informaci√≥n sobre la que tratan. ¬øD√≥nde est√° el cap√≠tulo sobre &quot;mi vida&quot;? Est√° en la p√°gina 1 (<em>Apunta</em> a la p√°gina 1). ¬øD√≥nde est√° el cap√≠tulo sobre &quot;mi trabajo&quot;? Est√° en la p√°gina 23.</p>
<p>El puntero que se ve habitualmente en Rust se denomina <strong>referencia</strong>. Esto es lo importante que se debe saber: una referencia apunta a la memoria de otro valor. Una referencia supone que <em>se tome prestado</em> el valor, pero no se apropia de √©l. Es lo mismo que en el libro anterior: la tabla de contenidos no posee la informaci√≥n. Se encuentra en los cap√≠tulos que son los que la poseen. En Rust, las referencias llevan el s√≠mbolo <code>&amp;</code> al principio de ellas. As√≠.</p>
<ul>
<li><code>let mi_variable = 8</code> crea una variable normal, pero</li>
<li><code>let mi_referencia = &amp;mi_variable</code> crea una referencia. Se lee como &quot;mi_referencia es una referencia a mi_variable&quot; o como &quot;mi_referencia se refiere a mi_variable&quot;.</li>
</ul>
<p>Esto significa que <code>mi_referencia</code> solo mira a los datos de <code>mi_variable</code>. <code>mi_variable</code> sigue siendo propietaria de sus datos.
Tambi√©n es posible tener una referencia que &quot;apunte&quot; a otra referencia. Hasta culquier n√∫mero de referencias.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mi_numero = 15; // Esto es un i32
    let referencia_simple = &amp;mi_numero; //  Esto es una &amp;i32
    let referencia_doble = &amp;referencia_simple; // Esto es una &amp;&amp;i32
    let referencia_quintuple = &amp;&amp;&amp;&amp;&amp;mi_numero; // Esto es una &amp;&amp;&amp;&amp;&amp;i32
}
</code></pre></pre>
<p>Todos estos son tipos de dato diferentes, de la misma forma que &quot;un amigo de un amigo&quot; es diferente de &quot;un amigo&quot;.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="m√°s-sobre-impresi√≥n"><a class="header" href="#m√°s-sobre-impresi√≥n">M√°s sobre impresi√≥n</a></h1>
<p>En Rust se puede imprimir como se quiera. Por eso, interesa conocer algunas cosas m√°s sobre este tema.</p>
<p>Si se a√±ade <code>\n</code> se imprimir√° una nueva l√≠nea. Si se a√±ade <code>\t</code> se insertar√° un tabulador:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Observa: la funci√≥n usada es print!, no println!
    print!(&quot;\tComienza con un tabulador\ny salta a una nueva l√≠nea&quot;);
}
</code></pre></pre>
<p>El c√≥digo anterior imprime lo siguiente:</p>
<pre><code class="language-text">        Comienza con un tabulador
y salta a una nueva l√≠nea
</code></pre>
<p>Dentro de <code>&quot;&quot;</code> se puede escribir en diferentes l√≠neas, pero es necesario tener cuidado con los espacios:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Nota: despu√©s de la primera l√≠nea tienes que comenzar la siguiente l√≠nea
    // en la primera columna (pegado a la izquierda).
    println!(&quot;Dentro de comillas
se puede escribir
en muchas l√≠neas
y se imprimir√° correctamente.&quot;);
    // Si se escribe directamente bajo la sentencia, se a√±adir√°n los espacios
    // correspondientes de la izquierda
    println!(&quot;Si se olvida que hay que
    escribir pegado al lado izquierdo
    estos espacios se a√±adir√°n
    a la impresi√≥n.&quot;);
}
</code></pre></pre>
<p>El c√≥digo anterior imprime:</p>
<pre><code class="language-text">Dentro de comillas
se puede escribir
en muchas l√≠neas
y se imprimir√° correctamente.
Si se olvida que hay que
    escribir pegado al lado izquierdo
    estos espacios se a√±adir√°n
    a la impresi√≥n.
</code></pre>
<p>Si se necesitase imprimir caracteres como <code>\n</code> (caracteres de escape, como el del salto de l√≠nea y el tabulador que se han visto antes), se puede a√±adir un <code>\</code> extra:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Se imprimen caracteres de escape, no inserta nueva l√≠nea y tabulador: \\n y \\t&quot;);
}
</code></pre></pre>
<p>Lo que imprime:</p>
<pre><code class="language-text">Se imprimen caracteres de escape, no inserta nueva l√≠nea y tabulador: \n y \t
</code></pre>
<p>A veces se necesitan muchos <code>&quot;</code> y caracteres de escape en el texto, por lo que Rust proporciona un m√©todo m√°s simple para ignorarlos: se a√±ade <code>r#</code> al comienzo y <code>#</code> al final de la cadena de caracteres.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // En esta l√≠nea hemos usado \ cinco veces
    println!(&quot;√âl dijo, \&quot;Puedes encontrar el fichero en c:\\files\\my_documents\\file.txt\&quot;. Y as√≠ fue como lo encontr√©.&quot;);
    println!(r#&quot;√âl dijo, &quot;Puedes encontrar el fichero en c:\files\my_documents\file.txt&quot;. Y as√≠ fue como lo encontr√©.&quot;#)
}
</code></pre></pre>
<p>Ambas opciones imprimen lo mismo, pero el uso de <code>r#</code> lo hace m√°s simple de entender.</p>
<pre><code class="language-text">√âl dijo, &quot;Puedes encontrar el fichero en c:\files\my_documents\file.txt&quot;. Y as√≠ fue como lo encontr√©.
√âl dijo, &quot;Puedes encontrar el fichero en c:\files\my_documents\file.txt&quot;. Y as√≠ fue como lo encontr√©.
</code></pre>
<p>Si se necesitara imprimir un car√°cter <code>#</code> en el texto, se puede usar <code>r##</code> al comienzo del texto y <code>##</code> al final. Si se usaran m√°s de dos consecutivos, se pueden seguir a√±adiendo <code>#</code> al comienzo y al final, hasta que no coincida con nada contenido en el texto.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

    let my_string = &quot;'Hola, mundo,' dijo.&quot;; // comilla simples
    let quote_string = r#&quot;&quot;Hola, mundo,&quot; dijo.&quot;#; // comillas dobles
    // Contiene # se necesita al menos ##
    let hashtag_string = r##&quot;El hasgtag #holamundo se ha hecho muy popular.&quot;##; 
    // Contiene ### se necesitan al menos ####
    let many_hashtags = r####&quot;&quot;No se tiene que teclear ### para usar un hashtag. Solo hay que usar #.&quot;&quot;####; 

    println!(&quot;{}\n{}\n{}\n{}\n&quot;, my_string, quote_string, hashtag_string, many_hashtags);
}
</code></pre></pre>
<p>Este c√≥digo imprimir√°:</p>
<pre><code class="language-text">'Hola, mundo,' dijo.
&quot;Hola, mundo,&quot; dijo.
El hasgtag #holamundo se ha hecho muy popular.
&quot;No se tiene que teclear ### para usar un hashtag. Solo hay que usar #.&quot;
</code></pre>
<p>Existe otro uso para <code>r#</code>: usar palabras reservadas (como <code>let</code>, <code>fn</code>, etc.) como nombres de variable.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let r#let = 6; // let como nombre de variable
    let mut r#mut = 10; // Esta variable se llama mut
}
</code></pre></pre>
<p>Esta funci√≥n de <code>r#</code> se introdujo porque las versiones m√°s antiguas de Rust ten√≠an menos palabras reservadas que ahora. As√≠ se pueden evitar errores en c√≥digo previo en el que se usaban nombres de variables que ahora son palabras reservadas.</p>
<p>Puede ser que por alguna raz√≥n <em>realmente</em> se necesite una funci√≥n que se denomine como <code>return</code>. As√≠ se puede escribir:</p>
<pre><pre class="playground"><code class="language-rust">fn r#return() -&gt; u8 {
    println!(&quot;Ah√≠ va tu n√∫mero.&quot;);
    8
}

fn main() {
    let mi_numero = r#return();
    println!(&quot;{}&quot;, mi_numero);
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">Ah√≠ va tu n√∫mero.
8
</code></pre>
<p>Esto no se va a necesitar normalmente, pero si <em>realmente</em> hace falta, se puede usar.</p>
<p>Si se necesita imprimir los bytes de un <code>&amp;str</code> o un <code>char</code>, basta con escribir la letra <code>b</code> delante de la cadena.
Esto funciona para todos los caracteres ASCII. Estos son todos los caracteres ASCII.</p>
<pre><code class="language-text">‚ò∫‚òª‚ô•‚ô¶‚ô£‚ô†‚ô´‚òº‚ñ∫‚óÑ‚Üï‚Äº¬∂¬ß‚ñ¨‚Ü®‚Üë‚Üì‚Üí‚àü‚Üî‚ñ≤‚ñº123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
</code></pre>
<p>As√≠, este c√≥digo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // N.T.: no se pueden poner tildes ya que en las 
    // vocales ya que las letras resultantes no forman
    // parte del conjunto de caracteres ASCII
    println!(&quot;{:?}&quot;, b&quot;Esto aparece como una lista de numeros&quot;);
}
</code></pre></pre>
<p>Da el siguiente resultado:</p>
<pre><code class="language-text">[69, 115, 116, 111, 32, 97, 112, 97, 114, 101, 99, 101, 32, 99, 111, 109, 111, 32, 117, 110, 97, 32, 108, 105, 115, 116, 97, 32, 100, 101, 32, 110, 117, 109, 101, 114, 111, 115]
</code></pre>
<p>Para un <code>char</code> esto se llama <em>byte</em> y para el tipo <code>&amp;str</code> se llama <em>byte de cadena de texto</em>.</p>
<p>Tambi√©n existe un sistema de escape para insertar caracteres Unicode: <code>\u{}</code>. As√≠ es posible imprimir cualquier car√°cter Unicode en una cadena de texto. Adem√°s, es posible formatear un n√∫mero en hexadecimal usando <code>{:X}</code>. El siguiente ejemplo demuestra c√≥mo imprimir el c√≥digo hexadecimal que representa al car√°cter Unicode y c√≥mo imprimirlo de nuevo como car√°cter.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Convierte el char a u32 para obtener su valor num√©rico
    println!(&quot;{:X}&quot;, 'Ìñâ' as u32); 
    println!(&quot;{:X}&quot;, 'H' as u32);
    println!(&quot;{:X}&quot;, 'Â±Ö' as u32);
    println!(&quot;{:X}&quot;, '„ÅÑ' as u32);

    // Imprime los caracteres con el sistema de escape \u
    println!(&quot;\u{D589}, \u{48}, \u{5C45}, \u{3044}&quot;); 
}
</code></pre></pre>
<p>Ya se conoce que <code>println!</code> puede imprimir con <code>{}</code> (modo <em>Display</em>) t <code>{:?}</code> (para Depuraci√≥n). Adem√°s de <code>{:#?}</code> para &quot;impresi√≥n bonita&quot;. Pero existen otras muchas formas de imprimir.</p>
<p>Por ejempli, si se dispone de una referencia se puede usar <code>{:p}</code> para imprimir la <em>direcci√≥n del puntero</em>. Es decir, el lugar de la memoria del ordenador a la que <em>apunta</em> la referencia.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 9;
    let number_ref = &amp;number;
    println!(&quot;{:p}&quot;, number_ref);
}
</code></pre></pre>
<p>El c√≥digo anterior imprime algo parecido a <code>0x7ffec9426f4c</code>, depender√° de d√≥nde se ejecute el programa y se almacene el n√∫mero referenciado en la memoria del ordenador.</p>
<p>Los valores num√©ricos se pueden imprimir en binario, hexadecimal u octal:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 555;
    println!(&quot;Binario: {:b}, hexadecimal: {:x}, octal: {:o}&quot;, number, number, number);
}
</code></pre></pre>
<p>Que imprime <code>Binario: 1000101011, hexadecimal: 22b, octal: 1053</code>.</p>
<p>Tambi√©n se pueden a√±adir n√∫meros entre las llaves para indicar qu√© variable utilizar, teniendo en cuenta que la primera tiene como √≠ndice el 0, la segunda el 1 y as√≠ sucesivamente.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nombre_padre = &quot;Jos√© Miguel&quot;;
    let nombre_hijo = &quot;V√≠ctor&quot;;
    let apellido = &quot;Gonz√°lez&quot;;
    println!(&quot;Este es {1} {2}, hijo de {0} {2}.&quot;, nombre_padre, nombre_hijo, apellido);
}
</code></pre></pre>
<p>La variable <code>nombre_padre</code> est√° en la posici√≥n 0, <code>nombre_hijo</code>en la 1 y <code>apellido</code> est√° en la posici√≥n 2. Por eso, el c√≥digo anterior imprime <code>Este es V√≠ctor Gonz√°lez, hijo de Jos√© Miguel Gonz√°lez.</code>.</p>
<p>Puede suceder que sea necesario imprimir una cadena de caracteres compleja con muchas variables dentro de las llaves. O puede que se necesite imprimir la misma variable dos o m√°s veces. Para ello, se pueden a√±adir nombres a las llaves.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(
        &quot;{city1} est√° en {pais} y {city2} tambi√©n est√° en {pais},
pero {city3} no est√° en {pais}.&quot;,
        city1 = &quot;Seul&quot;,
        city2 = &quot;Busan&quot;,
        city3 = &quot;Tokio&quot;,
        pais = &quot;Korea&quot;
    );
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">Seul est√° en Korea y Busan tambi√©n est√° en Korea,
pero Tokio no est√° en Korea.
</code></pre>
<p>Tambi√©n es posible editar de forma compleja el formato de la impresi√≥n. Tiene esta forma:</p>
<p><code>{variable:relleno alineamiento m√≠nimo.m√°ximo}</code></p>
<p>Para entender esta sintaxis:</p>
<ol>
<li>¬øSe quiere usar un nombre de variable? Se escribe primero su nombre, como antes en {pais}. Lo siguiente ser√° a√±adir (opcionalmente) <code>:</code> despu√©s si se quiere formatear de alg√∫n modo.</li>
<li>¬øSe se necesita un car√°cter de relleno? Por ejemplo, 55 con tres &quot;ceros de relleno&quot; se imprimir√≠a como 00055.</li>
<li>¬øQue alineamiento se necesita para el relleno? izquierda, centro o derecha.</li>
<li>¬øSe desea una longitud m√≠nima? solo hay que indicar el n√∫mero deseado.</li>
<li>¬øSe desea una longitud m√°xima? solo hay que indicarla con un <code>.</code> delante.</li>
</ol>
<p>Por ejemplo, si se quiere escribir la letra &quot;a&quot; con cinco caracteres - de relleno (a izquierda y derecha):</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let letra = &quot;a&quot;;
    println!(&quot;{:-^11}&quot;, letra);
}
</code></pre></pre>
<p>Que imprime <code>-----a-----</code>. El ordenador lo interpreta as√≠:</p>
<ul>
<li>¬øHay un nombre de variable? No, ya que lo primero que aparece en <code>{:-^11}</code> son los dos puntos. No hay nombre de variable delante de estos dos puntos.</li>
<li>¬øSe pide un car√°cter de relleno? S√≠, - est√° justo despu√©s de <code>:</code> y lo sigue un <code>^</code>, lo que significa que el texto se inserta en el centro y el car√°cter de relleno se reparte en los espacios sobrantes a izquierda y derecha. Las otras dos posibilidades son: <code>&lt;</code> que indica que el texto va a la izquierda y el car√°cter de relleno a la izquierda, y <code>&gt;</code> que indica que el texto va a la derecha con el relleno a la izquierda.</li>
</ul>
<p>A continuaci√≥n, se muestran diversos ejemplos de tipos de formateo.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let titulo = &quot;NOTICIAS DE HOY&quot;;
    // sin variable, relleno con -, centrado, longitud de 30 caracteres
    println!(&quot;{:-^30}&quot;, titulo); 
    let barra = &quot;|&quot;;
    // sin variable, relleno con espacios, 15 caracters cada uno, una barra a izquierda y otra a derecha
    println!(&quot;{: &lt;15}{: &gt;15}&quot;, barra, barra); 
    let a = &quot;SEUL&quot;;
    let b = &quot;TOKIO&quot;;
     // variables city1 y city2, relleno con -, a izquierda y a derecha
     println!(&quot;{city1:-&lt;15}{city2:-&gt;15}&quot;, city1 = a, city2 = b);
}
</code></pre></pre>
<p>El c√≥digo anterior imprime:</p>
<pre><code class="language-text">-------NOTICIAS DE HOY--------
|                            |
SEUL---------------------TOKIO
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cadenas-de-caracteres"><a class="header" href="#cadenas-de-caracteres">Cadenas de caracteres</a></h1>
<p><strong><a href="https://youtu.be/pSyaGzGg26o">Puedes ver este cap√≠tulo en YouTube en ingl√©s</a></strong></p>
<p>Rust tiene dos tipos de cadenas de caracteres: <code>String</code> y <code>&amp;str</code>. ¬øCu√°l es la diferencia?</p>
<ul>
<li><code>&amp;str</code> es una cadena de caracteres simple que reside en la pila. Cuando se escribe <code>let mi_variable = &quot;¬°Hola, mundo!&quot;</code> se crea una <code>&amp;str</code>. Este tipo es muy r√°pido.</li>
<li><code>String</code> es un tipo de dato m√°s complejo. Es un poco m√°s lento, pero tiene m√°s funciones. Una <code>String</code> es un puntero que almacena los datos en la memoria din√°mica.</li>
</ul>
<p>Hay que destacar que <code>&amp;str</code> tiene <code>&amp;</code> como primer car√°cter debido a que es necesaria una referencia para utilizar el tipo <code>str</code>.  Esto es por la raz√≥n que vimos anteriormente: la pila necesita conocer el tama√±o, as√≠ que se le da una referencia, las referencias siempre tienen el mismo tama√±o. Otro tema a tener en cuenta es que al utilizar <code>&amp;</code> una referencia para interactuar con el tipo <code>str</code>, nunca se es due√±o del tipo. Por el contrario, <code>String</code>es un tipo <em>con due√±o</em>. M√°s adelante se mostrar√° la importancia de esta distinci√≥n.</p>
<p>Ambos tipos, <code>&amp;str</code> y <code>String</code> son UTF-8. Por ejemplo, se puede escribir el siguiente c√≥digo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Nombre en coreano. No da problemas, ya que &amp;str es UTF-8
    let nombre = &quot;ÏÑúÌÉúÏßÄ&quot;;
    // »ö y »ô no son un problema en UTF-8.
    let otro_nombre = String::from(&quot;Adrian Fahrenheit »öepe»ô&quot;);
}
</code></pre></pre>
<p>En el c√≥digo anterior se observa que se puede construir de forma f√°cil una <code>String</code> de una <code>&amp;str</code>. Los dos tipos est√°n muy relacionados, aunque son muy diferentes.</p>
<p>Gracias a UTF-8, incluso se pueden escribir emojis.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nombre = &quot;üòÇ&quot;;
    println!(&quot;Mi nombre real es {}&quot;, nombre);
}
</code></pre></pre>
<p>Si se ejecuta este c√≥digo en el terminal de comandos de tu propio ordenador tiene que aparecer <code>Mi nombre real es üòÇ</code> a menos el terminal de comandos presente limitaciones y no lo pueda imprimir. En cuyo caso imprimir√° algo as√≠ <code>Mi nombre real es ÔøΩ</code>. En todo caso, Rust es capaz de manejar todos los caracteres Unicode.</p>
<p>La raz√≥n para utilizar una referencia <code>&amp;</code>para el tipo <code>str</code> es que <code>str</code> es un tipo de datos de tama√±o din√°mico, su tama√±o puede ser diferente. Por ejmplo, los nombres &quot;ÏÑúÌÉúÏßÄ&quot; y &quot;Adrian Fahrenheit »öepe»ô&quot; no son del mismo tama√±o:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

    // std::mem::size_of::&lt;Type&gt;() devuelve el tama√±o en bytes de un tipo
    println!(&quot;Una String siempre ocupa {:?} bytes. Es de tama√±o fijo.&quot;,
        std::mem::size_of::&lt;String&gt;()); 
    println!(&quot;Y un i8 siempre ocupa {:?} bytes. Es de tama√±o fijo.&quot;, 
        std::mem::size_of::&lt;i8&gt;());
    println!(&quot;Y un f64 siempre ocupa {:?} bytes. Es de tama√±o fijo.&quot;, 
        std::mem::size_of::&lt;f64&gt;());
     // std::mem::size_of_val() devuelve el tama√±o en bytes de una variable
    println!(&quot;¬øY un &amp;str? Puede ocupar cualquier tama√±o. 'ÏÑúÌÉúÏßÄ' ocupa {:?} bytes. No es de tama√±o fijo.&quot;,
        std::mem::size_of_val(&quot;ÏÑúÌÉúÏßÄ&quot;));
    println!(&quot;Y 'Adrian Fahrenheit »öepe»ô' ocupa {:?} bytes. No es de tama√±o fijo.&quot;,
        std::mem::size_of_val(&quot;Adrian Fahrenheit »öepe»ô&quot;));
}
</code></pre></pre>
<p>Lo que da como resultado:</p>
<pre><code class="language-text">Una String siempre ocupa 24 bytes. Es de tama√±o fijo.
Y un i8 siempre ocupa 1 bytes. Es de tama√±o fijo.
Y un f64 siempre ocupa 8 bytes. Es de tama√±o fijo.
¬øY un &amp;str? Puede ocupar cualquier tama√±o. 'ÏÑúÌÉúÏßÄ' ocupa 9 bytes. No es de tama√±o fijo.
Y 'Adrian Fahrenheit »öepe»ô' ocupa 25 bytes. No es de tama√±o fijo.
</code></pre>
<p>Por eso es necesario usar &amp;, porque as√≠ se construye un puntero (tipo de tama√±o fijo) que puede almacenarse en la pila.  Si se escribiera <code>str</code>, Rust no sabr√≠a qu√© hacer al no conocer su tama√±o.</p>
<p>Hay muchas formas de construir un elemento de tipo <code>String</code>. Algunas de ellas son:</p>
<ul>
<li><code>String::from(&quot;Esta es una cadena de texto&quot;);</code> - <code>String::from()</code> es un m√©todo de Strgin que crea un <code>String</code> a partir de una cadena de texto.</li>
<li><code>&quot;Esta es una cadena de texto&quot;.to_string()</code> - <code>&quot;&quot;.to_string()</code> es un m√©todo de <code>&amp;str</code> que crea un <code>String</code>.</li>
<li>La macro <code>format!</code> - Es como <code>println!</code> excepto que crea un String en lugar de imprimir el texto.</li>
</ul>
<p>A continuaci√≥n se muestran algunos ejemplos:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_name = &quot;Billybrobby&quot;;
    let my_country = &quot;USA&quot;;
    let my_home = &quot;Korea&quot;;

    let together = format!(
        &quot;Soy {} y vengo de {}, pero vivo en {}.&quot;,
        my_name, my_country, my_home
    );
}
</code></pre></pre>
<p>As√≠ se construye un objeto String denominado <em>together</em>, pero no se ha impreso.</p>
<p>Otra forma adicional para crear un String es con la funci√≥n <code>into()</code>, pero esta forma es algo diferente ya que no solo sirve para crear String. Algunos tipos se pueden convertir de forma f√°cil en otros utilizando <code>from</code> y <code>into()</code>. Si el tipo tiene <code>from</code>, tiene tambi√©n <code>into()</code>. <code>from</code> resulta m√°s claro ya que con √©l conoces los tipos: al usarlo <code>String::from(&quot;Cadena de texto&quot;)</code> se sabe que se crea una <code>String</code> de <code>&amp;str</code>. Sin embargo, con <code>.into()</code> el compilador, a veces, no lo conoce:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_string = &quot;Intento construir un String&quot;.into(); // ‚ö†Ô∏è
}
</code></pre></pre>
<p>Rust no conoce el tipo al que se quiere convertir la cadena de texto, porque se pueden crear muchos tipos diferentes a partir de un <code>&amp;str</code>. Rust se queja: puedo convertir &amp;str en muchos tipos diferentes. ¬øCu√°l es el que quieres?</p>
<pre><code class="language-text">error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let my_string = &quot;Intento construir un String&quot;.into(); // ‚ö†Ô∏è
  |         ^^^^^^^^^ consider giving `my_string` a type
</code></pre>
<p>Por lo que se puede corregir as√≠:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_string: String = &quot;Intento construir un String&quot;.into();
}
</code></pre></pre>
<p>Y ahora s√≠ se ha creado un objeto String.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="const-y-static"><a class="header" href="#const-y-static">const y static</a></h1>
<p><strong><a href="https://youtu.be/Ky3HqkWUcI0">Puedes ver este cap√≠tulo en YouTube en ingl√©s</a></strong></p>
<p>Adem√°s de <code>let</code>, existen dos maneras m√°s de declarar valores. <code>const</code> y <code>static</code>. Para estas declaraciones, Rust no realiza la inferencia de los tipos: es necesario declarar el tipo de los valores. Existen vamores que no cambian (<code>const</code> significa constante). La diferencia entre ellos es que:</p>
<ul>
<li><code>const</code> se utiliza para los valores que no cambian y el nombre se reemplaza por su valor, all√≠ donde se usa.</li>
<li><code>static</code> define una posici√≥n fija en memoria que puede actuar como una variable global.</li>
</ul>
<p>Por ello, son casi lo mismo. Los programadores de Rust casi siempre utilizan valores constantes con <code>const</code>.</p>
<p>Por convenci√≥n, las constantes se suelen escribir con todas las letras en may√∫sculas, normalmente est√°n fuera del <code>main</code> para que existan en todo el programas.</p>
<p>Dos ejemplos:</p>
<pre><pre class="playground"><code class="language-rust">const NUMERO_DE_MESES: u32 = 12;
static ESTACIONES: [&amp;str; 4] = [&quot;Primavera&quot;, &quot;Verano&quot;, &quot;Oto√±o&quot;, &quot;Invierno&quot;];

fn main() {
    println!(&quot;{}&quot;, NUMERO_DE_MESES);
    println!(&quot;{:?}&quot;, ESTACIONES);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="algo-m√°s-sobre-referencias"><a class="header" href="#algo-m√°s-sobre-referencias">Algo m√°s sobre referencias</a></h1>
<p><strong><a href="https://youtu.be/R13sQ8SNoEQ">Puedes ver este cap√≠tulo en YouTube en ingl√©s</a></strong></p>
<p>Las referencias son muy importantes en Rust. Las utiliza para asegurarse de que son seguros todos los accesos a la memoria. Ya se ha explicado anteriormente que para crear una referencia se utiliza <code>&amp;</code> delante del valor:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let pais = String::from(&quot;Austria&quot;);
    let ref_uno = &amp;pais;
    let ref_dos = &amp;pais;

    println!(&quot;{}&quot;, ref_uno);
}
</code></pre></pre>
<p>El c√≥digo anterior imprime <code>Austria</code>. <code>pais</code> es un <code>String</code>. Se crean dos referencias a <code>pais</code>. Estas referencias son de tipo <code>&amp;String</code>, es decir son dos variables que son &quot;referencias a String&quot;. Se pueden crear tantas referencias a <code>pais</code>como se quiera. Todas &quot;apuntan&quot; al mismo valor, pero son punteros diferentes.</p>
<p>A continuaci√≥n se muestra un ejemplo sobre c√≥mo Rust proteje el acceso a zonas de memoria err√≥neas:</p>
<pre><pre class="playground"><code class="language-rust">fn return_str() -&gt; &amp;str {
    let pais = String::from(&quot;Austria&quot;);
    let pais_ref = &amp;pais;
    pais_ref // ‚ö†Ô∏è
}

fn main() {
    let pais = return_str();
}
</code></pre></pre>
<p>La funci√≥n <code>return_str()</code> crea un valor de tipo String, luego crea una referencia a dicho valor. Cuando se intenta devolver la referencia se produce un error:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:1:20
  |
1 | fn return_str() -&gt; &amp;str {
  |                    ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
  |
1 | fn return_str() -&gt; &amp;'static str {
  |                    ^^^^^^^^
</code></pre>
<p>El valor de <code>pais</code> solo existe dentro de la funci√≥n, al terminar de ejecutarse desaparece. Una vez la variable desaparece, el ordenador libera la memoria que ocupaba y la utiliza para otra cosa. Por eso, despu√©s de que la funci√≥n termina, <code>pais_ref</code> apunta a una zona de memoria que ya no tiene el valor esperado y eso no es correcto. Rust previene este fallo en el c√≥digo e impide que el programa compile.</p>
<p>Este es el efecto importante de la existencia de tipos de dato &quot;con due√±o&quot; en Rust. En el c√≥digo anterior, el valor <code>String</code> tiene como due√±o a la variable <code>pais</code>, por eso se puede &quot;prestar&quot; a otras variables (referencias), pero cuando desaparece la variable due√±a del valor, <code>pais</code>, la referencia tambi√©n desaparece, la referencia tiene &quot;prestado&quot; el valor, por lo que no se puede pasar a otro &quot;due√±o&quot;.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="referencias-modificables-mutables"><a class="header" href="#referencias-modificables-mutables">Referencias modificables (mutables)</a></h1>
<p><strong><a href="https://youtu.be/G48z6Rv76vc">Puedes ver este cap√≠tulo en YouTube en ingl√©s</a></strong></p>
<p>Si se necesita modificar un valor a trav√©s de una referencia, se debe indicar que la referencia sea modificable (mutable). Para ello, se utiliza <code>&amp;mut</code> en lugar de <code>&amp;</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // no hay que olvidar que hay que escribir mut en la variable original
    let mut mi_numero = 8;
    let num_ref = &amp;mut mi_numero;
}
</code></pre></pre>
<p><code>mi_numero</code> es de tipo <code>i32</code>, y <code>num_ref</code> es de tipo <code>&amp;mut i32</code> (es una &quot;referencia modificable/mutable a un valor <code>√¨32</code>).</p>
<p>Si se desea usar esta referencia para sumar 10, no se puede usar <code>num_ref += 10</code> ya que <code>num_ref</code> no es de tipo <code>i32</code>, es <code>&amp;i32</code>. Para obtener el valor de la referencia, se debe usar <code>*</code> que significa que &quot;no se necesita la referencia, sino el valor que al que representa&quot;. En otras palabras, <code>*</code> es lo opuesto a <code>&amp;</code>, un <code>*</code> borra a un <code>&amp;</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut mi_numero = 8;
    let num_ref = &amp;mut mi_numero;
    *num_ref += 10; // Usa * para cambiar el valor i32
    println!(&quot;{}&quot;, mi_numero);

    let segundo_numero = 800;
    let triple_referencia = &amp;&amp;&amp;segundo_numero;
    println!(&quot;segundo_numero = ¬øtriple_referencia? {}&quot;,
        segundo_numero == ***triple_referencia);
}
</code></pre></pre>
<p>El c√≥digo anterior, da como resultado:</p>
<pre><code class="language-text">18
segundo_numero = ¬øtriple_referencia? true
</code></pre>
<p>El uso del operador sobre una variable <code>&amp;</code> se denomina &quot;referenciar&quot;. El uso del operador sobre una variable de referencia <code>*</code> se denomina &quot;<strong>des</strong>referenciar&quot;.</p>
<p>Rust usa dos reglas para las referencias mutables e inmutables. Son muy importantes y f√°ciles de recordar porque tienen sentido.</p>
<ul>
<li><strong>Regla 1</strong>: Si solo existen referencias inmutables a un valor, se pueden tener tantas como se quiera.</li>
<li><strong>Regla 2</strong>: Si existe una referencia mutable a un valor, solo puede existir una referencia. Esto √∫ltimo significa que no pueden existir a la vez referencias inmutables y mutables en el mismo momento.</li>
</ul>
<p>Estas reglas son necesarias debido a que las referencias mutables pueden cambiar los datos. Ser√≠a problem√°tico que se modificara un dato cuando otras referencias lo est√°n usando.</p>
<p>Un forma de entenderlo es pensar en la creaci√≥n de una presentaci√≥n de Powerpoint <sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>No se trata de un ejemplo excesivamente bueno, ya que actualmente es posible editar simult√°neamente en Office 365.</p>
</div>
<p>El primer caso representa el de <strong>la existencia de una referencia mutable</strong>: un empleado est√° editando una presentaci√≥n de Powerpoint. Piode ayuda a su jefe. El empleado entrega sus credenciales de acceso a su jefe para que pueda editar el Powerpoint. Ahora el jefe tiene una &quot;referencia mutable&quot; a la presentaci√≥n de su empleado. El jefe puede hacer los cambios que quiera y devolver el ordenador m√°s tarde. Nadie m√°s tiene acceso a la presentaci√≥n, por lo que este caso no da problemas.</p>
<p>El segundo caso representa el de **la existencia √∫nicamente de referencias inmutables&quot;: El empleado entrega la presentaci√≥n a 100 personas. Todas ellas pueden verla. Tienen una &quot;referencia inmutable&quot; a la presentaci√≥n ya que nadie puede modificarla, por lo que este caso no da problemas.</p>
<p>El tercer caso representa la <strong>situaci√≥n problem√°tica a evitar</strong>: El empleado entrega sus credenciales de acceso a su jefe, que a partir de aqu√≠ dispone de una &quot;referencia mutable&quot;. Adem√°s, el empleado entrega la presentaci√≥n a 100 personas. El jefe puede entrar a editar y estas modificaciones pueden verse o no por parte de las 100 personas, seg√∫n el momento en que accedan sin que puedan controlar.</p>
<p>Se puede ver que el intento de usar una referencia mutable simult√°neamente con una inmutable no es aceptado por el compilador:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut numero = 10;
    let numero_ref = &amp;numero;
    let numero_modif = &amp;mut numero;
    *numero_modif += 10;
    println!(&quot;{}&quot;, numero_ref); // ‚ö†Ô∏è
}
</code></pre></pre>
<p>El compilador muestra un mensaje explicativo muy claro para mostrar el problema:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `numero` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:4:24
  |
3 |     let numero_ref = &amp;numero;
  |                      ------- immutable borrow occurs here
4 |     let numero_modif = &amp;mut numero;
  |                        ^^^^^^^^^^^ mutable borrow occurs here
5 |     *numero_modif += 10;
6 |     println!(&quot;{}&quot;, numero_ref); // ‚ö†Ô∏è
  |                    ---------- immutable borrow later used here
</code></pre>
<p>Sin embargo, este c√≥digo s√≠ funciona. ¬øPor qu√©?</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut numero = 10;
    let numero_modif = &amp;mut numero; // referencia modificable
    *numero_modif += 10; // suma 10
    let numero_ref = &amp;numero; // referencia inmutable
    println!(&quot;{}&quot;, numero_ref); // imprime el valor referenciado
}
</code></pre></pre>
<p>Imprime <code>20</code> sin problemas. Funciona porque el compilador es suficientemente inteligente para comprender el c√≥digo. Conoce que se ha cmabiado <code>numero</code> a trav√©s de la referencia <code>numero_modif</code>, pero despu√©s, esta referencia mutable no se vuelve a usar. Por eso no hay problema aqu√≠. No se usan &quot;a la vez&quot; referencias inmutables y mutables (como s√≠ pasaba en el caso anterior).</p>
<p>En versiones anteriores de Rust, este c√≥digo s√≠ daba error, pero actualmente no lo hace ya que el compilador es m√°s inteligente. Puede entender no solo lo que se ha tecleado, sino como se usa todo.</p>
<h2 id="ocultaci√≥n-shadowing-de-nuevo"><a class="header" href="#ocultaci√≥n-shadowing-de-nuevo">Ocultaci√≥n (shadowing) de nuevo</a></h2>
<p>Es necesario recordar que el ocultamiento de variables no destruye sus valores, sino que los bloquea. Con el uso de las referencias esto se ve m√°s claro.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let pais = String::from(&quot;Austria&quot;);
    let pais_ref = &amp;pais;
    let pais = 8;
    println!(&quot;{}, {}&quot;, pais_ref, pais);
}
</code></pre></pre>
<p>¬øQu√© imprime este c√≥digo? ¬ø<code>Austria, 8</code> o <code>8, 8</code>? Imprime <code>Austria, 8</code>. En la primera l√≠nea, se declara una variable <code>String</code> con el valor <code>Austria</code> y denominada <code>pais</code>. En la segunda l√≠nea se crea una referencia al valor de esta variable. Es decir, a la <code>String</code> que contiene <code>Austria</code>. Despu√©s, se oculta la variable <code>pais</code> con una nueva cuyo valor es <code>8</code> y que es de tipo <code>i32</code>. El primer elemento <code>pais</code> no se destruy√≥ (lo har√° al finalizar el √°mbito en el que est√°, en la llave de cierre de este bloque), por lo que sigue accesible a trav√©s de la referencia <code>pais_ref</code>. Para mayor claridad, se vuelve a mostrar el c√≥digo, ahora con comentarios sobre su comportamiento.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let pais = String::from(&quot;Austria&quot;); // String denominada pais
    let pais_ref = &amp;pais; // pais_ref es una referencia al valor
    let pais = 8; // nueva variable pais con un valor 8. Sin relaci√≥n con la anterior, ni con pais_ref
    println!(&quot;{}, {}&quot;, pais_ref, pais); // pais_ref sigue &quot;apuntando&quot; al dato Austria
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="paso-de-referencias-a-funciones"><a class="header" href="#paso-de-referencias-a-funciones">Paso de referencias a funciones</a></h1>
<p><strong>Puedes ver este cap√≠tulo en Youtube en ingl√©s: <a href="https://youtu.be/mKWXt9YTavc">referencias inmutables</a> y <a href="https://youtu.be/kJV1wIvAbyk">referencias mutables</a></strong></p>
<p>Las referencias son muy √∫tiles en las funciones. La regla de Rust para todos los valores es que un valor solo puede tener una variable propietario.</p>
<p>Este c√≥digo no funcionar√°:</p>
<pre><pre class="playground"><code class="language-rust">fn print_pais(pais_nombre: String) {
    println!(&quot;{}&quot;, pais_nombre);
}

fn main() {
    let pais = String::from(&quot;Austria&quot;);
    print_pais(pais); // Se imprime &quot;Austria&quot;
    print_pais(pais); // ‚ö†Ô∏è Se intenta de nuevo, pero no funciona
}
</code></pre></pre>
<p>Devuelve el siguiente error:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `pais`
 --&gt; src/main.rs:8:16
  |
6 |     let pais = String::from(&quot;Austria&quot;);
  |         ---- move occurs because `pais` has type `String`, which does not implement the `Copy` trait
7 |     print_pais(pais); // Se imprime &quot;Austria&quot;
  |                ---- value moved here
8 |     print_pais(pais); // ‚ö†Ô∏è Se intenta de nuevo, pero no funciona
  |                ^^^^ value used here after move
</code></pre>
<p>La variable <code>pais</code> ya no existen en la √∫ltima l√≠nea. El funcionamiento es el siguiente:</p>
<ul>
<li>Paso 1: Se crea el valor de tipo <code>String</code> cuyo due√±o es la variable <code>pais</code>.</li>
<li>Paso 2: Se pasa <code>pais</code> a la funci√≥n <code>print_pais</code>. Es una funci√≥n que no tiene <code>-&gt;</code> en su declaraci√≥n, por lo que no retorna ning√∫n valor. Al hacer la llamada, la variable <code>pais_nombre</code> (par√°metro) es la nueva due√±a del valor. Despu√©s de que esta funci√≥n finaliza, <code>pais_nombre</code> desaparece, como es la due√±a del valor, este tambi√©n se destruye.</li>
<li>Paso 3: Se intenta pasar por segunda vez <code>pais</code> a la funci√≥n `print_pais, pero ya no existe ya que dej√≥ de ser due√±a del valor y el valor despareci√≥ dentro de la primera llamada a la funci√≥n.</li>
</ul>
<p>Se podr√≠a hacer que la funci√≥n <code>print_pais</code> devolviera de nuevo el valor <code>String</code>, pero es poco ortodoxo.</p>
<pre><pre class="playground"><code class="language-rust">fn print_pais(pais_nombre: String) -&gt; String {
    println!(&quot;{}&quot;, pais_nombre);
    pais_nombre // se devuelve el valor
}

fn main() {
    let pais = String::from(&quot;Austria&quot;);
    let pais = print_pais(pais); // Es necesario crear una nueva variable para recuperar el valor
    print_pais(pais);
}
</code></pre></pre>
<p>Ahora s√≠ funciona e imprime:</p>
<pre><code class="language-text">Austria
Austria
</code></pre>
<p>Es mucho mejor evitar que la variable <code>print_nombre</code>, par√°metro de la funci√≥n, sea due√±a del valor, solamente se &quot;presta&quot;, sin que la variable <code>pais</code> de la funci√≥n <code>main</code> deje de ser su due√±o.</p>
<pre><pre class="playground"><code class="language-rust">fn print_pais(pais_nombre: &amp;String) {
    println!(&quot;{}&quot;, pais_nombre);
}

fn main() {
    let pais = String::from(&quot;Austria&quot;);
    print_pais(&amp;pais); // Se imprime &quot;Austria&quot;
    print_pais(&amp;pais); // Se intenta de nuevo y funciona correctamente
}
</code></pre></pre>
<p>En este caso <code>print_pais()</code> toma una referencia a una <code>String</code>: <code>&amp;String</code>. Cuando se llama <code>print_pais()</code> se pasa una referencia con <code>&amp;pais</code>. Esto significa que &quot;la funci√≥n puede acceder al valor, pero no se hace due√±a de √©l&quot;.</p>
<p>A continuaci√≥n, se muestra un ejemplo similar para observar el comportamiento de las referencias modificables (mutables).</p>
<pre><pre class="playground"><code class="language-rust">fn a√±ade_hungria(pais_nombre: &amp;mut String) { // se pasa una referencia mutable
    pais_nombre.push_str(&quot;-Hungr√≠a&quot;); // push_str() a√±ade un &amp;str a un String
    println!(&quot;Ahora dice: {}&quot;, pais_nombre);
}

fn main() {
    // es importante que la variable se declare
    // como mutable para poder crear referencias mutables
    let mut pais = String::from(&quot;Austria&quot;);
    a√±ade_hungria(&amp;mut pais); // hay que pasar la referencia mutable.
    println!(&quot;Y el valor se ha modificado aqu√≠: {}&quot;, pais);
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">Ahora dice: Austria-Hungr√≠a
Y el valor se ha modificado aqu√≠: Austria-Hungr√≠a
</code></pre>
<p>En resumen:</p>
<ul>
<li><code>fn nombre_de_funcion(variable: String)</code> toma un <code>String</code> y se hace due√±o de √©l.</li>
<li><code>fn nombre_de_funcion(variable: &amp;String)</code> toma prestado un <code>String</code> y puede acceder a su valor.</li>
<li><code>fn nombre_de_funcion(variable: &amp;mut String)</code> toma prestado un <code>String</code>, puede acceder a su valor y modificarlo.</li>
</ul>
<p>El siguiente ejemplo puede parecer similar, pero es muy diferente. Sirve para mostrar c√≥mo quien se hace due√±o de un objeto puede decidir que sea modificable, aunque anteriormente no lo fuese.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let pais = String::from(&quot;Austria&quot;); // pais no es mutable, ni referencia
    a√±adir_hungria(pais);
}

fn a√±adir_hungria(mut pais: String) { // a√±adir_hungria declara su par√°metro como mutable
    pais.push_str(&quot;-Hungr√≠a&quot;);
    println!(&quot;{}&quot;, pais);
}
</code></pre></pre>
<p>La funci√≥n <code>a√±adir_hungria</code> se hace due√±a del valor en su variable <code>mut pais</code>. A partir de ah√≠, puede hacer con este valor lo que quiera.</p>
<p>Si se recuerda el ejemplo anterior sobre el empleado, su jefe y la presentaci√≥n en powerpoint, esta es la situaci√≥n en la que el empleado le da el control completo al jefe. El empleado no puede volver a tocar la presentaci√≥n y el jefe puede hacer lo que quiera con ella.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="copia"><a class="header" href="#copia">Copia</a></h1>
<p>Algunos tipos de Rust son muy simples. Se almacenan todos en la pila ya que el compilador conoce su tama√±o. Esto significa que son f√°ciles de copiar, por lo que el compilador siempre los copia cuando se env√≠an a una funci√≥n. Son valores de tama√±o fijo, conocido y peque√±o. En estos casos, no hay necesidad de preocuparse por qui√©n es el due√±o de estos tipos de dato. A estos tipos, se los denomina <strong>tipos copia</strong> (Copy Types, en ingl√©s).</p>
<p>Estos tipos simples incluyen a los enteros, flotantes, booleanos (<code>true</code> -verdadero- y <code>false</code> -falso-) y <code>char</code>.</p>
<p>Para que los tipos se puedan copiar tienen que <strong>implementar</strong> la posibilidad de copia (copy). Se puede consultar la documentaci√≥n de cada tipo para conocerlo. Por ejemplo, esta es la documentaci√≥n del tipo <code>char</code>:</p>
<p><a href="https://doc.rust-lang.org/std/primitive.char.html">https://doc.rust-lang.org/std/primitive.char.html</a></p>
<p>A la izquierda de esta documentaci√≥n se puede ver <strong>Trait Implementations</strong>. Se muestran, entre otras: <strong>Copy</strong>, <strong>Debug</strong> y <strong>Display</strong>. Lo que permite conocer que <code>char</code> puede:</p>
<ul>
<li>Copiarse cuando se pasa como par√°metro a una funci√≥n (<strong>Copy</strong>).</li>
<li>Puede usar <code>{}</code> para imprimir (<strong>Display</strong>).</li>
<li>Puede usar <code>{:?}</code> para imprimir (<strong>Debug</strong>).</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn prints_number(numero: i32) { // Esta funci√≥n no tiene -&gt;, no devuelve ning√∫n valor
                             // Si el n√∫mero no se copiara, esta funci√≥n se har√≠a au propietaria 
                             // y no se podr√≠a volver a usar
    println!(&quot;{}&quot;, numero);
}

fn main() {
    let mi_numero = 8;
    prints_number(mi_numero); // Imprime 8. prints_number obtiene una copia del n√∫mero
    prints_number(mi_numero); // Imprime 8 de nuevo.
                              // No hay problema ya que mi_numero es un tipo que se copia
}
</code></pre></pre>
<p>Sin embargo, si se revisa la documentaci√≥n de <code>String</code> se ve que no es un tipo que se copie.</p>
<p><a href="https://doc.rust-lang.org/std/string/struct.String.html">https://doc.rust-lang.org/std/string/struct.String.html</a></p>
<p>A la izquierda de esta documentaci√≥n se puede ver <strong>Trait Implementations</strong>, en orden alfab√©tico. En la C no est√° <strong>Copy</strong>. Lo que s√≠ aparece es <strong>Clone</strong>, que es similar a *<em>Copy</em>, solo que es necesario invocarlo expresamente con el m√©todo <code>clone()</code>. Es decir, que no se clona por s√≠ mismo, se tiene que pedir expresamente.</p>
<p>En el siguiente ejemplo, <code>prints_country()</code> imprime el nombre del pa√≠s, que es de tipo <code>String</code>. Se quiere, como en el caso anterior, imprimir dos veces, pero no es posible:</p>
<pre><pre class="playground"><code class="language-rust">fn prints_country(country_name: String) {
    println!(&quot;{}&quot;, country_name);
}

fn main() {
    let country = String::from(&quot;Kiribati&quot;);
    prints_country(country);
    prints_country(country); // ‚ö†Ô∏è
}
</code></pre></pre>
<p>El mensaje es autoexplicativo:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `country`
 --&gt; src\main.rs:4:20
  |
2 |     let country = String::from(&quot;Kiribati&quot;);
  |         ------- move occurs because `country` has type `std::string::String`, which does not implement the `Copy` trait
3 |     prints_country(country);
  |                    ------- value moved here
4 |     prints_country(country);
  |                    ^^^^^^^ value used here after move
</code></pre>
<p>Dice que <code>String</code> no implementa el rasgo necesario para copiar <code>Copy trait</code>. Sin embargo, se ha visto que s√≠ implementa el rasgo <code>Clone</code>, por lo que se puede a√±adir <code>.clone()</code> al c√≥digo para generar de forma expresa una copia del valor. De este modo, se puede enviar un clon del valor a la funci√≥n. As√≠, despu√©s de llamar a la funci√≥n, la variable <code>country</code> contin√∫a vigente y se puede utilizar.</p>
<pre><pre class="playground"><code class="language-rust">fn prints_country(country_name: String) {
    println!(&quot;{}&quot;, country_name);
}

fn main() {
    let country = String::from(&quot;Kiribati&quot;);
    prints_country(country.clone()); // crea un clon y lo pasa a la funci√≥n. country sigue vigente
    prints_country(country);
}
</code></pre></pre>
<p>Evidentemente, si el <code>String</code> es muy largo, generar un clon requiere el uso de mucha memoria. Una cadena de texto <code>String</code> puede ser de la longitud de un libro entero, y cada vez que se llama a <code>.clone()</code> se genera una copia completa. Por eso, es recomendable el uso de <code>&amp;</code> para utilizar una referencia cuando sea posible. Por ejemplo, el c√≥digo siguiente a√±ade una cadena de texto <code>&amp;str</code> en una <code>String</code> y despu√©s crea un clon cada vez que se utiliza en una funci√≥n:</p>
<pre><pre class="playground"><code class="language-rust">fn get_length(input: String) { // Se apropia de la cadena de texto
    println!(&quot;Tiene una longitud de {} palabras.&quot;, input.split_whitespace().count()); // la divide para contar el n√∫mero de palabras
}

fn main() {
    let mut my_string = String::new();
    for _ in 0..50 {
        my_string.push_str(&quot;Aqu√≠ van palabras en espa√±ol &quot;); // a√±ade las palabras
        get_length(my_string.clone()); // obtiene un nuevo clon cada vez
    }
}
</code></pre></pre>
<p>Lo que imprime es:</p>
<pre><code class="language-text">Tiene una longitud de 5 palabras.
Tiene una longitud de 10 palabras.
...
Tiene una longitud de 250 palabras
</code></pre>
<p>Esto genera 50 clones. El siguiente c√≥digo cumple la misma funci√≥n usando referencias y es mucho m√°s eficiente:</p>
<pre><pre class="playground"><code class="language-rust">fn get_length(input: &amp;String) {
    println!(&quot;Tiene una longitud de {} palabras.&quot;, input.split_whitespace().count());
}

fn main() {
    let mut my_string = String::new();
    for _ in 0..50 {
        my_string.push_str(&quot;Aqu√≠ van palabras en espa√±ol &quot;);
        get_length(&amp;my_string);
    }
}
</code></pre></pre>
<p>Con el c√≥digo anterior no se genera ning√∫n clon.</p>
<h2 id="variables-sin-valores"><a class="header" href="#variables-sin-valores">Variables sin valores</a></h2>
<p>Una variables sin valor est√° <em>sin inicializar</em>. Para crear una variable en este estado se usa <code>let</code> y el nombre de la variable:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_variable; // ‚ö†Ô∏è
}
</code></pre></pre>
<p>Rust no compila si hay alguna variable sin inicializar.</p>
<p>Sin embargo, en ocasiones pueden ser √∫tiles. Un claro ejemplo es cuando:</p>
<ul>
<li>Se tiene un bloque de c√≥digo en el que se genera el valor necesario para la variable y...</li>
<li>...la variable tiene que sobrevivir fuera del bloque de c√≥digo.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn loop_then_return(mut counter: i32) -&gt; i32 {
    loop {
        counter += 1;
        if counter % 50 == 0 {
            break;
        }
    }
    counter
}

fn main() {
    let my_number;

    { // Este bloque es innecesario, pero se crea para documentar caso
        let number = {
            // Aqu√≠ podria haber mucho c√≥digo
            // para generar un valor, por ejemplo:
            57
        };

        my_number = loop_then_return(number);
    }

    println!(&quot;{}&quot;, my_number);
}
</code></pre></pre>
<p>Este ejemplo imprime <code>100</code>.</p>
<p>Se observa que <code>my_number</code> se declar√≥n en la funci√≥n <code>main()</code>, por lo que su tiempo de vida dura hasta su finalizaci√≥n. Y obtiene su valor dentro del bucle <code>loop</code>. El valor pasa a ser propiedad de <code>my_number</code> antes de salir del bloque.</p>
<p>Si se hubiera declarado y asignado el valor en la misma l√≠nea con <code>let my_number = loop_then_return(number)</code> dentro del bloque, la variable hubiera desaparecido con el bloque.</p>
<p>De forma simplificada, ayuda a verlo el sustituir la funci√≥n por su valor de retorno, 100. Se ve en el siguiente c√≥digo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number;
    {
        my_number = 100;
    }

    println!(&quot;{}&quot;, my_number);
}
</code></pre></pre>
<p>Es casi como escribir <code>let my_number = { 100 };</code>.</p>
<p>Se debe observar que <code>my_number</code> no es <code>mut</code>. No se le asigna un valor hasta que se asigna el 100, por lo que no ha cambiado de valor. En el fondo el c√≥digo real para <code>my_number</code> es solo <code>let my_number = 100;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tipos-colecci√≥n"><a class="header" href="#tipos-colecci√≥n">Tipos colecci√≥n</a></h1>
<p>Rust tiene muchos tipos para construir una colecci√≥n. La colecciones sirven para almacenar m√°s de un valor en un mismo lugar. Por ejemplo, permiten almacenar la informaci√≥n sobre todas las ciudades de un pa√≠s en una variable.</p>
<p>Se iniciar√° con los arrays, que son los m√°s r√°pidos, pero tambi√©n los que tienen la funcionalidad m√°s limitada. En este sentido, son como el tipo <code>&amp;str</code>.</p>
<h2 id="arrays"><a class="header" href="#arrays">Arrays</a></h2>
<p>Son los datos guardados dentro de corchetes: <code>[]</code>.</p>
<p>Los Arrays:</p>
<ul>
<li>No pueden cambiar de tama√±o.</li>
<li>Tienen datos del mismo tipo.</li>
</ul>
<p>Sin embargo, son muy r√°pidos.</p>
<p>El tipo de un array es: <code>[tipo; longitud]</code>. Por ejemplo, el tipo de <code>[&quot;Uno&quot;, &quot;Dos&quot;]</code> es <code>[&amp;str; 2]</code>. Esto significa que los siguientes dos arrays tienen tipos diferentes:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let array1 = [&quot;One&quot;, &quot;Two&quot;]; // Este es de tipo [&amp;str; 2]
    let array2 = [&quot;One&quot;, &quot;Two&quot;, &quot;Five&quot;]; // Y este de tipo [&amp;str; 3]. ¬°Son dos tipos diferentes!
}
</code></pre></pre>
<p>Para conocer el tipo de una variable se puede &quot;pedir&quot; al compilador que haga algo con ella que no sea v√°lido, por ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let seasons = [&quot;Spring&quot;, &quot;Summer&quot;, &quot;Autumn&quot;, &quot;Winter&quot;];
    let seasons2 = [&quot;Spring&quot;, &quot;Summer&quot;, &quot;Fall&quot;, &quot;Autumn&quot;, &quot;Winter&quot;];
    seasons.ddd(); // ‚ö†Ô∏è
    seasons2.thd(); // ‚ö†Ô∏è tambi√©n
}
</code></pre></pre>
<p>El compilador dice, &quot;¬øQu√© haces? No existe el m√©todo <code>.ddd()</code> para la variable seasons y tampoco existe el m√©todo <code>.thd()</code> para seasons2&quot; como puedes ver:</p>
<pre><code class="language-text">error[E0599]: no method named `ddd` found for array `[&amp;str; 4]` in the current scope
 --&gt; src\main.rs:4:13
  |
4 |     seasons.ddd(); // 
  |             ^^^ method not found in `[&amp;str; 4]`

error[E0599]: no method named `thd` found for array `[&amp;str; 5]` in the current scope
 --&gt; src\main.rs:5:14
  |
5 |     seasons2.thd(); // 
  |              ^^^ method not found in `[&amp;str; 5]`
</code></pre>
<p>Y dice que <code>method not found in `[&amp;str; 4]`</code>, que es el tipo del array.</p>
<p>Si se necesita un array con el mismo valor en todos los elementos, se puede declarar de la siguiente forma:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_array = [&quot;a&quot;; 10];
    println!(&quot;{:?}&quot;, my_array);
}
</code></pre></pre>
<p>Que imprime <code>[&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;]</code>.</p>
<p>Este m√©todo se utiliza mucho para crear buffers. Por ejemplo, <code>let mut buffer = [0;640]</code> crea un array de 640 ceros. Posteriormente, se puede modificar el valor cero por otro dato.</p>
<p>Se pueden indexrar los valores (recuperarlos) con <code>[]</code>. El primer valor es <code>[0]</code>, el segundo <code>[1]</code> y as√≠ sucesivamente.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_numbers = [0, 10, -20];
    println!(&quot;{}&quot;, my_numbers[1]); // imprime 10
}
</code></pre></pre>
<p>Se puede obtener una secci√≥n (slice) de un array. Lo primero que se necesita es una referencia <code>&amp;</code> porque el compilador no conoce el tama√±o. Despu√©s se puede usar <code>..</code> para mostrar el rango.</p>
<p>Por ejemplo, si se utiliza el siguiente array: <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let array_of_ten = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    let three_to_five = &amp;array_of_ten[2..5];
    let start_at_two = &amp;array_of_ten[1..];
    let end_at_five = &amp;array_of_ten[..5];
    let everything = &amp;array_of_ten[..];

    println!(&quot;Tres a cinco: {:?}, comienza en el segundo: {:?}, finaliza en el quinto: {:?}, todo: {:?}&quot;, three_to_five, start_at_two, end_at_five, everything);
}
</code></pre></pre>
<p>Se debe recordar que:</p>
<ul>
<li>Los n√∫meros de √≠ndice comienzan en 0 (no en 1).</li>
<li>los rangos son <strong>excluyentes</strong> (es decir, no incluyen el √∫ltimo n√∫mero).</li>
</ul>
<p>As√≠, <code>[0..2]</code> obtiene el primer y segundo valor (0 y 1). Dicho de otro modo, el √≠ndice cero y uno. No obtiene el tercer valor, cuyo  √≠ndice es dos.</p>
<p>Es posible establecer un rango <strong>inclusivo</strong>, que s√≠ incluya el √∫ltimo n√∫mero del rango. Para ello se escribe <code>..=</code>, en lugar de <code>..</code>. As√≠ que <code>[0..=2]</code> permite obtener el primer, segundo y tercer elemento del array.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vectores"><a class="header" href="#vectores">Vectores</a></h1>
<p><strong><a href="https://youtu.be/Eh-DsRnDKmw">Puedes ver este cap√≠tulo en Youtube en ingl√©s</a></strong></p>
<p>Del mismo modo que se dispone de <code>&amp;str</code> y <code>String</code>, se dispone de arrays y vectores. Los arrays son m√°s r√°pidos, pero tienen menos funcionalidad, y los vectores son m√°s lentos, pero tienen m√°s funcionalidad (Rust siempre es muy r√°pido, solo que los vectores no son tan r√°pidos como los arrays). El tipo es <code>Vec</code> y, por lo tanto, se le puede llamar como &quot;vec&quot;.</p>
<p>Existen principalemente dos formas de declarar un vector. Una es igual a como se crea un <code>String</code>, mediante el uso de <code>new</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let name1 = String::from(&quot;Windy&quot;);
    let name2 = String::from(&quot;Gomesy&quot;);

    let mut my_vec = Vec::new();
    // Si se compilara este programa hasta aqu√≠, el compilador dar√° un error.
    // ya que no conoce el tipo de datos del vec.

    my_vec.push(name1); // Ahora s√≠ lo conoce, es un Vec&lt;String&gt;
    my_vec.push(name2);
}
</code></pre></pre>
<p>Los <code>Vec</code> siempre contienen valores y para eso sirven <code>&lt;&gt;</code> (los par√©ntesis angulares). Un <code>Vec&lt;String&gt;</code> es un vector que contiene elementos <code>String</code>. Algunos otros ejemplos son:</p>
<ul>
<li><code>Vec&lt;(i32, i32)&gt;</code> es un vector en el que cada elemento de contenido es una tupla <code>(i32, i32)</code>.</li>
<li><code>Vec&lt;Vec&lt;String&gt;&gt;</code> es un vector en el que cada elemento es otro vector de <code>String</code>. Por ejemplo, se puede pensar en almacenar el texto de un libro como un <code>Vec&lt;String&gt;</code>. Para almacenar varios libros har√≠a falta crear una lista de elementos del tipo anterior y esto se puede hacer en otro <code>Vec</code> que contiene <code>Vec&lt;String&gt;</code>. Por lo tanto, el tipo resultante ser√≠a as√≠ <code>Vec&lt;Vec&lt;String&gt;&gt;</code>.</li>
</ul>
<p>En lugar de usar <code>.push()</code> para llegar a deducir el tipo de elementos que contiene un vector, se puede declarar el tipo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec: Vec&lt;String&gt; = Vec::new(); // El compilador conoce el tipo
                                              // Por eso no hay error
}
</code></pre></pre>
<p>Como se observa, todos los elementos de un vector tienen que tener un mismo tipo.</p>
<p>Otra forma sencilla de crear un vector es usando la macro <code>vec!</code>, cuya sintaxis recuerda a la declaraci√≥n de un array.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec = vec![8, 10, 10];
}
</code></pre></pre>
<p>El tipo de los elementos, en este ejemplo, es <code>Vec&lt;i32&gt;</code>. Un vector de enteros. </p>
<p>Se pueden obtener secciones de un vector, igual que como se hace para un array.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let vec_of_ten = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    // Todo el c√≥digo es id√©ntico, salvo que se a√±ade vec!.
    let three_to_five = &amp;vec_of_ten[2..5];
    let start_at_two = &amp;vec_of_ten[1..];
    let end_at_five = &amp;vec_of_ten[..5];
    let everything = &amp;vec_of_ten[..];

    println!(&quot;Three to five: {:?},
start at two: {:?}
end at five: {:?}
everything: {:?}&quot;, three_to_five, start_at_two, end_at_five, everything);
}
</code></pre></pre>
<p>Puesto que un vector es m√°s lento que un array, se pueden usar diversos m√©todos para hacerlo m√°s r√°pido. Un vector tiene una <strong>capacidad</strong> de espacio asignada, que permite que al ir insertando nuevos elementos en el vector, se haga r√°pidamente. Cada vez que se hace esto, el vector se acerca al l√≠mite de su capacidad. Cuando esta se supera, Rust crea un nuevo espacio del doble del tama√±o actual y copia todos los elementos al nuevo espacio. Esto se denomina relocalizaci√≥n. Se puede usar el m√©todo <code>.capacity()</code>para ver la capacidad de un vector seg√∫n se le van a√±adiendo elementos.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut num_vec = Vec::new();
    println!(&quot;{}&quot;, num_vec.capacity()); // 0 elementos: immprime 0
    num_vec.push('a'); // a√±ade un car√°cter
    println!(&quot;{}&quot;, num_vec.capacity()); // 1 elemento: imprime 4. Vecs con 1 elemento siempre se inician con una capacidad de 4
    num_vec.push('a'); // a√±ade uno m√°s
    num_vec.push('a'); // a√±ade uno m√°s
    num_vec.push('a'); // a√±ade uno m√°s
    println!(&quot;{}&quot;, num_vec.capacity()); // 4 elementos: a√∫n 4 de capacidad.
    num_vec.push('a'); // a√±ade uno m√°s
    println!(&quot;{}&quot;, num_vec.capacity()); // imprime 8. Son 5 elementos, pero ha doblado la capacidad de 4 a 8 para hacer espacio.
}
</code></pre></pre>
<p>Esto imprime:</p>
<pre><code class="language-text">0
4
4
8
</code></pre>
<p>As√≠ que este vector ha sufrido dos relocalizaciones: de 0 a 4 y de 4 a 8. Para que fuese m√°s r√°pido se puede iniciar as√≠:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut num_vec = Vec::with_capacity(8); // Se crea con una capacidad inicial de 8
    num_vec.push('a'); // se a√±ade un car√°cter
    println!(&quot;{}&quot;, num_vec.capacity()); // imprime 8
    num_vec.push('a'); // a√±ade uno m√°s
    println!(&quot;{}&quot;, num_vec.capacity()); // imprime 8
    num_vec.push('a'); // a√±ade uno m√°s
    println!(&quot;{}&quot;, num_vec.capacity()); // imprime 8.
    num_vec.push('a'); // a√±ade uno m√°s
    num_vec.push('a'); // a√±ade uno m√°s
    // Ahora hay 5 elementos
    println!(&quot;{}&quot;, num_vec.capacity()); // A√∫n 8
}
</code></pre></pre>
<p>Este vector no ha sufrido ninguna relocalizaci√≥n, lo que es mejor. Por eso, si se conoce a priori el n√∫mero de elementos que se necesitar√°, se puede inicializar el vector con <code>Vec::with_capacity()</code> para que funcione m√°s r√°pido.</p>
<p>En el caso de las <code>&amp;str</code> se pod√≠a utilizar <code>.into()</code> para convertirlo en una <code>String</code>. Igualmente, se puede convertir un array en un vector con la misma funci√≥n.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec: Vec&lt;u8&gt; = [1, 2, 3].into();
    let my_vec2: Vec&lt;_&gt; = [9, 0, 10].into(); // Vec&lt;_&gt; significa &quot;elige el tipo del Vector por m√≠&quot;
                                             // Rust elegir√° Vec&lt;i32&gt;
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuplas"><a class="header" href="#tuplas">Tuplas</a></h1>
<p><strong><a href="https://youtu.be/U67Diy6SlTg">Se puede ver este cap√≠tulo en Youtube en ingl√©s</a></strong></p>
<p>En Rust las tuplas usan <code>()</code>. Ya han aparecido muchas tuplas vac√≠as ya que <em>nada</em>, en una funci√≥n, realmente significa una tupla vac√≠a:</p>
<pre><code class="language-text">fn do_something() {}
</code></pre>
<p>realmente es igual a:</p>
<pre><code class="language-text">fn do_something() -&gt; () {}
</code></pre>
<p>Esta funci√≥n no recibe ning√∫n par√°metro (recibe una tupla vac√≠a) y no retorna ning√∫n valor (una tupla vac√≠a). Por eso, se han estado usando ya muchas tuplas en los ejemplos de cap√≠tulos anteriores. Cuando no se retorna ning√∫n valor en una funci√≥n, se est√° retornando una tupla vac√≠a.</p>
<pre><pre class="playground"><code class="language-rust">fn just_prints() {
    println!(&quot;Estoy imprimiendo&quot;); // Al a√±adir un ;
    // como √∫ltimo dato antes de terminar la funci√≥n
    // se est√° indicando que se debe retornar una tupla vac√≠a
}

fn main() {}
</code></pre></pre>
<p>Las tuplas pueden almacenar muchos tipos de elementos diferentes a la vez. Los elementos incluidos se indexan con n√∫meros de 0 en adelante. Para acceder a ellos se utiliza el operador <code>.</code> en lugar de <code>[]</code>. A continuaci√≥n se incorporan datos de diferentes tipos en una √∫nica tupla:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let random_tuple = (&quot;Esto es un texto&quot;, 8, vec!['a'], 'b', [8, 9, 10], 7.7);
    println!(
        &quot;El interior de la tupla contiene: Primer elemento: {:?}
Segundo elemento: {:?}
Tercer elemento: {:?}
Cuarto elemento: {:?}
Quinto elemento: {:?}
Sexto elemento: {:?}&quot;,
        random_tuple.0,
        random_tuple.1,
        random_tuple.2,
        random_tuple.3,
        random_tuple.4,
        random_tuple.5,
    )
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">El interior de la tupla contiene: Primer elemento: &quot;Esto es un texto&quot;
Segundo elemento: 8
Tercer elemento: ['a']
Cuarto elemento: 'b'
Quinto elemento: [8, 9, 10]
Sexto elemento: 7.7
</code></pre>
<p>Esta tupla es de tipo <code>(&amp;str, i32, Vec&lt;char&gt;, char, [i32; 3], f64)</code>.</p>
<p>Se puede usar una tupla para crear m√∫ltiples variables. En el siguiente c√≥digo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let str_vec = vec![&quot;one&quot;, &quot;two&quot;, &quot;three&quot;];
}
</code></pre></pre>
<p><code>str_vec</code> contiene tres elementos. ¬øC√≥mo se pueden recuperar los tres valores de este vector en diferentes variables? Por ejemplo, con una tupla:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let str_vec = vec![&quot;one&quot;, &quot;two&quot;, &quot;three&quot;];

    let (a, b, c) = (str_vec[0], str_vec[1], str_vec[2]); // las variables ser√°n a, b, y c
    println!(&quot;{:?}&quot;, b);
}
</code></pre></pre>
<p>El resultado del c√≥digo anterior imprime <code>&quot;two&quot;</code>, que es lo que contiene la variable <code>b</code>. A esta forma de extraer valores en variables se denomina <em>desestructuramiento</em>.</p>
<p>Si se necesita desestructurar un conjunto de elementos, pero no se quieren todos, se puede utilizar <code>_</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let str_vec = vec![&quot;one&quot;, &quot;two&quot;, &quot;three&quot;];

    let (_, _, variable) = (str_vec[0], str_vec[1], str_vec[2]);
}
</code></pre></pre>
<p>El c√≥digo anterior solo crea una variable denominada <code>variable</code>, pero no las crea para el resto de elementos.</p>
<p>Existen muchos m√°s tipos colecci√≥n y muchas formas adicionales de utilizar a los arrays, vectores y tuplas. Se ense√±ar√° m√°s sobre ellos m√°s adelante, pero primero, se ense√±ar√° la forma de controlar el flujo de ejecuci√≥n de un programa.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="estructuras-de-control"><a class="header" href="#estructuras-de-control">Estructuras de control</a></h1>
<p><strong>Se puede ver este cap√≠tulo en YouTube en ingl√©s: <a href="https://youtu.be/UAymDOpv_us">Parte 1</a> y <a href="https://youtu.be/eqysTfiiQZs">Parte 2</a></strong></p>
<p>Las estructuras de control del flujo de ejecuci√≥n permiten indicar qu√© c√≥digo debe ejecutarse en cada caso. La estructura de control de flujo m√°s simple es <code>if</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 5;
    if my_number == 7 {
        println!(&quot;Es el siete&quot;);
    }
}
</code></pre></pre>
<p>Se utiliza <code>==</code> y no <code>=</code>. <code>==</code> sirve para comparar y <code>=</code> se utiliza para asignar un valor. Tambi√©n hay que destacar que se escribe <code>if my_number == 7</code> y no <code>if (my_number == 7)</code>. La estructura de control <code>if</code> no necesita par√©ntesis en Rust.</p>
<p>Esta estructura se completa con <code>else if</code> y <code>else</code> si resultan necesarias:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 5;
    if my_number == 7 {
        println!(&quot;Es el siete&quot;);
    } else if my_number == 6 {
        println!(&quot;Es el seis&quot;)
    } else {
        println!(&quot;Es un n√∫mero diferente&quot;)
    }
}
</code></pre></pre>
<p>El c√≥digo anterior imprime <code>Es un n√∫mbero diferente</code> porque no es igual a 7 o 6.</p>
<p>Se pueden a√±adir m√°s condiciones con <code>&amp;&amp;</code> (operador <code>y l√≥gico</code>) y <code>||</code> (operador <code>o l√≥gico</code>).</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 5;
    if my_number % 2 == 1 &amp;&amp; my_number &gt; 0 { // % 2 es el resto de la divisi√≥n entre dos
        println!(&quot;Es un n√∫mero impar positivo&quot;);
    } else if my_number == 6 {
        println!(&quot;Es el seis&quot;)
    } else {
        println!(&quot;Es un n√∫mero diferente&quot;)
    }
}
</code></pre></pre>
<p>El c√≥digo anterior imprime <code>Es un n√∫mero impar positivo</code> porque cuando se divide entre 2 el resto es 1, que es mayor que 0.</p>
<p>Se observa que cuando hay demasiados <code>if</code>, <code>else</code> y <code>else if</code> el c√≥digo puede resultar dif√≠cil de leer. En estos casos (y en otros muchos) se puede utilizar <code>match</code>, que resulta mucho m√°s l√≠mpio. <code>match</code> requiere que se contemplen todos los casos posibles para evitar errores. As√≠ que el siguiente c√≥digo no funciona:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number: u8 = 5;
    match my_number {
        0 =&gt; println!(&quot;Es cero&quot;),
        1 =&gt; println!(&quot;Es uno&quot;),
        2 =&gt; println!(&quot;Es dos&quot;),
        // ‚ö†Ô∏è
    }
}
</code></pre></pre>
<p>El compilar indica lo siguiente:</p>
<pre><code class="language-text">error[E0004]: non-exhaustive patterns: `3u8..=std::u8::MAX` not covered
 --&gt; src\main.rs:3:11
  |
3 |     match my_number {
  |           ^^^^^^^^^ pattern `3u8..=std::u8::MAX` not covered
</code></pre>
<p>El compilador se queja de que solo conoce lo que tiene que ejecutar los casos de 0 a 2, pero <code>u8</code> puede tener valores hasta el 255 (es decir <code>std::u8::MAX</code>). Qu√© debe hacer el programa para el resto de valores posibles que pueden aparecer.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number: u8 = 5;
    match my_number {
        0 =&gt; println!(&quot;Es cero&quot;),
        1 =&gt; println!(&quot;Es uno&quot;),
        2 =&gt; println!(&quot;Es dos&quot;),
        _ =&gt; println!(&quot;Es alg√∫n otro n√∫mero&quot;),
    }
}
</code></pre></pre>
<p>Este c√≥digo imprime <code>Es alg√∫n otro n√∫mero</code>.</p>
<p>Para el caso de <code>match</code> hay que recordar que:</p>
<ul>
<li>A todo <code>match</code> le sigue un bloque de c√≥digo <code>{}</code></li>
<li>Se escriben los <em>patrones</em> a la izquierda y se usa <code>=&gt;</code> (flecha gruesa -fat arrow-) para indicar qu√© hay que hacer cuando hay una coincidencia.</li>
<li>A cada l√≠nea con un patr√≥n se le denomina &quot;brazo&quot; del <code>match</code>.</li>
<li>Entre cada &quot;brazo&quot; se pone una coma de separaci√≥n (no se usa el punto y coma).</li>
</ul>
<p>Se puede declarar un valor usando <code>match</code> ya que retorna una valor.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 5;
    let second_number = match my_number {
        0 =&gt; 0,
        5 =&gt; 10,
        _ =&gt; 2,
    };
}
</code></pre></pre>
<p>En el ejemplo anterior, <code>second_number</code> tendr√° el valor 10. El match, en este caso acaba con un ; ya que una vez se ha finalizado su evaluaci√≥n esta sentencia es como si se hubiese escrito <code>let second_number = 10;</code>. Que define y asigna el 10 a <code>second_number</code>.</p>
<p><code>match</code> se puede utilizar para cosas m√°s complejas. Por ejemplo, con tuplas:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let sky = &quot;nuboso&quot;;
    let temperature = &quot;c√°lido&quot;;

    match (sky, temperature) {
        (&quot;nuboso&quot;, &quot;fr√≠o&quot;) =&gt; println!(&quot;El d√≠a es oscuro y desapacible&quot;),
        (&quot;despejado&quot;, &quot;c√°lido&quot;) =&gt; println!(&quot;El d√≠a es agradable&quot;),
        (&quot;nuboso&quot;, &quot;c√°lido&quot;) =&gt; println!(&quot;El d√≠a es oscuro, pero no se est√° mal&quot;),
        _ =&gt; println!(&quot;No s√© c√≥mo es el d√≠a de hoy&quot;),
    }
}
</code></pre></pre>
<p>Este c√≥digo imprime <code>El d√≠a es oscuro, pero no se est√° mal</code> porque coincide con &quot;nuboso&quot; y &quot;c√°lido&quot; para <code>sky</code> y <code>temperature</code>.</p>
<p>Incluso se puede utilizar <code>if</code> en las ramas de un <code>match</code>. Es lo que se llama una &quot;guarda de coincidencia&quot; (match guard):</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let children = 5;
    let married = true;

    match (children, married) {
        (children, married) if married == false =&gt; println!(&quot;Sin casar con {} ni√±os&quot;, children),
        (children, married) if children == 0 &amp;&amp; married == true =&gt; println!(&quot;Casado, pero sin ni√±os&quot;),
        _ =&gt; println!(&quot;¬øCasado? {}. N√∫mero de ni√±os: {}.&quot;, married, children),
    }
}
</code></pre></pre>
<p>Este progrma imprimir√° <code>¬øCasado? true. N√∫mero de ni√±os: 5.</code></p>
<p>Se puede usar <code>_</code> tantas veces como se necesite en un <code>match</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn match_colours(rbg: (i32, i32, i32)) {
    match rbg {
        (r, _, _) if r &lt; 10 =&gt; println!(&quot;No muy rojo&quot;),
        (_, b, _) if b &lt; 10 =&gt; println!(&quot;No muy azul&quot;),
        (_, _, g) if g &lt; 10 =&gt; println!(&quot;No muy verde&quot;),
        _ =&gt; println!(&quot;Cada color tiene al menos 10&quot;),
    }
}

fn main() {
    let first = (200, 0, 0);
    let second = (50, 50, 50);
    let third = (200, 50, 0);

    match_colours(first);
    match_colours(second);
    match_colours(third);

}
</code></pre></pre>
<p>Este c√≥digo imprime:</p>
<pre><code class="language-text">No muy azul
Cada color tiene al menos 10
No muy verde
</code></pre>
<p>Este c√≥digo tambi√©n muestra c√≥mo funcionan las sentencias <code>match</code>, porque en el primer ejemplo solo imprime <code>No muy rojo</code>, aunque tampoco tiene mucho verde. Las sentencias <code>match</code> siempre se detienen cuando encuentran una coincidencia y no chequea el resto de los &quot;brazos&quot;. Es un buen ejemplo de c√≥digo que compila bien, pero no hace lo que se quiere.</p>
<p>Se puede construir una sentencia <code>match</code>gigante para arreglar este c√≥digo, pero probablemente es mejor utilizar un bucle <code>for</code>. M√°s adelante se hablar√° de los bucles.</p>
<p>La sentencia <code>match</code> siempre tiene que devolver el mismo tipo de datos en todas sus ramas. Por eso, este c√≥digo no funciona:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 10;
    let some_variable = match my_number {
        10 =&gt; 8,
        _ =&gt; &quot;Not ten&quot;, // ‚ö†Ô∏è
    };
}
</code></pre></pre>
<p>El compilador indica lo siguiente:</p>
<pre><code class="language-text">error[E0308]: `match` arms have incompatible types
  --&gt; src\main.rs:17:14
   |
15 |       let some_variable = match my_number {
   |  _________________________-
16 | |         10 =&gt; 8,
   | |               - this is found to be of type `{integer}`
17 | |         _ =&gt; &quot;Not ten&quot;,
   | |              ^^^^^^^^^ expected integer, found `&amp;str`
18 | |     };
   | |_____- `match` arms have incompatible types
</code></pre>
<p>El c√≥digo siguiente, por la misma raz√≥n, tampoco funciona:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let some_variable = if my_number == 10 { 8 } else { &quot;something else &quot;}; // ‚ö†Ô∏è
}
</code></pre></pre>
<p>Pero el siguiente c√≥digo s√≠ funciona, porque no es un <code>match</code>y son dos sentencias diferentes:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 10;

    if my_number == 10 {
        let some_variable = 8;
    } else {
        let some_variable = &quot;Something else&quot;;
    }
}
</code></pre></pre>
<p>Tambi√©n se puede usar <code>@</code> para darle un nombre al valor de un patr√≥n <code>match</code> con el fin de poder usarlo en la expresi√≥n correspondiente a ese &quot;brazo&quot;. En este ejemplo, se guarda el valor en una variable <code>number</code> para pasarlo a una funci√≥n. Si es 4 o 13 se usa ese <code>number</code> en la sentencia <code>println!</code>. En otro caso, no se utiliza.</p>
<pre><pre class="playground"><code class="language-rust">fn match_number(input: i32) {
    match input {
    number @ 4 =&gt; println!(&quot;{} da mala suerte en China (suena parecido a Ê≠ª)&quot;, number),
    number @ 13 =&gt; println!(&quot;{} da mala suerte en Norte Am√©rica, ¬°Suerte en Italia! In bocca al lupo&quot;, number),
    _ =&gt; println!(&quot;Es un n√∫mero normal&quot;),
    }
}

fn main() {
    match_number(50);
    match_number(13);
    match_number(4);
}
</code></pre></pre>
<p>Este c√≥digo imprime:</p>
<pre><code class="language-text">Es un n√∫mero normal
13 da mala suerte en Norte Am√©rica, ¬°Suerte en Italia! In bocca al lupo
4 da mala suerte en China (suena parecido a Ê≠ª)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="estructuras---struct"><a class="header" href="#estructuras---struct">Estructuras - struct</a></h1>
<p><strong>Se puede ver este cap√≠tulo en YouTube en ingl√©s: <a href="https://youtu.be/W23uQghBOFk">Parte 1</a> y <a href="https://youtu.be/GSVhrjLCuNA">Parte 2</a></strong></p>
<p>Con las estructuras se pueden crear nuevos tipos de datos. Se utilizan constantemente en Rust, puesto que son muy √∫tiles. Las estructuras se crean con la palabra reservada <code>struct</code>. El nombre de las estructuras deber√≠a estar en UpperCamelCase (una letra may√∫scula por cada palabra sin espacios, ni guiones bajos). Si se escribe todo en min√∫sculas, el compilador avisar√°.</p>
<p>Existen tres tipos de estructuras.</p>
<p>La primera de ellas es la estructura unitaria &quot;unit struct&quot;, que no tiene nada. Simplemente se escribe su nombre seguido de un punto y coma.</p>
<pre><pre class="playground"><code class="language-rust">struct FileDirectory;
fn main() {}
</code></pre></pre>
<p>La segunda de ellas es la estructura tupla, o estructura sin nombres. Solo es necesario escribir los tipos de dato que contiene, sin nombres de campo. Las estructuras de tupla son indicadas cuando se necesita una estructura simple sin necesidad de utilizar nombres.</p>
<pre><pre class="playground"><code class="language-rust">struct Colour(u8, u8, u8);

fn main() {
    let my_colour = Colour(50, 0, 50); // Crea un color RGB (red, green, blue)
    println!(&quot;La segunda parte del color (la componente verde) es: {}&quot;, my_colour.1);
}
</code></pre></pre>
<p>Este c√≥digo imprime <code>La segunda parte del color (la componente verde) es: 0</code>.</p>
<p>El tercer tipo es la estructura con nombres. Que es, probablemente, la m√°s habitual. En estas estructuras se declaran los nombres de los campos y sus tipos en un bloque <code>{}</code>. Estos bloques no se terminan con punto y coma.</p>
<pre><pre class="playground"><code class="language-rust">struct Colour(u8, u8, u8); // Declara la misma estructura tupla para el color

struct SizeAndColour {
    size: u32,
    colour: Colour, // y la inserta en una estructura con nombres
}

fn main() {
    let my_colour = Colour(50, 0, 50);

    let size_and_colour = SizeAndColour {
        size: 150,
        colour: my_colour
    };
}
</code></pre></pre>
<p>Los campos de una estructura con nombres se separan con comas. El √∫ltimo campo puede llevar o no la coma. En el caso anterior, se puso una coma despu√©s de definir el campo <code>colour: Colour,</code>, pero no es necesario. Normalmente, se considera buena idea poner siempre la coma, porque en ocasiones resulta necesario cambiar el orden de los campos o a√±adir uno al final y de este modo es sistem√°tica la modificaci√≥n:</p>
<pre><pre class="playground"><code class="language-rust">struct Colour(u8, u8, u8); 

struct SizeAndColour {
    size: u32,
    colour: Colour // Sin coma
}

fn main() {}
</code></pre></pre>
<p>Se dedice cambiar su orden, cortando y pegando la fila...</p>
<pre><pre class="playground"><code class="language-rust">struct SizeAndColour {
    colour: Colour // ‚ö†Ô∏è ¬°Error! ya que no tiene coma.
    size: u32,
}

fn main() {}
</code></pre></pre>
<p>En todo caso, no es muy importante si se usa la coma o no.</p>
<p>En el siguiente ejemplo, se crea una estructura <code>Pais</code> que tiene los campos <code>poblacion</code>, <code>capital</code>y <code>presidente</code>.</p>
<pre><pre class="playground"><code class="language-rust">struct Pais {
    poblacion: u32,
    capital: String,
    presidente: String
}

fn main() {
    let poblacion = 500_000;
    let capital = String::from(&quot;Elista&quot;);
    let presidente = String::from(&quot;Batu Khasikov&quot;);

    let kalmykia = Pais {
        poblacion: poblacion,
        capital: capital,
        presidente: presidente,
    };
}
</code></pre></pre>
<p>Se observa que resuta prolijo tener que escribir el nombre del campo y su valor. Se escribe doble. <code>poblacion: poblacion</code>, <code>capital: capital</code> y <code>presidente: presidente</code>. Como se trata de alto habitual, Rust proporciona un atajo si tanto el campo, como la variable que contiene el valor se llaman igual. En ese caso, se puede simplificar as√≠:</p>
<pre><pre class="playground"><code class="language-rust">struct Pais {
    poblacion: u32,
    capital: String,
    presidente: String
}

fn main() {
    let poblacion = 500_000;
    let capital = String::from(&quot;Elista&quot;);
    let presidente = String::from(&quot;Batu Khasikov&quot;);

    let kalmykia = Pais {
        poblacion,
        capital,
        presidente,
    };
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enumerados---enum"><a class="header" href="#enumerados---enum">Enumerados - enum</a></h1>
<p><strong>Este cap√≠tulo se puede ver en YouTube en ingl√©s: <a href="https://youtu.be/SRnqNTJUgjs">Parte 1</a>, <a href="https://youtu.be/F_EcbWM63lk">Parte 2</a>, <a href="https://youtu.be/2uh64U9JesA">Parte 3</a> y <a href="https://youtu.be/LOHVUYTc5Us">Parte 4</a></strong></p>
<p>La palabra reservada de Rust <code>enum</code> se usa para los tipos enumerados. Esta es la diferencia con <code>struct</code>:</p>
<ul>
<li>Se utiliza <code>struct</code> cuando un tipo de datos debe representar una cosa <strong>Y</strong> otra cosa a la vez.</li>
<li>Se utiliza <code>enum</code> cuando un tipo de datos puede representar una cosa <strong>O</strong> alguna cosa diferente.</li>
</ul>
<p>Las estructuras sirven para unir diferentes elementos en uno solo, mientras que los enumerados permiten que un tipo de datos represente a diferentes cosas en diferente momento.</p>
<p>Para declarar un enumerado se debe escribir <code>enum</code> seguido de un bloque <code>{}</code> con las diferentes opciones separadas por coma. Como en el caso de los <code>struct</code> la √∫ltima opci√≥n puede llevar la coma o no. A continuaci√≥n se crea un enumerado denominado <code>CosasEnElCielo</code>:</p>
<pre><pre class="playground"><code class="language-rust">enum CosasEnElCielo {
    Sol,
    Estrellas,
}

fn main() {}
</code></pre></pre>
<p>Es un enumerado, por lo tanto, cuando se cree un valor es necesario que se elija entre el <code>Sol</code> o las <code>Estrellas</code>. A cada elemento que forma parte del enumerado se le denomina <strong>variante</strong>.</p>
<pre><pre class="playground"><code class="language-rust">// Crea el enumerado con dos variantes
enum CosasEnElCielo {
    Sol,
    Estrellas,
}

// Con esa funci√≥n se usa un i32 para crear CosasEnElCielo.
fn crear_estadoEnElCielo(time: i32) -&gt; CosasEnElCielo {
    match time {
        6..=18 =&gt; CosasEnElCielo::Sol, // Entre las 6 y 18 horas se ve el sol
        _ =&gt; CosasEnElCielo::Estrellas, // En otro caso se ven las estrellas
    }
}

// Con esta funci√≥n se localiza el estado y se muestran las CosasEnElCielo.
fn comprobar_el_cielo(state: &amp;CosasEnElCielo) {
    match state {
        CosasEnElCielo::Sol =&gt; println!(&quot;¬°Puedo ver el sol!&quot;),
        CosasEnElCielo::Estrellas =&gt; println!(&quot;¬°Puedo ver las estrellas!&quot;)
    }
}

fn main() {
    let time = 8; // Son las ocho de la ma√±ana
    let skystate = crear_estadoEnElCielo(time); // crear_estadoEnElCielo returns a CosasEnElCielo
    comprobar_el_cielo(&amp;skystate); // Se pasa una referencia para que pueda leer el estado del cielo
}
</code></pre></pre>
<p>Este c√≥digo imprime <code>¬°Puedo ver el sol!</code>.</p>
<p>A cada enumerado, se le pueden a√±adir datos (como en los struts):</p>
<pre><pre class="playground"><code class="language-rust">enum CosasEnElCielo {
    Sol(String), // Ahora cada variante tiene una cadena de texto
    Estrellas(String),
}

fn crear_estadoEnElCielo(time: i32) -&gt; CosasEnElCielo {
    match time {
        6..=18 =&gt; CosasEnElCielo::Sol(String::from(&quot;¬°Puedo ver el sol!&quot;)), // Da el valor aqu√≠
        _ =&gt; CosasEnElCielo::Estrellas(String::from(&quot;¬°Puedo ver las estrellas!&quot;)),
    }
}

fn comprobar_el_cielo(state: &amp;CosasEnElCielo) {
    match state {
        CosasEnElCielo::Sol(description) =&gt; println!(&quot;{}&quot;, description), // recupera la descripci√≥n para que se pueda imprimir
        CosasEnElCielo::Estrellas(n) =&gt; println!(&quot;{}&quot;, n), // se puede usar cualquier variable n para obtener la descripci√≥n
    }
}

fn main() {
    let time = 8; // Son las ocho de la ma√±ana
    let skystate = crear_estadoEnElCielo(time); // crear_estadoEnElCielo devuelve un elemento de CosasEnElCielo
    comprobar_el_cielo(&amp;skystate); // Se pasa una referencia para que pueda leer el estado del cielo
}
</code></pre></pre>
<p>Este c√≥digo imprime lo mismo que antes <code>¬°Puedo ver el sol!</code>.</p>
<p>Tambi√©n se puede &quot;importar&quot; un enumerado para que no haya que escribir mucho. A continuaci√≥n se muestra un ejemplo en se escribe <code>Estado::</code> cada vez que se comprueba el &quot;estado de √°nimo&quot;:</p>
<pre><pre class="playground"><code class="language-rust">enum Estado {
    Feliz,
    Cansado,
    NoEstoyMal,
    Enfadado,
}

fn comprueba_estado(mood: &amp;Estado) -&gt; i32 {
    let nivel_de_felicidad = match mood {
        Estado::Feliz =&gt; 10, // Se escribe Estado:: cada vez
        Estado::Cansado =&gt; 6,
        Estado::NoEstoyMal =&gt; 7,
        Estado::Enfadado =&gt; 2,
    };
    nivel_de_felicidad
}

fn main() {
    let my_mood = Estado::NoEstoyMal;
    let nivel_de_felicidad = comprueba_estado(&amp;my_mood);
    println!(&quot;De 1 a 10, mi estado de felicidad es {}&quot;, nivel_de_felicidad);
}
</code></pre></pre>
<p>El c√≥digo anterior imprime <code>De 1 a 10, mi estado de felicidad es 7</code>. A continuaci√≥n, el mismo c√≥digo, pero importando el enumerado para tener que escribir menos. Para importar todo se utiliza <code>*</code>. Es el mismo car√°cter que para desrreferenciar, pero con un uso diferente.</p>
<pre><pre class="playground"><code class="language-rust">enum Estado {
    Feliz,
    Cansado,
    NoEstoyMal,
    Enfadado,
}

fn comprueba_estado(mood: &amp;Estado) -&gt; i32 {
    use Estado::*; // Se importa el conjunto de variantes de Estado. Ahora se puede escribir menos
    let nivel_de_felicidad = match mood {
        Feliz =&gt; 10, // Ya no es necesario escribir Estado::
        Cansado =&gt; 6,
        NoEstoyMal =&gt; 7,
        Enfadado =&gt; 2,
    };
    nivel_de_felicidad
}

fn main() {
    let my_mood = Estado::NoEstoyMal;
    let nivel_de_felicidad = comprueba_estado(&amp;my_mood);
    println!(&quot;De 1 a 10, mi estado de felicidad es {}&quot;, nivel_de_felicidad);
}
</code></pre></pre>
<p>Las partes de un enumerado se pueden convertir a n√∫mero entero. Esto se debe a que Rust da a cada variante de un <code>enum</code> un n√∫mero que comienza con el 0 (para uso interno de Rust). Se puede utilizar en el c√≥digo, siempre que las variantes con contengan ning√∫n dato adicional:</p>
<pre><pre class="playground"><code class="language-rust">enum Estacion {
    Primavera, // If this was Primavera(String) or something it wouldn't work
    Verano,
    Oto√±o,
    Invierno,
}

fn main() {
    use Estacion::*;
    let cuatro_estaciones = vec![Primavera, Verano, Oto√±o, Invierno];
    for estacion in cuatro_estaciones {
        println!(&quot;{}&quot;, estacion as u32);
    }
}
</code></pre></pre>
<p>El c√≥digo anterior imprime:</p>
<pre><code class="language-text">0
1
2
3
</code></pre>
<p>Es posible asignar un n√∫mero entero expresamente a cada variante. A Rust no le importa el n√∫mero concreto que tenga cada una de ellas. Para ello, se a√±ade un s√≠mbolo <code>=</code> y el n√∫mero deseado a cada variante. No es necesario indicar el n√∫mero a cada variante. Si no se a√±ade, Rust utiliza el siguiente disponible (suma 1) a partir de la variante anterior que tuviera n√∫mero:</p>
<pre><pre class="playground"><code class="language-rust">enum Estrella {
    EnanaMarron = 10,
    EnanaRoja = 50,
    EstrellaAmarilla = 100,
    GiganteRoja = 1000,
    EstrellaMuerta, // ¬øQu√© n√∫mero tendr√°?
}

fn main() {
    use Estrella::*;
    let starvec = vec![EnanaMarron, EnanaRoja, EstrellaAmarilla, GiganteRoja];
    for star in starvec {
        match star as u32 {
            size if size &lt;= 80 =&gt; println!(&quot;No es la estrella m√°s grande&quot;),
            size if size &gt;= 80 =&gt; println!(&quot;Esta estrella tiene un buen tama√±o&quot;),
            _ =&gt; println!(&quot;Esta estrella es muy grande&quot;),
        }
    }
    println!(&quot;¬øQu√© n√∫mero tiene EstrellaMuerta? Es el n√∫mero {}.&quot;, EstrellaMuerta as u32);
}
</code></pre></pre>
<p>This prints:</p>
<pre><code class="language-text">No es la estrella m√°s grande
No es la estrella m√°s grande
Esta estrella tiene un buen tama√±o
Esta estrella tiene un buen tama√±o
¬øQu√© n√∫mero tiene EstrellaMuerta? Es el n√∫mero 1001.
</code></pre>
<p><code>EstrellaMuerta</code> hubiera sido el n√∫mero 4 si no se hubiera expresado ning√∫n n√∫mero, pero ahora es el 1001.</p>
<h2 id="los-enumerados-sirven-para-usar-tipos-diferentes"><a class="header" href="#los-enumerados-sirven-para-usar-tipos-diferentes">Los enumerados sirven para usar tipos diferentes</a></h2>
<p>Como ya se sabe, los elementos de un <code>Vec</code>, array, etc. tienen que ser del mismo tipo siempre (solo las tuplas permiten tipos diferentes). Los enumerados permiten incorporar diferentes tipos en las colecciones anteriores. Si se deseara tener un <code>Vec</code> que almacenara de forma indistinta <code>u32</code> o <code>i32</code> se puede declarar el <code>Vec</code> como que contiene un enumerado como en el siguiente ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">enum Numero {
    U32(u32),
    I32(i32),
}

fn main() {}
</code></pre></pre>
<p>As√≠, este enumerado tiene dos variantes: la variante <code>U32</code>con un <code>u32</code>y la variante <code>I32</code> con un <code>i32</code>. <code>U32</code> y <code>I32</code> son solo los nombres de cada variante. Se podr√≠an haber llamado <code>UTreintaYDos</code> o <code>ITreintaYDos</code> o cualquier otra cosa.</p>
<p>Ahora es posible declarar un <code>Vec</code> de la siguiente forma <code>Vec&lt;Numero&gt;</code> y el compilador no se queja porque el vector es de un solo tipo. Al compilador no le preocupa si en un momento dado hay <code>u32</code> o <code>i32</code> porque esa diferencia est√° oculta por el tipo <code>Numero</code>. Y como es un enumerado, es necesario seleccionar una variante cada vez. En el siguiente c√≥digo se usa el m√©todo <code>.is_positive()</code> para seleccionar la variante. Si es <code>true</code> se selecciona <code>U32</code> y si es <code>false</code> se selecciona <code>I32</code>.</p>
<p>Ahora el c√≥digo queda as√≠:</p>
<pre><pre class="playground"><code class="language-rust">enum Numero {
    U32(u32),
    I32(i32),
}

fn get_numero(input: i32) -&gt; Numero {
    let numero = match input.is_positive() {
        true =&gt; Numero::U32(input as u32), // lo cambia a u32 si es positivo
        false =&gt; Numero::I32(input), 
    };
    numero
}


fn main() {
    let my_vec = vec![get_numero(-800), get_numero(8)];

    for item in my_vec {
        match item {
            Numero::U32(numero) =&gt; println!(&quot;Es un u32 con el valor {}&quot;, numero),
            Numero::I32(numero) =&gt; println!(&quot;Es un i32 con el valor {}&quot;, numero),
        }
    }
}
</code></pre></pre>
<p>Este c√≥digo imprime:</p>
<pre><code class="language-text">Es un i32 con el valor -800
Es un u32 con el valor 8
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
