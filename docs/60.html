<!DOCTYPE HTML>
<html lang="es" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Entrada de datos de usuario - Rust en espa침ol f치cil</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="actualizaciones.html">Actualizaciones</a></li><li class="chapter-item expanded affix "><a href="introduccion.html">Introducci칩n</a></li><li class="chapter-item expanded affix "><a href="quiensoy.html">쯈ui칠n soy?</a></li><li class="chapter-item expanded affix "><a href="escritura.html">La escritura de Rust en ingl칠s f치cil</a></li><li class="chapter-item expanded affix "><li class="part-title">Parte 1 - Rust en tu navegador</li><li class="chapter-item expanded "><a href="01.html"><strong aria-hidden="true">1.</strong> El entorno de pruebas de Rust</a></li><li class="chapter-item expanded "><a href="02.html"><strong aria-hidden="true">2.</strong> 游뚾 y 丘멆잺</a></li><li class="chapter-item expanded "><a href="03.html"><strong aria-hidden="true">3.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="04.html"><strong aria-hidden="true">4.</strong> Tipos de dato</a></li><li class="chapter-item expanded "><a href="05.html"><strong aria-hidden="true">5.</strong> Inferencia de tipos de dato</a></li><li class="chapter-item expanded "><a href="06.html"><strong aria-hidden="true">6.</strong> Imprimiendo '춰Hola, mundo!'</a></li><li class="chapter-item expanded "><a href="07.html"><strong aria-hidden="true">7.</strong> La visualizaci칩n y depuraci칩n</a></li><li class="chapter-item expanded "><a href="08.html"><strong aria-hidden="true">8.</strong> Mutabilidad (cambio)</a></li><li class="chapter-item expanded "><a href="09.html"><strong aria-hidden="true">9.</strong> La pila, la memoria din치mica y los punteros</a></li><li class="chapter-item expanded "><a href="10.html"><strong aria-hidden="true">10.</strong> M치s sobre impresi칩n</a></li><li class="chapter-item expanded "><a href="11.html"><strong aria-hidden="true">11.</strong> Cadenas de caracteres</a></li><li class="chapter-item expanded "><a href="12.html"><strong aria-hidden="true">12.</strong> const y static</a></li><li class="chapter-item expanded "><a href="13.html"><strong aria-hidden="true">13.</strong> Algo m치s sobre referencias</a></li><li class="chapter-item expanded "><a href="14.html"><strong aria-hidden="true">14.</strong> Referencias modificables (mutables)</a></li><li class="chapter-item expanded "><a href="15.html"><strong aria-hidden="true">15.</strong> Paso de referencias a funciones</a></li><li class="chapter-item expanded "><a href="16.html"><strong aria-hidden="true">16.</strong> Copia</a></li><li class="chapter-item expanded "><a href="17.html"><strong aria-hidden="true">17.</strong> Tipos colecci칩n</a></li><li class="chapter-item expanded "><a href="18.html"><strong aria-hidden="true">18.</strong> Vectores</a></li><li class="chapter-item expanded "><a href="19.html"><strong aria-hidden="true">19.</strong> Tuplas</a></li><li class="chapter-item expanded "><a href="20.html"><strong aria-hidden="true">20.</strong> Estructuras de control</a></li><li class="chapter-item expanded "><a href="21.html"><strong aria-hidden="true">21.</strong> Estructuras - struct</a></li><li class="chapter-item expanded "><a href="22.html"><strong aria-hidden="true">22.</strong> Enumerados - enum</a></li><li class="chapter-item expanded "><a href="23.html"><strong aria-hidden="true">23.</strong> Bucles</a></li><li class="chapter-item expanded "><a href="24.html"><strong aria-hidden="true">24.</strong> Implementando structs y enums</a></li><li class="chapter-item expanded "><a href="25.html"><strong aria-hidden="true">25.</strong> Desestructurar</a></li><li class="chapter-item expanded "><a href="26.html"><strong aria-hidden="true">26.</strong> Referencias y el operador punto .</a></li><li class="chapter-item expanded "><a href="27.html"><strong aria-hidden="true">27.</strong> Gen칠ricos</a></li><li class="chapter-item expanded "><a href="28.html"><strong aria-hidden="true">28.</strong> Los enumerados Option y Result</a></li><li class="chapter-item expanded "><a href="29.html"><strong aria-hidden="true">29.</strong> Otras colecciones</a></li><li class="chapter-item expanded "><a href="30.html"><strong aria-hidden="true">30.</strong> El operador ?</a></li><li class="chapter-item expanded "><a href="31.html"><strong aria-hidden="true">31.</strong> Traits (Rasgos)</a></li><li class="chapter-item expanded "><a href="32.html"><strong aria-hidden="true">32.</strong> Encadenando m칠todos</a></li><li class="chapter-item expanded "><a href="33.html"><strong aria-hidden="true">33.</strong> Iteradores</a></li><li class="chapter-item expanded "><a href="34.html"><strong aria-hidden="true">34.</strong> Closures - Cierres</a></li><li class="chapter-item expanded "><a href="35.html"><strong aria-hidden="true">35.</strong> La macro dbg! e .inspect()</a></li><li class="chapter-item expanded "><a href="36.html"><strong aria-hidden="true">36.</strong> Tipos de &str</a></li><li class="chapter-item expanded "><a href="37.html"><strong aria-hidden="true">37.</strong> Tiempos de vida (lifetimes)</a></li><li class="chapter-item expanded "><a href="38.html"><strong aria-hidden="true">38.</strong> Mutabilidad interior</a></li><li class="chapter-item expanded "><a href="39.html"><strong aria-hidden="true">39.</strong> Cow</a></li><li class="chapter-item expanded "><a href="40.html"><strong aria-hidden="true">40.</strong> Alias de tipos</a></li><li class="chapter-item expanded "><a href="41.html"><strong aria-hidden="true">41.</strong> La macro todo!</a></li><li class="chapter-item expanded "><a href="42.html"><strong aria-hidden="true">42.</strong> Rc</a></li><li class="chapter-item expanded "><a href="43.html"><strong aria-hidden="true">43.</strong> M칰ltiples hilos</a></li><li class="chapter-item expanded "><a href="44.html"><strong aria-hidden="true">44.</strong> Cierres en funciones</a></li><li class="chapter-item expanded "><a href="45.html"><strong aria-hidden="true">45.</strong> impl Trait</a></li><li class="chapter-item expanded "><a href="46.html"><strong aria-hidden="true">46.</strong> Arc</a></li><li class="chapter-item expanded "><a href="47.html"><strong aria-hidden="true">47.</strong> Canales</a></li><li class="chapter-item expanded "><a href="48.html"><strong aria-hidden="true">48.</strong> Entender la documentaci칩n de Rust</a></li><li class="chapter-item expanded "><a href="49.html"><strong aria-hidden="true">49.</strong> Atributos</a></li><li class="chapter-item expanded "><a href="50.html"><strong aria-hidden="true">50.</strong> Box</a></li><li class="chapter-item expanded "><a href="51.html"><strong aria-hidden="true">51.</strong> Box y los rasgos</a></li><li class="chapter-item expanded "><a href="52.html"><strong aria-hidden="true">52.</strong> Default y el patr칩n constructor (builder)</a></li><li class="chapter-item expanded "><a href="53.html"><strong aria-hidden="true">53.</strong> Deref y DerefMut</a></li><li class="chapter-item expanded "><a href="54.html"><strong aria-hidden="true">54.</strong> Crates (cajones) y m칩dulos</a></li><li class="chapter-item expanded "><a href="55.html"><strong aria-hidden="true">55.</strong> Pruebas (testing)</a></li><li class="chapter-item expanded "><a href="56.html"><strong aria-hidden="true">56.</strong> Crates externas</a></li><li class="chapter-item expanded "><a href="57.html"><strong aria-hidden="true">57.</strong> Un paseo por la librer칤a est치ndar</a></li><li class="chapter-item expanded "><a href="58.html"><strong aria-hidden="true">58.</strong> La escritura de macros</a></li><li class="chapter-item expanded affix "><li class="part-title">Parte 2 - Rust en tu ordenador</li><li class="chapter-item expanded "><a href="59.html"><strong aria-hidden="true">59.</strong> cargo</a></li><li class="chapter-item expanded "><a href="60.html" class="active"><strong aria-hidden="true">60.</strong> Entrada de datos de usuario</a></li><li class="chapter-item expanded "><a href="61.html"><strong aria-hidden="true">61.</strong> Utilizando ficheros</a></li><li class="chapter-item expanded "><a href="62.html"><strong aria-hidden="true">62.</strong> cargo doc</a></li><li class="chapter-item expanded "><a href="63.html"><strong aria-hidden="true">63.</strong> 쮼l final?</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust en espa침ol f치cil</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="entrada-de-datos-de-usuario"><a class="header" href="#entrada-de-datos-de-usuario">Entrada de datos de usuario</a></h1>
<p>Una forma f치cil de permitir que el usuario &quot;teclee&quot; informaci칩n para el programa es usar la librer칤a <code>std::io::stdin</code>. Esta es la librer칤a &quot;est치ndar de entrada&quot;, que recibe las entradas del teclado. Con <code>stdin()</code> se puede obtener la entrada del usuario. Esto se guardar치 en una <code>&amp;mut String</code> con <code>.read_line()</code>. A continuaci칩n se muestra un ejemplo simple que no funciona del todo:</p>
<pre><pre class="playground"><code class="language-rust">use std::io;

fn main() {
    println!(&quot;Por favor, teclea algo o x para terminar:&quot;);
    let mut input_string = String::new();

    while input_string != &quot;x&quot; { // Esto es lo que no funciona bien
        input_string.clear(); // Primero vac칤a la cadena de caracteres. En otro caso, se estar칤a a침adiendo sin parar informaci칩n
        io::stdin().read_line(&amp;mut input_string).unwrap(); // Obtiene la entrada del usuario y la pone en  read_string
        println!(&quot;Escribiste: {}&quot;, input_string);
    }
    println!(&quot;춰Adios!&quot;);
}
</code></pre></pre>
<p>Esta es es la salida de este programa:</p>
<pre><code class="language-text">Por favor, teclea algo o x para terminar:
algo
Escribiste: algo

Algo m치s
Escribiste: Algo m치s

x
Escribiste: x

x
Escribiste: x

x
Escribiste: x
</code></pre>
<p>Toma el valor de entrada y lo escribe en pantalla, pero contin칰a a pesar de haber escrito <code>x</code>. La 칰nica forma de salir es cerrar la ventana o pulsar <code>ctrl</code> y <code>c</code> simult치neamente. Si se modifica el <code>{}</code> del <code>println!</code> por <code>{:?}</code> para obtener m치s informaci칩n (o se usa <code>dbg!(&amp;input_string)</code>) el programa imprime lo siguiente:</p>
<pre><code class="language-text">Por favor, teclea algo o x para terminar:
algo
Escribiste: &quot;algo\r\n&quot;
algo m치s
Escribiste: &quot;algo m치s\r\n&quot;
x
Escribiste: &quot;x\r\n&quot;
x
Escribiste: &quot;x\r\n&quot;
</code></pre>
<p>Esto se debe a que la entrada que se recibe del teclado no es la palabra &quot;algo&quot;, sino que es &quot;algo&quot; y el resultado de la tecla <code>Intro</code> (Enter en ingl칠s). La forma m치s f치cil para resolver esto es usar el m칠todo <code>.trim()</code> que elimina todos los espacios en blanco que rodean al texto por ambos lados. En esta caso por espacio en blanco <code>.trim()</code> entiende estos <a href="https://doc.rust-lang.org/reference/whitespace.html">caracteres</a>:</p>
<pre><code class="language-text">U+0009 (tabulador horizontal, '\t')
U+000A (salto de l칤nea, '\n')
U+000B (tabulador vertical)
U+000C (salto de p치gina)
U+000D (retorno de carro, '\r')
U+0020 (espacio, ' ')
U+0085 (siguiente l칤nea)
U+200E (marca de izquierda a derecha)
U+200F (marca de derecha a izquierda)
U+2028 (separador de l칤nea)
U+2029 (separador de p치rrafo)
</code></pre>
<p>De esta forma, la cadena <code>x\r\n</code> se convierte en <code>x</code>. Con este cambio, la aplicaci칩n funciona:</p>
<pre><pre class="playground"><code class="language-rust">use std::io;

fn main() {
    println!(&quot;Por favor, teclea algo o x para terminar:&quot;);
    let mut input_string = String::new();

    while input_string.trim() != &quot;x&quot; {
        input_string.clear();
        io::stdin().read_line(&amp;mut input_string).unwrap();
        println!(&quot;Escribiste: {}&quot;, input_string);
    }
    println!(&quot;춰Adi칩s!&quot;);
}
</code></pre></pre>
<p>Ahora imprimir치:</p>
<pre><code class="language-text">Por favor, teclea algo o x para terminar:
algo
Escribiste: algo

algo
Escribiste: algo

x
Escribiste: x

춰Adi칩s!
</code></pre>
<p>Hay otra clase de entrada de usuario denominada <code>std::env::Args</code> (env significa entorno). <code>Args</code> es lo que teclea el usuario cuando inicia el programa (en la misma l칤nea de arranque). Siempre existe un <code>Arg</code> en todos los programas.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;{:?}&quot;, std::env::args());
}
</code></pre></pre>
<p>Si se teclea <code>cargo run</code> el c칩digo anterior imprime:</p>
<pre><code class="language-text">Args { inner: [&quot;target\\debug\\rust_book.exe&quot;] }
</code></pre>
<p>A continuaci칩n, se ejecuta el mismo programa, pero pas치ndole m치s argumentos, por ejemplo: <code>cargo run but with some extra words</code>. En este caso, imprime:</p>
<pre><code class="language-text">Args { inner: [&quot;target\\debug\\rust_book.exe&quot;, &quot;but&quot;, &quot;with&quot;, &quot;some&quot;, &quot;extra&quot;, &quot;words&quot;] }
</code></pre>
<p>Es interesante el resultado. Cuando se observa <a href="https://doc.rust-lang.org/std/env/struct.Args.html">la p치gina de Args</a> se ve que implementa <code>IntoIterator</code>. Esto significa que se puede leer con un iterador:</p>
<pre><pre class="playground"><code class="language-rust">use std::env::args;

fn main() {
    let input = args();

    for entry in input {
        println!(&quot;You entered: {}&quot;, entry);
    }
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">You entered: target\debug\rust_book.exe
You entered: but
You entered: with
You entered: some
You entered: extra
You entered: words
</code></pre>
<p>El primer argumento siempre es el nombre del programa, por lo que lo habitual es salt치rselo:</p>
<pre><pre class="playground"><code class="language-rust">use std::env::args;

fn main() {
    let input = args();

    input.skip(1).for_each(|item| {
        println!(&quot;You wrote {}, which in capital letters is {}&quot;, item, item.to_uppercase());
    })
}
</code></pre></pre>
<p>Que imprimir치:</p>
<pre><code class="language-text">You wrote but, which in capital letters is BUT
You wrote with, which in capital letters is WITH
You wrote some, which in capital letters is SOME
You wrote extra, which in capital letters is EXTRA
You wrote words, which in capital letters is WORDS
</code></pre>
<p>Un uso habitual de <code>Args</code> es para las configuraciones de usuario. A continuaci칩n, se muestra un programa que pone las palabas que se teclean en may칰sculas (capital) o min칰sculas (lowercase), seg칰n sea la configuraci칩n inicial:</p>
<pre><pre class="playground"><code class="language-rust">use std::env::args;

enum Letters {
    Capitalize,
    Lowercase,
    Nothing,
}

fn main() {
    let mut changes = Letters::Nothing;
    let input = args().collect::&lt;Vec&lt;_&gt;&gt;();

    if input.len() &gt; 2 {
        match input[1].as_str() {
            &quot;capital&quot; =&gt; changes = Letters::Capitalize,
            &quot;lowercase&quot; =&gt; changes = Letters::Lowercase,
            _ =&gt; {}
        }
    }

    for word in input.iter().skip(2) {
      match changes {
        Letters::Capitalize =&gt; println!(&quot;{}&quot;, word.to_uppercase()),
        Letters::Lowercase =&gt; println!(&quot;{}&quot;, word.to_lowercase()),
        _ =&gt; println!(&quot;{}&quot;, word)
      }
    }
    
}
</code></pre></pre>
<p>Algunos ejemplos de su ejecuci칩n:</p>
<p>Entrada <code>cargo run please make capitals</code>:</p>
<pre><code class="language-text">make capitals
</code></pre>
<p>Entrada <code>cargo run capital</code>:</p>
<pre><code class="language-text">// No imprime nada...
</code></pre>
<p>Entrada <code>cargo run capital I think I understand now</code>:</p>
<pre><code class="language-text">I
THINK
I
UNDERSTAND
NOW
</code></pre>
<p>ENtrada <code>cargo run lowercase Does this work too?</code>:</p>
<pre><code class="language-text">does
this
work
too?
</code></pre>
<p>Adem치s de los argumentos tecleados por el usuario al arrancar el programa, <code>std::env</code> tiene tambi칠n <code>Vars</code> que son las variables del sistema. Estas son diversas configuraciones que el usuario no tiene que teclera. Para acceder a ellas se usa <code>std::env::vars()</code> que devuelve una lista de tuplas <code>(String, String)</code>. Suelen existir muchas. POr ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for item in std::env::vars() {
        println!(&quot;{:?}&quot;, item);
    }
}
</code></pre></pre>
<p>El programa anterior muestra la informaci칩n completa de las variables de sesi칩n del usaurio:</p>
<pre><code class="language-text">(&quot;CARGO&quot;, &quot;/playground/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/cargo&quot;)
(&quot;CARGO_HOME&quot;, &quot;/playground/.cargo&quot;)
(&quot;CARGO_MANIFEST_DIR&quot;, &quot;/playground&quot;)
(&quot;CARGO_PKG_AUTHORS&quot;, &quot;The Rust Playground&quot;)
(&quot;CARGO_PKG_DESCRIPTION&quot;, &quot;&quot;)
(&quot;CARGO_PKG_HOMEPAGE&quot;, &quot;&quot;)
(&quot;CARGO_PKG_NAME&quot;, &quot;playground&quot;)
(&quot;CARGO_PKG_REPOSITORY&quot;, &quot;&quot;)
(&quot;CARGO_PKG_VERSION&quot;, &quot;0.0.1&quot;)
(&quot;CARGO_PKG_VERSION_MAJOR&quot;, &quot;0&quot;)
(&quot;CARGO_PKG_VERSION_MINOR&quot;, &quot;0&quot;)
(&quot;CARGO_PKG_VERSION_PATCH&quot;, &quot;1&quot;)
(&quot;CARGO_PKG_VERSION_PRE&quot;, &quot;&quot;)
(&quot;DEBIAN_FRONTEND&quot;, &quot;noninteractive&quot;)
(&quot;HOME&quot;, &quot;/playground&quot;)
(&quot;HOSTNAME&quot;, &quot;f94c15b8134b&quot;)
(&quot;LD_LIBRARY_PATH&quot;, &quot;/playground/target/debug/build/backtrace-sys-3ec4c973f371c302/out:/playground/target/debug/build/libsqlite3-sys-fbddfbb9b241dacb/out:/playground/target/debug/build/ring-cadba5e583648abb/out:/playground/target/debug/deps:/playground/target/debug:/playground/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/x86_64-unknown-linux-gnu/lib:/playground/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib&quot;)
(&quot;PATH&quot;, &quot;/playground/.cargo/bin:/playground/.cargo/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;)
(&quot;PLAYGROUND_EDITION&quot;, &quot;2018&quot;)
(&quot;PLAYGROUND_TIMEOUT&quot;, &quot;10&quot;)
(&quot;PWD&quot;, &quot;/playground&quot;)
(&quot;RUSTUP_HOME&quot;, &quot;/playground/.rustup&quot;)
(&quot;RUSTUP_TOOLCHAIN&quot;, &quot;stable-x86_64-unknown-linux-gnu&quot;)
(&quot;RUST_RECURSION_COUNT&quot;, &quot;1&quot;)
(&quot;SHLVL&quot;, &quot;1&quot;)
(&quot;SSL_CERT_DIR&quot;, &quot;/usr/lib/ssl/certs&quot;)
(&quot;SSL_CERT_FILE&quot;, &quot;/usr/lib/ssl/certs/ca-certificates.crt&quot;)
(&quot;USER&quot;, &quot;playground&quot;)
(&quot;_&quot;, &quot;/usr/bin/timeout&quot;)
</code></pre>
<p>La forma m치s sencilla de acceder a una de ellas de forma independiente es usar la macro <code>env!</code>. Se le da el nombre de una variable y devolver치 un <code>&amp;str</code> con el valor. No funcionar치 si la variable no existe, por lo que es mejor usar <code>option_env!</code>. Si se escribe el siguiente c칩digo en Playground:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;{}&quot;, env!(&quot;USER&quot;));
    println!(&quot;{}&quot;, option_env!(&quot;ROOT&quot;).unwrap_or(&quot;Can't find ROOT&quot;));
    println!(&quot;{}&quot;, option_env!(&quot;CARGO&quot;).unwrap_or(&quot;Can't find CARGO&quot;));
}
</code></pre></pre>
<p>Se obtiene:</p>
<pre><code class="language-text">playground
Can't find ROOT
/playground/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/cargo
</code></pre>
<p>Se ve que es mejor usar <code>option_env!</code>, salvo que realmente se quiera que el programa falle si no existe determinada variable de entorno de sistema/usuario, entonces ser칤a mejor <code>env!</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="59.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="61.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="59.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="61.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
