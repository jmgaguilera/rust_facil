<!DOCTYPE HTML>
<html lang="es" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tiempos de vida (lifetimes) - Rust en espa침ol f치cil</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="actualizaciones.html">Actualizaciones</a></li><li class="chapter-item expanded affix "><a href="introduccion.html">Introducci칩n</a></li><li class="chapter-item expanded affix "><a href="quiensoy.html">쯈ui칠n soy?</a></li><li class="chapter-item expanded affix "><a href="escritura.html">La escritura de Rust en ingl칠s f치cil</a></li><li class="chapter-item expanded affix "><li class="part-title">Parte 1 - Rust en tu navegador</li><li class="chapter-item expanded "><a href="01.html"><strong aria-hidden="true">1.</strong> El entorno de pruebas de Rust</a></li><li class="chapter-item expanded "><a href="02.html"><strong aria-hidden="true">2.</strong> 游뚾 y 丘멆잺</a></li><li class="chapter-item expanded "><a href="03.html"><strong aria-hidden="true">3.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="04.html"><strong aria-hidden="true">4.</strong> Tipos de dato</a></li><li class="chapter-item expanded "><a href="05.html"><strong aria-hidden="true">5.</strong> Inferencia de tipos de dato</a></li><li class="chapter-item expanded "><a href="06.html"><strong aria-hidden="true">6.</strong> Imprimiendo '춰Hola, mundo!'</a></li><li class="chapter-item expanded "><a href="07.html"><strong aria-hidden="true">7.</strong> La visualizaci칩n y depuraci칩n</a></li><li class="chapter-item expanded "><a href="08.html"><strong aria-hidden="true">8.</strong> Mutabilidad (cambio)</a></li><li class="chapter-item expanded "><a href="09.html"><strong aria-hidden="true">9.</strong> La pila, la memoria din치mica y los punteros</a></li><li class="chapter-item expanded "><a href="10.html"><strong aria-hidden="true">10.</strong> M치s sobre impresi칩n</a></li><li class="chapter-item expanded "><a href="11.html"><strong aria-hidden="true">11.</strong> Cadenas de caracteres</a></li><li class="chapter-item expanded "><a href="12.html"><strong aria-hidden="true">12.</strong> const y static</a></li><li class="chapter-item expanded "><a href="13.html"><strong aria-hidden="true">13.</strong> Algo m치s sobre referencias</a></li><li class="chapter-item expanded "><a href="14.html"><strong aria-hidden="true">14.</strong> Referencias modificables (mutables)</a></li><li class="chapter-item expanded "><a href="15.html"><strong aria-hidden="true">15.</strong> Paso de referencias a funciones</a></li><li class="chapter-item expanded "><a href="16.html"><strong aria-hidden="true">16.</strong> Copia</a></li><li class="chapter-item expanded "><a href="17.html"><strong aria-hidden="true">17.</strong> Tipos colecci칩n</a></li><li class="chapter-item expanded "><a href="18.html"><strong aria-hidden="true">18.</strong> Vectores</a></li><li class="chapter-item expanded "><a href="19.html"><strong aria-hidden="true">19.</strong> Tuplas</a></li><li class="chapter-item expanded "><a href="20.html"><strong aria-hidden="true">20.</strong> Estructuras de control</a></li><li class="chapter-item expanded "><a href="21.html"><strong aria-hidden="true">21.</strong> Estructuras - struct</a></li><li class="chapter-item expanded "><a href="22.html"><strong aria-hidden="true">22.</strong> Enumerados - enum</a></li><li class="chapter-item expanded "><a href="23.html"><strong aria-hidden="true">23.</strong> Bucles</a></li><li class="chapter-item expanded "><a href="24.html"><strong aria-hidden="true">24.</strong> Implementando structs y enums</a></li><li class="chapter-item expanded "><a href="25.html"><strong aria-hidden="true">25.</strong> Desestructurar</a></li><li class="chapter-item expanded "><a href="26.html"><strong aria-hidden="true">26.</strong> Referencias y el operador punto .</a></li><li class="chapter-item expanded "><a href="27.html"><strong aria-hidden="true">27.</strong> Gen칠ricos</a></li><li class="chapter-item expanded "><a href="28.html"><strong aria-hidden="true">28.</strong> Los enumerados Option y Result</a></li><li class="chapter-item expanded "><a href="29.html"><strong aria-hidden="true">29.</strong> Otras colecciones</a></li><li class="chapter-item expanded "><a href="30.html"><strong aria-hidden="true">30.</strong> El operador ?</a></li><li class="chapter-item expanded "><a href="31.html"><strong aria-hidden="true">31.</strong> Traits (Rasgos)</a></li><li class="chapter-item expanded "><a href="32.html"><strong aria-hidden="true">32.</strong> Encadenando m칠todos</a></li><li class="chapter-item expanded "><a href="33.html"><strong aria-hidden="true">33.</strong> Iteradores</a></li><li class="chapter-item expanded "><a href="34.html"><strong aria-hidden="true">34.</strong> Closures - Cierres</a></li><li class="chapter-item expanded "><a href="35.html"><strong aria-hidden="true">35.</strong> La macro dbg! e .inspect()</a></li><li class="chapter-item expanded "><a href="36.html"><strong aria-hidden="true">36.</strong> Tipos de &str</a></li><li class="chapter-item expanded "><a href="37.html" class="active"><strong aria-hidden="true">37.</strong> Tiempos de vida (lifetimes)</a></li><li class="chapter-item expanded "><a href="38.html"><strong aria-hidden="true">38.</strong> Mutabilidad interior</a></li><li class="chapter-item expanded "><a href="39.html"><strong aria-hidden="true">39.</strong> Cow</a></li><li class="chapter-item expanded "><a href="40.html"><strong aria-hidden="true">40.</strong> Alias de tipos</a></li><li class="chapter-item expanded "><a href="41.html"><strong aria-hidden="true">41.</strong> La macro todo!</a></li><li class="chapter-item expanded "><a href="42.html"><strong aria-hidden="true">42.</strong> Rc</a></li><li class="chapter-item expanded "><a href="43.html"><strong aria-hidden="true">43.</strong> M칰ltiples hilos</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust en espa침ol f치cil</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tiempos-de-vida-lifetimes"><a class="header" href="#tiempos-de-vida-lifetimes">Tiempos de vida (lifetimes)</a></h1>
<p>El tiempo de vida asociado a todos los valores y variables indica &quot;cu치nto vive una variable&quot;. Solo es necesario pensar en ellos cuando se trabaja con referencias. Esto se debe a que las referencias no pueden vivir m치s tiempo que el propio objeto al que referencian. Por ejemplo, esta funci칩n no compila:</p>
<pre><pre class="playground"><code class="language-rust">fn returns_reference() -&gt; &amp;str {
    let my_string = String::from(&quot;I am a string&quot;);
    &amp;my_string // 丘멆잺
}

fn main() {}
</code></pre></pre>
<p>El problema es que <code>my_string</code> solo vive dentro de la propia funci칩n, pero la funci칩n intenta devolver una referencia <code>&amp;my_string</code> y esta no podr치 existir cuando se libere <code>my_string</code> al terminar de ejecutarse la funci칩n. Por eso el compilador falla.</p>
<p>Este otro c칩digo tampoco funciona:</p>
<pre><pre class="playground"><code class="language-rust">fn returns_str() -&gt; &amp;str {
    let my_string = String::from(&quot;I am a string&quot;);
    &quot;I am a str&quot; // 丘멆잺
}

fn main() {
    let my_str = returns_str();
    println!(&quot;{}&quot;, my_str);
}
</code></pre></pre>
<p>Aunque por poco. El compilador indica:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; src\main.rs:6:21
  |
6 | fn returns_str() -&gt; &amp;str {
  |                     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
  |
6 | fn returns_str() -&gt; &amp;'static str {
  |                     ^^^^^^^^
</code></pre>
<p>El mensaje <code>missing lifetieme specifier</code> significa que tenemos que a침adir <code>'</code> con un tiempo de vida.</p>
<p>Despu칠s indica <code>contains a borrowed value, but there is no value for it to be borrowed from</code>. Esto signfiica que <code>I am a str</code> no se obtiene de ning칰n sitio. Adem치s, indica <code>consider using the 'static lifetime</code> escribiendo <code>&amp;'static str</code>. Por lo que el compilador piensa que se debe indicar que la variable es de tipo cadena de caracteres literal (como es el caso).</p>
<p>Con la modificaci칩n, lo siguiente funciona:</p>
<pre><pre class="playground"><code class="language-rust">fn returns_str() -&gt; &amp;'static str {
    let my_string = String::from(&quot;I am a string&quot;);
    &quot;I am a str&quot;
}

fn main() {
    let my_str = returns_str();
    println!(&quot;{}&quot;, my_str);
}
</code></pre></pre>
<p>Que funcione, se debe a que se ha indicado al compilador que esta funci칩n devuelve un <code>&amp;str</code> con un tiempo de vida est치tico. Si se quisiera evolver <code>my_string</code> solo podr칤a hacerse como <code>String</code>, no como referencia. El fallo del paso por referencia del primer ejemplo de este apartado, se debe a que la propiedad no se traspasar칤a al c칩digo que llamara a la funci칩n y en la siguiente l칤nea se eliminar칤a el valor de <code>my_string</code>. Rust evita que exista una referencia cuyo tiempo de vida sea mayor que el del valor al que referencia.</p>
<p>Ahora <code>fn returns_str() -&gt; &amp;'static str</code> le dice a Rust que no debe preocuparse, se retorna una cadena de caracteres literal. La cadena de caracteres literal dura toda la ejecuci칩n del programa. Se observa que se asemeja a los gen칠ricos. Cuando se indica al compilador algo como <code>&lt;T: Display&gt;</code>, se le est치 diciendo que solo se va a usar este c칩digo con tipos <code>Display</code>. Los  tiempos de vida son similares: no se est치 cambiando nada en las propias variables, solo se est치 indicando al compilador cuales ser치n los tiempos de vida de cada variable de entrada y de salida.</p>
<p>L칩gicamente, <code>'static</code> no es el 칰nico tiempo de vida posible. Cada variable tiene su tiempo de vida, aunque normalmente no es necesario indicarlo en el c칩digo. El compilador es inteligente y puede deducirlo por s칤 mismo. Solo es necesario expresarlo en el c칩digo cuando el compilador no puede hacerlo.</p>
<p>A continuaci칩n se muestra un ejemplo de otro tiempo de vida. Si se quiere crear un struct <code>Ciudad</code> y pasarle un <code>&amp;str</code> para el nombre (por ejemplo, para que su rendimiento sea mejor que con un <code>String</code>). Se puede intentar as칤 (este c칩digo no funciona):</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Ciudad {
    name: &amp;str, // 丘멆잺
    date_founded: u32,
}

fn main() {
    let mi_ciudad = Ciudad {
        name: &quot;Ichinomiya&quot;,
        date_founded: 1921,
    };
}
</code></pre></pre>
<p>El compilador indica:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; src\main.rs:3:11
  |
3 |     name: &amp;str,
  |           ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
2 | struct Ciudad&lt;'a&gt; {
3 |     name: &amp;'a str,
  |
</code></pre>
<p>Rust necesita un tiempo de vida para <code>&amp;str</code> porque <code>&amp;str</code> es una referencia. 쯈u칠 sucede cuando el valor al que apunta <code>name</code> se libera? No ser칤a seguro usar este c칩digo.</p>
<p>쯈u칠 pasa si se pone <code>'static</code>? 쯙uncionar치 como en los casos anteriores? Si se prueba:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Ciudad {
    name: &amp;'static str, 
    date_founded: u32,
}

fn main() {
    let mi_Ciudad = Ciudad {
        name: &quot;Ichinomiya&quot;,
        date_founded: 1921,
    };

println!(&quot;{} se fund칩 en {}&quot;, mi_Ciudad.name, mi_Ciudad.date_founded);

}
</code></pre></pre>
<p>En este caso funciona. Sin embargo, solo se le pueden pasar cadenas de caracteres literales, no referencias a otro tipo de valores. Por eso, este otro c칩digo no funciona:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Ciudad {
    name: &amp;'static str, // debe existir el valor durante todo el programa
    date_founded: u32,
}

fn main() {
    let Ciudad_names = vec![&quot;Ichinomiya&quot;.to_string(), &quot;Kurume&quot;.to_string()]; // Ciudad_names no vive durante todo el programa

    let my_Ciudad = Ciudad {
        name: &amp;Ciudad_names[0], // 丘멆잺 Es un &amp;str, pero no &amp;'static str. Es una referencia a un valor interno de Ciudad_names
        date_founded: 1921,
    };

    println!(&quot;{} se fund칩 en {}&quot;, my_Ciudad.name, my_Ciudad.date_founded);
}
</code></pre></pre>
<p>El compilador dice:</p>
<pre><code class="language-text">error[E0597]: `Ciudad_names` does not live long enough
  --&gt; src\main.rs:12:16
   |
12 |         name: &amp;Ciudad_names[0],
   |                ^^^^^^^^^^
   |                |
   |                borrowed value does not live long enough
   |                requires that `Ciudad_names` is borrowed for `'static`
...
18 | }
   | - `Ciudad_names` dropped here while still borrowed
</code></pre>
<p>Este ejemplo es importante entenderlo, ya que la referencia que se pasa s칤 que vive lo suficiente. Pero lo que se ha indicado en el c칩digo es que solo se le va a pasar <code>'static str'</code> y ese es el problema.</p>
<p>As칤 que se va a intentar lo que el compilador suger칤a antes: escribir <code>struct Ciudad&lt;'a&gt;</code> y <code>name: &amp;'a str</code>. Que significa que la referencia a <code>name</code> solo existe mientras exista el valor <code>struct Ciudad</code>.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Ciudad&lt;'a&gt; { // City has lifetime 'a
    name: &amp;'a str, // and name also has lifetime 'a.
    date_founded: u32,
}

fn main() {
    let ciudad_names = vec![&quot;Ichinomiya&quot;.to_string(), &quot;Kurume&quot;.to_string()];

    let my_Ciudad = Ciudad {
        name: &amp;ciudad_names[0],
        date_founded: 1921,
    };

    println!(&quot;{} se fund칩 en {}&quot;, my_Ciudad.name, my_Ciudad.date_founded);
}
</code></pre></pre>
<p>Es necesario recordar que se puede escribir cualquier cosa en lugar de  <code>'a</code>. Vuelve a ser similar a los gen칠ricos en los que se escribe <code>T</code> y <code>U</code>, pero se puede escribir cualquier palabra.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct City&lt;'city&gt; { // El tiempo de vida se llama ahora 'city
    name: &amp;'city str, // y name vive solo lo que 'city
    date_founded: u32,
}

fn main() {}
</code></pre></pre>
<p>En todo caso, se suelen usar por convenci칩n <code>'a</code>, <code>'b</code>, <code>'c</code>, etc. En caso de usar otros nombres, es conveniente aprovechar para que tengan sentido para los humanos.</p>
<p>Se presenta de nuevo una comparaci칩n con los rasgos y gen칠ricos. Por ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

fn prints&lt;T: Display&gt;(input: T) {
    println!(&quot;T is {}&quot;, input);
}

fn main() {}
</code></pre></pre>
<p><code>T:Display</code> significa que solo se puede usar un valor si este implementa <code>Display</code>. No significa que doy <code>Display</code> a <code>T</code>.</p>
<p>Lo mismo sucede con los tiempos de vida. Si se escribe:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct City&lt;'a&gt; {
    name: &amp;'a str,
    date_founded: u32,
}

fn main() {}
</code></pre></pre>
<p>Significa que solo se permiten valores de referencia para <code>name</code> que duren al menos lo mismo que el <code>struct</code> de <code>City</code> que se est치 creando. No significa que el valor asignado a <code>name</code> pase a dura lo mismo que el <code>struct</code> de <code>City</code> creado.</p>
<p>Ahora se puede entender <code>&lt;'_&gt;</code> que se apareci칩 anteriormente. Se denomina &quot;tiempo de vida an칩nimo&quot; y es un indicador de que se est치n usando referencias. Rust lo sugiere cuando se implementan <code>struct</code>. Por ejemplo: este es un c칩digo que no funciona:</p>
<pre><pre class="playground"><code class="language-rust">    // 丘멆잺
struct Adventurer&lt;'a&gt; {
    name: &amp;'a str,
    hit_points: u32,
}

impl Adventurer {
    fn take_damage(&amp;mut self) {
        self.hit_points -= 20;
        println!(&quot;{} has {} hit points left!&quot;, self.name, self.hit_points);
    }
}

fn main() {}
</code></pre></pre>
<p>Se ha hecho todo lo necesario para que la referencia en el <code>name</code> requira tener el tiempo de vida del <code>struct</code> como m칤nimo. Sin embargo, Rust se queja de la parte de la implementaci칩n.</p>
<pre><code class="language-text">error[E0726]: implicit elided lifetime not allowed here
 --&gt; src\main.rs:6:6
  |
6 | impl Adventurer {
  |      ^^^^^^^^^^- help: indicate the anonymous lifetime: `&lt;'_&gt;`
</code></pre>
<p>Pide que se a침ada una tiempo de vida an칩nimo para que quede claro en la implementaci칩n que existe una referencia en este c칩digo que se est치 usando. Basta con atender a la sugerencia:</p>
<pre><pre class="playground"><code class="language-rust">struct Adventurer&lt;'a&gt; {
    name: &amp;'a str,
    hit_points: u32,
}

impl Adventurer&lt;'_&gt; {
    fn take_damage(&amp;mut self) {
        self.hit_points -= 20;
        println!(&quot;{} has {} hit points left!&quot;, self.name, self.hit_points);
    }
}

fn main() {}
</code></pre></pre>
<p>Este tiempo de vida an칩nimo simplifica la forma general que tendr칤a que haber tenido en este caso <code>impl&lt;'a&gt; Adventurer&lt;'a&gt;</code>.</p>
<p>Los tiempos de vida son uno de los temas que puede ser m치s dif칤cil en Rust. A continuaci칩n se muestran algunas sugerencias para que sirvan de ayuda:</p>
<ul>
<li>Se pueden evitar las referencias pasando clones y con objetos copy, etc.</li>
<li>La mayor parte de las veces en las que el compilador necesita un tiempo de vida, simplemente habr치 que escribir <code>'a</code> en un par de sitios y funcionar치.</li>
<li>Se puede ir aprendiendo este tema en peque침as dosis. Se puede escribir el c칩digo con valores propietarios, sin referencias, luego convertir uno de ellos en referencia. El compilador empezar치 a quejarse y a dar sugerencias. Si se complica mucho, se puede deshacer el cambio e intentarlo m치s tarde.</li>
</ul>
<p>Se presenta aqu칤 un ejemplo que ya contiene una referencia y no indica tiempo de vida alguno. Se seguir치n las indicaciones para subsanarlo.</p>
<pre><pre class="playground"><code class="language-rust">// 丘멆잺
struct Adventurer {
    name: &amp;str,
    hit_points: u32,
}

impl Adventurer {
    fn take_damage(&amp;mut self) {
        self.hit_points -= 20;
        println!(&quot;{} has {} hit points left!&quot;, self.name, self.hit_points);
    }
}

impl std::fmt::Display for Adventurer {
        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
            write!(f, &quot;{} has {} hit points.&quot;, self.name, self.hit_points)
        }
}

fn main() {}
</code></pre></pre>
<p>La primera queja es:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; src\main.rs:2:11
  |
2 |     name: &amp;str,
  |           ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 | struct Adventurer&lt;'a&gt; {
2 |     name: &amp;'a str,
  |
</code></pre>
<p>Sugiere qu칠 es lo que hay que hacer:</p>
<pre><pre class="playground"><code class="language-rust">// 丘멆잺
struct Adventurer&lt;'a&gt; {
    name: &amp;'a str,
    hit_points: u32,
}

impl Adventurer {
    fn take_damage(&amp;mut self) {
        self.hit_points -= 20;
        println!(&quot;{} has {} hit points left!&quot;, self.name, self.hit_points);
    }
}

impl std::fmt::Display for Adventurer {
        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
            write!(f, &quot;{} has {} hit points.&quot;, self.name, self.hit_points)
        }
}

fn main() {}
</code></pre></pre>
<p>Ahora no tiene problema con esa parte de c칩digo, pero se queja de otra parte:</p>
<pre><code class="language-text">error[E0726]: implicit elided lifetime not allowed here
 --&gt; src\main.rs:6:6
  |
6 | impl Adventurer {
  |      ^^^^^^^^^^- help: indicate the anonymous lifetime: `&lt;'_&gt;`

error[E0726]: implicit elided lifetime not allowed here
  --&gt; src\main.rs:12:28
   |
12 | impl std::fmt::Display for Adventurer {
   |                            ^^^^^^^^^^- help: indicate the anonymous lifetime: `&lt;'_&gt;`
</code></pre>
<p>As칤 que se sigue la sugerencia y se modifica como pide:</p>
<pre><pre class="playground"><code class="language-rust">struct Adventurer&lt;'a&gt; {
    name: &amp;'a str,
    hit_points: u32,
}

impl Adventurer&lt;'_&gt; {
    fn take_damage(&amp;mut self) {
        self.hit_points -= 20;
        println!(&quot;{} has {} hit points left!&quot;, self.name, self.hit_points);
    }
}

impl std::fmt::Display for Adventurer&lt;'_&gt; {

        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
            write!(f, &quot;{} has {} hit points.&quot;, self.name, self.hit_points)
        }
}

fn main() {
    let mut billy = Adventurer {
        name: &quot;Billy&quot;,
        hit_points: 100_000,
    };
    println!(&quot;{}&quot;, billy);
    billy.take_damage();
}
</code></pre></pre>
<p>Esto da como salida:</p>
<pre><code class="language-text">Billy has 100000 hit points.
Billy has 99980 hit points left!
</code></pre>
<p>As칤 se puede observar que los tiempos de vida en muchas ocasiones sirven para que el compilador se asegure de que no se est치 cometiendo un error. Normalmente es lo suficientemente inteligente para determinar qu칠 tiempo de vida tiene cada valor y solo &quot;pregunta&quot; cuando no lo puede saber con seguridad.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="36.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="38.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="36.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="38.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
