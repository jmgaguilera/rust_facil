<!DOCTYPE HTML>
<html lang="es" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Un paseo por la librer√≠a est√°ndar - Rust en espa√±ol f√°cil</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="actualizaciones.html">Actualizaciones</a></li><li class="chapter-item expanded affix "><a href="introduccion.html">Introducci√≥n</a></li><li class="chapter-item expanded affix "><a href="quiensoy.html">¬øQui√©n soy?</a></li><li class="chapter-item expanded affix "><a href="escritura.html">La escritura de Rust en ingl√©s f√°cil</a></li><li class="chapter-item expanded affix "><li class="part-title">Parte 1 - Rust en tu navegador</li><li class="chapter-item expanded "><a href="01.html"><strong aria-hidden="true">1.</strong> El entorno de pruebas de Rust</a></li><li class="chapter-item expanded "><a href="02.html"><strong aria-hidden="true">2.</strong> üöß y ‚ö†Ô∏è</a></li><li class="chapter-item expanded "><a href="03.html"><strong aria-hidden="true">3.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="04.html"><strong aria-hidden="true">4.</strong> Tipos de dato</a></li><li class="chapter-item expanded "><a href="05.html"><strong aria-hidden="true">5.</strong> Inferencia de tipos de dato</a></li><li class="chapter-item expanded "><a href="06.html"><strong aria-hidden="true">6.</strong> Imprimiendo '¬°Hola, mundo!'</a></li><li class="chapter-item expanded "><a href="07.html"><strong aria-hidden="true">7.</strong> La visualizaci√≥n y depuraci√≥n</a></li><li class="chapter-item expanded "><a href="08.html"><strong aria-hidden="true">8.</strong> Mutabilidad (cambio)</a></li><li class="chapter-item expanded "><a href="09.html"><strong aria-hidden="true">9.</strong> La pila, la memoria din√°mica y los punteros</a></li><li class="chapter-item expanded "><a href="10.html"><strong aria-hidden="true">10.</strong> M√°s sobre impresi√≥n</a></li><li class="chapter-item expanded "><a href="11.html"><strong aria-hidden="true">11.</strong> Cadenas de caracteres</a></li><li class="chapter-item expanded "><a href="12.html"><strong aria-hidden="true">12.</strong> const y static</a></li><li class="chapter-item expanded "><a href="13.html"><strong aria-hidden="true">13.</strong> Algo m√°s sobre referencias</a></li><li class="chapter-item expanded "><a href="14.html"><strong aria-hidden="true">14.</strong> Referencias modificables (mutables)</a></li><li class="chapter-item expanded "><a href="15.html"><strong aria-hidden="true">15.</strong> Paso de referencias a funciones</a></li><li class="chapter-item expanded "><a href="16.html"><strong aria-hidden="true">16.</strong> Copia</a></li><li class="chapter-item expanded "><a href="17.html"><strong aria-hidden="true">17.</strong> Tipos colecci√≥n</a></li><li class="chapter-item expanded "><a href="18.html"><strong aria-hidden="true">18.</strong> Vectores</a></li><li class="chapter-item expanded "><a href="19.html"><strong aria-hidden="true">19.</strong> Tuplas</a></li><li class="chapter-item expanded "><a href="20.html"><strong aria-hidden="true">20.</strong> Estructuras de control</a></li><li class="chapter-item expanded "><a href="21.html"><strong aria-hidden="true">21.</strong> Estructuras - struct</a></li><li class="chapter-item expanded "><a href="22.html"><strong aria-hidden="true">22.</strong> Enumerados - enum</a></li><li class="chapter-item expanded "><a href="23.html"><strong aria-hidden="true">23.</strong> Bucles</a></li><li class="chapter-item expanded "><a href="24.html"><strong aria-hidden="true">24.</strong> Implementando structs y enums</a></li><li class="chapter-item expanded "><a href="25.html"><strong aria-hidden="true">25.</strong> Desestructurar</a></li><li class="chapter-item expanded "><a href="26.html"><strong aria-hidden="true">26.</strong> Referencias y el operador punto .</a></li><li class="chapter-item expanded "><a href="27.html"><strong aria-hidden="true">27.</strong> Gen√©ricos</a></li><li class="chapter-item expanded "><a href="28.html"><strong aria-hidden="true">28.</strong> Los enumerados Option y Result</a></li><li class="chapter-item expanded "><a href="29.html"><strong aria-hidden="true">29.</strong> Otras colecciones</a></li><li class="chapter-item expanded "><a href="30.html"><strong aria-hidden="true">30.</strong> El operador ?</a></li><li class="chapter-item expanded "><a href="31.html"><strong aria-hidden="true">31.</strong> Traits (Rasgos)</a></li><li class="chapter-item expanded "><a href="32.html"><strong aria-hidden="true">32.</strong> Encadenando m√©todos</a></li><li class="chapter-item expanded "><a href="33.html"><strong aria-hidden="true">33.</strong> Iteradores</a></li><li class="chapter-item expanded "><a href="34.html"><strong aria-hidden="true">34.</strong> Closures - Cierres</a></li><li class="chapter-item expanded "><a href="35.html"><strong aria-hidden="true">35.</strong> La macro dbg! e .inspect()</a></li><li class="chapter-item expanded "><a href="36.html"><strong aria-hidden="true">36.</strong> Tipos de &str</a></li><li class="chapter-item expanded "><a href="37.html"><strong aria-hidden="true">37.</strong> Tiempos de vida (lifetimes)</a></li><li class="chapter-item expanded "><a href="38.html"><strong aria-hidden="true">38.</strong> Mutabilidad interior</a></li><li class="chapter-item expanded "><a href="39.html"><strong aria-hidden="true">39.</strong> Cow</a></li><li class="chapter-item expanded "><a href="40.html"><strong aria-hidden="true">40.</strong> Alias de tipos</a></li><li class="chapter-item expanded "><a href="41.html"><strong aria-hidden="true">41.</strong> La macro todo!</a></li><li class="chapter-item expanded "><a href="42.html"><strong aria-hidden="true">42.</strong> Rc</a></li><li class="chapter-item expanded "><a href="43.html"><strong aria-hidden="true">43.</strong> M√∫ltiples hilos</a></li><li class="chapter-item expanded "><a href="44.html"><strong aria-hidden="true">44.</strong> Cierres en funciones</a></li><li class="chapter-item expanded "><a href="45.html"><strong aria-hidden="true">45.</strong> impl Trait</a></li><li class="chapter-item expanded "><a href="46.html"><strong aria-hidden="true">46.</strong> Arc</a></li><li class="chapter-item expanded "><a href="47.html"><strong aria-hidden="true">47.</strong> Canales</a></li><li class="chapter-item expanded "><a href="48.html"><strong aria-hidden="true">48.</strong> Entender la documentaci√≥n de Rust</a></li><li class="chapter-item expanded "><a href="49.html"><strong aria-hidden="true">49.</strong> Atributos</a></li><li class="chapter-item expanded "><a href="50.html"><strong aria-hidden="true">50.</strong> Box</a></li><li class="chapter-item expanded "><a href="51.html"><strong aria-hidden="true">51.</strong> Box y los rasgos</a></li><li class="chapter-item expanded "><a href="52.html"><strong aria-hidden="true">52.</strong> Default y el patr√≥n constructor (builder)</a></li><li class="chapter-item expanded "><a href="53.html"><strong aria-hidden="true">53.</strong> Deref y DerefMut</a></li><li class="chapter-item expanded "><a href="54.html"><strong aria-hidden="true">54.</strong> Crates (cajones) y m√≥dulos</a></li><li class="chapter-item expanded "><a href="55.html"><strong aria-hidden="true">55.</strong> Pruebas (testing)</a></li><li class="chapter-item expanded "><a href="56.html"><strong aria-hidden="true">56.</strong> Crates externas</a></li><li class="chapter-item expanded "><a href="57.html" class="active"><strong aria-hidden="true">57.</strong> Un paseo por la librer√≠a est√°ndar</a></li><li class="chapter-item expanded "><a href="58.html"><strong aria-hidden="true">58.</strong> La escritura de macros</a></li><li class="chapter-item expanded affix "><li class="part-title">Parte 2 - Rust en tu ordenador</li><li class="chapter-item expanded "><a href="59.html"><strong aria-hidden="true">59.</strong> cargo</a></li><li class="chapter-item expanded "><a href="60.html"><strong aria-hidden="true">60.</strong> Entrada de datos de usuario</a></li><li class="chapter-item expanded "><a href="61.html"><strong aria-hidden="true">61.</strong> Utilizando ficheros</a></li><li class="chapter-item expanded "><a href="62.html"><strong aria-hidden="true">62.</strong> cargo doc</a></li><li class="chapter-item expanded "><a href="63.html"><strong aria-hidden="true">63.</strong> ¬øEl final?</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust en espa√±ol f√°cil</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="un-paseo-por-la-librer√≠a-est√°ndar"><a class="header" href="#un-paseo-por-la-librer√≠a-est√°ndar">Un paseo por la librer√≠a est√°ndar</a></h1>
<p>Ahora que ya se conoce bastante sobre Rust, se puede entender la mayor parte de lo que contiene la librer√≠a est√°ndar. El c√≥digo que contiene no debe asustar ya. Se muestran en este cap√≠tulo algunas partes de lo que a√∫n no se ha aprendido. Se revisitar√°n conceptos que ya se conocen, para aprenderlos en mayor detalle.</p>
<h2 id="arrays"><a class="header" href="#arrays">Arrays</a></h2>
<p>En el pasado (antes de Rust 1.53), los arrays no implementaban <code>Iterator</code> y se necesitaba usar m√©todos como <code>.iter()</code> en bucles <code>for</code> (O se usaba <code>&amp;</code> para obtener una secci√≥n que usar en un bucle <code>for</code>). En resume, este c√≥digo no funcionaba en el pasado:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_cities = [&quot;Beirut&quot;, &quot;Tel Aviv&quot;, &quot;Nicosia&quot;];

    for city in my_cities {
        println!(&quot;{}&quot;, city);
    }
}
</code></pre></pre>
<p>El compilador daba el siguiente error:</p>
<pre><code class="language-text">error[E0277]: `[&amp;str; 3]` is not an iterator
 --&gt; src\main.rs:5:17
  |
  |                 ^^^^^^^^^ borrow the array with `&amp;` or call `.iter()` on it to iterate over it
</code></pre>
<p>Afortunadamente, esto ya no es un problema. Por lo que las siguientes tres versiones funcionan sin problema:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_cities = [&quot;Beirut&quot;, &quot;Tel Aviv&quot;, &quot;Nicosia&quot;];

    for city in my_cities {
        println!(&quot;{}&quot;, city);
    }
    for city in &amp;my_cities {
        println!(&quot;{}&quot;, city);
    }
    for city in my_cities.iter() {
        println!(&quot;{}&quot;, city);
    }
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">Beirut
Tel Aviv
Nicosia
Beirut
Tel Aviv
Nicosia
Beirut
Tel Aviv
Nicosia
</code></pre>
<p>Si se quiere recuperar elementos de un array para guardarlos en una variable se puede usar <code>[]</code> para desestructurarlo (como en las tuplas en sentencias <code>match</code>):</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_cities = [&quot;Beirut&quot;, &quot;Tel Aviv&quot;, &quot;Nicosia&quot;];
    let [city1, city2, city3] = my_cities;
    println!(&quot;{}&quot;, city1);
}
</code></pre></pre>
<p>El c√≥digo anterior imprime <code>Beirut</code>.</p>
<h2 id="char"><a class="header" href="#char">char</a></h2>
<p>Se puede usar <code>.escape_unicode()</code> para recuperar el c√≥digo unicode de un car√°cter <code>char</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let korean_word = &quot;Ï≤≠Ï∂òÏòàÏ∞¨&quot;;
    for character in korean_word.chars() {
        print!(&quot;{} &quot;, character.escape_unicode());
    }
}
</code></pre></pre>
<p>El c√≥digo anterior imprime <code>\u{ccad} \u{cd98} \u{c608} \u{cc2c}</code>.</p>
<p>Se puede obtener un <code>char</code> de un <code>u8</code> usando el rasgo <code>From</code>, pero para obtenerlo de un <code>u32</code> resulta necesario usar <code>TryFrom</code> ya que no todos los valores <code>u32</code> son caracteres unicode y puede fallar la conversi√≥n:</p>
<pre><pre class="playground"><code class="language-rust">extern crate rand;
use std::convert::TryFrom; // Se necesita importar TryFrom para usarlo
use rand::prelude::*;      // Tambi√©n se usar√°n n√∫meros aleatorios

fn main() {
    let some_character = char::from(99); // Este es f√°cil - no necesita TryFrom
    println!(&quot;{}&quot;, some_character);

    let mut random_generator = rand::thread_rng();
    // Se intenta esto 40,000 times: crear un char de un u32.
    // El rango entre 0 (std::u32::MIN) to u32's highest number (std::u32::MAX). Si no funciona, devolver√° '-'.
    for _ in 0..40_000 {
        let bigger_character = char::try_from(random_generator.gen_range(std::u32::MIN..std::u32::MAX)).unwrap_or('-');
        print!(&quot;{}&quot;, bigger_character)
    }
}
</code></pre></pre>
<p>Casi siempre se genera un <code>-</code>. La salida del programa anterior se parecer√° a lo siguiente:</p>
<pre><code class="language-text">------------------------------------------------------------------------§í∞---------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-------------------------------------------------------------Ï∂ó--------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
------------Úáçú----------------------------------------------------
</code></pre>
<p>A partir de agosto de 2020 se puede crear un <code>String</code> a partir de <code>char</code>. (<code>String</code> implementa <code>From&lt;char&gt;</code>). Para ello, se usa <code>String::from()</code> pasando como par√°metro un <code>char</code>.</p>
<h2 id="enteros"><a class="header" href="#enteros">Enteros</a></h2>
<p>Los tipos de dato enteros tienen a su disposici√≥n muchos m√©todos matem√°ticos y algunos otros. A continuaci√≥n se muestran algunos de los m√°s √∫tiles.</p>
<p><code>.checked_add()</code>, <code>.checked_sub()</code>, <code>.checked_mul()</code>, <code>.checked_div()</code>. Son m√©todos que validan que el resultado &quot;cabe&quot; en el tipo. Devuelven <code>Option</code> para que se puda validar de forma f√°cil el resultado sin que el programa entre en p√°nico.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let some_number = 200_u8;
    let other_number = 200_u8;

    println!(&quot;{:?}&quot;, some_number.checked_add(other_number));
    println!(&quot;{:?}&quot;, some_number.checked_add(1));
}
</code></pre></pre>
<p>Este c√≥digo imprime:</p>
<pre><code class="language-text">None
Some(201)
</code></pre>
<p>Se habr√° observado que la p√°gina de documentaci√≥n de los tipos enteros dice mucho <code>rhs</code> que significa &quot;right hand side&quot; (lado de la derecha). Por ejemplo, en <code>5 + 6</code>, el lado izquierdo es <code>5</code> y el derecho es <code>6</code>. Es decir, <code>6</code> es el <code>rhs</code>.</p>
<p>Es posible implementar la suma para cualquier tipo. Para ello, se usa el rasgo correspondiente <code>Add</code>. Despu√©s de implementarlo, se puede usar el operador <code>+</code> en el tipo en que se haya codificado. Este es el ejemplo de la documentaci√≥n oficial:</p>
<pre><pre class="playground"><code class="language-rust">
#![allow(unused)]
fn main() {
use std::ops::Add; // a√±ade acceso al rasgo Add

#[derive(Debug, Copy, Clone, PartialEq)] // PartialEq es importante para poder comparar n√∫meros
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Self; // Recuerda, este es el tipo asociado. El tipo &quot;que va&quot; con este otro
                        // En este caso es otro Point

    fn add(self, other: Self) -&gt; Self {
        Self {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}
}
</code></pre></pre>
<p>A continuaci√≥n se implementa para un tipo propio. Se van a sumar dos pa√≠ses para comparar sus econom√≠as.</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;
use std::ops::Add;

#[derive(Clone)]
struct Country {
    name: String,
    population: u32,
    gdp: u32, // This is the size of the economy
}

impl Country {
    fn new(name: &amp;str, population: u32, gdp: u32) -&gt; Self {
        Self {
            name: name.to_string(),
            population,
            gdp,
        }
    }
}

impl Add for Country {
    type Output = Self;

    fn add(self, other: Self) -&gt; Self {
        Self {
            name: format!(&quot;{} y {}&quot;, self.name, other.name), // Se unen los nombres,
            population: self.population + other.population, // se suma la poblaci√≥n,
            gdp: self.gdp + other.gdp,   // y el producto interior bruto (gross domestic product)
        }
    }
}

impl fmt::Display for Country {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(
            f,
            &quot;En {} hay {} personas y un producto interior bruto de {}‚Ç¨&quot;, // As√≠ se puede imprimir con solo {}
            self.name, self.population, self.gdp
        )
    }
}

fn main() {
    let nauru = Country::new(&quot;Nauru&quot;, 10_670, 160_000_000);
    let vanuatu = Country::new(&quot;Vanuatu&quot;, 307_815, 820_000_000);
    let micronesia = Country::new(&quot;Micronesia&quot;, 104_468, 367_000_000);

    // Si se hubiera usado &amp;str en lugar de String para el name, habr√≠a que haber usado ciclos de vida
    // y era demasiado para un ejemplo. Mejor usar clone cuando se llama a println!.
    println!(&quot;{}&quot;, nauru.clone());
    println!(&quot;{}&quot;, nauru.clone() + vanuatu.clone());
    println!(&quot;{}&quot;, nauru + vanuatu + micronesia);
}
</code></pre></pre>
<p>El c√≥digo anterior imprime:</p>
<pre><code class="language-text">En Nauru hay 10670 personas y un producto interior bruto de 160000000‚Ç¨
En Nauru y Vanuatu hay 318485 personas y un producto interior bruto de 980000000‚Ç¨
En Nauru y Vanuatu y Micronesia hay 422953 personas y un producto interior bruto de 1347000000‚Ç¨
</code></pre>
<p>M√°s adelante en este c√≥digo se puede cambiar <code>.fmt()</code> para mostrar un n√∫mero de forma que sea m√°s sencillo de leer (formate√°ndolo).</p>
<p>Hay otros rasgos <code>Sub</code>, <code>Mul</code> y <code>Div</code> para implementar la resta, multiplicaci√≥n y divisi√≥n. Para poder usar <code>+=</code>, <code>-=</code>, <code>*=</code> y <code>/=</code> se deben a√±adir los rassgos: <code>AddAssign</code>, <code>SubAssign</code>, <code>MulAssign</code> y <code>DivAssign</code>. La lista completa existente se puede consultar <a href="https://doc.rust-lang.org/std/ops/index.html#structs">aqu√≠</a>. Hay muchos m√°s, como <code>%</code>, que se llama <code>Rem</code>, o como <code>-</code> (operador unario), que se denomina <code>Neg</code>.</p>
<h2 id="n√∫meros-flotantes"><a class="header" href="#n√∫meros-flotantes">N√∫meros flotantes</a></h2>
<p><code>f32</code> y <code>f64</code> tienen un amplio n√∫mero de m√©todos matem√°ticos. Hay otros m√°s que se pueden usar. Por ejemplo <code>.floor()</code>, <code>.ceil()</code>, <code>.round()</code> y <code>.trunc()</code>. Estos m√©todos devuelven <code>f32</code> o <code>f64</code> solo que con la parte decimal con valor 0. Esta es su funci√≥n:</p>
<ul>
<li><code>.floor()</code>: devuelve el valor entero inmediatamente anterior.</li>
<li><code>.ceil()</code>: devuelve el valor entero inmediatamente siguiente.</li>
<li><code>.round()</code>: devuelve el valor <code>.ceil()</code> si la parte decimal es <code>0.5</code> o superior. Devuelve el valor <code>.floor()</code> si no es as√≠. A esto se le llama redondeo, porque devuelve un n√∫mero &quot;redondo&quot;.</li>
<li><code>.trunc()</code>: simplemente elimina la parte decimal. (N.T.: en los n√∫meros positivos funciona igual que <code>.floor()</code>, en los negativos no.)</li>
</ul>
<p>A continuaci√≥n, se muestra un ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">fn four_operations(input: f64) {
    println!(
&quot;Para el n√∫mero {}:
floor: {}
ceiling: {}
rounded: {}
truncated: {}\n&quot;,
        input,
        input.floor(),
        input.ceil(),
        input.round(),
        input.trunc()
    );
}

fn main() {
    four_operations(9.1);
    four_operations(100.7);
    four_operations(-1.1);
    four_operations(-19.9);
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">For the number 9.1:
floor: 9
ceiling: 10
rounded: 9 // because less than 9.5
truncated: 9

For the number 100.7:
floor: 100
ceiling: 101
rounded: 101 // because more than 100.5
truncated: 100

For the number -1.1:
floor: -2
ceiling: -1
rounded: -1
truncated: -1

For the number -19.9:
floor: -20
ceiling: -19
rounded: -20
truncated: -19
</code></pre>
<p><code>f32</code> y <code>f64</code> tienen m√©todos denominados <code>.max()</code> y <code>.min()</code> que devuelven el menor y mayor n√∫mero de dos (para otros tipos se puede usar <code>std::cmp::max</code> y <code>std::cmp::min</code>). A continuaci√≥n se muestra una forma de obtener el n√∫mero mayor y el menor usando <code>.fold()</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![8.0_f64, 7.6, 9.4, 10.0, 22.0, 77.345, 10.22, 3.2, -7.77, -10.0];
    let maximum = my_vec.iter().fold(f64::MIN, |current_number, next_number| current_number.max(*next_number)); // Nota: inicia con el menor f64 existente.
    let minimum = my_vec.iter().fold(f64::MAX, |current_number, next_number| current_number.min(*next_number)); // Y en este se inicia con el mayor posible
    println!(&quot;{}, {}&quot;, maximum, minimum);
}
</code></pre></pre>
<h2 id="bool"><a class="header" href="#bool">bool</a></h2>
<p>En Rust, se pueden convertir los valores <code>bool</code> a enteros: es seguro hacerlo. <code>true</code> se convierte en <code>1</code> y `false' en '0'. Sin embargo, no es posible hacer la conversi√≥n en sentido opuesto.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let true_false = (true, false);
    println!(&quot;{} {}&quot;, true_false.0 as u8, true_false.1 as i32);
}
</code></pre></pre>
<p>Que imprime <code>1 0</code>. O se puede usar <code>.into()</code>, dici√©ndole al compilador el tipo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let true_false: (i128, u16) = (true.into(), false.into());
    println!(&quot;{} {}&quot;, true_false.0, true_false.1);
}
</code></pre></pre>
<p>Que imprime lo mismo.</p>
<p>Desde Rust 1.50 (liberado en Febrero 2021), existe un m√©todo denominado <code>then()</code>, que convierte un <code>bool</code> en <code>Option</code>. En el m√©todo <code>.then()</code> se pasa como par√°metro un cierre (closure) que solo se llama si el elemento es <code>true</code>. El valor de retorno del cierre se guarda como valor de retorno en el <code>Option</code>. Por ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

    let (tru, fals) = (true.then(|| 8), false.then(|| 8));
    println!(&quot;{:?}, {:?}&quot;, tru, fals);
}
</code></pre></pre>
<p>Que imprime <code>Some(8), None</code>.</p>
<p>A continuaci√≥n un ejemplo un poco m√°s largo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let bool_vec = vec![true, false, true, false, false];
    
    let option_vec = bool_vec
        .iter()
        .map(|item| {
            item.then(|| { // Lo incluye en un map para poder pasarlo
                println!(&quot;¬°Tengo un {}!&quot;, item);
                &quot;Tiene valor true&quot; // Esto va dentro de Some si es true
                                      // En otro caso, pasa None
            })
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!(&quot;Tenemos este resultado: {:?}&quot;, option_vec);

    // Esto imprime Nones tambi√©n. Se filtran para pasarlo a un nuevo Vec.
    let filtered_vec = option_vec.into_iter().filter_map(|c| c).collect::&lt;Vec&lt;_&gt;&gt;();

    println!(&quot;Y sin los None: {:?}&quot;, filtered_vec);
}
</code></pre></pre>
<h2 id="vec"><a class="header" href="#vec">Vec</a></h2>
<p><code>Vec</code> tiene muchos m√©todos que a√∫n no se han revisado. En primer lugar, <code>.sort()</code> necesita una variable <code>mut self</code> para poder ordenar.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec = vec![100, 90, 80, 0, 0, 0, 0, 0];
    my_vec.sort();
    println!(&quot;{:?}&quot;, my_vec);
}
</code></pre></pre>
<p>Esto imprime <code>[0, 0, 0, 0, 0, 80, 90, 100]</code>. Existe otro m√©todo que suele ser m√°s r√°pido denominado <code>.sort_unstable()</code>. En este caso, no se preocupa del orden de los n√∫meros si son el mismo. En el caso de <code>.sort()</code> se sabe que el √∫ltimo <code>0, 0, 0, 0, 0</code> estar√° en el mismo orden despu√©s. En el caso de <code>.sort_unstable()</code> podr√≠a pasar que el √∫ltimo cero estuviese en la posici√≥n <code>0</code>, el tercero inicialmente en la posici√≥n <code>2</code>, etc.</p>
<p><code>.dedup()</code> significa &quot;quitar duplicados&quot;. Elimina los elementos iguales que est√°n en un vector, pero solo si est√°n uno junto a otro. El c√≥digo siguiente no solo imprime <code>&quot;sun&quot;, &quot;moon&quot;</code>, sino que mantiene repetidos, siempre que no estuvieran juntos.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec = vec![&quot;sun&quot;, &quot;sun&quot;, &quot;moon&quot;, &quot;moon&quot;, &quot;sun&quot;, &quot;moon&quot;, &quot;moon&quot;];
    my_vec.dedup();
    println!(&quot;{:?}&quot;, my_vec);
}
</code></pre></pre>
<p>El resultado es <code>[&quot;sun&quot;, &quot;moon&quot;, &quot;sun&quot;, &quot;moon&quot;]</code>.</p>
<p>Si se quieren eliminar todos los duplicados es necesario usar <code>.sort()</code> antes:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec = vec![&quot;sun&quot;, &quot;sun&quot;, &quot;moon&quot;, &quot;moon&quot;, &quot;sun&quot;, &quot;moon&quot;, &quot;moon&quot;];
    my_vec.sort();
    my_vec.dedup();
    println!(&quot;{:?}&quot;, my_vec);
}
</code></pre></pre>
<p>As√≠, el resultado es <code>[&quot;moon&quot;, &quot;sun&quot;]</code>.</p>
<h2 id="string"><a class="header" href="#string">String</a></h2>
<p>Se recordar√° que un <code>String</code> es un tipo de <code>Vec</code>, por lo tanto se pueden usar muchos de los m√©todos de los vectores. POr ejemplo, se puede iniciar una cadena de caracteres <code>String::with_capacity()</code>. Por ejemplo, puede ser util para ser eficiente cuando se prev√© que se van a a√±adir caracteres con <code>.push()</code> o <code>.push_str()</code> (cuando se va a insertar un <code>&amp;str</code>).</p>
<p>El siguiente ejemplo, es poco eficiente:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut push_string = String::new();
    let mut capacity_counter = 0; // la capacidad se inicia a 0
    for _ in 0..100_000 { // Hace esto 100,000 veces
        if push_string.capacity() != capacity_counter { // Comprueba si ha variado la capacidad
            println!(&quot;{}&quot;, push_string.capacity()); // Si ha variado, se muestra la nueva
            capacity_counter = push_string.capacity(); // y se guarda en el contador
        }
        push_string.push_str(&quot;I'm getting pushed into the string!&quot;); // y a√±ade esto a la cadena cada vez
    }
}
</code></pre></pre>
<p>Esto imprime</p>
<pre><code class="language-text">35
70
140
280
560
1120
2240
4480
8960
17920
35840
71680
143360
286720
573440
1146880
2293760
4587520
</code></pre>
<p>Durante esta ejecuci√≥n, ha habido que mover la cadena de sitio en memoria 18 veces. Y se conoce la capacidad final. Se puede crear la cadena de caracteres con la capacidad necesaria desde el inicio.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut push_string = String::with_capacity(4587520); // Capacidad necesaria
    let mut capacity_counter = 0;
    for _ in 0..100_000 {
        if push_string.capacity() != capacity_counter {
            println!(&quot;{}&quot;, push_string.capacity());
            capacity_counter = push_string.capacity();
        }
        push_string.push_str(&quot;I'm getting pushed into the string!&quot;);
    }
}
</code></pre></pre>
<p>Esto imprime <code>4587520</code> una sola vez. No ha habido que mover la cadena de caracteres ni una sola vez.</p>
<p>En este caso, la longitud real es un poco menor. Esto se debe a que Rust duplica la capacidad de una cadena de caracteres cada vez que necesita moverla. Existe el m√©todo <code>.shrink_to_fit()</code> (igual que en <code>Vec</code>). As√≠ se puede reducir el tama√±o al espacio realmente ocupado.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut push_string = String::with_capacity(4587520);
    let mut capacity_counter = 0;
    for _ in 0..100_000 {
        if push_string.capacity() != capacity_counter {
            println!(&quot;{}&quot;, push_string.capacity());
            capacity_counter = push_string.capacity();
        }
        push_string.push_str(&quot;I'm getting pushed into the string!&quot;);
    }
    push_string.shrink_to_fit();
    println!(&quot;{}&quot;, push_string.capacity());
    push_string.push('a');
    println!(&quot;{}&quot;, push_string.capacity());
    push_string.shrink_to_fit();
    println!(&quot;{}&quot;, push_string.capacity());
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">4587520
3500000
7000000
3500001
</code></pre>
<p>La primera vez, una vez completa, la cadena de caracteres ocupa <code>4587520</code>, pero no se est√° usando todo. Se usa <code>.shrink_to_fit()</code> y pasa a ocupar <code>35000000</code>. Despu√©s se a√±ade un <code>a</code> al final. En ese momento, Rust determina que necesita m√°s espacio y dobla la capacidad anterior a <code>7000000</code>. Una nueva ejecuci√≥n de <code>.shrink_to_fit()</code> lo reduce a <code>3500001</code>.</p>
<p><code>.pop()</code> funciona con una <code>String</code> igual que en un <code>Vec</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_string = String::from(&quot;.daer ot drah tib elttil a si gnirts sihT&quot;);
    loop {
        let pop_result = my_string.pop();
        match pop_result {
            Some(character) =&gt; print!(&quot;{}&quot;, character),
            None =&gt; break,
        }
    }
}
</code></pre></pre>
<p>Esto imprime <code>This string is a little bit hard to read</code>, porque est√° dada la vuelta.</p>
<p><code>.retain()</code> es un m√©todo que usa un cierre com par√°metro (lo cual es raro en este tipo <code>String</code>). Funciona como <code>.filter</code> en un iterador.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_string = String::from(&quot;Age: 20 Height: 194 Weight: 80&quot;);
    my_string.retain(|character| character.is_alphabetic() || character == ' '); // cons√©rvalo si es una letra o espacio
    dbg!(my_string); // Solo por variar, se usa dbg!() esta vez en lugar de println!
    // Se imprime solo en la consola de error
}
</code></pre></pre>
<p>Esto imprime:</p>
<pre><code class="language-text">[src\main.rs:4] my_string = &quot;Age  Height  Weight &quot;
</code></pre>
<h2 id="osstring-y-cstring"><a class="header" href="#osstring-y-cstring">OsString y CString</a></h2>
<p><code>std::ffi</code> es la parte de la librer√≠a <code>std</code> que ayuda a usar Rust con otros lenguajes o sistemas operativos. Tiene tipos como <code>OsString</code> y <code>CString</code> que son como <code>String</code> del sistema operativo o <code>String</code> del lenguaje C. Cada uno tiene sus propias versiones de <code>&amp;str</code>: <code>OsStr</code> y <code>CStr</code>. <code>ffi</code> significa &quot;foreign function interface&quot; (interfaz para funciones externas).</p>
<p>Se puede usar <code>OsString</code> para trabajar con un Sistema Operativo que no tenga unicode. Todas las cadenas de caracteres de Rust son unicode, pero no todos los sistemas operativos las usan. La explicaci√≥n de la librer√≠a est√°ndar dice lo siguiente:</p>
<ul>
<li>Una cadena de caracteres de Unix (Linux, etc) podr√≠an ser un conjunto de bytes juntos sin ceros. En ocasiones es necesario leerla como Unicode UTF-8.</li>
<li>Una cadena de caracteres de Windows podr√≠a estar compuesta de valores de 16 bits que no tengan ceros. Tambi√©n puede ser necesario leerla como Unicode UTF-16.</li>
<li>En Rust, las cadenas de caracteres siempre est√°n en UTF-8, que s√≠ puede contener ceros.</li>
</ul>
<p>Con <code>OsString</code> se pueden hacer las cosas habituales que se hacen con <code>String</code> como <code>OsString::from(&quot;Escribe algo aqu√≠&quot;)</code>. Tambi√©n dispone de un m√©todo interesante <code>.into_string()</code> que intenta convertirla en una <code>String</code> de Rust. Devuelve un <code>Result</code> en el que la parte <code>Err</code> es la cadena original <code>OsString</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
pub fn into_string(self) -&gt; Result&lt;String, OsString&gt;
}
</code></pre></pre>
<p>Si no funciona, simplemente se dispone de la cadena original del sistema opertivo. En este <code>Result</code> no es posible ejecutar <code>.unwrap()</code> porque el sistema entra en p√°nico, pero se puede recuperar usando <code>match</code>. Se prueba llamando a m√©todos que no existen.</p>
<pre><pre class="playground"><code class="language-rust">use std::ffi::OsString;

fn main() {
    // ‚ö†Ô∏è
    let os_string = OsString::from(&quot;This string works for your OS too.&quot;);
    match os_string.into_string() {
        Ok(valid) =&gt; valid.thth(),           // Compilador: &quot;Qu√© es .thth()??&quot;
        Err(not_valid) =&gt; not_valid.occg(),  // Compilador: &quot;Qu√© es .occg()??&quot;
    }
}
</code></pre></pre>
<p>El compilador indica exactamente lo que se necesita conocer. Al haber puesto m√©todos que no existen, el compilador indica el tipo de dato que no tiene este elemento. </p>
<pre><code class="language-text">error[E0599]: no method named `thth` found for struct `std::string::String` in the current scope
 --&gt; src/main.rs:6:28
  |
6 |         Ok(valid) =&gt; valid.thth(),
  |                            ^^^^ method not found in `std::string::String`

error[E0599]: no method named `occg` found for struct `std::ffi::OsString` in the current scope
 --&gt; src/main.rs:7:37
  |
7 |         Err(not_valid) =&gt; not_valid.occg(),
  |                                     ^^^^ method not found in `std::ffi::OsString`
</code></pre>
<p>Se ve que en el primer caso, el caso correcto, devolver√≠a <code>String</code> y en el caso incorrecto devolver√≠a <code>OsString</code>:</p>
<h2 id="mem"><a class="header" href="#mem">mem</a></h2>
<p><code>std::mem</code> tiene m√©todos muy interesantes. Ya se han visto algunos, como <code>.size_of()</code>, <code>.size_of_val()</code> y <code>.drop()</code>-</p>
<pre><pre class="playground"><code class="language-rust">use std::mem;

fn main() {
    println!(&quot;{}&quot;, mem::size_of::&lt;i32&gt;());
    let my_array = [8; 50];
    println!(&quot;{}&quot;, mem::size_of_val(&amp;my_array));
    let mut some_string = String::from(&quot;Se puede hacer drop de String porque est√° en el heap&quot;);
    mem::drop(some_string);
    // some_string.clear();   Esto podr√≠a entrar en p√°nico
</code></pre></pre>
<p>Esto imprime:</p>
<pre><code class="language-text">4
200
</code></pre>
<p>A continuaci√≥n, se presentan algunos m√©todos de <code>mem</code>:</p>
<p><code>swap()</code>: intercambia valors entre dos variables. Necesita una referencia mutable para cada una de ellas. Es √∫til cuando tienes dos tienes dos cosas que se quieren intercambiar y Rust no deja por las reglas de pr√©stamo. O simplemente, cuando se necesita hacer un intercambio r√°pido entre dos variables.</p>
<p>A continuaci√≥n, se muestra un ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">use std::{mem, fmt};

struct Ring { // Crea un anillo del Se√±or de los Anillos
    owner: String,
    former_owner: String,
    seeker: String, // es la persona busc√°ndolo
}

impl Ring {
    fn new(owner: &amp;str, former_owner: &amp;str, seeker: &amp;str) -&gt; Self {
        Self {
            owner: owner.to_string(),
            former_owner: former_owner.to_string(),
            seeker: seeker.to_string(),
        }
    }
}

impl fmt::Display for Ring { // Para mostrar qui√©n lo tiene y qui√©n lo busca
        fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
            write!(f, &quot;{} tiene el anillo, {} sol√≠a tenerlo, {} lo quiere&quot;, self.owner, self.former_owner, self.seeker)
        }
}

fn main() {
    let mut one_ring = Ring::new(&quot;Frodo&quot;, &quot;Gollum&quot;, &quot;Sauron&quot;);
    println!(&quot;{}&quot;, one_ring);
    mem::swap(&amp;mut one_ring.owner, &amp;mut one_ring.former_owner); // Gollum tiene el anillo fugazmente
    println!(&quot;{}&quot;, one_ring);
}
</code></pre></pre>
<p>Esto imprimir√°:</p>
<pre><code class="language-text">Frodo tiene el anillo, Gollum sol√≠a tenerlo, Sauron lo quiere
Gollum tiene el anillo, Frodo sol√≠a tenerlo, Sauron lo quiere
</code></pre>
<p><code>replace()</code>: se parece a swap y lo usa internamente, como se puede ver:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn replace&lt;T&gt;(dest: &amp;mut T, mut src: T) -&gt; T {
    swap(dest, &amp;mut src);
    src
}
<span class="boring">}
</span></code></pre></pre>
<p>Lo √∫nico que hace es conmutar los valores y devolver el antiguo elemento. As√≠, se puede usar con <code>let</code>. Como por ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">use std::mem;

struct City {
    name: String,
}

impl City {
    fn change_name(&amp;mut self, name: &amp;str) {
        let old_name = mem::replace(&amp;mut self.name, name.to_string());
        println!(
            &quot;La ciudad llamada en el pasado {} ahora se llama {}.&quot;,
            old_name, self.name
        );
    }
}

fn main() {
    let mut capital_city = City {
        name: &quot;Constantinopla&quot;.to_string(),
    };
    capital_city.change_name(&quot;Estambul&quot;);
}
</code></pre></pre>
<p>Esto imprime <code>La ciudad llamada en el pasado Constantinopla ahora se llama Estambul.</code>.</p>
<p><code>.take()</code> es una como <code>.replace()</code>, pero lo sustituye por el valor por defecto en el elemento. Se recordar√° que los valores por defecto suelen ser cosas como 0, &quot;&quot; o similar. Esta es su declaraci√≥n:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
pub fn take&lt;T&gt;(dest: &amp;mut T) -&gt; T
where
    T: Default,
<span class="boring">}
</span></code></pre></pre>
<p>Se pueden hacer cosas como:</p>
<pre><pre class="playground"><code class="language-rust">use std::mem;

fn main() {
    let mut number_vec = vec![8, 7, 0, 2, 49, 9999];
    let mut new_vec = vec![];

    number_vec.iter_mut().for_each(|number| {
        let taker = mem::take(number);
        new_vec.push(taker);
    });

    println!(&quot;{:?}\n{:?}&quot;, number_vec, new_vec);
}
</code></pre></pre>
<p>Como se puede ver en el resultado:</p>
<pre><code class="language-text">[0, 0, 0, 0, 0, 0]
[8, 7, 0, 2, 49, 9999]
</code></pre>
<p>Reemplaza todos los n√∫meros con 0, pero no elimina ning√∫n elemento.</p>
<p>En el caso de tipos propios, <code>Default</code> puede implementar lo que se necesite. En el siguiente ejemplo se dispone de un <code>Banco</code> y un <code>Ladron</code>. Cada vez que roba el <code>Banco</code>, se lleva el dinero del mostrador. Pero el mostrador puede tomar dinero del interior del bano siempre que se necesita, por lo que siempre tiene 50. Se va a construir este tipo para que ese sea su valor por defecto.</p>
<pre><pre class="playground"><code class="language-rust">use std::mem;
use std::ops::{Deref, DerefMut}; // Se usa esto para obtener la potencia de u32

struct Banco {
    dinero_dentro: u32,
    dinero_en_mostrador: DineroMostrador, // Es un &quot;puntero inteligente&quot;. tiene su propio Default, pero usa u32
}

struct DineroMostrador(u32);

impl Default for DineroMostrador {
    fn default() -&gt; Self {
        Self(50) // Siempre 50, no 0
    }
}

impl Deref for DineroMostrador { // Con este rasgo se puede acceder al u32 usando *
    type Target = u32;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}

impl DerefMut for DineroMostrador { // Y con esto se puede restar, sumar, etc.
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
        &amp;mut self.0
    }
}

impl Banco {
    fn comprobar_dinero(&amp;self) {
        println!(
            &quot;Hay {}‚Ç¨ en el banco y {}‚Ç¨ en el mostrador.\n&quot;,
            self.dinero_dentro, *self.dinero_en_mostrador // usa * para imprimir el u32
        );
    }
}

struct Ladron {
    dinero_en_bolsillo: u32,
}

impl Ladron {
    fn comprobar_dinero(&amp;self) {
        println!(&quot;El ladr√≥n tiene {}‚Ç¨ en este momento.\n&quot;, self.dinero_en_bolsillo);
    }

    fn robar_banco(&amp;mut self, Banco: &amp;mut Banco) {
        let nuevo_dinero = mem::take(&amp;mut Banco.dinero_en_mostrador); // Toma el dinero, pero deja siempre 50‚Ç¨ que es el valor por defecto.
        self.dinero_en_bolsillo += *nuevo_dinero; // Usa * porque solo se pueden sumar u32. DineroMostrador no puede sumar
        Banco.dinero_dentro -= *nuevo_dinero;    // Igual aqu√≠
        println!(&quot;¬°Ha robado el banco, ahora tiene {}‚Ç¨!\n&quot;, self.dinero_en_bolsillo);
    }
}

fn main() {
    let mut banco_de_klezkavania = Banco { // Prepara el banco
        dinero_dentro: 5000,
        dinero_en_mostrador: DineroMostrador(50),
    };
    banco_de_klezkavania.comprobar_dinero();

    let mut ladron = Ladron { // Prepara al Ladron
        dinero_en_bolsillo: 50,
    };
    ladron.comprobar_dinero();

    ladron.robar_banco(&amp;mut banco_de_klezkavania); // Roba, despu√©s comprueba el dinero
    ladron.comprobar_dinero();
    banco_de_klezkavania.comprobar_dinero();

    ladron.robar_banco(&amp;mut banco_de_klezkavania); // Vuelve a robar
    ladron.comprobar_dinero();
    banco_de_klezkavania.comprobar_dinero();

}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">Hay 5000‚Ç¨ en el banco y 50‚Ç¨ en el mostrador.

El ladr√≥n tiene 50‚Ç¨ en este momento.

¬°Ha robado el banco, ahora tiene 100‚Ç¨!

El ladr√≥n tiene 100‚Ç¨ en este momento.

Hay 4950‚Ç¨ en el banco y 50‚Ç¨ en el mostrador.

¬°Ha robado el banco, ahora tiene 150‚Ç¨!

El ladr√≥n tiene 150‚Ç¨ en este momento.

Hay 4900‚Ç¨ en el banco y 50‚Ç¨ en el mostrador.
</code></pre>
<p>Se puede obsverar que siempre hay 50‚Ç¨ en el mostrador.</p>
<h2 id="prelude"><a class="header" href="#prelude">prelude</a></h2>
<p>La librer√≠a est√°ndar tiene tambi√©n un preludio, que es lo que hace que no haya que escribir cosas como <code>use std::vec::Vec</code> para crear un <code>Vec</code>. Se pueden ver todos los elementos que contiene <a href="https://doc.rust-lang.org/std/prelude/index.html#prelude-contents">aqu√≠</a>. Ya han aparecido casi todos ellos:</p>
<ul>
<li><code>std::marker::{Copy, Send, Sized, Sync, Unpin}</code>. No se ha visto <code>Unpin</code> antes. Se usa en casi cualquier tipo (como <code>Sized</code>, que tambi√©n es muy com√∫n). <code>Pin</code> significa que no se puede mover de su lugar en la memoria, pero la mayor√≠a de los elementos implementan <code>Unpin</code>, por lo que es posible moverlos. Por ello funcionan m√©todos como <code>std::mem::replace</code>.</li>
<li><code>std::ops::{Drop, Fn, FnMut, FnOnce}</code>.</li>
<li><code>std::mem::drop</code></li>
<li><code>std::boxed::Box</code>.</li>
<li><code>std::borrow::ToOwned</code>. Se ha visto antes con <code>Cow</code>, que puede tomar contenido prestado y convertirlo en propiedad suya. Utiliza <code>.to_owned()</code> para hacerlo. Tambi√©n se puede usar <code>.to_owned()</code> en un <code>&amp;str</code> para convertirlo en <code>String</code> y lo mismo para otros valores prestados.</li>
<li><code>std::clone::Clone</code></li>
<li><code>std::cmp::{PartialEq, PartialOrd, Eq, Ord}</code>.</li>
<li><code>std::convert::{AsRef, AsMut, Into, From}</code>.</li>
<li><code>std::default::Default</code>.</li>
<li><code>std::iter::{Iterator, Extend, IntoIterator, DoubleEndedIterator, ExactSizeIterator}</code>. Anteriormente, se us√≥ <code>.rev()</code> en un iterador: en realidad esta funci√≥n crea un <code>DoubleEndedIterator</code>. Un <code>ExactSizeIterator</code> es algo como <code>0..10</code>: se sabe al inicio que tiene una longitud de 10 elementos. Otros iteradores no conocen su tama√±o con seguridad.</li>
<li><code>std::option::Option::{self, Some, None}</code>.</li>
<li><code>std::result::Result::{self, Ok, Err}</code>.</li>
<li><code>std::string::{String, ToString}</code>.</li>
<li><code>std::vec::Vec</code>.</li>
</ul>
<p>Si por alguna raz√≥n no se deseara cargar el preludio, se debe a√±adir el atributo <code>#![no_implicit_prelude]</code>. Se prueba lo siguiente y se observa que el compilador se queja:</p>
<pre><pre class="playground"><code class="language-rust">// ‚ö†Ô∏è
#![no_implicit_prelude]
fn main() {
    let my_vec = vec![8, 9, 10];
    let my_string = String::from(&quot;Esto no funciona&quot;);
    println!(&quot;{:?}, {}&quot;, my_vec, my_string);
}
</code></pre></pre>
<p>Ahora, Rust desconoce qu√© son determinados elementos y no compila.</p>
<pre><code class="language-text">error: cannot find macro `println` in this scope
 --&gt; src/main.rs:5:5
  |
5 |     println!(&quot;{:?}, {}&quot;, my_vec, my_string);
  |     ^^^^^^^

error: cannot find macro `vec` in this scope
 --&gt; src/main.rs:3:18
  |
3 |     let my_vec = vec![8, 9, 10];
  |                  ^^^

error[E0433]: failed to resolve: use of undeclared type or module `String`
 --&gt; src/main.rs:4:21
  |
4 |     let my_string = String::from(&quot;This won't work&quot;);
  |                     ^^^^^^ use of undeclared type or module `String`

error: aborting due to 3 previous errors
</code></pre>
<p>Para este c√≥digo tan simple, manteniendo que Rust no cargue el preludio, solo hay que a√±adir la librer√≠a est√°ndar con <code>extern crate std</code> y luego a√±adir los elementos que se usan realmente. Quedar√≠a como sigue:</p>
<pre><pre class="playground"><code class="language-rust">#![no_implicit_prelude] 
extern crate std; // Hay que decirle a Rust que se quiere usar la librer√≠a std
use std::vec; // se necesita la macro vec
use std::string::String; // y string
use std::convert::From; // Y este rasgo para convertir de &amp;str a String
use std::println; // y esto para imprimir

fn main() {
    let my_vec = vec![8, 9, 10];
    let my_string = String::from(&quot;Esto s√≠ funciona&quot;);
    println!(&quot;{:?}, {}&quot;, my_vec, my_string);
}
</code></pre></pre>
<p>Ahora s√≠ funciona e imprime <code>[8, 9, 10], Esto s√≠ funciona</code>.</p>
<p>Adem√°s, se puede llegar a utilizar un atributo <code>#![no_std]</code> (se vio anteriormente) cuando no se puede usar ni la pila. La mayor parte del tiempo no es necesario quitar el preludio o <code>std</code>.</p>
<p>En el pasado se usaba mucho m√°s la palabra clave <code>extern</code>. Era necesario para cualquier librer√≠a externa que se quisiera usar. Por ejemplo, para usar <code>rand</code> era necesario escribir:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate rand;
<span class="boring">}
</span></code></pre></pre>
<p>y despu√©s las sentencias <code>use</code> que fuesen necesarias para incorporar m√≥dulos, rasgos, etc. El compilador ya no lo necesita, es suficiente con expresar los diferentes <code>use</code> y el propio compilador se encarga de encontrarlos en las librer√≠as a que correspondan.</p>
<h2 id="time"><a class="header" href="#time">time</a></h2>
<p><code>std::time</code> es donde se encuentran las funciones relacionadas con la fecha y hora (si son necesarias m√°s, se puede usar la librer√≠a <code>chrono</code>). La funci√≥n m√°s sencilla es la que recupera la hora del sistema <code>Instant::now()</code>.</p>
<pre><pre class="playground"><code class="language-rust">use std::time::Instant;

fn main() {
    let time = Instant::now();
    println!(&quot;{:?}&quot;, time);
}
</code></pre></pre>
<p>Si se imprime, se obtiene algo como esto: <code>Instant { tv_sec: 432756, tv_nsec: 504281663 }</code>. Muestra segundos y nanosegundos, lo que no resulta muy √∫til. La <a href="https://doc.rust-lang.org/std/time/struct.Instant.html">p√°gina de documentaci√≥n de <code>Instant</code></a> indica ques &quot;opaco y solo es √∫til con <code>Duration</code>&quot;. Solo es √∫til, comparando distintos momentos del tiempo.</p>
<p>Si se observan los rasgos de este tipo, uno de ellos es <code>Sub&lt;Instant&gt;</code>. Se pueden restar unos de otros. Si se ve su c√≥digo fuente:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Sub&lt;Instant&gt; for Instant {
    type Output = Duration;

    fn sub(self, other: Instant) -&gt; Duration {
        self.duration_since(other)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Toma un <code>Instant</code> y usa <code>.duration_since()</code> para obtener una <code>Duration</code>. Para probarlo, se van a tomar dos instantes separados por un cierto intervalo:</p>
<pre><pre class="playground"><code class="language-rust">use std::time::Instant;

fn main() {
    let time1 = Instant::now();
    let time2 = Instant::now(); // Estos dos instantes est√°n muy cerca entre s√≠

    let mut new_string = String::new();
    loop {
        new_string.push('·É¨'); // Se va a crear un String a√±adiendo una letra 100.000 veces
        if new_string.len() &gt; 100_000 { //  hasta que es de longitud 100.000 
            break;
        }
    }
    let time3 = Instant::now();
    println!(&quot;{:?}&quot;, time2 - time1);
    println!(&quot;{:?}&quot;, time3 - time1);
}
</code></pre></pre>
<p>Esto imprimir√° un <code>Duration</code>:</p>
<pre><code class="language-text">1.025¬µs
683.378¬µs
</code></pre>
<p>En este ejemplo, uno representa un poco m√°s de 1 microsegundo vs. 683 microsegundos. Se observa que construir la cadena de caracteres llev√≥ su tiempo.</p>
<p>Hay una √∫ltima cosa que se puede hacer con un √∫nico <code>Instant</code>. Convertirlo a <code>String</code> con <code>format!(&quot;{:?}&quot;, Instant::now());</code>:</p>
<pre><pre class="playground"><code class="language-rust">use std::time::Instant;

fn main() {
    let time1 = format!(&quot;{:?}&quot;, Instant::now());
    println!(&quot;{}&quot;, time1);
}
</code></pre></pre>
<p>Esto imprime algo as√≠ como <code>Instant { tv_sec: 433468, tv_nsec: 406649320 }</code>. Si se usa <code>.iter()</code>, <code>.rev()</code> y <code>.skip(2)</code>, es posible saltar la llave <code>}</code> final y se puede crear un generador de n√∫meros aleatorios.</p>
<pre><pre class="playground"><code class="language-rust">use std::time::Instant;

fn bad_random_number(digits: usize) {
    if digits &gt; 9 {
        panic!(&quot;El n√∫mero debe ser como m√°ximo de 9 d√≠gitos&quot;);
    }
    let now = Instant::now();
    let output = format!(&quot;{:?}&quot;, now);

    output
        .chars()
        .rev()
        .skip(2)
        .take(digits)
        .for_each(|character| print!(&quot;{}&quot;, character));
    println!();
}

fn main() {
    bad_random_number(1);
    bad_random_number(1);
    bad_random_number(3);
    bad_random_number(3);
}
</code></pre></pre>
<p>Esto imprimir√° algo as√≠ como:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>6
4
967
180
<span class="boring">}
</span></code></pre></pre>
<p>No es un buen generador de n√∫meros aleatorios. Rust tiene librer√≠as mucho mejores para ello, como <code>rand</code> y <code>fastrand</code>. Pero es un ejemplo de lo que se puede hacer con <code>Instant</code> y cierta imaginaci√≥n.</p>
<p>En un hilo es posible parar durante un tiempo con <code>std::thread::sleep</code>. Cuando se hace esto hay que darle una duraci√≥n. Para obtener las unidades necesarias, se puede usar <code>Duration::from_millis()</code>, <code>Duration::from_secs()</code>, etc. Por ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">use std::time::Duration;
use std::thread::sleep;

fn main() {
    let three_seconds = Duration::from_secs(3);
    println!(&quot;Me voy a dormir.&quot;);
    sleep(three_seconds);
    println!(&quot;¬øMe he perdido algo?&quot;);
}
</code></pre></pre>
<p>Esto imprimir√°:</p>
<pre><code class="language-text">Me voy a dormir.
¬øMe he perdido algo?
</code></pre>
<p>Pero el hilo no har√° nada durante esos tres segundos. Normalmente, se usa <code>.sleep()</code> cuando existen diversos hilos que tienen que repetir o intentar algo varias veces, como conectarse a un servicio. En estos casos, se intenta o repite la acci√≥n, despu√©s se duerme duratne un tiempo establecido, hasta que se completa y se vuelve ha realizar la acci√≥n programada. Y as√≠ cada vez que se despierta el hilo.</p>
<h2 id="otras-macros"><a class="header" href="#otras-macros">Otras macros</a></h2>
<p>A continuaci√≥n, se recorren algunas otras macros de Rust.</p>
<h3 id="unreachable"><a class="header" href="#unreachable">unreachable!()</a></h3>
<p>Es una especie de <code>todo!()</code> salvo por ser para c√≥digo que nunca se usar√°. Es posible que exista un <code>match</code> en la que se sepa que una de las ramas nunca se alcanza. Si es as√≠, se escribe esta macro para que el compilador lo sepa y pueda ignorar esa parte.</p>
<p>Por ejemplo, se escribe un programa que imprime algo cada vez que se elige un pa√≠s para vivir. Est√°n en Ucrania y todos son lugares elegibles salvo Chernobyl. El c√≥digo puede ser como sigue:</p>
<pre><pre class="playground"><code class="language-rust">enum UkrainePlaces {
    Kiev,
    Kharkiv,
    Chernobyl, 
    Odesa,
    Dnipro,
}

fn choose_city(place: &amp;UkrainePlaces) {
    use UkrainePlaces::*;
    match place {
        Kiev =&gt; println!(&quot;Vivir√°s en Kiev&quot;),
        Kharkiv =&gt; println!(&quot;Vivir√°s en Kharkiv&quot;),
        Chernobyl =&gt; unreachable!(),
        Odesa =&gt; println!(&quot;Vivir√°s en Odesa&quot;),
        Dnipro =&gt; println!(&quot;Vivir√°s en Dnipro&quot;),
    }
}

fn main() {
    let user_input = UkrainePlaces::Kiev; // El usuario introducir√≠a el lugar de alg√∫n modo sin poder elegir Chernobyl
    choose_city(&amp;user_input);
}
</code></pre></pre>
<p>Este c√≥digo imprimir√° <code>Vivir√°s en Kiev</code>.</p>
<p><code>unreachable!()</code> es √∫til para recordar que esa parte del programa no se va a ejecutar nunca. Hay que estar seguro de ello. Si el compilador llega a entrar en esta funci√≥n, el programa entrar√° en p√°nico.</p>
<p>El compilador avisar√° en los casos en que tenga claro que el programador se ha equivocado y hay c√≥digo inalcanzable que no se haya marcado como tal. Por ejemplo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let true_or_false = true;

    match true_or_false {
        true =&gt; println!(&quot;It's true&quot;),
        false =&gt; println!(&quot;It's false&quot;),
        true =&gt; println!(&quot;It's true&quot;), // Vaya, se ha vuelto a escribir true
    }
}
</code></pre></pre>
<p>Lo anterior, dar√° el siguiente aviso:</p>
<pre><code class="language-text">warning: unreachable pattern
 --&gt; src/main.rs:7:9
  |
7 |         true =&gt; println!(&quot;It's true&quot;),
  |         ^^^^
  |
</code></pre>
<h3 id="column-line-file-module_path"><a class="header" href="#column-line-file-module_path">column!, line!, file!, module_path!</a></h3>
<p>Estas cuatro macros son parecidas a <code>dbg!()</code> porque solo se incorporan para obtener informaci√≥n de depuraci√≥n. No necesitan par√°metros, se uan con los par√©ntesis, sin nada m√°s. Son f√°ciles de aprender juntas:</p>
<ul>
<li><code>column!()</code> muestra la columna en la que se escribi√≥.</li>
<li><code>file!()</code> muestra el nombre del fichero en el que se escribi√≥.</li>
<li><code>line!()</code> muestra el n√∫mero de l√≠na en la que se escribi√≥.</li>
<li><code>module_path!()</code> muestra el m√≥dulo en el que se encuentra.</li>
</ul>
<p>El c√≥digo siguiente muestra su uso. Se simula la creaci√≥n de diversos m√≥dulos (unos dentro de otros) para que se vea el resultado de estas macros:</p>
<pre><pre class="playground"><code class="language-rust">pub mod something {
    pub mod third_mod {
        pub fn print_a_country(input: &amp;mut Vec&lt;&amp;str&gt;) {
            println!(
                &quot;The last country is {} inside the module {}&quot;,
                input.pop().unwrap(),
                module_path!()
            );
        }
    }
}

fn main() {
    use something::third_mod::*;
    let mut country_vec = vec![&quot;Portugal&quot;, &quot;Czechia&quot;, &quot;Finland&quot;];
    
    // do some stuff
    println!(&quot;Hello from file {}&quot;, file!());

    // do some stuff
    println!(
        &quot;On line {} we got the country {}&quot;,
        line!(),
        country_vec.pop().unwrap()
    );

    // do some more stuff

    println!(
        &quot;The next country is {} on line {} and column {}.&quot;,
        country_vec.pop().unwrap(),
        line!(),
        column!(),
    );

    // lots more code

    print_a_country(&amp;mut country_vec);
}
</code></pre></pre>
<p>Este c√≥digo imprime:</p>
<pre><code class="language-text">Hello from file src/main.rs
On line 23 we got the country Finland
The next country is Czechia on line 32 and column 9.
The last country is Portugal inside the module playground::something::third_mod
</code></pre>
<h3 id="cfg"><a class="header" href="#cfg">cfg!</a></h3>
<p>Se sabe que se pueden usar atributos como <code>#[cfg(test)]</code> y <code>#[cfg(windows)]</code> para informar al compilador qu√© hacer en ciertos casos. En el caso de <code>test</code> se ejecuta el c√≥digo marcado por el atributo si se est√° ejecutando el programa en modo test (usando <code>cargo test</code>). Cuando se usa <code>windows</code>, se ejecuta el c√≥digo cuando el sistema operativo es Windows. Pero puede ser que solo se quiera cambiar una peque√±a parte de c√≥digo dependiendo del sistema operativo en que se ejecute. Es en este caso, cuando esta macro es √∫til. Devuelve un <code>bool</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let helpful_message = if cfg!(target_os = &quot;windows&quot;) { &quot;backslash&quot; } else { &quot;slash&quot; };

    println!(
        &quot;...then in your hard drive, type the directory name followed by a {}. Then you...&quot;,
        helpful_message
    );
}
</code></pre></pre>
<p>Este trozo de c√≥digo imprimir√° diferente texto en funci√≥n del sistema operativo en que se encuentre. El playground de Rust se ejecuta en Linux, por lo que se imprime:</p>
<pre><code class="language-text">...then in your hard drive, type the directory name followed by a slash. Then you...
</code></pre>
<p><code>cfg!()</code> funciona para cualquier configuraci√≥n disponible. El c√≥digo siguiente muestra c√≥mo ejecutar algo cuando se est√° en un test.</p>
<pre><pre class="playground"><code class="language-rust">#[cfg(test)] // cfg! buscar√° la existencia de este atributo de configuraci√≥n
mod testing {
    use super::*;
    #[test]
    fn check_if_five() {
        assert_eq!(bring_number(true), 5); // Esta funci√≥n comprueba que bring_number() devolver√° 5
    }
}

fn bring_number(should_run: bool) -&gt; u32 { // esta funci√≥n comprueba si debe ejecutarse o no
    if cfg!(test) &amp;&amp; should_run { // Si se tiene que ejecutar y est√° en test, devuelve 5
        5
    } else if should_run { // Si no es test devuelve 5 e imprime
        println!(&quot;Returning 5. This is not a test&quot;);
        5
    } else {
        println!(&quot;This shouldn't run, returning 0.&quot;); // en otro caso devuelve 0
        0
    }
}

fn main() {
    bring_number(true);
    bring_number(false);
}
</code></pre></pre>
<p>Este c√≥digo devolver√°:</p>
<pre><code class="language-text">Returning 5. This is not a test
This shouldn't run, returning 0.
</code></pre>
<p>Cuando no est√° en modo test. Cuando se ejecuta en modo test (<code>cargo test</code>), ejecutar√° la preuba y en este caso, siempre devuelve 5, por lo que pasar√° el test.</p>
<pre><code class="language-text">running 1 test
test testing::check_if_five ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="56.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="58.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="56.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="58.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
