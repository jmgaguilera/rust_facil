<!DOCTYPE HTML>
<html lang="es" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Traits (Rasgos) - Rust en espa√±ol f√°cil</title>
        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="actualizaciones.html">Actualizaciones</a></li><li class="chapter-item expanded affix "><a href="introduccion.html">Introducci√≥n</a></li><li class="chapter-item expanded affix "><a href="quiensoy.html">¬øQui√©n soy?</a></li><li class="chapter-item expanded affix "><a href="escritura.html">La escritura de Rust en ingl√©s f√°cil</a></li><li class="chapter-item expanded affix "><li class="part-title">Parte 1 - Rust en tu navegador</li><li class="chapter-item expanded "><a href="01.html"><strong aria-hidden="true">1.</strong> El entorno de pruebas de Rust</a></li><li class="chapter-item expanded "><a href="02.html"><strong aria-hidden="true">2.</strong> üöß y ‚ö†Ô∏è</a></li><li class="chapter-item expanded "><a href="03.html"><strong aria-hidden="true">3.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="04.html"><strong aria-hidden="true">4.</strong> Tipos de dato</a></li><li class="chapter-item expanded "><a href="05.html"><strong aria-hidden="true">5.</strong> Inferencia de tipos de dato</a></li><li class="chapter-item expanded "><a href="06.html"><strong aria-hidden="true">6.</strong> Imprimiendo '¬°Hola, mundo!'</a></li><li class="chapter-item expanded "><a href="07.html"><strong aria-hidden="true">7.</strong> La visualizaci√≥n y depuraci√≥n</a></li><li class="chapter-item expanded "><a href="08.html"><strong aria-hidden="true">8.</strong> Mutabilidad (cambio)</a></li><li class="chapter-item expanded "><a href="09.html"><strong aria-hidden="true">9.</strong> La pila, la memoria din√°mica y los punteros</a></li><li class="chapter-item expanded "><a href="10.html"><strong aria-hidden="true">10.</strong> M√°s sobre impresi√≥n</a></li><li class="chapter-item expanded "><a href="11.html"><strong aria-hidden="true">11.</strong> Cadenas de caracteres</a></li><li class="chapter-item expanded "><a href="12.html"><strong aria-hidden="true">12.</strong> const y static</a></li><li class="chapter-item expanded "><a href="13.html"><strong aria-hidden="true">13.</strong> Algo m√°s sobre referencias</a></li><li class="chapter-item expanded "><a href="14.html"><strong aria-hidden="true">14.</strong> Referencias modificables (mutables)</a></li><li class="chapter-item expanded "><a href="15.html"><strong aria-hidden="true">15.</strong> Paso de referencias a funciones</a></li><li class="chapter-item expanded "><a href="16.html"><strong aria-hidden="true">16.</strong> Copia</a></li><li class="chapter-item expanded "><a href="17.html"><strong aria-hidden="true">17.</strong> Tipos colecci√≥n</a></li><li class="chapter-item expanded "><a href="18.html"><strong aria-hidden="true">18.</strong> Vectores</a></li><li class="chapter-item expanded "><a href="19.html"><strong aria-hidden="true">19.</strong> Tuplas</a></li><li class="chapter-item expanded "><a href="20.html"><strong aria-hidden="true">20.</strong> Estructuras de control</a></li><li class="chapter-item expanded "><a href="21.html"><strong aria-hidden="true">21.</strong> Estructuras - struct</a></li><li class="chapter-item expanded "><a href="22.html"><strong aria-hidden="true">22.</strong> Enumerados - enum</a></li><li class="chapter-item expanded "><a href="23.html"><strong aria-hidden="true">23.</strong> Bucles</a></li><li class="chapter-item expanded "><a href="24.html"><strong aria-hidden="true">24.</strong> Implementando structs y enums</a></li><li class="chapter-item expanded "><a href="25.html"><strong aria-hidden="true">25.</strong> Desestructurar</a></li><li class="chapter-item expanded "><a href="26.html"><strong aria-hidden="true">26.</strong> Referencias y el operador punto .</a></li><li class="chapter-item expanded "><a href="27.html"><strong aria-hidden="true">27.</strong> Gen√©ricos</a></li><li class="chapter-item expanded "><a href="28.html"><strong aria-hidden="true">28.</strong> Los enumerados Option y Result</a></li><li class="chapter-item expanded "><a href="29.html"><strong aria-hidden="true">29.</strong> Otras colecciones</a></li><li class="chapter-item expanded "><a href="30.html"><strong aria-hidden="true">30.</strong> El operador ?</a></li><li class="chapter-item expanded "><a href="31.html" class="active"><strong aria-hidden="true">31.</strong> Traits (Rasgos)</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust en espa√±ol f√°cil</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="traits-rasgos"><a class="header" href="#traits-rasgos">Traits (Rasgos)</a></h1>
<p>Anteriormente, se han visto algunos <em>traits</em><sup class="footnote-reference"><a href="#1">1</a></sup> (rasgos). <code>Debug</code>, <code>Copy</code> y <code>Clone</code> son traits  (rasgos). Para que un tipo tenga un trait (rasgo) hay que implementarlo. Puesto que algunos traits son tan comunes (como <code>Debug</code>), existen atributos en Rust que los implementan autom√°ticamente (con una implementaci√≥n por defecto). Esto es lo que sucede cuando se escribe <code>#[derive(Debug)]</code>: se implementa de forma autom√°tica el trait <code>Debug</code>.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct MiStruct {
    numero: usize,
}

fn main() {}
</code></pre></pre>
<p>Pero hay otros traits que son m√°s dif√≠ciles de implementar y hay que hacerlo a mano con <code>impl</code>. Por ejemplo, el trait <code>Add</code>, que se encuentra en <code>std::ops::Add</code> y se utiliza para sumar dos cosas. Pero Rust no puede adivinar c√≥mo se pueden sumar dos cosas cualquiera, por lo que hay qu√© codificarlo.</p>
<pre><pre class="playground"><code class="language-rust">struct CosasASumar {
    primera_cosa: u32,
    segunda_cosa: f32,
}

fn main() {}
</code></pre></pre>
<p>Se pueden sumar <code>primera_cosa</code> y <code>segunda_cosa</code>, pero hay que dar m√°s informaci√≥n. Puede que se quiera sumar <code>f32</code>, algo as√≠:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
let resultado = self.segunda_cosa + self.primera_cosa as f32
<span class="boring">}
</span></code></pre></pre>
<p>O puede que se quiera poner <code>self.primera_cosa</code> junto a <code>self.segunda_cosa</code> y que sea as√≠ como se quiera sumar. As√≠ la suma de 55 a 33.4 ser√≠a 5533.4 y no 88.4.</p>
<p>A continuaci√≥n, se analiza en primer lugar como se crea un trait. Lo importante es recordar que los trait sirven para describir un comportamiento determinado de quien los implementen. Para crear un trait, se escribe <code>trait</code> y se crean algunas funciones (o ninguna).</p>
<pre><pre class="playground"><code class="language-rust">struct Animal { // Un simple struct - un Animal que solo contiene su nombre
    nombre: String,
}

trait Perro { // El trait Perro asigna alguna funcionalidad
    fn ladrar(&amp;self) { // Puede ladrar
        println!(&quot;¬°Guau, guau!&quot;);
    }
    fn correr(&amp;self) { // y puede correr
        println!(&quot;¬°El perro est√° corriendo!&quot;);
    }
}

impl Perro for Animal {} // Ahora el Animal implementa el trait Perro

fn main() {
    let rover = Animal {
        nombre: &quot;Rover&quot;.to_string(),
    };

    rover.ladrar(); // El Animal puede usar ladrar()
    rover.correr();  // y puede usar correr()
}
</code></pre></pre>
<p>As√≠ est√° bien, pero no se quiere imprimir &quot;¬°El perro est√° corriendo!&quot;. Se pueden modificar los m√©todos que implementa por defecto un trait, para ello la nueva implementaci√≥n tiene que tener la misma declaraci√≥n. Esto significa que tiene que tomar los mismos par√°metros y devolver el mismo tipo de resultado. Por ejemplo, se puede modificar el m√©todo <code>.correr()</code>. La declaraci√≥n indica:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
fn correr(&amp;self) {
    println!(&quot;¬°El perro est√° corriendo!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p><code>fn correr(&amp;self)</code> significa que la funci√≥n <code>correr()</code> tiene de par√°metro <code>&amp;self</code> y no devuelve ning√∫n valor. Por lo que no se puede definir una nueva implementaci√≥n as√≠:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn correr(&amp;self) -&gt; i32 { // ‚ö†Ô∏è
    5
}
<span class="boring">}
</span></code></pre></pre>
<p>Rust se quejar√° as√≠:</p>
<pre><code class="language-text">   = note: expected fn pointer `fn(&amp;Animal)`
              found fn pointer `fn(&amp;Animal) -&gt; i32`
</code></pre>
<p>Pero s√≠ se puede hacer esto:</p>
<pre><pre class="playground"><code class="language-rust">struct Animal { // Un simple struct - un Animal que solo contiene su nombre
    nombre: String,
}

trait Perro { // El trait Perro asigna alguna funcionalidad
    fn ladrar(&amp;self) { // Puede ladrar
        println!(&quot;¬°Guau, guau!&quot;);
    }
    fn correr(&amp;self) { // y puede correr
        println!(&quot;¬°El perro est√° corriendo!&quot;);
    }
}

impl Perro for Animal { // Ahora el Animal implementa el trait Perro
    fn correr(&amp;self) {
        println!(&quot;¬°{} est√° corriendo!&quot;, self.nombre);
    }
}

fn main() {
    let rover = Animal {
        nombre: &quot;Rover&quot;.to_string(),
    };

    rover.ladrar(); // El Animal puede usar ladrar()
    rover.correr();  // y puede usar correr()
}
</code></pre></pre>
<p>Ahora imprime <code>¬°Rover est√° corriendo!</code>. Esta funci√≥n es correcta porque devuelve <code>()</code> o nada, que es lo que indica la implementaci√≥n del trait.</p>
<p>Cuando se define un trait, se puede escribir solo la declaraci√≥n de las funciones. Esto obliga a que quien lo quiera implementar tenga que escribir el c√≥digo que desea para las funciones que solo est√°n declaradas en el trait (sin implementar). En el c√≥digo siguiente el trait solo declara las funciones sin aportar una definici√≥n por defecto de <code>ladrar()</code> y <code>correr()</code>, por eso se obliga a escribir el c√≥digo en la implementaci√≥n del trait por parte del Perro.</p>
<pre><pre class="playground"><code class="language-rust">struct Animal {
    nombre: String,
}

trait Perro {
    fn ladrar(&amp;self); // Solo se indica que necesita el par√°metro &amp;self y que no devuelva nada

    fn correr(&amp;self); // necesita &amp;self y que no devuelva nada
    // Ahora se tiene que escribir el c√≥digo en la implementaci√≥n del Perro
}

impl Perro for Animal {

    fn ladrar(&amp;self) {
        println!(&quot;¬°{}, para de ladrar!&quot;, self.nombre);
    }
    
    fn correr(&amp;self) {
        println!(&quot;¬°{} est√° corriendo!&quot;, self.nombre);
    }

}

fn main() {
    let rover = Animal {
        nombre: &quot;Rover&quot;.to_string(),
    };

    rover.ladrar();
    rover.correr();
}
</code></pre></pre>
<p>Cuando se crea un trait (rasgo), se debe pensar: ¬øQu√© funciones deber√° tener? ¬øqu√© funciones se pueden implementar en el propio trait? y ¬øqu√© funciones deber√° implementar el propio usuario?</p>
<p>A continuaci√≥n se implementa el trait <code>Display</code> para el siguiente struct simple:</p>
<pre><pre class="playground"><code class="language-rust">struct Gato {
    nombre: String,
    edad: u8,
}

fn main() {
    let mr_mantle = Gato {
        nombre: &quot;Reggie Mantle&quot;.to_string(),
        edad: 4,
    };
}
</code></pre></pre>
<p>Se quiere imprimir <code>mr_mantle</code>. <code>Debug</code> es f√°cil de derivar:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Gato {
    nombre: String,
    edad: u8,
}

fn main() {
    let mr_mantle = Gato {
        nombre: &quot;Reggie Mantle&quot;.to_string(),
        edad: 4,
    };

    println!(&quot;Mr. Mantle es un {:?}&quot;, mr_mantle);
}
</code></pre></pre>
<p>Pero la implementaci√≥n de Debug no es muy bonita. Este es el resultado:</p>
<pre><code class="language-text">Mr. Mantle es un Gato { nombre: &quot;Reggie Mantle&quot;, edad: 4 }
</code></pre>
<p>Por eso, se tiene que implementar <code>Display</code> para un <code>Gato</code> si se quiere que la impresi√≥n sea bonita. En <a href="https://doc.rust-lang.org/std/fmt/trait.Display.html">https://doc.rust-lang.org/std/fmt/trait.Display.html</a> se puede ver la informaci√≥n detallada para Display con un ejemplo que dice:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Position {
    longitude: f32,
    latitude: f32,
}

impl fmt::Display for Position {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.longitude, self.latitude)
    }
}

fn main() {}
</code></pre></pre>
<p>Hay algunas cosas que a√∫n no se entienden en este c√≥digo, como <code>&lt;'_&gt;</code> y lo que hace <code>f</code>. Pero se entiende que el struct <code>Position</code> tiene √∫nicamente dos valores <code>f32</code>. Los campos de este struct son <code>self.longitude</code> y <code>self.latitude</code>. As√≠ que posiblemente se pueda utilizar este c√≥digo ara implementar la versi√≥n que se necesita para <code>Gato</code>, cambiando los campos por <code>self.nombre</code> y <code>self.edad</code>. Por √∫ltimo, <code>write!</code> se parece mucho a <code>println!</code>. As√≠, el c√≥digo queda:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Gato {
    nombre: String,
    edad: u8,
}

impl fmt::Display for Gato {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;{} es un gato de {} a√±os.&quot;, self.nombre, self.edad)
    }
}

fn main() {}
</code></pre></pre>
<p>Si ahora se a√±ade una funci√≥n <code>fn main()</code>, el c√≥digo queda as√≠:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Gato {
    nombre: String,
    edad: u8,
}

impl fmt::Display for Gato {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;{} es un gato de {} a√±os.&quot;, self.nombre, self.edad)
    }
}

fn main() {
    let mr_mantle = Gato {
        nombre: &quot;Reggie Mantle&quot;.to_string(),
        edad: 4,
    };

    println!(&quot;{}&quot;, mr_mantle);
}
</code></pre></pre>
<p>¬°Estupendo! Ahora, cuando se usa <code>{}</code> para imprimir a un Gato, se obtiene <code>Reggie Mantle es un gato de 4 a√±os.</code>, que queda mucho mejor.</p>
<p>Por cierto, cuando se implementa el trait <code>Display</code> se dispone del trait <code>ToString</code> sin nada que hacer adicionalmente. Esto pasa al usar la macro <code>format!</code> que facilita la creaci√≥n de un <code>String</code> con la funci√≥n <code>.to_string()</code>. As√≠ que se puede hacer algo como lo siguiente cuando se pasa la variable <code>reggie_mantle</code> a una funci√≥n que necesite un <code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;
struct Gato {
    nombre: String,
    edad: u8,
}

impl fmt::Display for Gato {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;{} es un gato de {} a√±os.&quot;, self.nombre, self.edad)
    }
}

fn print_gatos(mascota: String) {
    println!(&quot;{}&quot;, mascota);
}

fn main() {
    let mr_mantle = Gato {
        nombre: &quot;Reggie Mantle&quot;.to_string(),
        edad: 4,
    };

    print_gatos(mr_mantle.to_string()); // Lo convierte en un String
    println!(&quot;La cadena de caracteres de Mr. Mantle tiene {} letras.&quot;,
        mr_mantle.to_string().chars().count()); // Los convierte en caracteres y los cuenta
}
</code></pre></pre>
<p>Lo anterior imprime:</p>
<pre><code class="language-text">Reggie Mantle es un gato de 4 a√±os.
La cadena de caracteres de Mr. Mantle tiene 35 letras.
</code></pre>
<p>Lo que se debe recordar sobre los rasgos es que tratan sobre el comportamiento de algo. ¬øC√≥mo se comporta un determinado <code>struct</code>? ¬øQu√© puede hacer? Para eso son los rasgos. Si se revisan los rasgos que se han visto hasta el momento, todos tratan sobre alg√∫n comportamiento: <code>Copy</code>es algo que un tipo determinado puede hacer. <code>Display</code> tambi√©n es algo que un tipo puede hacer. <code>ToString</code> es otro rasgo y tambi√©n es algo que un tipo puede hacer: convertirse en una <code>String</code>. En el rasgo <code>Perro</code> la palabra <em>perro</em> no significa algo que se pueda hacer, pero proporciona algunos m√©todos que le permiten hacer cosas. Se puede implementar para una estructura <code>Caniche</code> o para una <code>Chucho</code> y as√≠ ambas podr√≠an disponer de los m√©todos de <code>Perro</code>.</p>
<p>A continuaci√≥n se presenta otro ejemplo a√∫n m√°s conectado con algo que solo es comportamiento. Se imaginar√° un juego de fantas√≠a con algunos personajes simples. Uno es un <code>Monstruo</code>, los otros dos son <code>Mago</code> y <code>Cazador</code>. El <code>Monstruo</code> tiene <code>salud</code> y se le puede atacar, los otros dos no tendr√°n nada a√∫n. Se crear√°n dos rasgos (traits). Uno llamado <code>LuchaCercana</code> que permite luchar de cerca y otro <code>LuchaADistancia</code> que permite lugar desde lejos. Solo el <code>Cazador</code> puede usar <code>LuchaADistancia</code>. Este es el c√≥digo resultante:</p>
<pre><pre class="playground"><code class="language-rust">struct Monstruo {
    salud: i32,
}

struct Mago {}
struct Cazador {}

trait LuchaCercana {
    fn atacar_con_espada(&amp;self, oponente: &amp;mut Monstruo) {
        oponente.salud -= 10;
        println!(
            &quot;Atacaste con espada. Tu oponente tiene ahora {} de salud.&quot;,
            oponente.salud
        );
    }
    fn atacar_con_la_mano(&amp;self, oponente: &amp;mut Monstruo) {
        oponente.salud -= 2;
        println!(
            &quot;Atacaste con la mano. tu oponente tiene ahora {} de salud.&quot;,
            oponente.salud
        );
    }
}
impl LuchaCercana for Mago {}
impl LuchaCercana for Cazador {}

trait LuchaADistancia {
    fn atacar_con_arco(&amp;self, oponente: &amp;mut Monstruo, distancia: u32) {
        if distancia &lt; 10 {
            oponente.salud -= 10;
            println!(
                &quot;Atacaste con el arco. Tu oponente tiene ahora {} de salud.&quot;,
                oponente.salud
            );
        }
    }
    fn atacar_con_piedra(&amp;self, oponente: &amp;mut Monstruo, distancia: u32) {
        if distancia &lt; 3 {
            oponente.salud -= 4;
        }
        println!(
            &quot;Atacaste con una piedra. Your oponente tiene ahora {} de salud.&quot;,
            oponente.salud
        );
    }
}
impl LuchaADistancia for Cazador {}

fn main() {
    let radagast = Mago {};
    let aragorn = Cazador {};

    let mut uruk_hai = Monstruo { salud: 40 };

    radagast.atacar_con_espada(&amp;mut uruk_hai);
    aragorn.atacar_con_arco(&amp;mut uruk_hai, 8);
}
</code></pre></pre>
<p>Lo anterior imprime:</p>
<pre><code class="language-text">Atacaste con espada. Tu oponente tiene ahora 30 de salud.
Atacaste con el arco. Tu oponente tiene ahora 20 de salud.
</code></pre>
<p>En este ejemplo, se pasa constantemente <code>self</code> a los m√©todos de los rasgos, pero solo se conoce que se trata de un tipo que implementa el propio rasgo. Puede ser un <code>Mago</code> o un <code>Cazador</code>. O podr√≠a ser una nueva <code>struct</code> llamada <code>Toefocfgetobjtnode</code> o cualquier otra que implementara el rasgo correspondiente. Para facilitar que <code>self</code> tenga m√°s funcionalidad, se puede a√±adir restricciones a un <code>trait</code>. Se puede a√±adir otros <code>trait</code> que son necesarios para el <code>trait</code> que se define. Por ejemplo, si que se quiere que en los m√©todos de un <code>trait</code> se pueda usar <code>{:?}</code> para imprimir, se necesita que implemente el trait <code>Debug</code>. Eso se puede indicar mediante la escritura de <code>:</code> (dos puntos). As√≠ quedar√≠a el c√≥digo:</p>
<pre><pre class="playground"><code class="language-rust">struct Monstruo {
    salud: i32,
}

#[derive(Debug)] // Ahora el mago tiene Debug
struct Mago {
    salud: i32, // Ahora el mago tiene salud
}

#[derive(Debug)] // Ahora el Cazador tiene Debug
struct Cazador {
    salud: i32, // Ahora el cazador tiene salud
}

trait LuchaCercana: std::fmt::Debug {
    // Ahora el tipo necesita tener Debug 
    // para poder implementar LuchaCercana
    fn atacar_con_espada(&amp;self, oponente: &amp;mut Monstruo) {
        oponente.salud -= 10;
        println!(
            &quot;Atacaste con espada. Tu oponente tiene ahora {} de salud. Ahora tienes {:?}&quot;,
            // se puede usar {:?} porque se dispone de Debug
            oponente.salud, &amp;self
        );
    }
    fn atacar_con_la_mano(&amp;self, oponente: &amp;mut Monstruo) {
        oponente.salud -= 2;
        println!(
            &quot;Atacaste con la mano. tu oponente tiene ahora {} de salud. Ahora tienes {:?}&quot;,
            oponente.salud, &amp;self
        );
    }
}
impl LuchaCercana for Mago {}
impl LuchaCercana for Cazador {}

trait LuchaADistancia: std::fmt::Debug {
    // tambi√©n se podr√≠a haber escrito LuchaADistancia: LuchaCercana
    // porque LuchaCercana implementa ya Debug
    fn atacar_con_arco(&amp;self, oponente: &amp;mut Monstruo, distancia: u32) {
        if distancia &lt; 10 {
            oponente.salud -= 10;
            println!(
                &quot;Atacaste con el arco. Tu oponente tiene ahora {} de salud. Ahora tienes {:?}&quot;,
                oponente.salud, &amp;self
            );
        }
    }
    fn atacar_con_piedra(&amp;self, oponente: &amp;mut Monstruo, distancia: u32) {
        if distancia &lt; 3 {
            oponente.salud -= 4;
        }
        println!(
            &quot;Atacaste con una piedra. Your oponente tiene ahora {} de salud. Ahora tienes {:?}&quot;,
            oponente.salud, &amp;self
        );
    }
}
impl LuchaADistancia for Cazador {}

fn main() {
    let radagast = Mago { salud: 60 };
    let aragorn = Cazador { salud: 80 };

    let mut uruk_hai = Monstruo { salud: 40 };

    radagast.atacar_con_espada(&amp;mut uruk_hai);
    aragorn.atacar_con_arco(&amp;mut uruk_hai, 8);
}
</code></pre></pre>
<p>Ahora, se imprime:</p>
<pre><code class="language-text">Atacaste con espada. Tu oponente tiene ahora 30 de salud. Ahora tienes Mago { salud: 60 }
Atacaste con el arco. Tu oponente tiene ahora 20 de salud. Ahora tienes Cazador { salud: 80 }
</code></pre>
<p>En un juego real ser√≠a mejor reescribir esto para cada tipo, ya que <code>Ahora tienes Mago { salud: 60 }</code> queda muy raro. Por eso, los m√©todos predefinidos de los rasgos suelen ser muy simples, porque no se conoce el tipo que lo va a usar. No se puede escribir algo como <code>self.0 += 10</code>, por ejemplo. En cualquier caso, el ejemplo anterior muestra c√≥mo se puede usar otro trait dentro de uno que se est√© escribiendo y disponer as√≠ de los m√©todos de ese otro.</p>
<p>Otra forma de usar un rasgo es mediante lo que se llama <code>trait bounds</code> (N.T.: l√≠mites de un rasgo). Son f√°ciles de implementar ya que no necesitan nada. A continuaci√≥n, se reescribe el ejemplo anterior sin que los rasgos implementen ning√∫n m√©todo, a cambio, se dispone de funciones que necesitan rasgos para que se puedan usar.</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Debug;  // para no tener que escribir todo el camino al rasgo

struct Monstruo {
    salud: i32,
}

#[derive(Debug)]
struct Mago {
    salud: i32,
}
#[derive(Debug)]
struct Cazador {
    salud: i32,
}

trait Magia{} // todos los traits sin m√©todos. Son l√≠mites de rasgo


trait LuchaCercana {}
trait LuchaADistancia {}

impl LuchaCercana for Cazador{} // Cada tipo tiene LuchaCercana,
impl LuchaCercana for Mago {}
impl LuchaADistancia for Cazador{} // Pero solo el cazador lucha a distancia
impl Magia for Mago{}  // y solo el mago hace magia

fn atacar_con_flecha&lt;T: LuchaADistancia + Debug&gt;(personaje: &amp;T, oponente: &amp;mut Monstruo, distancia: u32) {
    if distancia &lt; 10 {
        oponente.salud -= 10;
        println!(
            &quot;Atacaste con el arco. Tu oponente tiene ahora {} de salud. Ahora tienes {:?}&quot;,
            oponente.salud, personaje
        );
    }
}

fn atacar_con_espada&lt;T: LuchaCercana + Debug&gt;(personaje: &amp;T, oponente: &amp;mut Monstruo) {
    oponente.salud -= 10;
    println!(
        &quot;Atacaste con la espada. Tu oponente tiene ahora {} de salud. Ahora tienes {:?}&quot;,
        oponente.salud, personaje
    );
}

fn atacar_con_bola_de_fuego&lt;T: Magia + Debug&gt;(personaje: &amp;T, oponente: &amp;mut Monstruo, distancia: u32) {
    if distancia &lt; 15 {
        oponente.salud -= 20;
        println!(&quot;¬°Levantas las manos y conjuras una bola de fuego! Tu oponente tiene ahora {} de salud. Ahora tienes: {:?}&quot;,
    oponente.salud, personaje);
    }
}

fn main() {
    let radagast = Mago { salud: 60 };
    let aragorn = Cazador { salud: 80 };

    let mut uruk_hai = Monstruo { salud: 40 };

    atacar_con_espada(&amp;radagast, &amp;mut uruk_hai);
    atacar_con_flecha(&amp;aragorn, &amp;mut uruk_hai, 8);
    atacar_con_bola_de_fuego(&amp;radagast, &amp;mut uruk_hai, 8);
}
</code></pre></pre>
<pre><code class="language-text">Atacaste con la espada. Tu oponente tiene ahora 30 de salud. Ahora tienes Mago { salud: 60 }
Atacaste con el arco. Tu oponente tiene ahora 20 de salud. Ahora tienes Cazador { salud: 80 }
¬°Levantas las manos y conjuras una bola de fuego! Tu oponente tiene ahora 0 de salud. Ahora tienes: Mago { salud: 60 }
</code></pre>
<p>Se puede ver que hay varias formas de obtener el mismo resultado cuando se usan rasgos. Todo depende de lo que tenga m√°s sentido en el programa que se est√° escribiendo.</p>
<p>A continuaci√≥n, se echa un vistazo a c√≥mo implementar algunos de los rasgos m√°s usados en Rust.</p>
<h2 id="el-rasgo-from"><a class="header" href="#el-rasgo-from">El rasgo From</a></h2>
<p><em>From</em> es un rasgo muy √∫til que ya se ha usado. Con <em>From</em> se puede crear una <code>String</code> a partir de una <code>&amp;str</code>, pero se puede usar para convertir cualquier tipo en otro. Por ejemplo, <code>Vec</code> utiliza <em>From</em> para lo siguiente:</p>
<pre><code class="language-text">From&lt;&amp;'_ [T]&gt;
From&lt;&amp;'_ mut [T]&gt;
From&lt;&amp;'_ str&gt;
From&lt;&amp;'a Vec&lt;T&gt;&gt;
From&lt;[T; N]&gt;
From&lt;BinaryHeap&lt;T&gt;&gt;
From&lt;Box&lt;[T]&gt;&gt;
From&lt;CString&gt;
From&lt;Cow&lt;'a, [T]&gt;&gt;
From&lt;String&gt;
From&lt;Vec&lt;NonZeroU8&gt;&gt;
From&lt;Vec&lt;T&gt;&gt;
From&lt;VecDeque&lt;T&gt;&gt;
</code></pre>
<p>Implementa un mont√≥n de <code>Vec::from()</code> que no se han usado a√∫n en este manual. Se pueden usar algunos para ver qu√© pasa.</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display; // se usar√° Display para crear una funci√≥n gen√©rica y mostrar el resultado

fn print_vec&lt;T: Display&gt;(input: &amp;Vec&lt;T&gt;) { // Toma cualquier Vec&lt;T&gt; cuyo tipo T que tenga Display
    for item in input {
        print!(&quot;{} &quot;, item);
    }
    println!();
}

fn main() {

    let array_vec = Vec::from([8, 9, 10]); // &quot;from&quot; un array
    print_vec(&amp;array_vec);

    let str_vec = Vec::from(&quot;¬øQu√© clase de vector ser√©?&quot;); // Array &quot;from&quot; un &amp;str
    print_vec(&amp;str_vec);

    let string_vec = Vec::from(&quot;Un String ¬øQu√© clase de vector ser√°?&quot;.to_string()); // Tambi√©n &quot;from&quot; un String
    print_vec(&amp;string_vec);
}
</code></pre></pre>
<p>Se imprime lo siguiente:</p>
<pre><code class="language-text">8 9 10
87 104 97 116 32 107 105 110 100 32 111 102 32 118 101 99 32 119 105 108 108 32 73 32 98 101 63
87 104 97 116 32 107 105 110 100 32 111 102 32 118 101 99 32 119 105 108 108 32 97 32 83 116 114 105 110 103 32 98 101 63
</code></pre>
<p>Si se observa el tipo, los segundo y tercer vector son de tipo <code>Vec&lt;u8&gt;</code>, lo que significa que contiene los bytes de <code>&amp;str</code> y <code>String</code>. Se ve as√≠ que <code>From</code> es muy flexible y se usa mucho.</p>
<p>El siguiente ejemplo implemente <code>From</code> en tipos desarrollados en el c√≥digo. Se construyen dos structs y luego implementan <code>From</code> para una de ellas. Una ser√° una <code>Ciudad</code> y la otra un <code>Pais</code>. Se quiere que sea posible hacer esto: <code>let country_nombre = Pais::from(vector_de_ciudades)</code>.</p>
<p>Queda as√≠ el c√≥digo:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)] // Para poder imprimir la Ciudad
struct Ciudad {
    nombre: String,
    poblacion: u32,
}

impl Ciudad {
    fn new(nombre: &amp;str, poblacion: u32) -&gt; Self { // funci√≥n new
        Self {
            nombre: nombre.to_string(),
            poblacion,
        }
    }
}
#[derive(Debug)] // Pais necesita imprimirse
struct Pais {
    ciudades: Vec&lt;Ciudad&gt;, // Las ciudades van aqu√≠
}

impl From&lt;Vec&lt;Ciudad&gt;&gt; for Pais { // Note: no se crea From&lt;Ciudad&gt;, se crea
    // From&lt;Vec&lt;Ciudad&gt;&gt;. Es decir, sobre un tipo, Vec, que no se ha creado en el c√≥digo
    fn from(ciudades: Vec&lt;Ciudad&gt;) -&gt; Self {
        Self { ciudades }
    }
}

impl Pais {
    fn imprimir_ciudades(&amp;self) { // funci√≥n para imprimir las ciudades del Pais
        for ciudad in &amp;self.ciudades {
            // &amp; porque Vec&lt;Ciudad&gt; no es Copy
            println!(&quot;{:?} tiene una poblaci√≥n de {:?}.&quot;, ciudad.nombre, ciudad.poblacion);
        }
    }
}

fn main() {
    let helsinki = Ciudad::new(&quot;Helsinki&quot;, 631_695);
    let turku = Ciudad::new(&quot;Turku&quot;, 186_756);

    let finland_ciudades = vec![helsinki, turku]; // Esto es  el Vec&lt;Ciudad&gt;
    let finland = Pais::from(finland_ciudades); // En este punto se usa From

    finland.imprimir_ciudades();
}
</code></pre></pre>
<p>Que imprime:</p>
<pre><code class="language-text">&quot;Helsinki&quot; tiene una poblaci√≥n de 631695.
&quot;Turku&quot; tiene una poblaci√≥n de 186756.
</code></pre>
<p>Se observa que es f√°cil implementar <code>From</code> para tipos que no se han creado por el desarrollador, por ejemplo, <code>Vec</code>, <code>i32</code> o cualquier otro.</p>
<p>A continuaci√≥n, se muestra otro ejemplo en el que se crea un vector que contiene dos vectores. El primer vector contiene n√∫meros pares y el segundo, impares. Con <code>From</code> se puede tomar un vector de <code>i32</code> y convertirlo en <code>Vec&lt;Vec&lt;i32&gt;&gt;</code>: un vector que contiene vectores de <code>i32</code>.</p>
<pre><pre class="playground"><code class="language-rust">use std::convert::From;

struct ParImparVec(Vec&lt;Vec&lt;i32&gt;&gt;);

impl From&lt;Vec&lt;i32&gt;&gt; for ParImparVec {
    fn from(input: Vec&lt;i32&gt;) -&gt; Self {
        let mut par_impar_vec: Vec&lt;Vec&lt;i32&gt;&gt; = vec![vec![], vec![]]; // Un vec con dos vecs vac√≠os dentro
        // se rellena para despu√©s retornarlo 
        for item in input {
            if item % 2 == 0 {
                par_impar_vec[0].push(item);
            } else {
                par_impar_vec[1].push(item);
            }
        }
        Self(par_impar_vec) // una vez relleno se devuelve como Self (Self = ParImparVec)
    }
}

fn main() {
    let varios_numero = vec![8, 7, -1, 3, 222, 9787, -47, 77, 0, 55, 7, 8];
    let new_vec = ParImparVec::from(varios_numero);

    println!(&quot;N√∫meros pares: {:?}\nN√∫meros impares: {:?}&quot;, new_vec.0[0], new_vec.0[1]);
}
</code></pre></pre>
<p>Lo anterior imprime:</p>
<pre><code class="language-text">N√∫meros pares: [8, 222, 0, 8]
N√∫meros impares: [7, -1, 3, 9787, -47, 77, 55, 7]
</code></pre>
<p>Un tipo como <code>ParImparVec</code> es mejor definirlo como gen√©rico <code>T</code> para poder usarlo en muchos tipos de n√∫meros. Se deja esta idea como pr√°ctica.</p>
<h2 id="paso-de-par√°metros-string-y-str-a-funciones"><a class="header" href="#paso-de-par√°metros-string-y-str-a-funciones">Paso de par√°metros String y &amp;str a funciones</a></h2>
<p>En ocasiones se necesita que una funci√≥n pueda recibir tanto <code>String</code> como <code>&amp;str</code> en el mismo par√°metro. Esto se puede conseguir con gen√©ricos y con el rasgo <code>AsRef</code>. <code>AsRef</code> se utiliza para pasar una referencia de un tipo a otro tipo. Si se observa la documentaci√≥n de <code>String</code>, se ve que implementa <code>AsRef</code> para muchos tipos:</p>
<p><a href="https://doc.rust-lang.org/std/string/struct.String.html">https://doc.rust-lang.org/std/string/struct.String.html</a></p>
<p>Estas son algunas de las declaraciones de funci√≥n:</p>
<p><code>AsRef&lt;str&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
impl AsRef&lt;str&gt; for String

fn as_ref(&amp;self) -&gt; &amp;str
<span class="boring">}
</span></code></pre></pre>
<p><code>AsRef&lt;[u8]&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
impl AsRef&lt;[u8]&gt; for String

fn as_ref(&amp;self) -&gt; &amp;[u8]
<span class="boring">}
</span></code></pre></pre>
<p><code>AsRef&lt;OsStr&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
impl AsRef&lt;OsStr&gt; for String

fn as_ref(&amp;self) -&gt; &amp;OsStr
<span class="boring">}
</span></code></pre></pre>
<p>Se observa que implementa la funci√≥n <code>as_ref</code> que recibe como par√°metro <code>&amp;self</code> y devuelve una referencia a otro tipo. Esto permite que si se dispone de un tipo gen√©rico T, se pueda indicar que ese tipo necesita <code>AsRef&lt;str&gt;</code>. As√≠, ser√° posible que se pase como un <code>&amp;str</code> o un <code>String</code>.</p>
<p>El c√≥digo siguiente implementa la funci√≥n gen√©rica, pero da error:</p>
<pre><pre class="playground"><code class="language-rust">fn imprimelo&lt;T&gt;(input: T) {
    println!(&quot;{}&quot;, input) // ‚ö†Ô∏è
}

fn main() {
    imprimelo(&quot;Por favor, impr√≠meme&quot;);
}
</code></pre></pre>
<p>Rust dice <code>error[E0277]: </code>T<code> doesn't implement std::fmt::Display</code>. Se necesita que lo implemente:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

fn imprimelo&lt;T: Display&gt;(input: T) {
    println!(&quot;{}&quot;, input)
}

fn main() {
    imprimelo(&quot;Por favor, impr√≠meme&quot;);
}
</code></pre></pre>
<p>Ahora funciona e imprime <code>Por favor, impr√≠meme</code>. Eso es mejor, pero T puede ser muchas cosas a√∫n. Puede ser <code>i8</code>, <code>f32</code> o cualquier cosa que tenga <code>Display</code>. Si se a√±ade ahora <code>AsRef&lt;str&gt;</code>, T necesita ambos rasgos.</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

fn imprimelo&lt;T: AsRef&lt;str&gt; + Display&gt;(input: T) {
    println!(&quot;{}&quot;, input)
}

fn main() {
    imprimelo(&quot;Por favor, impr√≠meme&quot;);
    imprimelo(&quot;Tambi√©n, por favor, impr√≠meme&quot;.to_string());
    // imprimelo(7); &lt;- Esto no compilar√°
}
</code></pre></pre>
<p>Ahora no dejar√° pasar tipos como <code>i8</code>.</p>
<p>No se puede olvidar que se puede utilizar <code>where</code> ara escribir de forma m√°s compacta la declaraci√≥n de la funci√≥n cuando esta se hace muy larga. Si se a√±adiera Debug la l√≠nea quedar√≠a muy larga, <code>fn imprimelo&lt;T: AsRef&lt;str&gt; + Display + Debug&gt;(input: T)</code>, as√≠ que se puede escribir de la siguiente forma.</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::{Debug, Display}; // a√±ade Debug

fn imprimelo&lt;T&gt;(input: T) // Ahora la l√≠nea es m√°s f√°cil de leer
where
    T: AsRef&lt;str&gt; + Debug + Display, // y tambi√©n se leen bien los rasgos del tipo
{
    println!(&quot;{}&quot;, input)
}

fn main() {
    imprimelo(&quot;Por favor, impr√≠meme&quot;);
    imprimelo(&quot;Tambi√©n, por favor, impr√≠meme&quot;.to_string());
}
</code></pre></pre>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>N.T.: Este concepto de Rust se puede traducir como <em>rasgo</em>. Est√° relacionado con la programaci√≥n orientada a aspectos. Los rasgos de Rust describen determinados aspectos de los tipos, funciones o variables que los implementen.</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="30.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="30.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
