<!DOCTYPE HTML>
<html lang="es" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Pruebas (testing) - Rust en espa√±ol f√°cil</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="actualizaciones.html">Actualizaciones</a></li><li class="chapter-item expanded affix "><a href="introduccion.html">Introducci√≥n</a></li><li class="chapter-item expanded affix "><a href="quiensoy.html">¬øQui√©n soy?</a></li><li class="chapter-item expanded affix "><a href="escritura.html">La escritura de Rust en ingl√©s f√°cil</a></li><li class="chapter-item expanded affix "><li class="part-title">Parte 1 - Rust en tu navegador</li><li class="chapter-item expanded "><a href="01.html"><strong aria-hidden="true">1.</strong> El entorno de pruebas de Rust</a></li><li class="chapter-item expanded "><a href="02.html"><strong aria-hidden="true">2.</strong> üöß y ‚ö†Ô∏è</a></li><li class="chapter-item expanded "><a href="03.html"><strong aria-hidden="true">3.</strong> Comentarios</a></li><li class="chapter-item expanded "><a href="04.html"><strong aria-hidden="true">4.</strong> Tipos de dato</a></li><li class="chapter-item expanded "><a href="05.html"><strong aria-hidden="true">5.</strong> Inferencia de tipos de dato</a></li><li class="chapter-item expanded "><a href="06.html"><strong aria-hidden="true">6.</strong> Imprimiendo '¬°Hola, mundo!'</a></li><li class="chapter-item expanded "><a href="07.html"><strong aria-hidden="true">7.</strong> La visualizaci√≥n y depuraci√≥n</a></li><li class="chapter-item expanded "><a href="08.html"><strong aria-hidden="true">8.</strong> Mutabilidad (cambio)</a></li><li class="chapter-item expanded "><a href="09.html"><strong aria-hidden="true">9.</strong> La pila, la memoria din√°mica y los punteros</a></li><li class="chapter-item expanded "><a href="10.html"><strong aria-hidden="true">10.</strong> M√°s sobre impresi√≥n</a></li><li class="chapter-item expanded "><a href="11.html"><strong aria-hidden="true">11.</strong> Cadenas de caracteres</a></li><li class="chapter-item expanded "><a href="12.html"><strong aria-hidden="true">12.</strong> const y static</a></li><li class="chapter-item expanded "><a href="13.html"><strong aria-hidden="true">13.</strong> Algo m√°s sobre referencias</a></li><li class="chapter-item expanded "><a href="14.html"><strong aria-hidden="true">14.</strong> Referencias modificables (mutables)</a></li><li class="chapter-item expanded "><a href="15.html"><strong aria-hidden="true">15.</strong> Paso de referencias a funciones</a></li><li class="chapter-item expanded "><a href="16.html"><strong aria-hidden="true">16.</strong> Copia</a></li><li class="chapter-item expanded "><a href="17.html"><strong aria-hidden="true">17.</strong> Tipos colecci√≥n</a></li><li class="chapter-item expanded "><a href="18.html"><strong aria-hidden="true">18.</strong> Vectores</a></li><li class="chapter-item expanded "><a href="19.html"><strong aria-hidden="true">19.</strong> Tuplas</a></li><li class="chapter-item expanded "><a href="20.html"><strong aria-hidden="true">20.</strong> Estructuras de control</a></li><li class="chapter-item expanded "><a href="21.html"><strong aria-hidden="true">21.</strong> Estructuras - struct</a></li><li class="chapter-item expanded "><a href="22.html"><strong aria-hidden="true">22.</strong> Enumerados - enum</a></li><li class="chapter-item expanded "><a href="23.html"><strong aria-hidden="true">23.</strong> Bucles</a></li><li class="chapter-item expanded "><a href="24.html"><strong aria-hidden="true">24.</strong> Implementando structs y enums</a></li><li class="chapter-item expanded "><a href="25.html"><strong aria-hidden="true">25.</strong> Desestructurar</a></li><li class="chapter-item expanded "><a href="26.html"><strong aria-hidden="true">26.</strong> Referencias y el operador punto .</a></li><li class="chapter-item expanded "><a href="27.html"><strong aria-hidden="true">27.</strong> Gen√©ricos</a></li><li class="chapter-item expanded "><a href="28.html"><strong aria-hidden="true">28.</strong> Los enumerados Option y Result</a></li><li class="chapter-item expanded "><a href="29.html"><strong aria-hidden="true">29.</strong> Otras colecciones</a></li><li class="chapter-item expanded "><a href="30.html"><strong aria-hidden="true">30.</strong> El operador ?</a></li><li class="chapter-item expanded "><a href="31.html"><strong aria-hidden="true">31.</strong> Traits (Rasgos)</a></li><li class="chapter-item expanded "><a href="32.html"><strong aria-hidden="true">32.</strong> Encadenando m√©todos</a></li><li class="chapter-item expanded "><a href="33.html"><strong aria-hidden="true">33.</strong> Iteradores</a></li><li class="chapter-item expanded "><a href="34.html"><strong aria-hidden="true">34.</strong> Closures - Cierres</a></li><li class="chapter-item expanded "><a href="35.html"><strong aria-hidden="true">35.</strong> La macro dbg! e .inspect()</a></li><li class="chapter-item expanded "><a href="36.html"><strong aria-hidden="true">36.</strong> Tipos de &str</a></li><li class="chapter-item expanded "><a href="37.html"><strong aria-hidden="true">37.</strong> Tiempos de vida (lifetimes)</a></li><li class="chapter-item expanded "><a href="38.html"><strong aria-hidden="true">38.</strong> Mutabilidad interior</a></li><li class="chapter-item expanded "><a href="39.html"><strong aria-hidden="true">39.</strong> Cow</a></li><li class="chapter-item expanded "><a href="40.html"><strong aria-hidden="true">40.</strong> Alias de tipos</a></li><li class="chapter-item expanded "><a href="41.html"><strong aria-hidden="true">41.</strong> La macro todo!</a></li><li class="chapter-item expanded "><a href="42.html"><strong aria-hidden="true">42.</strong> Rc</a></li><li class="chapter-item expanded "><a href="43.html"><strong aria-hidden="true">43.</strong> M√∫ltiples hilos</a></li><li class="chapter-item expanded "><a href="44.html"><strong aria-hidden="true">44.</strong> Cierres en funciones</a></li><li class="chapter-item expanded "><a href="45.html"><strong aria-hidden="true">45.</strong> impl Trait</a></li><li class="chapter-item expanded "><a href="46.html"><strong aria-hidden="true">46.</strong> Arc</a></li><li class="chapter-item expanded "><a href="47.html"><strong aria-hidden="true">47.</strong> Canales</a></li><li class="chapter-item expanded "><a href="48.html"><strong aria-hidden="true">48.</strong> Entender la documentaci√≥n de Rust</a></li><li class="chapter-item expanded "><a href="49.html"><strong aria-hidden="true">49.</strong> Atributos</a></li><li class="chapter-item expanded "><a href="50.html"><strong aria-hidden="true">50.</strong> Box</a></li><li class="chapter-item expanded "><a href="51.html"><strong aria-hidden="true">51.</strong> Box y los rasgos</a></li><li class="chapter-item expanded "><a href="52.html"><strong aria-hidden="true">52.</strong> Default y el patr√≥n constructor (builder)</a></li><li class="chapter-item expanded "><a href="53.html"><strong aria-hidden="true">53.</strong> Deref y DerefMut</a></li><li class="chapter-item expanded "><a href="54.html"><strong aria-hidden="true">54.</strong> Crates (cajones) y m√≥dulos</a></li><li class="chapter-item expanded "><a href="55.html" class="active"><strong aria-hidden="true">55.</strong> Pruebas (testing)</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust en espa√±ol f√°cil</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="pruebas-testing"><a class="header" href="#pruebas-testing">Pruebas (testing)</a></h1>
<p>Ahora que ya se entiende el funcionamiento de los m√≥dulos es un buen momento para aprender sobre las pruebas. En Rust es muy f√°cil probar el c√≥digo porque se pueden escribir los tests junto al propio c√≥digo.</p>
<p>La forma m√°s sencilla de empezar a probar es a√±adir <code>#[test]</code> a una funci√≥n. Por ejemplo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn dos_es_dos() {
    assert_eq!(2, 2);
}
<span class="boring">}
</span></code></pre></pre>
<p>Pero si se intenta ejecutar en Playground, da un error: <code>error[E0601]: `main` function not found in crate `playground</code>. Esto se debe a que no se utiliza Run para ejecutar las pruebas. En playground se puede pulsar junto a RUN en los <code>¬∑¬∑¬∑</code> y cambiar a TEST. Ahora, si se pulsa, ejecutar√° las pruebas. Si se tiene ya instalado Rust en el ordenador, se debe ejecutar <code>cargo test</code> en lugar de <code>cargo run</code>.</p>
<p>Este es el resultado de ejecutar el test anterior:</p>
<pre><code class="language-text">running 1 test
test dos_es_dos ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Si se modifica <code>assert_eq!(2, 2)</code> a <code>assert_eq!(2, 3)</code> el test falla y devuelve una informaci√≥n mucho m√°s detallada:</p>
<pre><code class="language-text">running 1 test
test dos_es_dos ... FAILED

failures:

---- dos_es_dos stdout ----
thread 'dos_es_dos' panicked at 'assertion failed: `(left == right)`
  left: `2`,
 right: `3`', src/lib.rs:3:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    dos_es_dos

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>En Rust, <code>assert_eq!(left, right)</code> es el principal modo de probar una funci√≥n. Si no funciona, mostar√° los dos valores que son diferentes: <code>left has 2, but right has 3</code>.</p>
<p>¬øQu√© significa <code>RUST_BACKTRACE=1</code>? Es una variable del sistema que se puede activar para dar m√°s informaci√≥n sobre el error. En Playground se puede activar pulsando <code>¬∑¬∑¬∑</code> junto a <code>STABLE</code>y establecer la traza (backtrace) a <code>ENABLED</code>. Si se hace as√≠, se mostrar√° mucha informaci√≥n:</p>
<pre><code class="language-text">running 1 test
test dos_es_dos ... FAILED

failures:

---- dos_es_dos stdout ----
thread 'dos_es_dos' panicked at 'assertion failed: 2 == 3', src/lib.rs:3:5
stack backtrace:
   0: backtrace::backtrace::libunwind::trace
             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.46/src/backtrace/libunwind.rs:86
   1: backtrace::backtrace::trace_unsynchronized
             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.46/src/backtrace/mod.rs:66
   2: std::sys_common::backtrace::_print_fmt
             at src/libstd/sys_common/backtrace.rs:78
   3: &lt;std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display&gt;::fmt
             at src/libstd/sys_common/backtrace.rs:59
   4: core::fmt::write
             at src/libcore/fmt/mod.rs:1076
   5: std::io::Write::write_fmt
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/io/mod.rs:1537
   6: std::io::impls::&lt;impl std::io::Write for alloc::boxed::Box&lt;W&gt;&gt;::write_fmt
             at src/libstd/io/impls.rs:176
   7: std::sys_common::backtrace::_print
             at src/libstd/sys_common/backtrace.rs:62
   8: std::sys_common::backtrace::print
             at src/libstd/sys_common/backtrace.rs:49
   9: std::panicking::default_hook::{{closure}}
             at src/libstd/panicking.rs:198
  10: std::panicking::default_hook
             at src/libstd/panicking.rs:215
  11: std::panicking::rust_panic_with_hook
             at src/libstd/panicking.rs:486
  12: std::panicking::begin_panic
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/panicking.rs:410
  13: playground::dos_es_dos
             at src/lib.rs:3
  14: playground::dos_es_dos::{{closure}}
             at src/lib.rs:2
  15: core::ops::function::FnOnce::call_once
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libcore/ops/function.rs:232
  16: &lt;alloc::boxed::Box&lt;F&gt; as core::ops::function::FnOnce&lt;A&gt;&gt;::call_once
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/liballoc/boxed.rs:1076
  17: &lt;std::panic::AssertUnwindSafe&lt;F&gt; as core::ops::function::FnOnce&lt;()&gt;&gt;::call_once
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/panic.rs:318
  18: std::panicking::try::do_call
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/panicking.rs:297
  19: std::panicking::try
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/panicking.rs:274
  20: std::panic::catch_unwind
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/panic.rs:394
  21: test::run_test_in_process
             at src/libtest/lib.rs:541
  22: test::run_test::run_test_inner::{{closure}}
             at src/libtest/lib.rs:450
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.


failures:
    dos_es_dos

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>No es necesario disponer de toda la traza, salvo que no se pueda encontrar cu√°l es el problema. Normalmente, tampoco es necesario comprender toda la traza. En ella, se observa que en la l√≠nea 13, se habla de <code>dos_es_dos</code>. A partir de ah√≠ es donde empieza a hablar del c√≥digo de la aplicaci√≥n. Todo lo dem√°s es sobre lo que Rust est√° haciendo en otras librer√≠as para ejecutar el programa. Estas dos l√≠neas (13 y 14) muestran que son errores en las l√≠neas 2 y 3 de playground, es ah√≠ donde est√° el error.</p>
<pre><code class="language-text">  13: playground::dos_es_dos
             at src/lib.rs:3
  14: playground::dos_es_dos::{{closure}}
             at src/lib.rs:2
</code></pre>
<p>Nota: Rust mejor√≥ los mensajes de traza a comienzos de 2021 para mostrar solo la informaci√≥n m√°s √∫til. Ahora es m√°s f√°cil de leer:</p>
<pre><code class="language-text">failures:

---- dos_es_dos stdout ----
thread 'dos_es_dos' panicked at 'assertion failed: `(left == right)`
  left: `2`,
 right: `3`', src/lib.rs:3:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/std/src/panicking.rs:493:5
   1: core::panicking::panic_fmt
             at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/core/src/panicking.rs:92:14
   2: playground::dos_es_dos
             at ./src/lib.rs:3:5
   3: playground::dos_es_dos::{{closure}}
             at ./src/lib.rs:2:1
   4: core::ops::function::FnOnce::call_once
             at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/core/src/ops/function.rs:227:5
   5: core::ops::function::FnOnce::call_once
             at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/core/src/ops/function.rs:227:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.


failures:
    dos_es_dos

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.02s
</code></pre>
<p>En el siguiente ejemplo se desactiva la traza y se a√±aden algunas funciones que se probar√°n a trav√©s de unas funciones de prueba:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn return_two() -&gt; i8 {
    2
}
#[test]
fn it_returns_two() {
    assert_eq!(return_two(), 2);
}

fn return_six() -&gt; i8 {
    4 + return_two()
}
#[test]
fn it_returns_six() {
    assert_eq!(return_six(), 6)
}
<span class="boring">}
</span></code></pre></pre>
<p>Ahora se ejecutan los dos tests:</p>
<pre><code class="language-text">running 2 tests
test it_returns_two ... ok
test it_returns_six ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Normalmente, los tests se llevar√°n a un m√≥dulo espec√≠fico. Para ello, se usa <code>mod</code> como ya se conoce y se antecede con <code>#[cfg(test)]</code>. Delante de las funciones de prueba se sigue poniendo <code>#[test]</code>. Desde la l√≠nea de comando de Rust, esto permitir√° realizar diferentes tipos de prueba, ejecutar solo una funci√≥n de prueba, todas o unas algunas de ellas. En el m√≥dulo de prueba ser√° necesario escribir <code>use super::*</code> para que pueda tener acceso sencillo a todas las funciones del m√≥dulo principal que se est√° probando. Queda as√≠:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn return_two() -&gt; i8 {
    2
}
fn return_six() -&gt; i8 {
    4 + return_two()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_returns_six() {
        assert_eq!(return_six(), 6)
    }
    #[test]
    fn it_returns_two() {
        assert_eq!(return_two(), 2);
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="desarrollo-dirigido-por-pruebas"><a class="header" href="#desarrollo-dirigido-por-pruebas">Desarrollo dirigido por pruebas</a></h2>
<p>En ingl√©s se denomina TDD, test driven development. Es una forma de escribir programas en la que primero se escribe el c√≥digo de prueba de una funci√≥n y luego se escribe su c√≥digo. As√≠, siempre se dispone de pruebas para todo el c√≥digo que se escribe. Normalmente, se escriben las pruebas, se ejecutan y fallan, puesto que no se ha escrito el c√≥digo. Despu√©s, se escribe el c√≥digo de la funci√≥n hasta que pasan todas las pruebas existentes. Esto es muy sencillo en Rust ya que el compilador da mucha informaci√≥n sobre lo que hay que arreglar. A continuaci√≥n, se escribe un peque√±o ejemplo de desarrollo orientado por pruebas para ver c√≥mo se hace.</p>
<p>Se va a suponer que se desarrolla una calculadora que suma y resta. Si el usuario escribe &quot;5 + 6&quot; deber√≠a dar como resultado 11. Si el usuario escribe &quot;5 + 6 - 7&quot;, deber√≠a devolver 4, y as√≠ para cada entrada. En primer lugar, se escriben las funciones de prueba. Los nombres de las funciones de prueba suelen ser largos, para dejar claro cual es cada prueba y conocer bien qu√© significa si falla.</p>
<p>El c√≥digo real de esta calculadora se encontrar√° en una funci√≥n <code>math()</code> que realiza los c√°lculos. Devolver√° un i32 (no realiza c√°lculos con decimales). En primer lugar, esta funci√≥n solo devolver√° un n√∫mero fijo, el 6. Evidentemente, esto hace que el c√≥digo de prueba falle:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn math(input: &amp;str) -&gt; i32 {
    6
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_plus_one_is_two() {
        assert_eq!(math(&quot;1 + 1&quot;), 2);
    }
    #[test]
    fn one_minus_two_is_minus_one() {
        assert_eq!(math(&quot;1 - 2&quot;), -1);
    }
    #[test]
    fn one_minus_minus_one_is_two() {
        assert_eq!(math(&quot;1 - -1&quot;), 2);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>La ejecuci√≥n de las pruebas, en este momento, da el siguiente resultado:</p>
<pre><code class="language-text">running 3 tests
test tests::one_minus_minus_one_is_two ... FAILED
test tests::one_minus_two_is_minus_one ... FAILED
test tests::one_plus_one_is_two ... FAILED
</code></pre>
<p>El texto anterior, est√° resumido. Adem√°s, se dispone de toda la informaci√≥n del motivo de cada fallo, pero no se reproduce aqu√≠.</p>
<p>Ahora se va a dise√±ar la calculadora. Esta aceptar√° los d√≠gitos, los s√≠mbolos <code>+</code> y <code>-</code> y el espacio en blanco. Y nada m√°s. En primer lugar, se crea un <code>const</code> con todos los caracteres posibles. La funci√≥n <code>math()</code> iterar√° a trav√©s de todos los caracteres que tenga el par√°metro y comprobar√° si est√°n incluidos entre los caracteres v√°lidos.</p>
<p>Este es el momento para a√±adir una prueba que tenga que fallar debido a que se le pase alg√∫n car√°cter no v√°lido. Para que el resultado de una prueba que falla sea considerado que es el resultado que debe valoes se debe a√±adir el atributo <code>#[should_panic]</code> a la prueba. Es decir, que la funci√≥n de prueba entre en p√°nico es lo correcto en este caso.</p>
<p>El c√≥digo queda as√≠:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const OKAY_CHARACTERS: &amp;str = &quot;1234567890+- &quot;; // Con el espacio entre los caracteres v√°lidos

fn math(input: &amp;str) -&gt; i32 {
    if !input.chars().all(|character| OKAY_CHARACTERS.contains(character)) {
        panic!(&quot;Please only input numbers, +-, or spaces&quot;);
    }
    6 // por ahora se sigue devolviendo un 6
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_plus_one_is_two() {
        assert_eq!(math(&quot;1 + 1&quot;), 2);
    }
    #[test]
    fn one_minus_two_is_minus_one() {
        assert_eq!(math(&quot;1 - 2&quot;), -1);
    }
    #[test]
    fn one_minus_minus_one_is_two() {
        assert_eq!(math(&quot;1 - -1&quot;), 2);
    }

    #[test]
    #[should_panic]  // Esta es la nueva prueba - que debe lanzar panic como resultado correcto
    fn panics_when_characters_not_right() {
        math(&quot;7 + seven&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Ahora, el resultado de ejecutar los tests es:</p>
<pre><code class="language-text">running 4 tests
test tests::one_minus_two_is_minus_one ... FAILED
test tests::one_minus_minus_one_is_two ... FAILED
test tests::panics_when_characters_not_right ... ok
test tests::one_plus_one_is_two ... FAILED
</code></pre>
<p>Una prueba ha funcionado, la funci√≥n solo acepta caracteres v√°lidos.</p>
<p>El siguiente paso consiste en escribir el c√≥digo que calcula los resultados. La l√≥gica de la calculadora ser√° as√≠:</p>
<ul>
<li>Todos los espacios se eliminar√°n. Esto se hace con <code>.filter()</code>.</li>
<li>La entrada se convertir√° en un <code>Vec</code> con todas las entradas. <code>+</code> no necesita ser una entrada, pero cuando el programa vea un <code>+</code> deber√≠a saber que el n√∫mero est√° completo. Por ejemplo, para la entrada <code>11+1</code> deber√≠a hacer algo as√≠:
<ol>
<li>Encuentra el 1 y lo inserta en una cadena de caracteres vac√≠a.</li>
<li>Encuentra el siguiente 1 y lo inserta en la cadena de caracteres que ahora contendr√° &quot;11&quot;.</li>
<li>Encuentra el car√°cter <code>+</code>, entiende que el n√∫mero se ha terminado y guarda la cadena de caracteres en el <code>vec</code> y limpia la cadena de caracteres.</li>
</ol>
</li>
<li>El programa debe contar el n√∫emro de <code>-</code>. Un n√∫mero impar (1,3,5,...) significar√° restar, un n√∫mero par significar√° sumar. As√≠, 1--9 deber√≠a dar 10, no -8. Es decir, 1 menos el -9.</li>
<li>El programa deber√≠a eliminar todos lo que aparezca despu√©s del √∫ltimo n√∫mero. <code>5+5+++++-----</code> est√° compuesto de todos los caracteres en <code>OKAY_CHARACTERS</code>, pero deber√≠a convertirlo a <code>5+5</code>. Es f√°cil hacer esto con <code>.trim_end_matches()</code>. Esta funci√≥n elimina todo lo que coincida con ella al final de una <code>&amp;str</code>.</li>
</ul>
<p>(Por cierto, <code>.trim_end_matches()</code> y <code>.trim_start_matches()</code> se denominaban antes <code>.trim_right_matches()</code> y <code>.trim_left_matches()</code>. Pero se observ√≥ que algunos lenguajes se leen de derecha a izquierda (persa, hebreo, etc), por lo que la denominaci√≥n de izquierda y derecha era err√≥nea. En alg√∫n c√≥digo antiguo, a√∫n pueden estar us√°ndose las funciones antiguas).</p>
<p>En primer lugar, se debe conseguir que la funci√≥n pase todas las pruebas. Despu√©s, se puede refactorizar el c√≥digo para hacerlo mejor:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const OKAY_CHARACTERS: &amp;str = &quot;1234567890+- &quot;;

fn math(input: &amp;str) -&gt; i32 {
    if !input.chars().all(|character| OKAY_CHARACTERS.contains(character)) ||
       !input.chars().take(2).any(|character| character.is_numeric())
    {
        panic!(&quot;Please only input numbers, +-, or spaces.&quot;);
    }

    let input = input.trim_end_matches(|x| &quot;+- &quot;.contains(x)) // Elimina +, - y espacios al final
        .chars().filter(|x| *x != ' ') // Elimina todos los espacios restantes
        .collect::&lt;String&gt;(); 
    let mut result_vec = vec![]; // Los resultados van aqu√≠
    let mut push_string = String::new(); // Esta cadena es para hacer push de lo que se va encontrando. Se reutiliza entre diferentes n√∫meros
    for character in input.chars() {
        match character {
            '+' =&gt; {
                if !push_string.is_empty() { // Si la cadena es vac√≠a, no se quiere a√±adir &quot;&quot; al result_vec
                    result_vec.push(push_string.clone()); // Pero si no es vac√≠a, es un n√∫mero que se a√±ade al vector
                    push_string.clear(); // Y se limpia la cadena temporal
                }
            },
            '-' =&gt; { // Si llega un s√≠mbolo -,
                if push_string.contains('-') || push_string.is_empty() { // Hay que ver si est√° vac√≠a o ya tiene -
                    push_string.push(character) // si es as√≠, se a√±ade.
                } else { // en otro caso, contendr√° un n√∫mero
                result_vec.push(push_string.clone()); // a√±ade el valor a result_vec
                push_string.clear(); // limpia la cadena temporal
                push_string.push(character); // y a√±ade el -
                }
            },
            number =&gt; { // cualquier otra cosa que venga, que ser√°n d√≠gitos, pasa por aqu√≠
                if push_string.contains('-') { // Su hay - en la cadena temporal, hay que a√±adirlos.
                    result_vec.push(push_string.clone());
                    push_string.clear();
                    push_string.push(number);
                } else { // si no es as√≠, se a√±ade a la cadena temporal
                    push_string.push(number);
                }
            },
        }
    }
    result_vec.push(push_string); // Cuando se acaba el bucle, se a√±ade lo que quedara en a cadena. No es necesario .clone() porque no se usa la variable m√°s.

    let mut total = 0; // Ahora es el momento de hacer los c√°lculos
    let mut adds = true; // true = sumar, false = restar
    let mut math_iter = result_vec.into_iter();
    while let Some(entry) = math_iter.next() { // Itera a trav√©s de los elementos
        if entry.contains('-') { // Si contiene -, se comprueba si son par o impar
            if entry.chars().count() % 2 == 1 {
                adds = match adds {
                    true =&gt; false,
                    false =&gt; true
                };
                continue; // va al siguiente elemento
            } else {
                continue;
            }
        }
        if adds == true {
            total += entry.parse::&lt;i32&gt;().unwrap(); // Si llega aqu√≠, tiene que ser un n√∫mero, por lo que es seguro hacer unwrap
        } else {
            total -= entry.parse::&lt;i32&gt;().unwrap();
            adds = true;  // Despu√©s de restar, se resetea a suma.
        }
    }
    total // Finalmente, devuelve el total
}
   /// Se a√±aden m√°s tests para a√±adir seguridad

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_plus_one_is_two() {
        assert_eq!(math(&quot;1 + 1&quot;), 2);
    }
    #[test]
    fn one_minus_two_is_minus_one() {
        assert_eq!(math(&quot;1 - 2&quot;), -1);
    }
    #[test]
    fn one_minus_minus_one_is_two() {
        assert_eq!(math(&quot;1 - -1&quot;), 2);
    }
    #[test]
    fn nine_plus_nine_minus_nine_minus_nine_is_zero() {
        assert_eq!(math(&quot;9+9-9-9&quot;), 0); // Este es nuevo
    }
    #[test]
    fn eight_minus_nine_plus_nine_is_eight_even_with_characters_on_the_end() {
        assert_eq!(math(&quot;8  - 9     +9-----+++++&quot;), 8); // Este es nuevo
    }
    #[test]
    #[should_panic]
    fn panics_when_characters_not_right() {
        math(&quot;7 + seven&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Y ahora, las pruebas pasan:</p>
<pre><code class="language-text">running 6 tests
test tests::one_minus_minus_one_is_two ... ok
test tests::nine_plus_nine_minus_nine_minus_nine_is_zero ... ok
test tests::one_minus_two_is_minus_one ... ok
test tests::eight_minus_nine_plus_nine_is_eight_even_with_characters_on_the_end ... ok
test tests::one_plus_one_is_two ... ok
test tests::panics_when_characters_not_right ... ok

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Se observa que, durante el proceso de desarrollo orientado a pruebas, existe un continuo ir y venir que sigue el siguiente patr√≥n:</p>
<ul>
<li>Primero se escriben todos los casos de prueba que se puedan imaginar.</li>
<li>Luego se comienza a escribir c√≥digo.</li>
<li>Seg√∫n se escribe el c√≥digo, aparecen ideas para hacer otras pruebas.</li>
<li>Se a√±aden estas otras pruebas. As√≠, las pruebas van creciendo seg√∫n se programa. Cuantos m√°s pruebas (NT: pruebas que cubran casos nuevos) se codifiquen, m√°s veces pruebas el c√≥digo.</li>
</ul>
<p>En todo caso, las pruebas no aseguran que todo est√© correcto. Pero s√≠ son muy √∫tiles cuando se va a modificar el c√≥digo m√°s tarde. Facilitan encontrar posibles fallos introducidos por el nuevo c√≥digo.</p>
<p>Ahora se va a reescribir un poco el c√≥digo (refactorizar). Una buena forma de comenzar es usar <code>clippy</code>. Si se ha instalado Rust, se puede usar <code>cargo clippy</code>. En Playgroudn se puede pulsar en <code>TOOLS</code> y seleccionar <code>Clippy</code>. Clippy analizar√° el c√≥digo y dar√° pistas para hacerlo m√°s simple.</p>
<p>En este caso, Clippy dice dos cosas:</p>
<pre><code class="language-text">warning: this loop could be written as a `for` loop
  --&gt; src/lib.rs:44:5
   |
44 |     while let Some(entry) = math_iter.next() { // Iter through the items
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for entry in math_iter`
   |
   = note: `#[warn(clippy::while_let_on_iterator)]` on by default
   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#while_let_on_iterator

warning: equality checks against true are unnecessary
  --&gt; src/lib.rs:53:12
   |
53 |         if adds == true {
   |            ^^^^^^^^^^^^ help: try simplifying it as shown: `adds`
   |
   = note: `#[warn(clippy::bool_comparison)]` on by default
   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#bool_comparison
</code></pre>
<p>Esto es cierto: <code>for entry in math_iter</code> es mucho m√°s simple que <code>while let Some(entry) = math_iter(next)</code>. Un bucle <code>for</code> ya realiza la iteraci√≥n, por lo que no hay que escribir <code>.iter()</code>. Y tampoco se necesitaba usar <code>math_iter</code>, se puede esribir <code>for entry in result_vec</code>.</p>
<p>Adem√°s, se va a refactorizar parte del c√≥digo. En lugar de variables separadas, se crea una estructura <code>Calculator</code> que une las variables necesarias. Se cambiar√°n dos nombres por claridad. <code>result_vec</code> se convierte en <code>results</code> y <code>push_string</code> en <code>current_input</code> (la entrada actual). En este momento, esta estructura solo tiene un m√©todo: <code>new()</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
#[derive(Clone)]
struct Calculator {
    results: Vec&lt;String&gt;,
    current_input: String,
    total: i32,
    adds: bool,
}

impl Calculator {
    fn new() -&gt; Self {
        Self {
            results: vec![],
            current_input: String::new(),
            total: 0,
            adds: true,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Ahora el c√≥digo es un poco m√°s largo, pero m√°s f√°cil de leer. Por ejemplo, <code>if adds</code> ahora es <code>if calculator.adds</code>, que es casi como leer ingl√©s. Queda as√≠:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct Calculator {
    results: Vec&lt;String&gt;,
    current_input: String,
    total: i32,
    adds: bool,
}

impl Calculator {
    fn new() -&gt; Self {
        Self {
            results: vec![],
            current_input: String::new(),
            total: 0,
            adds: true,
        }
    }
}

const OKAY_CHARACTERS: &amp;str = &quot;1234567890+- &quot;;

fn math(input: &amp;str) -&gt; i32 {
    if !input.chars().all(|character| OKAY_CHARACTERS.contains(character)) ||
       !input.chars().take(2).any(|character| character.is_numeric()) {
        panic!(&quot;Please only input numbers, +-, or spaces&quot;);
    }

    let input = input.trim_end_matches(|x| &quot;+- &quot;.contains(x)).chars().filter(|x| *x != ' ').collect::&lt;String&gt;();
    let mut calculator = Calculator::new();

    for character in input.chars() {
        match character {
            '+' =&gt; {
                if !calculator.current_input.is_empty() {
                    calculator.results.push(calculator.current_input.clone());
                    calculator.current_input.clear();
                }
            },
            '-' =&gt; {
                if calculator.current_input.contains('-') || calculator.current_input.is_empty() {
                    calculator.current_input.push(character)
                } else {
                calculator.results.push(calculator.current_input.clone());
                calculator.current_input.clear();
                calculator.current_input.push(character);
                }
            },
            number =&gt; {
                if calculator.current_input.contains('-') {
                    calculator.results.push(calculator.current_input.clone());
                    calculator.current_input.clear();
                    calculator.current_input.push(number);
                } else {
                    calculator.current_input.push(number);
                }
            },
        }
    }
    calculator.results.push(calculator.current_input);

    for entry in calculator.results {
        if entry.contains('-') {
            if entry.chars().count() % 2 == 1 {
                calculator.adds = match calculator.adds {
                    true =&gt; false,
                    false =&gt; true
                };
                continue;
            } else {
                continue;
            }
        }
        if calculator.adds {
            calculator.total += entry.parse::&lt;i32&gt;().unwrap();
        } else {
            calculator.total -= entry.parse::&lt;i32&gt;().unwrap();
            calculator.adds = true;
        }
    }
    calculator.total
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_plus_one_is_two() {
        assert_eq!(math(&quot;1 + 1&quot;), 2);
    }
    #[test]
    fn one_minus_two_is_minus_one() {
        assert_eq!(math(&quot;1 - 2&quot;), -1);
    }
    #[test]
    fn one_minus_minus_one_is_two() {
        assert_eq!(math(&quot;1 - -1&quot;), 2);
    }
    #[test]
    fn nine_plus_nine_minus_nine_minus_nine_is_zero() {
        assert_eq!(math(&quot;9+9-9-9&quot;), 0);
    }
    #[test]
    fn eight_minus_nine_plus_nine_is_eight_even_with_characters_on_the_end() {
        assert_eq!(math(&quot;8  - 9     +9-----+++++&quot;), 8);
    }
    #[test]
    #[should_panic]
    fn panics_when_characters_not_right() {
        math(&quot;7 + seven&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Finalmente, se a√±aden dos m√©todos nuevos. Uno se denomina <code>.clear()</code> que vac√≠a la entrada actual. El otro se denomina <code>push_char()</code> que a√±ade una caracter a la entrada actual. As√≠ queda el c√≥digo refactorizado.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct Calculator {
    results: Vec&lt;String&gt;,
    current_input: String,
    total: i32,
    adds: bool,
}

impl Calculator {
    fn new() -&gt; Self {
        Self {
            results: vec![],
            current_input: String::new(),
            total: 0,
            adds: true,
        }
    }

    fn clear(&amp;mut self) {
        self.current_input.clear();
    }

    fn push_char(&amp;mut self, character: char) {
        self.current_input.push(character);
    }
}

const OKAY_CHARACTERS: &amp;str = &quot;1234567890+- &quot;;

fn math(input: &amp;str) -&gt; i32 {
    if !input.chars().all(|character| OKAY_CHARACTERS.contains(character)) ||
       !input.chars().take(2).any(|character| character.is_numeric()) {
        panic!(&quot;Please only input numbers, +-, or spaces&quot;);
    }

    let input = input.trim_end_matches(|x| &quot;+- &quot;.contains(x)).chars().filter(|x| *x != ' ').collect::&lt;String&gt;();
    let mut calculator = Calculator::new();

    for character in input.chars() {
        match character {
            '+' =&gt; {
                if !calculator.current_input.is_empty() {
                    calculator.results.push(calculator.current_input.clone());
                    calculator.clear();
                }
            },
            '-' =&gt; {
                if calculator.current_input.contains('-') || calculator.current_input.is_empty() {
                    calculator.push_char(character)
                } else {
                calculator.results.push(calculator.current_input.clone());
                calculator.clear();
                calculator.push_char(character);
                }
            },
            number =&gt; {
                if calculator.current_input.contains('-') {
                    calculator.results.push(calculator.current_input.clone());
                    calculator.clear();
                    calculator.push_char(number);
                } else {
                    calculator.push_char(number);
                }
            },
        }
    }
    calculator.results.push(calculator.current_input);

    for entry in calculator.results {
        if entry.contains('-') {
            if entry.chars().count() % 2 == 1 {
                calculator.adds = match calculator.adds {
                    true =&gt; false,
                    false =&gt; true
                };
                continue;
            } else {
                continue;
            }
        }
        if calculator.adds {
            calculator.total += entry.parse::&lt;i32&gt;().unwrap();
        } else {
            calculator.total -= entry.parse::&lt;i32&gt;().unwrap();
            calculator.adds = true;
        }
    }
    calculator.total
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_plus_one_is_two() {
        assert_eq!(math(&quot;1 + 1&quot;), 2);
    }
    #[test]
    fn one_minus_two_is_minus_one() {
        assert_eq!(math(&quot;1 - 2&quot;), -1);
    }
    #[test]
    fn one_minus_minus_one_is_two() {
        assert_eq!(math(&quot;1 - -1&quot;), 2);
    }
    #[test]
    fn nine_plus_nine_minus_nine_minus_nine_is_zero() {
        assert_eq!(math(&quot;9+9-9-9&quot;), 0);
    }
    #[test]
    fn eight_minus_nine_plus_nine_is_eight_even_with_characters_on_the_end() {
        assert_eq!(math(&quot;8  - 9     +9-----+++++&quot;), 8);
    }
    #[test]
    #[should_panic]
    fn panics_when_characters_not_right() {
        math(&quot;7 + seven&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Se pueden escribir m√°s m√©todos, pero l√≠neas como <code>calculator.results.push(calculator.current_input.clone());</code> ya quedan suficientemente claras. Cuando se refactoriza, es bueno que el c√≥digo quede legible, no se trata de hacerlo m√°s corto: <code>clc.clr()</code> es peor que <code>calculator.clear()</code>, por ejemplo.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="54.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="54.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
